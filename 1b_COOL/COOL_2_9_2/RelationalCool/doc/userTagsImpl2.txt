===============================================
User tag example specification (AV 28.02.2006)
===============================================

General idea: an IOV can be inserted with AT MOST ONE associated user tag. 
This means that a consistent HEAD version must be kept (within the folder
and the channel) not only for ALL IOVS, but also for EACH subset of IOVS
associated to any given user tag.

Two specifications are discussed:
- In the 'old' (April 2005) specification, 'user tags' (those specified 
  when inserting a new IOV) are different from 'standard tags' (those 
  specified when tagging the HEAD of existing IOVs) and can NOT be mixed.
- In the 'new' (February 2006) specification, 'user tags' (those specified 
  when inserting a new IOV) are NOT different from 'standard tags (those 
  specified when tagging the HEAD of existing IOVs) and can be mixed.

[NB Each tag is independent of each other: it is NOT foreseen that one can 
ask for "the HEAD for tag A AND tag B, or the HEAD for tag A OR tag B".]

Example 1
----------
1. User inserts P1 payload in [  0, 100] with NO (user) tags
2. User inserts P2 payload in [ 10,  50] with (user) tag #1
3. User inserts P3 payload in [ 30,  80] with (user) tag #2
4. User inserts P4 payload in [ 20,  40] with (user) tag #1
5. User inserts P5 payload in [ 30,  70] with (user) tag #2

The following applies both to the old and new specifications.
The only difference is in terminology: in the old specification, 
these tags are 'user' tags (different type from 'standard' tags),
while in the new specification they are just 'tags'.

HEAD versions after last insertion:

All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P2 in [ 10,  20]
  P4 in [ 20,  30]
  P5 in [ 30,  70]
  P3 in [ 70,  80]
  P1 in [ 80, 100]

(User) tag #1:
  P2 in [ 10,  20]
  P4 in [ 20,  40]
  P2 in [ 40,  50]

(User) tag #2:
  P5 in [ 30,  70]
  P3 in [ 70,  80]

Example 2 (old specification)
------------------------------
1. User inserts P1 payload in [  0,  50] with NO user tags
2. User inserts P2 payload in [ 50, 100] with NO user tags
3. User tags HEAD of folder with tag #2
4. User inserts P4 payload in [ 10,  50] with user tag #1
5. User inserts P5 payload in [ 30,  80] with user tag #2 - EXCEPTION
6. User inserts P6 payload in [ 20,  40] with user tag #1
7. User inserts P7 payload in [ 30,  70] with user tag #2 - EXCEPTION

In the old specification, step 5 and 7 here throw an exception: tag #2 is 
already reserved as a 'standard' tag and cannot be used as a 'user' tag.

HEAD versions after last insertion (ignoring step 5 and 7):

All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P4 in [ 10,  20]
  P6 in [ 20,  30]
  P7 in [ 30,  70]
  P5 in [ 70,  80]
  P2 in [ 80, 100]

Tag #1:
  P4 in [ 10,  20]
  P6 in [ 20,  40]
  P4 in [ 40,  50]

User tag #2:
  P1 in [  0,  50]
  P2 in [ 50, 100]

Example 2 (new specification)
------------------------------
1. User inserts P1 payload in [  0,  50] with NO user tags
2. User inserts P2 payload in [ 50, 100] with NO user tags
3. User tags HEAD of folder with tag #2
4. User inserts P4 payload in [ 10,  50] with user tag #1
5. User inserts P5 payload in [ 30,  80] with user tag #2
6. User inserts P6 payload in [ 20,  40] with user tag #1
7. User inserts P7 payload in [ 30,  70] with user tag #2

In the new specification, no exceptions are thrown.

HEAD versions after last insertion:

All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P4 in [ 10,  20]
  P6 in [ 20,  30]
  P7 in [ 30,  70]
  P5 in [ 70,  80]
  P2 in [ 80, 100]

Tag #1:
  P4 in [ 10,  20]
  P6 in [ 20,  40]
  P4 in [ 40,  50]

Tag #2:
  P1 in [  0,  30]
  P7 in [ 30,  70]
  P5 in [ 70,  80]
  P2 in [ 80, 100]

Example 3 (new specification)
------------------------------
 1. User inserts P1  payload in [  0,  50] with NO user tags
 2. User inserts P2  payload in [ 50, 100] with NO user tags
 3. User tags HEAD of folder with tag #2
 4. User inserts P4  payload in [ 10,  50] with user tag #1
 5. User inserts P5  payload in [ 30,  80] with user tag #2
 6. User inserts P6  payload in [ 20,  40] with user tag #1
 7. User inserts P7  payload in [ 30,  70] with user tag #2
 8. User tags HEAD of folder with tag #2
 9. User inserts P9  payload in [ 30,  80] with user tag #2
10. User inserts P10 payload in [ 20,  40] with user tag #1

In the new specification, no exceptions are thrown.

HEAD versions after last insertion:

All IOVS (irrespective of tags):
  P1  in [  0,  10]
  P4  in [ 10,  20]
  P10 in [ 20,  40]
  P9  in [ 40,  80]
  P2  in [ 80, 100]

Tag #1:
  P4  in [ 10,  20]
  P10 in [ 20,  40]
  P4  in [ 40,  50]

Tag #2:
  P1 in [  0,  10]
  P4 in [ 10,  20]
  P6 in [ 20,  30]
  P9 in [ 30,  80]
  P2 in [ 80, 100]

Essentially, tagging the HEAD (in step 8) with the same tag name 
previously used for inserting IOVs with attached tags (e.g. step 5)
logically erases all tag-to-IOV relations defined when inserting 
IOVs with attached tags (e.g. the tag attached in step 5 loses meaning).

===============================================
User tag implementation (AV 28.02.2006)
===============================================

IOV table
----------

Each IOV is uniquely identified by an ObjectId that can be built 
from three variables:

- UserId or 'layer number': the order in which objects are inserted by 
  the user (irrespective of whether they are associated to tags or not)

- SystemId3 which can take exactly one of THREE values, for instance
  > 0: user-inserted
  > 1: left system-inserted for the (user tag or global) HEAD
  > 2: right system-inserted for the (user tag or global) HEAD

- HasTagId which can be 0 (not associated to user tag) or 1
  (associated to user tag)

The combination of SystemId3 and HasTagId gives SystemId6 
  SystemId6 = 3*(HasTagId-1) + SystemId3
which can take exactly one of SIX values, for instance
  > 0: user-inserted (NOT marked as belonging to a user tag)
  > 1: left system-inserted for the global HEAD (IOVs with any tag or none)
  > 2: right system-inserted for the global HEAD (IOVs with any tag or none)
  > 3: copy of the user-inserted IOV (marked as belonging to a user tag)
  > 4: left system-inserted for the HEAD of the user tag
  > 5: right system-inserted for the HEAD of the user tag

The ObjectId column already exists (COOL128) and the value is
  ObjectId = 6*(UserId-1) + 3*(HasTagId-1) + SystemId3
i.e.
  ObjectId = 6*(UserId-1) + SystemId6

Instead of a HasTagId column, it is better to add to the IOV table 
a TagId column, containing either 0 (no tag) or >0 (the tag id
of the user tag specified at insertion).

To sum up the implementation:
- Add three columns ObjIdSys3, ObjIdUser and ObjIdTag.
- The ObjIdTag column references as FK the tagId column in the tag table.
- The ObjectId column (surrogate PK) is kept and is equal to 
  ObjectId = 6*(ObjIdUser-1) + 3*((is ObjIdTag>0?)-1) + ObjIdSys3
  A check constraint can/should be added to impose this. 
- ObjIdUser is assigned from an internal sequence-like object.
  Note that this corresponds to the global order id 
  for the insertion into the IOV table, across all channels.
- User inserted IOVs with no associated user tag are inserted only once
  with ObjIdSys=0 and ObjIdTag=0.
- User inserted IOVs with an associated user tag tagId are inserted twice:
  once with ObjIdSys=0 and ObjIdTag=0, once with ObjIdSys=0 and ObjIdTag=tagId.
  This represents a modest storage overhead but simplifies the algorithm.
- System inserted IOVs are inserted with ObjIdSys=1 or 2 and with
  ObjIdTag=0 if they refer to the global HEAD, or ObjIdTag=tagId
  if they refer to the HEAD within the subset of IOVs tagged as tagId.

Note that the payload is presently stored inline and is copied 
within the IOV table in up to 6 identical copies.
Eventually, when the payload is split from the IOV table,
only a FK reference to a separate payload table needs 
to be copied in up to 6 identical copies.

Note that more complex constraints across separate rows
are imposed by the C++ algorithm but are not imposed on the database.
For instance, pairs of objects with the same ObjUserId and with ObjSysId3=0
are identical even if one has ObjIdTag=0 and one has ObjIdTag>0.

IOV2TAG table
--------------

1. Old specifcation

In the 'old' specification, user tags and standard HEAD tags are two 
different kinds of tags: all IOV data associated to user tags is 
contained in the IOV table, all IOV data associated to standard tags 
is contained in the IOV2TAG table. The two types of tags cannot be mixed.

When storeObject(IOV,tag) is called, rows are inserted and updated 
in the IOV table. In order to find/browse IOVs within a user tag,
only the IOV table must be queried.

When tag(tag) is called, rows are inserted and deleted in the IOV2TAG table. 
In order to find/browse IOVs within a standard tag, only the IOV2TAG table 
must be queried (joined with the IOV table to retrieve the actual payload).

As all IOV data associated to user tags is in the IOV table, where rows
can only be inserted or updated but never deleted, note that in the 
'old' specification the IOV table may be used to preserve the history
log of all transactions associated to a given user tag. Rows in the
IOV2TAG table, conversely, are deleted and reinserted whenever a
new HEAD tag operation is performed, and the history log associated
to 'standard' tags is lost: only the tag-to-IOV associations defined
by the last tag operation are preserved persistently.

2. New specification

In the 'new' specification, the two types of tags can be mixed
and are actually a single type of tag. The IOV data associated
to tags is maintained both in the IOV and IOV2TAG tables.

For simplicity, and because no user requirement to preserve
the history log of tag modifications has been expressed, the
design will assume that the history log of tag modifications
can be scratched. This implies that rows can/should also be deleted
from the IOV table.

The IOV2TAG table is in any case maintained always up to date:
in order to find/browse IOVs within a standard tag, only the IOV2TAG table 
must be queried (joined with the IOV table to retrieve the actual payload).

When storeObject(IOV,tag) is called, rows are inserted and updated 
in the IOV table. No rows are deleted from the IOV table, they are
only updated. The iov-to-tag associations relevant to the given tag
are ALSO stored by inserting and deleting rows in the IOV2TAG table.

When tag(tag) is called, rows are inserted and deleted in the IOV2TAG table. 
If the tag already existed and had been used to store IOVs in the IOV table
via the storeObject(IOV,tag) method, ALL rows associated to the given tag
(i.e. with ObjIdTag=tagId) are DELETED from the IOV table. This erases
all history of the given tag previous to the last tag(tag) call.

Note that it is possible to design amn implementation to keep track
of all previous tag modifications. This can be done by never deleting
rows from either the IOV or the IOV2TAG table, and only updating rows
marking them as old (a new column is required in the IOV2TAG table).
But this was not required and will not be implemented.

Roles and privileges
---------------------

In the scenario where obsolete tag data is deleted from the IOV table,
the 'retag' role must be granted the privilege to delete rows from
the IOV table.

Eventually this role should be improved so that the privilege is only 
granted on the appropriate view, for instance on the view selecting
from the IOV table where ObjIdTag>0. This may imply however that also 
the C++ code manipulates the same view rather than the underlying table.

Note also that other roles also need to be improved. For instance
the 'insert' role currently has privileges to update the IOV table,
but it would be safer to restrict this privilege to updating
only the relevant columns in the table. Unless this is done,
granting the delete on IOV table via a view is meaningless
(a nasty person could update the IOV table to set tagId>0
and then delete the row, or in any case corrupt the IOV table
by randomly updating all rows).
Schema evolution tools
-----------------------

Schema evolution tools are needed to add the new columns and fill them
with appropriate data.

Regression tests across different schema/software versions are also needed.

===============================================
User tag example implementation (AV 28.02.2006)
===============================================

Example 1
----------

1. User inserts P1 payload in [  0, 100] with NO (user) tags
2. User inserts P2 payload in [ 10,  50] with (user) tag #1
3. User inserts P3 payload in [ 30,  80] with (user) tag #2
4. User inserts P4 payload in [ 20,  40] with (user) tag #1
5. User inserts P5 payload in [ 30,  70] with (user) tag #2

IOV table:

ObjId ObjIdUs ObjIdS3 ObjIdTag Since Until Payload OrigId    NewHeadId
o     u       s                                    o(u,s)    o(u,s)  

1     1       0       0        0     100   P1      0(0,0)    7(2,0)

7     2       0       0        10    50    P2      0(0,0)    13(3,0)
8     2       1       0        0     10    P1      1(1,0)    0(0,0)
9     2       2       0        50    100   P1      1(1,0)    13(3,0)
10    2       0       1        10    50    P2      0(0,0)    19(4,0)

13    3       0       0        30    80    P3      0(0,0)    19(4,0)
14    3       1       0        10    30    P2      7(2,0)    19(4,0)
15    3       2       0        80    100   P1      9(2,2)    0(0,0)
16    3       0       2        30    80    P3      0(0,0)    25(5,0)

19    4       0       0        20    40    P4      0(0,0)    25(5,0)
20    4       1       0        10    20    P2      14(3,1)   0(0,0)
21    4       2       0        40    80    P3      13(3,0)   25(5,0)      
22    4       0       1        20    40    P4      0(0,0)    0(0,0)
23    4       1       1        10    20    P2      10(2,0)   0(0,0)       
24    4       2       1        40    50    P2      10(2,0)   0(0,0)       

25    5       0       0        30    70    P5      0(0,0)    0(0,0)
26    5       1       0        20    30    P4      19(4,0)   0(0,0)
27    5       2       0        70    80    P3      21(4,2)   0(0,0)
28    5       0       2        30    70    P5      0(0,0)    0(0,0)
29    5       2       2        70    80    P3      16(3,0)   0(0,0)

IOV2TAG table:

TagId ObjId Since Until
1     23    10    20
1     22    20    40
1     24    40    50
2     28    30    70
2     25    70    80

Example 2 (new specification)
------------------------------
1. User inserts P1 payload in [  0,  50] with NO user tags
2. User inserts P2 payload in [ 50, 100] with NO user tags
3. User tags HEAD of folder with tag #2
4. User inserts P4 payload in [ 10,  50] with user tag #1
5. User inserts P5 payload in [ 30,  80] with user tag #2
6. User inserts P6 payload in [ 20,  40] with user tag #1
7. User inserts P7 payload in [ 30,  70] with user tag #2

ObjId ObjIdUs ObjIdS3 ObjIdTag Since Until Payload OrigId    NewHeadId
o     u       s                                    o(u,s)    o(u,s)  

1     1       0       0        0     50    P1      0(0,0)    13(3,0)

7     2       0       0        50    100   P2      0(0,0)    19(4,0)

  --HEAD tagged as tag 2--

13    3       0       0        10    50    P4      0(0,0)    19(4,0)
14    3       1       0        0     10    P1      1(1,0)    0(0,0)
16    3       0       1        10    50    P4      0(0,0)    0(0,0)

19    4       0       0        30    80    P5      0(0,0)    25(5,0)
20    4       1       0        10    30    P4      13(3,0)   25(5,0)
21    4       2       0        80    100   P2      7(2,0)    0(0,0)
22    4       0       2        30    80    P5      0(0,0)    31(6,0)
23    4       1       2        0     30    P1      0(0,0)    0(0,0)
24    4       2       2        80    100   P2      0(0,0)    0(0,0)

25    5       0       0        20    40    P6      0(0,0)    31(6,0)
26    5       1       0        10    20    P4      20(4,1)   0(0,0)
27    5       2       0        40    80    P5      19(4,0)   31(6,0)
28    5       0       1        20    40    P6      0(0,0)    0(0,0)
29    5       1       1        10    20    P4      16(3,0)   0(0,0)
30    5       2       1        40    50    P4      16(3,0)   0(0,0)

31    6       0       0        30    70    P7      0(0,0)    0(0,0)
32    6       1       0        20    30    P6      25(5,0)   0(0,0)
33    6       2       0        70    80    P5      27(5,2)   0(0,0)
34    6       0       2        30    70    P7      0(0,0)    0(0,0)
36    6       2       2        70    80    P5      22(4,0)   0(0,0)

IOV2TAG table:

TagId ObjId Since Until
1     29    10    20
1     28    20    40
1     30    40    50
2     23    0     30
2     34    30    70
2     36    70    80
2     24    80    100

COMMENT 1
----------

The IOV2TAG table is badly needed for performance reasons
in the retrieval of tagged MV data.
[Note that the HEAD tag instead is retrieved directly from the IOV table.]

Nevertheless, it would be possible in principle to rebuild the
IOV2TAG table starting from the IOV table alone, provided that
for each tag the TAG table stores the value of the last inserted IOV id
at the moment when the last HEAD tag operation was performed.

In the example above:
  tagId  headTaggedAsOfId
  1      7 
  2      0 (tag exists but was not used to tag the HEAD so far)  

This value cannot be simply used in a relational query to find/browse
all IOVs in a given tag, but could be used to trigger a C++ verification
of the contents of the IOV2TAG table.

COMMENT 2
----------

The performance of the standard HEAD query is under investigation.
If this proved to be too slow, it is possible to envisage adding 
all HEAD IOVs to the IOV2TAG table too with a reserved tagId of 0.
This would indicate the global HEAD tag.

This may actually be required in any case if the FK constraint
between the IOV table (ObjIdTag) and the TAG table is imposed,
unless ObjIdTag is left as NULL rather than equal to 0.

COMMENT 3
----------

In the proposal above the ObjectId column is encripted as
  ObjectId = 6*(ObjIdUser-1) + 3*((is ObjIdTag>0?)-1) + ObjIdSys3
This is consistent with the present (COOL128) numbering,
where user-inserted IOVs are numbered 1,7,13,19...

An alternative possibility would be to use the encription
  ObjectId = 10*(ObjIdUser-1) + 3*((is ObjIdTag>0?)-1) + ObjIdSys3
so that user-inserted IOVs would be numbered 1,11,21,31...
The advantage would only be that the numbering is more intuitive.

