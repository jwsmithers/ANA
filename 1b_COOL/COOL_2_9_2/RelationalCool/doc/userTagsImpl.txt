===============================================
User tag example specification (AV 06.04.2005)
===============================================

General idea: an IOV can be inserted with one (or more?) associated user tags. 
This means that a consistent HEAD version must be kept (within the folder
and the channel) not only for ALL IOVS, but also for EACH subset of IOVS
associated to any given user tag.

Let's consider two scenarios:
1. Each IOV can be inserted with ZERO or ONE user tags.
2. Each IOV can be inserted with any number of associated tags.

NB Each tag is independent of each other: it is NOT foreseen that one can 
ask for "the HEAD for tag A AND tag B, or the HEAD for tag A OR tag B".
Such a functionality can be implemented in scenario 2 by attaching ALSO 
tag A_or_B to any IOV satisfying either tagA or tagB, for instance (any 
such operation would be left to the user).

Example 1 (scenario 1)
----------------------
1. User inserts P1 payload in [  0, 100] with NO user tags
2. User inserts P2 payload in [ 10,  50] with user tag #1
3. User inserts P3 payload in [ 30,  80] with user tag #2
4. User inserts P4 payload in [ 20,  40] with user tag #1
5. User inserts P5 payload in [ 30,  70] with user tag #2

HEAD versions after last insertion:

All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P2 in [ 10,  20]
  P4 in [ 20,  30]
  P5 in [ 30,  70]
  P3 in [ 70,  80]
  P1 in [ 80, 100]

User tag #1:
  P2 in [ 10,  20]
  P4 in [ 20,  40]
  P2 in [ 40,  50]

User tag #2:
  P5 in [ 30,  70]
  P3 in [ 70,  80]

Example 2 (scenario 2)
----------------------
1. User inserts P1 payload in [  0, 100] with NO user tags
2. User inserts P2 payload in [ 10,  50] with user tag #1
3. User inserts P3 payload in [ 30,  80] with user tag #2
4. User inserts P4 payload in [ 20,  40] with user tags #1 and #2 
5. User inserts P5 payload in [ 30,  70] with user tag #2

The ONLY difference with example 1 is that P4 is ALSO associated to tag #2.

HEAD versions after last insertion:

All IOVS (irrespective of tags): - no difference with example 1
  P1 in [  0,  10]
  P2 in [ 10,  20]
  P4 in [ 20,  30]
  P5 in [ 30,  70]
  P3 in [ 70,  80]
  P1 in [ 80, 100]

User tag #1: - no difference with example 1
  P2 in [ 10,  20]
  P4 in [ 20,  40]
  P2 in [ 40,  50]

User tag #2:
  P4 in [ 20,  30] - ONLY difference with respect to example 1
  P5 in [ 30,  70]
  P3 in [ 70,  80]

================================================
User tag example implementation (AV 06.04.2005)
================================================

* Unique identifiers

The second scenario is more complex to implement than the first one.
The reason is that the unique identifier of each IOV/row is more complex.

In scenario 1, each IOV is uniquely identified by
- UserId (Andrea's terminology) or 'layer number' (Sven's terminology):
  the order in which objects are inserted by the user (irrespective of whether
  they are associated to tags or not)
- SystemId which can take exactly one of FIVE values, for instance
  > 0: user-inserted
  > 1: left system-inserted for the ALL-tag HEAD
  > 2: right system-inserted for the ALL-tag HEAD
  > 3: left system-inserted for the HEAD of THE user tag
  > 4: right system-inserted for the HEAD of THE user tag

Also, in scenario 1, the IOV table only needs ONE extra column to identify
the user tag associated to each IOV (0 if no tag, tag# if there is one user tag).

In scenario 2, each IOV is uniquely identified by
- UserId (Andrea's terminology) or 'layer number' (Sven's terminology):
  the order in which objects are inserted by the user (irrespective of whether
  they are associated to tags or not) - as in scenario 1
- SystemId which can take exactly one of 3+2*Ntag values (for ntag tags), for instance
  > 0: user-inserted
  > 1: left system-inserted for the ALL-tag HEAD
  > 2: right system-inserted for the ALL-tag HEAD
  > 3: left system-inserted for the HEAD of user tag #1
  > 4: right system-inserted for the HEAD of user tag #1
  > 5: left system-inserted for the HEAD of user tag #2
  > 6: right system-inserted for the HEAD of user tag #2

Also, in scenario 2, a more complex mechanism is needed to map each IOV to the MANY
possible user tags associated to it.

* Possible implementations

As a consequence, the possible implementations of the two scenarios imply the 
following modifications to the IOV table schema and storage pattern.

In scenario 1 (implementation 1a):
- Add one column in the IOV table to hold the user tag ID
  Type 0 (user inserted objects) have 0 in this column if no user tag is specified,
  or they have the tagID in this column if a user tag is specified.
  Type 1/2 (system inserted for ALL TAG) have always 0 in this column.
  Type 3/4 (system inserted for the USER TAG) have the user tag in this column.
- SystemId is between 0 and 4 as explained above.
- Unique identifier is layer number + systemId from 0 to 4.
  This can also be used to encode (or randomly assign) a surrogate key.
- Disadvantage of the model: assume that usertag must be 0 for sysId=1,2 and it 
  must be >0 for sysId=3,4 (but this can easily be enforced with a check constraint)

START - Sven, read this part only if you really have nothing better to do!

In scenario 2:
- The easiest (not the cleanest) option seems to be to add a single user tag column 
  (like in the previous case) and duplicate the rows for each user tag. 
  If an IOV is stored with no user tag, it is stored once with usertag=0 (sysid=0).
  If an IOV is stored with user tag #3, it is stored twice, once with usertag=0
  and once with usertag=3 (sysid=0 in both cases).
- SystemId is only 0 (user), 1 (left system), 2 (right system).
- Unique identifier has three pieces, layer number, sysId from 0 to 2, user tag.
  This can also be used to encode (or randomly assign) a surrogate key.
- Essentially each usertag is treated as a special "channel".
- Disadvantage: storage overhead, each user object is stored N+1 times if it
  has N tags associated. Also (more important): model assumes that all objects with
  the same layer number and sysId=0 are identical even if they have different usertags.
- Advantage: everything is contained in the IOV table, no need for a separate
  iov2usertag table.

We do not really care about scenario 2 because users acepted that only scenario 1
is important. However scenario 2 is interesting as it points out possible
different implementations of scenario 1.

In scenario 1 (implementation 1b):
- Add one column in the IOV table to hold the user tag ID
  Type 0 (user inserted objects) have 0 in this column if no user tag is specified,
  or they have the tagID in this column if a user tag is specified.
  Type 1/2 (system inserted for ALL TAG) have always 0 in this column.
  Type 3/4 (system inserted for the USER TAG) have the user tag in this column.
  All as in implementation 1a.
- SystemId is only 0 (user), 1 (left system), 2 (right system).
- Unique identifier has three pieces, layer number, sysId from 0 to 2, user tag.
  This can also be used to encode (or randomly assign) a surrogate key.
- Disadvantage of the model: need to enforce (very difficult!) the extra constraint
  that layer number is a unique key for rows with sysId=0 (you do not want to 
  have rows that have the same layer number and sysId=0 but different userTag
  values - either a user IOV had a user tag or it id not)

In scenario 1 (implementation 1c):
- Add one column in the IOV table to hold the user tag ID
  Type 0 (user inserted objects) are stoored once (with userTag=0) if no user tag
  is specified and are stored twice (once also with userTag not 0) if a user tag
  is specified. Type 1/2 (system inserted for ALL TAG) have always 0 in this column.
  Type 3/4 (system inserted for the USER TAG) have the user tag in this column.
- SystemId is only 0 (user), 1 (left system), 2 (right system).
- Unique identifier has three pieces, layer number, sysId from 0 to 2, user tag.
  This can also be used to encode (or randomly assign) a surrogate key.
- Disadvantage: storage overhead, each user object is stored two times if it
  has one tag associated. Also (more important): model assumes that all objects with
  the same layer number and sysId=0 are identical even if they have different usertags.

All in all, the implementation of scenario 1 that seems easiest and safest is 1a.

END - End of ranting ;-)

* Possible implementation of example 1

Using implementation 1a, example 1 translates to the following table.

Note that I use the following encoding algorithm for the surrogate key:
  objectId = 1 + (layer#-1) * 5 + systemId (0,1,2,3 or 4)
This is similar to the present encoding without user tags,
  objectId = 1 + (layer#-1) * 3 + systemId (0,1 or 2)

Colum explanation:
- ObjectId = 5 * UserId + SystemId (surrogate PK)
- UserId = layer number (first of two fields in PK)
- SytemId = between 0 and 4 (second of two fields in PK)
- UserTag = 0 (no tag) or tagId
- Since, Until = IOV boundaries
- Payload = example payload
- OrigId = originalId as ObjectId and as (UserId, SystemId)
- NewHeadId = newHeadId as ObjectId and as (UserId, SystemId)

1. User inserts P1 payload in [  0, 100] with NO user tags
2. User inserts P2 payload in [ 10,  50] with user tag #1
3. User inserts P3 payload in [ 30,  80] with user tag #2
4. User inserts P4 payload in [ 20,  40] with user tag #1
5. User inserts P5 payload in [ 30,  70] with user tag #2

ObjId   UserId  SysId   UserTag Since   Until   Payload OrigId          NewHeadId
(5u+s)  (layer) (0to4)                                  o(u,s)          o(u,s)  

1       1       0       0       0       100     P1      0(0,0)          6(2,0)

6       2       0       1       10      50      P2      0(0,0)          11(3,0)
7       2       1       0       0       10      P1      1(1,0)          0(0,0)
8       2       2       0       50      100     P1      1(1,0)          11(3,0)

11      3       0       2       30      80      P3      0(0,0)          0(0,0)
12      3       1       0       10      30      P2      6(2,0)          0(0,0)
13      3       2       0       80      100     P1      8(2,2)          0(0,0)

16      4       0       1       20      40      P4      0(0,0)          0(0,0)
17      4       1       0       10      20      P2      12(3,1)         ARGHHHH
18      4       2       0       40      80      P3      11(3,0)         
19      4       3       1       10      20      P2      6(2,0)          
20      4       4       1       40      50      P2      6(2,0)          

21      5       0       2       30      70      P5      0(0,0)          0(0,0)
22      5       1       0       20      30      P4      16(4,0)
23      5       2       0       70      80      P3      18(4,2) 
25      5       4       2       70      80      P3      11(3,0)

Still other missing constraints:
- originalId points to null if sysId=0 (check constraint)
- newHeadId is always a user object (any u, s=0)
- newHeadId if userTag>0 points to an object with the same userTag
- originalId if sysId>0 and userTag>0 points to an object with the same userTag
         
HEAD versions after last insertion:
All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P2 in [ 10,  20]
  P4 in [ 20,  30]
  P5 in [ 30,  70]
  P3 in [ 70,  80]
  P1 in [ 80, 100]
User tag #1:
  P2 in [ 10,  20]
  P4 in [ 20,  40]
  P2 in [ 40,  50]
User tag #2:
  P5 in [ 30,  70]
  P3 in [ 70,  80]

.............................. INTERRUPT .................................

This thinking was very useful: there are many problems pending.

Problem 1 (user tags)
----------------------

Implementation 1a is not enough.

ONE newHeadId column, which is needed for the tag as of id functionality,
is not enough for user tags. User objects (sysId=0) with a tag 
need TWO new heads: one for the no tag case, one for the tag case.

It looks as if implementation 1c is better than implementation 1a.

This means that the unique identifier (WITHIN EACH CHANNEL)
must span the layer number, the system id and the user tag.

Note that in this case we can even accept scenario 2.

Problem 2 (channels)
---------------------

The objectId surrogate key now is unique across channels.
There is no possible sensible encoding (unless we limit the number 
of channels to a certain number) to decode into a surrogate ObjectId
unique across channels the totality of (channelId,userTag,layer,sysId).

PS

I like implementation 1c better because
+ there is a single newheadid column and 
+ you may remove a user tag (remove all data associated to a user tag)
+ you may fit scenario 2
- disadvantage: storage overhead                            

==============================================================================

Re: URGENT: and the channelId? 
From: Andrea Valassi <Andrea.Valassi@cern.ch> 
To: Sven A. Schmidt <sas@abstracture.de> 
Reply-To: Andrea Valassi <Andrea.Valassi@cern.ch> 
Date: Apr 7 2005 - 9:51am  

Hi Sven,

I will call you on the phone to discuss this, anyway here's my new morning 
rants...

3. ChannelId holes

You mention that this is not a problem.
In the end I agree, I do not care, for the moment, and not sure I would 
care later. I just hope we can at least keep without holes the "this is 
the insertionId order in this folder - across different channels".

Just incidentally, we wuld not have an inflation in the number of sequence 
tables. I think the best would be to have a single seqiene table per 
folder, with one line per channel. By the way, eventually I think we need 
a channel table per folder anyway. But this is FOR MUCH LATER.

=> Conclusion: ok to keep the holes in each channel.

2. ObjectId across channelId

I made such a fuss about it, but in the end I am not sure what changes. I 
agree it was good I at least realised that, so that we know the meaning of 
the quantities (eg the insertionId we need to know that it spans several 
channels). But maybe the queries are correct in the end. We should add 
some tests using different channels, thats true. And I think eventually we 
should add the possibility to selectively tag only the IOVS in a folder 
which belong to a certain channel: in this case the queries should contain 
the channelId, but otherwise maybe they would work anyway?

=> Conclusion: probably not a problem.
We should add some tests across channels and see.

1. ObjectId and UK.

As I said, the schema will change with user tags. And having two separate
columns with insertionId and sysId is probably safer.

NEVERTHELESS: 
- I have already quite a good idea bout the schema for user tags
- I would like to change as little as possible now
- I believe we can still keep some encoding (connected to insertionId 
unique across channels)
- IF at some oint we change the schema radically, nothing would make sense 
anymore anyway: so better plan for now for the minimal changes
that would still be backward compatible

The schema I propose (I will send you the details) foresees that user tags 
"reserve" 3 (or maybe 2, but lets keep 3 for safety) extra ids for the 
IOVS related to user tags (2 are the left and right inserted IOV, the 
extra third one is the original user inserted iov, that I believe may be 
safer to duplicate with a different id - once with usertag=0, once with 
usertag=tag#). I would propose to simply keep the same algorithmic we have 
now, both for encoding objectIds and obtaining the correct insertionId,
but just change the encoding from 3N+0,1,2 to 6N+0,1,2,3,4,5. For you, 
this mainly means you need to "reserve" 5 holes instead of 2.
I think this is the fastest... and it is not so bad, I also keep some 
encoding. IF at some point we change things radically, well it will not be 
backward compatible anyway. But this intermediate solution leaves us some 
space for manuevring. On top, we can ALSO add the two columns, provided 
the insertionId makes sense like now, "the order of insertion in the 
folder, across different channels": this is what is needed in the queries 
anyway.

By the way, IF we keep this encoding, this allows us to postpone the 
addition of the two columns. We can always insert the extra columns later 
and just derive them from the objectid.

=> Conclusions: 
- change "reserve 2 holes" to "reserve 5 holes" (Sven)
- change "3N+0,1,2" to "6N+0,1,2,3,4,5" in ObjectId (Sven or Andrea)
- add (but this is less urgent) two extra columns

4. Tests

Yes definitely needed

=> Conclusion: Sven, plese try to devise some tests across channels.

5. Was this useful?

Well... I think it was useful thinking. But maybe there is not so much 
that needs to be done or that would have caused a disaster, even having 
forgotten channels. Or am I stil missing something?

a.


On Wed, 6 Apr 2005, Sven A. Schmidt wrote:
> 
> On 06.04.2005, at 18:10, Andrea Valassi wrote:
> 
> > To summarise:
> >
> > 1. Please go ahead and add a layer number (I would call it insertionId
> > or userObjectId, see later) and a quantity systemId equal to 0,1,2 for
> > the IOV table. The tagAsOfObjectId should only rely on these columns
> > and not on the surrogate PK. I would keep the present encoding because
> > it does not harm, but we must take into account that things may change
> > in the future. Adding a user tag will mean either that an extra column
> > userTag (on top of channelId, insertionId, systemId) is needed to make
> > up a unique identifier (you may have data with the same ch=15,
> > insId=44 and sysId=1 meaning it is on the left, but different userTag
> > meaning that it was left inserted in the HEAD of ALL HEAD, tag=0, or a
> > specific tag>0), or it will mean that we change the meaning and
> > spectrum of systemId (for instance, sysId=3,4 for system inserted
> > associated to THE user tag). I would say: since it is not clear what
> > the objectId will be in the future, it is dangerous to give it a
> > meaning now. Better to rely on other columns starting now.
> 
> Ok, will do.
> 
> > 2. Please be aware that the "layer number" we discussed this morning
> > DOES HAVE HOLES. This is because there are several channels in the
> > same folder. This is why I am thinking it is maybe better to call it
> > "insertionId": it is just like an insertion time, but it is a number.
> > Like a ticket when you go to the supermarket and queue up at the
> > cheese shop... The meaning should be "this is the order - with no
> > holes - in which objects were inserted into this folder, to different
> > channels". Any other name suggestion? Calling it layer to me suggests
> > too much an order with no holes.
> 
> Yes, ok.
> 
> > 3. If you want to get rid of the previous problem, we would need to
> > have one sequence per channel. We could do that eventually... but not
> > now I think.
> 
> I don't think it's a problem to have holes with respect to a channel. 
> In any case it's much better than having sequence table inflation. The
> code reviewers would flog us around the LEP tunnel if they found out
> that we create an extra table per channel ;)
> 
> > 4. It would be good indeed to think of introducing more tests where
> > several channels are mixed. Just to see if our logic works or not.
> > Maybe you can think of some weird cases?
> 
> Yes, I'll add more.
> 
> > 5. All this said, it seems to me I wasted one day of work. Not sure at
> > all we can keep some schema compatibility with the next schema... even
> > if of course we can try.
> 
> I think it was very good you have spotted this. While the mutliversion
> code was not wrong in itself, it did not support the features you had in
> mind (tag atomicity). Had we released like this we'd definitely have to
> introduce backward incompatible changes. I think we still have a chance
> to pull this off.
> 

