From Andrea.Valassi@cern.ch Wed Mar  1 17:46:57 2006
Date: Wed, 1 Mar 2006 17:46:17 +0100 (CET)
From: Andrea Valassi <Andrea.Valassi@cern.ch>
To: LCG ConditionsDB developers
    <project-lcg-peb-conditionsdb-developers@cern.ch>
Subject: User tag functionality specification

Dear all,

following Monday's discussion with Sven and Richard at the weekly COOL 
meeting about the new 'user tag' functionality required for COOL_1_3_0,
we had some discussion in the development team about the possibility
to extend the specification proposed last year to meet the new requirements
discussed at the meeting. We also discussed the possible implementation
of the additional requirements.

To cut a long story short: we are working on the additional requirements
presented, and it seems feasible that we could be able to implement
them eventually. However, the planned timescale for user tag implementation
in COOL_1_3_0 by March 21 is too tight to complete the specification
and implementation design. I would therefore propose that we only provide
an implementation of the 'old' specification (spec#1 below) in COOL130.
We can then converge on the discussion of an extended specification
and of its implementation, if required.

Would this be acceptable, or is it useless to have an implementation
of the 'old' user tag requirement specification (spec#1), and you would 
rather wait to have one of the two 'extended' specifications (spec#2 and 
spec#3) implemented later on?

Extensive details of the proposed specification spec#1 for COOL130,
and of its possible future extensions spec#2 and spec#3, follow below.

The main difference is that in spec#1 standard tags and user tags
are different types of tags that cannot be mixed, while in spec#2
and spec#3 they are the same single type of tags and can be mixed.
The difference between spec#2 and spec#3 is on the issue whether
the system should/can erase all memory of tag manipulations (spec#2)
or should preserve it (spec#3).

Please let us know...

Thanks
Andrea

===============================================
User tag specification (AV 01.03.2006)
===============================================

For reference: the original specification is the one I proposed 
in an e-mail message in April last year, which you may find in
the COOL CVS doc repository in http://cool.cvs.cern.ch/cgi-bin/cool.cgi/cool/RelationalCool/doc/userTagsSpec.txt

Details of the specifications we are discussing:

Spec#1 (April 2005)
--------------------
- Users may attach a (standard) tag to the current HEAD (already in COOL128).
- Users may attach a (standard) tag to the HEAD as it was at a given time 
  in the past (already in COOL128).
- NEW: Users may attach AT MOST ONE (user) tag to any IOV they are inserting.
- User tags (attached on IOV insertion) and standard tags (attached by
  tagging the current or past HEAD) are of two different types and they 
  cannot be mixed. There are methods to check what type of tag is
  a given tag name. If a tag already exists as standard/user tag,
  then an exception is thrown on any attempt to use it as the
  opposite type user/standard.
- A method to 'tag as tagB all IOVs that were tagged as tagA at time t0 in
  the past' has not been explicitly requested and will NOT be implemented,
  neither for HEAD tags (as in COOL128), nor in the new user tags.
  Nevertheless, the proposed implementation for spec#1 could (to be 
  confirmed) allow this extra functionality to be added without major
  schema changes, both for standard tags and user tags.

More details about the last point (history of retags, i.e. changes of tags):
- Whenever a current/past HEAD is attached a tag, any memory of previously
  assigned tags is erased (this is what happens in COOL128). This is very
  clear as the 'retag' functionality is only available to users by first
  deleting the tag and then reassigning it. In principle, however, it is 
  always possible to recover a previously assigned HEAD tag, as long
  as one knows the time at which the relevant IOVs were the HEAD.
- User tags are different from standard tags and are implemented in
  a different way. The insertion of new IOVs with a user tag attached to
  them implies a continuous modification of the set of IOVs with the
  user tag attached. However, the proposed implementation of user tags 
  is a clone of that used for the global HEAD tag, on a separate branch:
  in principle, it should be possible to recover the set of IOVs that
  were in a certain user tag at a specified time in the past, just like 
  this is possible for the global HEAD.

Implementation notes:
- Tag to IOV associations are stored in a separate IOV2TAG table.
  The contents of this table, however, are largely redundant with
  the IOV table and could easily be rebuilt via simple queries
  on the IOV table (as in COOL128).

Spec#2 (February 2006)
-----------------------
- Users may attach a (standard) tag to the current HEAD (already in COOL128).
- Users may attach a (standard) tag to the HEAD as it was at a given time 
  in the past (already in COOL128).
- NEW: Users may attach AT MOST ONE (user) tag to any IOV they are inserting.
- User tags (attached on IOV insertion) and standard tags (attached by
  tagging the current or past HEAD) are not two different types of tags.
  Users can tag a current global HEAD or past global HEAD with a given tag, 
  then insert a new IOV and attach it to the existing tag. They can also tag 
  a current global HEAD or past global HEAD with a tag after having inserted
  an IOV with that same tag attached.
- The system has NO MEMORY whatsoever of tag manipulations.
  A method to 'tag as tagB all IOVs that were tagged as tagA at time t0 in
  the past' has not been explicitly requested and CANNOT be implemented.
  Whenever the contents of a tag are changed, whether through tagged
  IOV insertion or through current/past HEAD tag, all previous associations
  of IOVs to tags are ERASED. If users make a mistake in tagging... too bad.
  In particular, if a user inserts an IOV with MYTAG, but later tags
  a new HEAD as MYTAG, that IOV is kept in the system (and is used in the
  determination of the global HEAD), but the information that it had been 
  inserted with tag MYTAG is ERASED.

Implementation notes:
- The proposed implementation might (to be confirmed) also make it possible 
  to attach any number of tags on insertion. This is because an IOV may
  in any case be attached to any number of tags via the current/past HEAD
  tag functionality. The system is thus forced to maintain as many
  separate IOV branches as there are tags defined, whether these were
  attached as HEAD tags or on IOV insertion.
- Tag to IOV associations are stored in a separate IOV2TAG table.
  The contents of this table CANNOT easily be recovered from simple queries
  on the IOV table, because the memory of tag manipulations is missing.
  The IOV2TAG table provides a lot of extra information with respect
  to that contained in the IOV table. Note that the payload is stored
  in the IOV table.

Spec#3 (March 2006)
--------------------
- Users may attach a (standard) tag to the current HEAD (already in COOL128).
- Users may attach a (standard) tag to the HEAD as it was at a given time 
  in the past (already in COOL128).
- NEW: Users may attach AT MOST ONE (user) tag to any IOV they are inserting.
- User tags (attached on IOV insertion) and standard tags (attached by
  tagging the current or past HEAD) are not two different types of tags.
  Users can tag a current global HEAD or past global HEAD with a given tag, 
  then insert a new IOV and attach it to the existing tag. They can also tag 
  a current global HEAD or past global HEAD with a tag after having inserted
  an IOV with that same tag attached.
- The system maintains the full memory of tag manipulations.
  A method to 'tag as tagB all IOVs that were tagged as tagA at time t0 in
  the past' can be implemented. Whenever the contents of a tag are changed, 
  whether through tagged IOV insertion or through current/past HEAD tag, 
  tag-to-IOV associations are updated and new ones are inserted,
  but none are deleted. Methods are provided to allow users to
  erase (or simply archive?) obsolete data from the IOV table if required.

Implementation notes:
- The proposed implementation might (to be confirmed) also make it possible 
  to attach any number of tags on insertion. This is because an IOV may
  in any case be attached to any number of tags via the current/past HEAD
  tag functionality. The system is thus forced to maintain as many
  separate IOV branches as there are tags defined, whether these were
  attached as HEAD tags or on IOV insertion.
- Tag to IOV associations and their history are stored in the IOV table. 
  A snapshot of this table containing only the currently tagged IOVs
  is stored in the IOV2TAG table for performance reasons.
- The number of rows in the IOV table is roughly proportional to the
  number of tags applied, because the full history of tag manipulations
  is retained. The need to move the payload to a separate table
  becomes much more pressing.

===============================================
User tag example specification (AV 01.03.2006)
===============================================

Main points of spec#1:
- An IOV can be inserted with AT MOST ONE associated user tag. 
  This means that a consistent HEAD version must be kept (within the folder
  and the channel) not only for ALL IOVS, but also for EACH subset of IOVS
  associated to any given user tag.
- Two types of tags exist: 'user tags' (those specified when inserting a 
  new IOV) are different from 'standard tags' (those specified when tagging 
  the HEAD of existing IOVs) and can NOT be mixed.

[NB Each tag is independent of each other: it is NOT foreseen that one can 
ask for "the HEAD for tag A AND tag B, or the HEAD for tag A OR tag B".]

Example 1
----------
1. User inserts P1 payload in [  0, 100] with NO (user) tags
2. User inserts P2 payload in [ 10,  50] with (user) tag #1
3. User inserts P3 payload in [ 30,  80] with (user) tag #2
4. User inserts P4 payload in [ 20,  40] with (user) tag #1
5. User inserts P5 payload in [ 30,  70] with (user) tag #2

Note that this example is the same for all of spec#1, spec#2 and spec#3. 
The only difference is in terminology: in spec#1
these tags are 'user' tags (different type from 'standard' tags),
while in spec#2 and spec#3 they are just 'tags'.

HEAD versions after last insertion:

All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P2 in [ 10,  20]
  P4 in [ 20,  30]
  P5 in [ 30,  70]
  P3 in [ 70,  80]
  P1 in [ 80, 100]

(User) tag #1:
  P2 in [ 10,  20]
  P4 in [ 20,  40]
  P2 in [ 40,  50]

(User) tag #2:
  P5 in [ 30,  70]
  P3 in [ 70,  80]

Example 2 (spec #1)
--------------------
1. User inserts P1 payload in [  0,  50] with NO user tags
2. User inserts P2 payload in [ 50, 100] with NO user tags
3. User tags HEAD of folder with tag #2
4. User inserts P4 payload in [ 10,  50] with user tag #1
5. User inserts P5 payload in [ 30,  80] with user tag #2 - EXCEPTION
6. User inserts P6 payload in [ 20,  40] with user tag #1
7. User inserts P7 payload in [ 30,  70] with user tag #2 - EXCEPTION

In spec#1, step 5 and 7 here throw an exception: tag #2 is already reserved 
as a 'standard' tag and cannot be used as a 'user' tag.

HEAD versions after last insertion (ignoring step 5 and 7):

All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P4 in [ 10,  20]
  P6 in [ 20,  30]
  P7 in [ 30,  70]
  P5 in [ 70,  80]
  P2 in [ 80, 100]

Tag #1:
  P4 in [ 10,  20]
  P6 in [ 20,  40]
  P4 in [ 40,  50]

User tag #2:
  P1 in [  0,  50]
  P2 in [ 50, 100]

Example 2 (spec#2 and spec#3)
------------------------------
1. User inserts P1 payload in [  0,  50] with NO user tags
2. User inserts P2 payload in [ 50, 100] with NO user tags
3. User tags HEAD of folder with tag #2
4. User inserts P4 payload in [ 10,  50] with user tag #1
5. User inserts P5 payload in [ 30,  80] with user tag #2
6. User inserts P6 payload in [ 20,  40] with user tag #1
7. User inserts P7 payload in [ 30,  70] with user tag #2

In specifications spec#2 and spec#3, no exceptions are thrown.

HEAD versions after last insertion:

All IOVS (irrespective of tags):
  P1 in [  0,  10]
  P4 in [ 10,  20]
  P6 in [ 20,  30]
  P7 in [ 30,  70]
  P5 in [ 70,  80]
  P2 in [ 80, 100]

Tag #1:
  P4 in [ 10,  20]
  P6 in [ 20,  40]
  P4 in [ 40,  50]

Tag #2:
  P1 in [  0,  30]
  P7 in [ 30,  70]
  P5 in [ 70,  80]
  P2 in [ 80, 100]

Example 3 (spec#2 and spec#3)
------------------------------
 1. User inserts P1  payload in [  0,  50] with NO user tags
 2. User inserts P2  payload in [ 50, 100] with NO user tags
 3. User tags HEAD of folder with tag #2
 4. User inserts P4  payload in [ 10,  50] with user tag #1
 5. User inserts P5  payload in [ 30,  80] with user tag #2
 6. User inserts P6  payload in [ 20,  40] with user tag #1
 7. User inserts P7  payload in [ 30,  70] with user tag #2
 8. User tags HEAD of folder with tag #2
 9. User inserts P9  payload in [ 30,  80] with user tag #2
10. User inserts P10 payload in [ 20,  40] with user tag #1

In specification spec#1, step 5 throws an exception.
This example mainly shows the differemce between spec#2 and spec#3.

In spec#2 and spec#3, no exceptions are thrown.
In both specifications the tags after the last insertions are the same:

HEAD versions after last insertion:

All IOVS (irrespective of tags):
  P1  in [  0,  10]
  P4  in [ 10,  20]
  P10 in [ 20,  40]
  P9  in [ 40,  80]
  P2  in [ 80, 100]

Tag #1:
  P4  in [ 10,  20]
  P10 in [ 20,  40]
  P4  in [ 40,  50]

Tag #2:
  P1 in [  0,  10]
  P4 in [ 10,  20]
  P6 in [ 20,  30]
  P9 in [ 30,  80]
  P2 in [ 80, 100]

In spec#2, tagging the HEAD (in step 8) with the same tag name 
previously used for inserting IOVs with attached tags (e.g. step 5)
logically erases all tag-to-IOV relations defined when inserting 
IOVs with attached tags (e.g. the tag attached in step 5 loses meaning).
That is to say, the memory that P5 and P7 were inserted with tag#2 is lost.
The memory that a HEAD tag was applied at the time of step 3 is also lost.

In spec#3, the full memory of tag manipulations is retained.

-------------------------------------------------------------------------------

For reference: David Malon presented his use case in the presentation 
at the 2003 CondDB Workshop: http://agenda.cern.ch/fullAgenda.php?ida=a036470

