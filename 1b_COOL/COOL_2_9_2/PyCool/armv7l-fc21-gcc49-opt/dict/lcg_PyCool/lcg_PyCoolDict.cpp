// Generated at Wed Apr 15 17:02:02 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/home/jwsmith/HDD/ANA/ANA/1_LCGSoftware/lcgcmake_install-armv7l-fc21-gcc49-opt-71/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="g++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/home/jwsmith/HDD/ANA/ANA/1_LCGSoftware/lcgcmake_install-armv7l-fc21-gcc49-opt-71/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/home/jwsmith/HDD/ANA/ANA/1_LCGSoftware/lcgcmake_install-armv7l-fc21-gcc49-opt-71/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__UINT_LEAST16_MAX__='65535' -D__ARM_SIZEOF_WCHAR_T='4' -D__ATOMIC_ACQUIRE='2' -D__SFRACT_IBIT__='0' -D__FLT_MIN__='1.1754943508222875e-38F' -D__GCC_IEC_559_COMPLEX='2' -D__UFRACT_MAX__='0XFFFFP-16UR' -D__UINT_LEAST8_TYPE__='unsigned char' -D__DQ_FBIT__='63' -D__INTMAX_C(c)='c ## LL' -D__ARM_FEATURE_SAT='1' -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK' -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__UINT8_MAX__='255' -D__ACCUM_FBIT__='15' -D__WINT_MAX__='4294967295U' -D__USFRACT_FBIT__='8' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='4294967295U' -D__ARM_ARCH_ISA_ARM='1' -D__WCHAR_MAX__='4294967295U' -D__LACCUM_IBIT__='32' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.9406564584124654e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__GCC_IEC_559='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__cpp_binary_literals='201304' -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__FRACT_FBIT__='15' -D__UINT_FAST64_MAX__='18446744073709551615ULL' -D__SIG_ATOMIC_TYPE__='int' -D__UACCUM_FBIT__='16' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__ARMEL__='1' -D__ARM_FEATURE_UNALIGNED='1' -D__LFRACT_IBIT__='0' -D__GNUC_PATCHLEVEL__='2' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR' -D__UINT_FAST8_MAX__='255' -D__has_include(STR)='__has_include__(STR)' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615ULL' -D__SA_FBIT__='15' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L' -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16' -D__ARM_FP='12' -D__UFRACT_MIN__='0.0UR' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__CHAR_UNSIGNED__='1' -D__UINT32_MAX__='4294967295U' -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64' -D__LDBL_MAX_EXP__='1024' -D__WINT_MIN__='0U' -D__linux__='1' -D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='0U' -D__INT64_C(c)='c ## LL' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='4' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USACCUM_IBIT__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)' -D__HA_IBIT__='8' -D__ARM_NEON_FP='4' -D__TQ_IBIT__='0' -D__FLT_EPSILON__='1.1920928955078125e-7F' -D__APCS_32__='1' -D__GXX_WEAK__='1' -D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L' -D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF' -D__DA_IBIT__='32' -D__ARM_SIZEOF_MINIMAL_ENUM='4' -D__INT32_MAX__='2147483647' -D__UQQ_FBIT__='8' -D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK' -D__STDC_IEC_559__='1' -D__STDC_ISO_10646__='201103L' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR' -D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1' -D__has_include_next(STR)='__has_include_next__(STR)' -D__ARM_PCS_VFP='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32' -D__UACCUM_EPSILON__='0x1P-16UK' -D__GNUC__='4' -D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__GXX_RTTI='1' -D__HQ_IBIT__='0' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D__BIGGEST_ALIGNMENT__='8' -D__DQ_IBIT__='0' -D__DBL_MAX__='double(1.7976931348623157e+308L)' -D__ULFRACT_IBIT__='0' -D__INT_FAST32_MAX__='2147483647' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807LL' -D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-94)' -D__THUMB_INTERWORK__='1' -D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__INT_FAST16_TYPE__='int' -D__LDBL_HAS_DENORM__='1' -D__ARM_FEATURE_LDREX='15' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK' -D__DEC128_EPSILON__='1E-33DL' -D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0' -D__PTRDIFF_MAX__='2147483647' -D__UACCUM_MIN__='0.0UK' -D__STDC_NO_THREADS__='1' -D__UACCUM_IBIT__='16' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4' -D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4' -D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK' -D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64' -D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR' -D__UFRACT_IBIT__='0' -D__ARM_FEATURE_QBIT='1' -D__INT_FAST64_TYPE__='long long int' -D__DBL_MIN__='double(2.2250738585072014e-308L)' -D__FLT_MIN_10_EXP__='(-37)' -D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32' -D__GXX_TYPEINFO_EQUALITY_INLINE='0' -D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0' -D__UINT8_TYPE__='unsigned char' -D__UHA_FBIT__='8' -D__NO_INLINE__='1' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.9.2 20150212 (Red Hat 4.9.2-6)"' -D__UINT64_C(c)='c ## ULL' -D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R' -D__ULACCUM_MIN__='0.0ULK' -D_STDC_PREDEF_H='1' -D__UDA_FBIT__='32' -D__LLACCUM_EPSILON__='0x1P-31LLK' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__USFRACT_MIN__='0.0UHR' -D__ULLACCUM_IBIT__='32' -D__UQQ_IBIT__='0' -D__STDC_IEC_559_COMPLEX__='1' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -D__INT_FAST32_TYPE__='int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='unsigned int' -D__UINT64_MAX__='18446744073709551615ULL' -D__UDQ_FBIT__='64' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__ARM_ARCH_PROFILE='65' -D__LDBL_EPSILON__='2.2204460492503131e-16L' -D__UINTMAX_C(c)='c ## ULL' -D__GNUC_RH_RELEASE__='6' -D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__VFP_FP__='1' -D__SIZEOF_PTRDIFF_T__='4' -D__LACCUM_EPSILON__='0x1P-31LK' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='2147483647' -D__UINT_FAST32_MAX__='4294967295U' -D__UINT_LEAST64_TYPE__='long long unsigned int' -D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='2147483647L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__unix='1' -D__USA_FBIT__='16' -D__UINT_FAST16_TYPE__='unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__ARM_32BIT_STATE='1' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__SACCUM_FBIT__='7' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long long int' -D__ARM_FEATURE_CLZ='1' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__SQ_FBIT__='31' -D__DEC32_MAX_EXP__='97' -D__ARM_ARCH_ISA_THUMB='2' -D__INT_FAST8_MAX__='127' -D__ARM_ARCH='7' -D__INTPTR_MAX__='2147483647' -D__QQ_FBIT__='7' -Dlinux='1' -D__UTA_IBIT__='64' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='53' -D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__INTPTR_TYPE__='int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='unsigned int' -D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32' -D__UINTPTR_MAX__='4294967295U' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807LL' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long long unsigned int' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31' -D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__INT64_TYPE__='long long int' -D__FLT_MAX_EXP__='128' -D__UTQ_IBIT__='0' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807LL' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0' -D__LDBL_MIN_EXP__='(-1021)' -D__arm__='1' -D__UDA_IBIT__='32' -D__INT_LEAST8_MAX__='127' -D__LFRACT_FBIT__='31' -D__WCHAR_UNSIGNED__='1' -D__ARM_ARCH_7A__='1' -D__LDBL_MAX_10_EXP__='308' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.2204460492503131e-16L)' -D__ARM_FEATURE_SIMD32='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long long unsigned int' -D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127' -D__INT_FAST8_TYPE__='signed char' -D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0' -D__LLACCUM_IBIT__='32' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63' -D__UDQ_IBIT__='0' -D__ORDER_BIG_ENDIAN__='4321' -D__ACCUM_EPSILON__='0x1P-15K' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807LL' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.4012984643248171e-45F' -D__LLFRACT_IBIT__='0' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.4028234663852886e+38F' -D__USACCUM_FBIT__='8' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__UFRACT_EPSILON__='0x1P-16UR' -D__INTMAX_TYPE__='long long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='9' -D__UINTMAX_MAX__='18446744073709551615ULL' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)' -D__ATOMIC_SEQ_CST='5' -D__DA_FBIT__='31' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='unsigned int' -D__USA_IBIT__='16' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__ARM_EABI__='1' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8' -D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='15' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='4294967295U' -D__GNUC_GNU_INLINE__='1' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32' -D__ARM_FEATURE_DSP='1' -D__QQ_IBIT__='0' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/home/jwsmith/HDD/ANA/ANA/1_LCGSoftware/lcgcmake_install-armv7l-fc21-gcc49-opt-71/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/GCC/4.9" -isystem"/home/jwsmith/HDD/ANA/ANA/1_LCGSoftware/lcgcmake_install-armv7l-fc21-gcc49-opt-71/Python/2.7.6/armv7l-fc21-gcc49-opt/include/python2.7" -isystem"/home/jwsmith/HDD/ANA/ANA/1a_CORAL/CORAL-2-4-2/../armv7l-fc21-gcc49-opt/include" -isystem"." -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/armv7hl-redhat-linux-gnueabi" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/backward" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/include" -isystem"/usr/local/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/home/jwsmith/HDD/ANA/ANA/1_LCGSoftware/lcgcmake_install-armv7l-fc21-gcc49-opt-71/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9"

Compiler info:
g++ (GCC) 4.9.2 20150212 (Red Hat 4.9.2-6)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/home/jwsmith/HDD/ANA/ANA/1b_COOL/COOL_2_9_2/PyCool/armv7l-fc21-gcc49-opt/dict/PyCool_headers_and_helpers.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("__gnu_cxx") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("cool") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("coral") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("boost") );
  ::Reflex::NamespaceBuilder nsb5( Reflex::Literal("cool::HvsTagLock") );
  ::Reflex::NamespaceBuilder nsb6( Reflex::Literal("cool::MSG") );
  ::Reflex::NamespaceBuilder nsb7( Reflex::Literal("cool::PayloadMode") );
  ::Reflex::NamespaceBuilder nsb8( Reflex::Literal("cool::FolderVersioning") );
  ::Reflex::NamespaceBuilder nsb9( Reflex::Literal("boost::detail") );
  ::Reflex::NamespaceBuilder nsb10( Reflex::Literal("cool::PyCool::Helpers") );
  ::Reflex::Type type_30 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_116 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1770 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_2380 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_1862 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_614 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_1736 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1730 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_91 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_75 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_2220 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Time"));
  ::Reflex::Type type_2231 = ::Reflex::TypeBuilder(Reflex::Literal("coral::Blob"));
  ::Reflex::Type type_2208 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ITime"));
  ::Reflex::Type type_46 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1737 = ::Reflex::TypeBuilder(Reflex::Literal("long double"));
  ::Reflex::Type type_2160 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IField"));
  ::Reflex::Type type_2199 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Record"));
  ::Reflex::Type type_130 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_2191 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord"));
  ::Reflex::Type type_2210 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObject"));
  ::Reflex::Type type_242 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_2300 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolder"));
  ::Reflex::Type type_2134 = ::Reflex::TypeBuilder(Reflex::Literal("seal::Context"));
  ::Reflex::Type type_1592 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_2228 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNode"));
  ::Reflex::Type type_1594 = ::Reflex::TypeBuilder(Reflex::Literal("std::exception"));
  ::Reflex::Type type_2291 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception"));
  ::Reflex::Type type_2250 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IDatabase"));
  ::Reflex::Type type_2242 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagExists"));
  ::Reflex::Type type_2339 = ::Reflex::TypeBuilder(Reflex::Literal("coral::Attribute"));
  ::Reflex::Type type_1699 = ::Reflex::TypeBuilder(Reflex::Literal("std::__true_type"));
  ::Reflex::Type type_2167 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSet"));
  ::Reflex::Type type_2276 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeExists"));
  ::Reflex::Type type_2354 = ::Reflex::TypeBuilder(Reflex::Literal("coral::Exception"));
  ::Reflex::Type type_108 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long long"));
  ::Reflex::Type type_1257 = ::Reflex::TypeBuilder(Reflex::Literal("std::__false_type"));
  ::Reflex::Type type_2170 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageType"));
  ::Reflex::Type type_2157 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagNotFound"));
  ::Reflex::Type type_2202 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldIsNull"));
  ::Reflex::Type type_2280 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagIsLocked"));
  ::Reflex::Type type_2269 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Application"));
  ::Reflex::Type type_2268 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeNotFound"));
  ::Reflex::Type type_2243 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IDatabaseSvc"));
  ::Reflex::Type type_2233 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IApplication"));
  ::Reflex::Type type_2159 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelExists"));
  ::Reflex::Type type_2342 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList"));
  ::Reflex::Type type_1425 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_2194 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ObjectNotFound"));
  ::Reflex::Type type_2235 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord"));
  ::Reflex::Type type_7891 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::MSG::Level"));
  ::Reflex::Type type_2283 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderNotFound"));
  ::Reflex::Type type_2348 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeData"));
  ::Reflex::Type type_2345 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IWebCacheInfo"));
  ::Reflex::Type type_2337 = ::Reflex::TypeBuilder(Reflex::Literal("coral::ISessionProxy"));
  ::Reflex::Type type_2154 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSelection"));
  ::Reflex::Type type_2281 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordIterator"));
  ::Reflex::Type type_2245 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException"));
  ::Reflex::Type type_2153 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObjectIterator"));
  ::Reflex::Type type_2196 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelNotFound"));
  ::Reflex::Type type_2212 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseNotOpen"));
  ::Reflex::Type type_2246 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ReservedHeadTag"));
  ::Reflex::Type type_2341 = ::Reflex::TypeBuilder(Reflex::Literal("coral::ILookupService"));
  ::Reflex::Type type_2333 = ::Reflex::EnumTypeBuilder(Reflex::Literal("coral::AccessMode"));
  ::Reflex::Type type_1488 = ::Reflex::TypeBuilder(Reflex::Literal("std::char_traits<char>"));
  ::Reflex::Type type_2225 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSelection"));
  ::Reflex::Type type_2278 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelSelection"));
  ::Reflex::Type type_1333 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_1700 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2182 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderSetNotFound"));
  ::Reflex::Type type_2186 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldWrongCppType"));
  ::Reflex::Type type_2251 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagRelationExists"));
  ::Reflex::Type type_2346 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IWebCacheControl"));
  ::Reflex::Type type_1604 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_node_base"));
  ::Reflex::Type type_2211 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidTagRelation"));
  ::Reflex::Type type_8226 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::IHvsNode::Type"));
  ::Reflex::Type type_2244 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecification"));
  ::Reflex::Type type_2255 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseSvcFactory"));
  ::Reflex::Type type_2259 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidChannelName"));
  ::Reflex::Type type_2168 = ::Reflex::TypeBuilder(Reflex::Literal("cool::CompositeSelection"));
  ::Reflex::Type type_2209 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ConstRecordAdapter"));
  ::Reflex::Type type_1288 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_2205 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFieldSpecification"));
  ::Reflex::Type type_2164 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidChannelRange"));
  ::Reflex::Type type_2179 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagRelationNotFound"));
  ::Reflex::Type type_2193 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecification"));
  ::Reflex::Type type_2270 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeIsSingleVersion"));
  ::Reflex::Type type_2353 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IConnectionService"));
  ::Reflex::Type type_2299 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderSpecification"));
  ::Reflex::Type type_8751 = ::Reflex::EnumTypeBuilder(Reflex::Literal("coral::monitor::Level"));
  ::Reflex::Type type_2343 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IRelationalService"));
  ::Reflex::Type type_2351 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeException"));
  ::Reflex::Type type_8968 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::weak_count"));
  ::Reflex::Type type_2171 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSpecification"));
  ::Reflex::Type type_1291 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::IField*>"));
  ::Reflex::Type type_2197 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException"));
  ::Reflex::Type type_2201 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyException"));
  ::Reflex::Type type_2213 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseDoesNotExist"));
  ::Reflex::Type type_2286 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSpecification"));
  ::Reflex::Type type_2282 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeRelationNotFound"));
  ::Reflex::Type type_2344 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IMonitoringReporter"));
  ::Reflex::Type type_8922 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::shared_count"));
  ::Reflex::Type type_2207 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderIsSingleVersion"));
  ::Reflex::Type type_2267 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeFloatIsNaN"));
  ::Reflex::Type type_7924 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::PayloadMode::Mode"));
  ::Reflex::Type type_1429 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned int>"));
  ::Reflex::Type type_7885 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::HvsTagLock::Status"));
  ::Reflex::Type type_2249 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeDoubleIsNaN"));
  ::Reflex::Type type_2262 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeBlobTooLong"));
  ::Reflex::Type type_2335 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeSpecification"));
  ::Reflex::Type type_1432 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IField*>"));
  ::Reflex::Type type_2142 = ::Reflex::TypeBuilder(Reflex::Literal("__cxxabiv1::__class_type_info"));
  ::Reflex::Type type_7597 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::StorageType::TypeId"));
  ::Reflex::Type type_2277 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue"));
  ::Reflex::Type type_2198 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeWrongCppType"));
  ::Reflex::Type type_2338 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IAuthenticationService"));
  ::Reflex::Type type_2347 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeListException"));
  ::Reflex::Type type_8916 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::sp_nothrow_tag"));
  ::Reflex::Type type_1297 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<coral::Attribute*>"));
  ::Reflex::Type type_2165 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeStringTooLong"));
  ::Reflex::Type type_2254 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidUInt63"));
  ::Reflex::Type type_8754 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator"));
  ::Reflex::Type type_8896 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::sp_counted_base"));
  ::Reflex::Type type_1423 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_2218 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityIntervalBackwards"));
  ::Reflex::Type type_2334 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IReplicaSortingAlgorithm"));
  ::Reflex::Type type_1657 = ::Reflex::TypeBuilder(Reflex::Literal("std::bidirectional_iterator_tag"));
  ::Reflex::Type type_2180 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IObject>"));
  ::Reflex::Type type_2214 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolder>"));
  ::Reflex::Type type_2288 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IRecord>"));
  ::Reflex::Type type_2252 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification"));
  ::Reflex::Type type_8580 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::FolderVersioning::Mode"));
  ::Reflex::Type type_2247 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyOutOfBoundaries"));
  ::Reflex::Type type_2265 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseOpenInReadOnlyMode"));
  ::Reflex::Type type_10064 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs"));
  ::Reflex::Type type_8434 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::ChannelSelection::Order"));
  ::Reflex::Type type_1440 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::Attribute*>"));
  ::Reflex::Type type_2204 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification"));
  ::Reflex::Type type_2192 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecificationWrongName"));
  ::Reflex::Type type_2332 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeListSpecification"));
  ::Reflex::Type type_2226 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IDatabase>"));
  ::Reflex::Type type_7599 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::FieldSelection::Relation"));
  ::Reflex::Type type_7691 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::FieldSelection::Nullness"));
  ::Reflex::Type type_2284 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecificationWrongSize"));
  ::Reflex::Type type_8750 = ::Reflex::TypeBuilder(Reflex::Literal("coral::monitor::IMonitoringService"));
  ::Reflex::Type type_2187 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolderSet>"));
  ::Reflex::Type type_2248 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecificationInvalidName"));
  ::Reflex::Type type_8758 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator_base"));
  ::Reflex::Type type_1292 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::IRecordSelection*>"));
  ::Reflex::Type type_3566 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelSelection::ChannelRange"));
  ::Reflex::Type type_8753 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::const_iterator"));
  ::Reflex::Type type_3893 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>::_Alloc_hider"));
  ::Reflex::Type type_1287 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_2176 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecificationUnknownField"));
  ::Reflex::Type type_2230 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecificationCannotExtend"));
  ::Reflex::Type type_1516 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"));
  ::Reflex::Type type_2336 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IConnectionServiceConfiguration"));
  ::Reflex::Type type_1433 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>"));
  ::Reflex::Type type_1294 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1964 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>"));
  ::Reflex::Type type_2158 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyFields"));
  ::Reflex::Type type_2253 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeStringContainsNullChar"));
  ::Reflex::Type type_2172 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>"));
  ::Reflex::Type type_1283 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute**>"));
  ::Reflex::Type type_1426 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::basic_string<char> >"));
  ::Reflex::Type type_2155 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecificationWrongStorageType"));
  ::Reflex::Type type_7819 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::CompositeSelection::Connective"));
  ::Reflex::Type type_1435 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1293 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const cool::IRecordSelection*>"));
  ::Reflex::Type type_2263 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationInvalidFieldName"));
  ::Reflex::Type type_1296 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1970 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>"));
  ::Reflex::Type type_2294 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyBlobFields"));
  ::Reflex::Type type_1289 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1290 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_1284 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute* const*>"));
  ::Reflex::Type type_1437 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1515 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_1591 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_2302 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyString255Fields"));
  ::Reflex::Type type_1430 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1431 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_1295 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_1963 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>"));
  ::Reflex::Type type_8601 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeListSpecification::const_iterator"));
  ::Reflex::Type type_10228 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord* boost::shared_ptr<cool::IRecord>::*"));
  ::Reflex::Type type_10076 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObject* boost::shared_ptr<cool::IObject>::*"));
  ::Reflex::Type type_10122 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolder* boost::shared_ptr<cool::IFolder>::*"));
  ::Reflex::Type type_1436 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_1965 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1450 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IField*>::rebind<cool::IField*>"));
  ::Reflex::Type type_1318 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_1713 = ::Reflex::TypeBuilder(Reflex::Literal("std::__are_same<coral::Attribute**,coral::Attribute**>"));
  ::Reflex::Type type_1279 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>"));
  ::Reflex::Type type_1280 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>"));
  ::Reflex::Type type_10137 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*"));
  ::Reflex::Type type_1932 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned int> >"));
  ::Reflex::Type type_1969 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1936 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >"));
  ::Reflex::Type type_10083 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*"));
  ::Reflex::Type type_1282 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>"));
  ::Reflex::Type type_1961 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1962 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_2025 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >"));
  ::Reflex::Type type_1456 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::Attribute*>::rebind<coral::Attribute*>"));
  ::Reflex::Type type_1712 = ::Reflex::TypeBuilder(Reflex::Literal("std::__are_same<coral::Attribute* const*,coral::Attribute**>"));
  ::Reflex::Type type_2007 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_1567 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >"));
  ::Reflex::Type type_1942 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >"));
  ::Reflex::Type type_2006 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_1966 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_1571 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >"));
  ::Reflex::Type type_2161 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_2223 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_2040 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >"));
  ::Reflex::Type type_1935 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >"));
  ::Reflex::Type type_10058 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*"));
  ::Reflex::Type type_1929 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_2019 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_1937 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1575 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >"));
  ::Reflex::Type type_1427 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_2028 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >"));
  ::Reflex::Type type_1449 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>"));
  ::Reflex::Type type_1941 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_2005 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_1534 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_2020 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_1933 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_1934 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_5327 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::_Vector_impl"));
  ::Reflex::Type type_2029 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> >"));
  ::Reflex::Type type_1451 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1367 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_1938 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_2036 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_1950 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>"));
  ::Reflex::Type type_1570 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >"));
  ::Reflex::Type type_1563 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::basic_string<char> > >"));
  ::Reflex::Type type_1566 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_1586 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_5399 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::_Vector_impl"));
  ::Reflex::Type type_2037 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_1455 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1711 = ::Reflex::TypeBuilder(Reflex::Literal("std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>"));
  ::Reflex::Type type_1956 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>"));
  ::Reflex::Type type_1572 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1562 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> > >"));
  ::Reflex::Type type_2026 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >"));
  ::Reflex::Type type_1447 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1448 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_2017 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_1541 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_1321 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,bool>"));
  ::Reflex::Type type_1549 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> > >"));
  ::Reflex::Type type_1574 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_5309 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::_Vector_impl"));
  ::Reflex::Type type_2027 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> >"));
  ::Reflex::Type type_2030 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1452 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_2018 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_1930 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1540 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_1949 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>"));
  ::Reflex::Type type_1568 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_1569 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_1548 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> > >"));
  ::Reflex::Type type_1539 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_5345 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::_Vector_impl"));
  ::Reflex::Type type_2031 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1559 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >"));
  ::Reflex::Type type_2035 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_1951 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1573 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_1538 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1558 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >"));
  ::Reflex::Type type_2021 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_2023 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_5381 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::_Vector_impl"));
  ::Reflex::Type type_2034 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_1955 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1547 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> > >"));
  ::Reflex::Type type_5273 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::_Vector_impl"));
  ::Reflex::Type type_5291 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::_Vector_impl"));
  ::Reflex::Type type_1537 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_2022 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_2024 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_2032 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_10040 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*"));
  ::Reflex::Type type_10131 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*"));
  ::Reflex::Type type_1947 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1948 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_1546 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> > >"));
  ::Reflex::Type type_1551 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> > >"));
  ::Reflex::Type type_1536 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_5363 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::_Vector_impl"));
  ::Reflex::Type type_2033 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_1952 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_1550 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> > >"));
  ::Reflex::Type type_1557 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> > >"));
  ::Reflex::Type type_1543 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >"));
  ::Reflex::Type type_1545 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >"));
  ::Reflex::Type type_1556 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >"));
  ::Reflex::Type type_1542 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >"));
  ::Reflex::Type type_1544 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >"));
  ::Reflex::Type type_1553 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> > >"));
  ::Reflex::Type type_1552 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> > >"));
  ::Reflex::Type type_1320 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1319 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1651 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned int,std::basic_string<char> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_2162 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IRecordVectorPtr"), type_2161);
  ::Reflex::Type type_2173 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectIteratorPtr"), type_2172);
  ::Reflex::Type type_2175 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IRecordVector"), type_1289);
  ::Reflex::Type type_2181 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectPtr"), type_2180);
  ::Reflex::Type type_2183 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectVector"), type_1290);
  ::Reflex::Type type_2188 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IFolderSetPtr"), type_2187);
  ::Reflex::Type type_1340 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1333);
  ::Reflex::Type type_2200 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String64k"), type_1340);
  ::Reflex::Type type_2215 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IFolderPtr"), type_2214);
  ::Reflex::Type type_2224 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectVectorPtr"), type_2223);
  ::Reflex::Type type_2227 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IDatabasePtr"), type_2226);
  ::Reflex::Type type_2232 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Blob16M"), type_2231);
  ::Reflex::Type type_2240 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String4k"), type_1340);
  ::Reflex::Type type_2258 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String16M"), type_1340);
  ::Reflex::Type type_2289 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IRecordPtr"), type_2288);
  ::Reflex::Type type_2290 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Blob64k"), type_2231);
  ::Reflex::Type type_2292 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::DatabaseId"), type_1340);
  ::Reflex::Type type_2297 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String255"), type_1340);
  ::Reflex::Type type_5035 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::iterator"), type_1367);
  ::Reflex::Type type_5036 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_iterator"), type_1586);
  ::Reflex::Type type_11211 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String255"), type_2297);
  ::Reflex::Type type_11212 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String4k"), type_2240);
  ::Reflex::Type type_11213 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String64k"), type_2200);
  ::Reflex::Type type_11214 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String16M"), type_2258);
  ::Reflex::Type type_11215 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob64k"), type_2290);
  ::Reflex::Type type_11216 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob16M"), type_2232);
  ::Reflex::Type type_2171c = ::Reflex::ConstBuilder(type_2171);
  ::Reflex::Type type_10023 = ::Reflex::ReferenceBuilder(type_2171c);
  ::Reflex::Type type_2256 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt32"), type_75);
  ::Reflex::Type type_1340c = ::Reflex::ConstBuilder(type_1340);
  ::Reflex::Type type_4025 = ::Reflex::ReferenceBuilder(type_1340c);
  ::Reflex::Type type_2160c = ::Reflex::ConstBuilder(type_2160);
  ::Reflex::Type type_8420 = ::Reflex::ReferenceBuilder(type_2160c);
  ::Reflex::Type type_2191c = ::Reflex::ConstBuilder(type_2191);
  ::Reflex::Type type_8419 = ::Reflex::ReferenceBuilder(type_2191c);
  ::Reflex::Type type_1717 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_1591);
  ::Reflex::Type type_8415 = ::Reflex::ReferenceBuilder(type_1717);
  ::Reflex::Type type_2342c = ::Reflex::ConstBuilder(type_2342);
  ::Reflex::Type type_8803 = ::Reflex::ReferenceBuilder(type_2342c);
  ::Reflex::Type type_1471 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_30);
  ::Reflex::Type type_3009 = ::Reflex::PointerBuilder(type_2288);
  ::Reflex::Type type_3011 = ::Reflex::ReferenceBuilder(type_2288);
  ::Reflex::Type type_9172 = ::Reflex::ReferenceBuilder(type_1279);
  ::Reflex::Type type_1279c = ::Reflex::ConstBuilder(type_1279);
  ::Reflex::Type type_9173 = ::Reflex::ReferenceBuilder(type_1279c);
  ::Reflex::Type type_10075 = ::Reflex::PointerBuilder(type_2210);
  ::Reflex::Type type_2203 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::ChannelId"), type_2256);
  ::Reflex::Type type_2203c = ::Reflex::ConstBuilder(type_2203);
  ::Reflex::Type type_10035 = ::Reflex::ReferenceBuilder(type_2203c);
  ::Reflex::Type type_2261 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt64"), type_108);
  ::Reflex::Type type_2296 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt63"), type_2261);
  ::Reflex::Type type_2237 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::ValidityKey"), type_2296);
  ::Reflex::Type type_2237c = ::Reflex::ConstBuilder(type_2237);
  ::Reflex::Type type_10113 = ::Reflex::ReferenceBuilder(type_2237c);
  ::Reflex::Type type_10114 = ::Reflex::ReferenceBuilder(type_2281);
  ::Reflex::Type type_2208c = ::Reflex::ConstBuilder(type_2208);
  ::Reflex::Type type_8416 = ::Reflex::ReferenceBuilder(type_2208c);
  ::Reflex::Type type_3020 = ::Reflex::PointerBuilder(type_2180);
  ::Reflex::Type type_3022 = ::Reflex::ReferenceBuilder(type_2180);
  ::Reflex::Type type_9174 = ::Reflex::ReferenceBuilder(type_1280);
  ::Reflex::Type type_1280c = ::Reflex::ConstBuilder(type_1280);
  ::Reflex::Type type_9175 = ::Reflex::ReferenceBuilder(type_1280c);
  ::Reflex::Type type_3039 = ::Reflex::PointerBuilder(type_2335);
  ::Reflex::Type type_3039c = ::Reflex::ConstBuilder(type_3039);
  ::Reflex::Type type_3042 = ::Reflex::PointerBuilder(type_3039c);
  ::Reflex::Type type_3044 = ::Reflex::ReferenceBuilder(type_3039c);
  ::Reflex::Type type_9179 = ::Reflex::ReferenceBuilder(type_1282);
  ::Reflex::Type type_1282c = ::Reflex::ConstBuilder(type_1282);
  ::Reflex::Type type_9180 = ::Reflex::ReferenceBuilder(type_1282c);
  ::Reflex::Type type_3051 = ::Reflex::PointerBuilder(type_2339);
  ::Reflex::Type type_3054 = ::Reflex::PointerBuilder(type_3051);
  ::Reflex::Type type_3056 = ::Reflex::ReferenceBuilder(type_3051);
  ::Reflex::Type type_9181 = ::Reflex::ReferenceBuilder(type_1283);
  ::Reflex::Type type_1283c = ::Reflex::ConstBuilder(type_1283);
  ::Reflex::Type type_9182 = ::Reflex::ReferenceBuilder(type_1283c);
  ::Reflex::Type type_3051c = ::Reflex::ConstBuilder(type_3051);
  ::Reflex::Type type_3065 = ::Reflex::PointerBuilder(type_3051c);
  ::Reflex::Type type_3067 = ::Reflex::ReferenceBuilder(type_3051c);
  ::Reflex::Type type_9184 = ::Reflex::ReferenceBuilder(type_1284);
  ::Reflex::Type type_1284c = ::Reflex::ConstBuilder(type_1284);
  ::Reflex::Type type_9185 = ::Reflex::ReferenceBuilder(type_1284c);
  ::Reflex::Type type_1527 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_75);
  ::Reflex::Type type_1527c = ::Reflex::ConstBuilder(type_1527);
  ::Reflex::Type type_3032 = ::Reflex::ReferenceBuilder(type_2380);
  ::Reflex::Type type_2380c = ::Reflex::ConstBuilder(type_2380);
  ::Reflex::Type type_3883 = ::Reflex::ReferenceBuilder(type_2380c);
  ::Reflex::Type type_744 = ::Reflex::PointerBuilder(type_2380);
  ::Reflex::Type type_1731 = ::Reflex::PointerBuilder(type_2380c);
  ::Reflex::Type type_1425c = ::Reflex::ConstBuilder(type_1425);
  ::Reflex::Type type_9299 = ::Reflex::ReferenceBuilder(type_1425c);
  ::Reflex::Type type_1333c = ::Reflex::ConstBuilder(type_1333);
  ::Reflex::Type type_3103 = ::Reflex::ReferenceBuilder(type_1333c);
  ::Reflex::Type type_2946 = ::Reflex::ReferenceBuilder(type_1333);
  ::Reflex::Type type_3098 = ::Reflex::PointerBuilder(type_1333);
  ::Reflex::Type type_3100 = ::Reflex::PointerBuilder(type_1333c);
  ::Reflex::Type type_1426c = ::Reflex::ConstBuilder(type_1426);
  ::Reflex::Type type_9191 = ::Reflex::ReferenceBuilder(type_1426c);
  ::Reflex::Type type_1287c = ::Reflex::ConstBuilder(type_1287);
  ::Reflex::Type type_9192 = ::Reflex::ReferenceBuilder(type_1287c);
  ::Reflex::Type type_9193 = ::Reflex::ReferenceBuilder(type_1287);
  ::Reflex::Type type_2378 = ::Reflex::PointerBuilder(type_75);
  ::Reflex::Type type_75c = ::Reflex::ConstBuilder(type_75);
  ::Reflex::Type type_3166 = ::Reflex::PointerBuilder(type_75c);
  ::Reflex::Type type_3168 = ::Reflex::ReferenceBuilder(type_75);
  ::Reflex::Type type_3170 = ::Reflex::ReferenceBuilder(type_75c);
  ::Reflex::Type type_1429c = ::Reflex::ConstBuilder(type_1429);
  ::Reflex::Type type_9195 = ::Reflex::ReferenceBuilder(type_1429c);
  ::Reflex::Type type_1288c = ::Reflex::ConstBuilder(type_1288);
  ::Reflex::Type type_9196 = ::Reflex::ReferenceBuilder(type_1288c);
  ::Reflex::Type type_9197 = ::Reflex::ReferenceBuilder(type_1288);
  ::Reflex::Type type_10227 = ::Reflex::PointerBuilder(type_2191);
  ::Reflex::Type type_2288c = ::Reflex::ConstBuilder(type_2288);
  ::Reflex::Type type_3236 = ::Reflex::ReferenceBuilder(type_2288c);
  ::Reflex::Type type_10086 = ::Reflex::ReferenceBuilder(type_2191);
  ::Reflex::Type type_172 = ::Reflex::PointerBuilder(type_1862);
  ::Reflex::Type type_8925 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("boost::detail::sp_typeinfo"), type_1592);
  ::Reflex::Type type_8925c = ::Reflex::ConstBuilder(type_8925);
  ::Reflex::Type type_10043 = ::Reflex::ReferenceBuilder(type_8925c);
  ::Reflex::Type type_3233 = ::Reflex::PointerBuilder(type_2288c);
  ::Reflex::Type type_1430c = ::Reflex::ConstBuilder(type_1430);
  ::Reflex::Type type_9199 = ::Reflex::ReferenceBuilder(type_1430c);
  ::Reflex::Type type_1289c = ::Reflex::ConstBuilder(type_1289);
  ::Reflex::Type type_9200 = ::Reflex::ReferenceBuilder(type_1289c);
  ::Reflex::Type type_9201 = ::Reflex::ReferenceBuilder(type_1289);
  ::Reflex::Type type_2180c = ::Reflex::ConstBuilder(type_2180);
  ::Reflex::Type type_3302 = ::Reflex::ReferenceBuilder(type_2180c);
  ::Reflex::Type type_10077 = ::Reflex::ReferenceBuilder(type_2210);
  ::Reflex::Type type_3299 = ::Reflex::PointerBuilder(type_2180c);
  ::Reflex::Type type_1431c = ::Reflex::ConstBuilder(type_1431);
  ::Reflex::Type type_9203 = ::Reflex::ReferenceBuilder(type_1431c);
  ::Reflex::Type type_1290c = ::Reflex::ConstBuilder(type_1290);
  ::Reflex::Type type_9204 = ::Reflex::ReferenceBuilder(type_1290c);
  ::Reflex::Type type_9205 = ::Reflex::ReferenceBuilder(type_1290);
  ::Reflex::Type type_3359 = ::Reflex::PointerBuilder(type_2160);
  ::Reflex::Type type_3365 = ::Reflex::PointerBuilder(type_3359);
  ::Reflex::Type type_3359c = ::Reflex::ConstBuilder(type_3359);
  ::Reflex::Type type_3367 = ::Reflex::PointerBuilder(type_3359c);
  ::Reflex::Type type_3369 = ::Reflex::ReferenceBuilder(type_3359);
  ::Reflex::Type type_3371 = ::Reflex::ReferenceBuilder(type_3359c);
  ::Reflex::Type type_1432c = ::Reflex::ConstBuilder(type_1432);
  ::Reflex::Type type_9207 = ::Reflex::ReferenceBuilder(type_1432c);
  ::Reflex::Type type_1291c = ::Reflex::ConstBuilder(type_1291);
  ::Reflex::Type type_9208 = ::Reflex::ReferenceBuilder(type_1291c);
  ::Reflex::Type type_9209 = ::Reflex::ReferenceBuilder(type_1291);
  ::Reflex::Type type_3428 = ::Reflex::PointerBuilder(type_2225);
  ::Reflex::Type type_3434 = ::Reflex::PointerBuilder(type_3428);
  ::Reflex::Type type_3428c = ::Reflex::ConstBuilder(type_3428);
  ::Reflex::Type type_3436 = ::Reflex::PointerBuilder(type_3428c);
  ::Reflex::Type type_3438 = ::Reflex::ReferenceBuilder(type_3428);
  ::Reflex::Type type_3440 = ::Reflex::ReferenceBuilder(type_3428c);
  ::Reflex::Type type_1433c = ::Reflex::ConstBuilder(type_1433);
  ::Reflex::Type type_9211 = ::Reflex::ReferenceBuilder(type_1433c);
  ::Reflex::Type type_1292c = ::Reflex::ConstBuilder(type_1292);
  ::Reflex::Type type_9212 = ::Reflex::ReferenceBuilder(type_1292c);
  ::Reflex::Type type_9213 = ::Reflex::ReferenceBuilder(type_1292);
  ::Reflex::Type type_3497 = ::Reflex::PointerBuilder(type_2205);
  ::Reflex::Type type_3503 = ::Reflex::PointerBuilder(type_3497);
  ::Reflex::Type type_3497c = ::Reflex::ConstBuilder(type_3497);
  ::Reflex::Type type_3505 = ::Reflex::PointerBuilder(type_3497c);
  ::Reflex::Type type_3507 = ::Reflex::ReferenceBuilder(type_3497);
  ::Reflex::Type type_3509 = ::Reflex::ReferenceBuilder(type_3497c);
  ::Reflex::Type type_1435c = ::Reflex::ConstBuilder(type_1435);
  ::Reflex::Type type_9215 = ::Reflex::ReferenceBuilder(type_1435c);
  ::Reflex::Type type_1294c = ::Reflex::ConstBuilder(type_1294);
  ::Reflex::Type type_9216 = ::Reflex::ReferenceBuilder(type_1294c);
  ::Reflex::Type type_9217 = ::Reflex::ReferenceBuilder(type_1294);
  ::Reflex::Type type_10210 = ::Reflex::ReferenceBuilder(type_2278);
  ::Reflex::Type type_2278c = ::Reflex::ConstBuilder(type_2278);
  ::Reflex::Type type_10211 = ::Reflex::ReferenceBuilder(type_2278c);
  ::Reflex::Type type_8434c = ::Reflex::ConstBuilder(type_8434);
  ::Reflex::Type type_10212 = ::Reflex::ReferenceBuilder(type_8434c);
  ::Reflex::Type type_3576 = ::Reflex::ReferenceBuilder(type_3566);
  ::Reflex::Type type_3566c = ::Reflex::ConstBuilder(type_3566);
  ::Reflex::Type type_3578 = ::Reflex::ReferenceBuilder(type_3566c);
  ::Reflex::Type type_3572 = ::Reflex::PointerBuilder(type_3566);
  ::Reflex::Type type_3574 = ::Reflex::PointerBuilder(type_3566c);
  ::Reflex::Type type_1436c = ::Reflex::ConstBuilder(type_1436);
  ::Reflex::Type type_9229 = ::Reflex::ReferenceBuilder(type_1436c);
  ::Reflex::Type type_1295c = ::Reflex::ConstBuilder(type_1295);
  ::Reflex::Type type_9230 = ::Reflex::ReferenceBuilder(type_1295c);
  ::Reflex::Type type_9231 = ::Reflex::ReferenceBuilder(type_1295);
  ::Reflex::Type type_3640 = ::Reflex::PointerBuilder(type_3039);
  ::Reflex::Type type_3643 = ::Reflex::ReferenceBuilder(type_3039);
  ::Reflex::Type type_1437c = ::Reflex::ConstBuilder(type_1437);
  ::Reflex::Type type_9232 = ::Reflex::ReferenceBuilder(type_1437c);
  ::Reflex::Type type_1296c = ::Reflex::ConstBuilder(type_1296);
  ::Reflex::Type type_9233 = ::Reflex::ReferenceBuilder(type_1296c);
  ::Reflex::Type type_9234 = ::Reflex::ReferenceBuilder(type_1296);
  ::Reflex::Type type_1440c = ::Reflex::ConstBuilder(type_1440);
  ::Reflex::Type type_9235 = ::Reflex::ReferenceBuilder(type_1440c);
  ::Reflex::Type type_1297c = ::Reflex::ConstBuilder(type_1297);
  ::Reflex::Type type_9236 = ::Reflex::ReferenceBuilder(type_1297c);
  ::Reflex::Type type_9237 = ::Reflex::ReferenceBuilder(type_1297);
  ::Reflex::Type type_9457 = ::Reflex::ReferenceBuilder(type_1430);
  ::Reflex::Type type_9458 = ::Reflex::ReferenceBuilder(type_1431);
  ::Reflex::Type type_9459 = ::Reflex::ReferenceBuilder(type_1432);
  ::Reflex::Type type_9460 = ::Reflex::ReferenceBuilder(type_1433);
  ::Reflex::Type type_9461 = ::Reflex::ReferenceBuilder(type_1435);
  ::Reflex::Type type_9462 = ::Reflex::ReferenceBuilder(type_1436);
  ::Reflex::Type type_9463 = ::Reflex::ReferenceBuilder(type_1437);
  ::Reflex::Type type_9470 = ::Reflex::ReferenceBuilder(type_1440);
  ::Reflex::Type type_9482 = ::Reflex::ReferenceBuilder(type_1447);
  ::Reflex::Type type_1447c = ::Reflex::ConstBuilder(type_1447);
  ::Reflex::Type type_9483 = ::Reflex::ReferenceBuilder(type_1447c);
  ::Reflex::Type type_9484 = ::Reflex::ReferenceBuilder(type_1448);
  ::Reflex::Type type_1448c = ::Reflex::ConstBuilder(type_1448);
  ::Reflex::Type type_9485 = ::Reflex::ReferenceBuilder(type_1448c);
  ::Reflex::Type type_9486 = ::Reflex::ReferenceBuilder(type_1449);
  ::Reflex::Type type_1449c = ::Reflex::ConstBuilder(type_1449);
  ::Reflex::Type type_9487 = ::Reflex::ReferenceBuilder(type_1449c);
  ::Reflex::Type type_9488 = ::Reflex::ReferenceBuilder(type_1450);
  ::Reflex::Type type_1450c = ::Reflex::ConstBuilder(type_1450);
  ::Reflex::Type type_9489 = ::Reflex::ReferenceBuilder(type_1450c);
  ::Reflex::Type type_9490 = ::Reflex::ReferenceBuilder(type_1451);
  ::Reflex::Type type_1451c = ::Reflex::ConstBuilder(type_1451);
  ::Reflex::Type type_9491 = ::Reflex::ReferenceBuilder(type_1451c);
  ::Reflex::Type type_9492 = ::Reflex::ReferenceBuilder(type_1452);
  ::Reflex::Type type_1452c = ::Reflex::ConstBuilder(type_1452);
  ::Reflex::Type type_9493 = ::Reflex::ReferenceBuilder(type_1452c);
  ::Reflex::Type type_9498 = ::Reflex::ReferenceBuilder(type_1455);
  ::Reflex::Type type_1455c = ::Reflex::ConstBuilder(type_1455);
  ::Reflex::Type type_9499 = ::Reflex::ReferenceBuilder(type_1455c);
  ::Reflex::Type type_9500 = ::Reflex::ReferenceBuilder(type_1456);
  ::Reflex::Type type_1456c = ::Reflex::ConstBuilder(type_1456);
  ::Reflex::Type type_9501 = ::Reflex::ReferenceBuilder(type_1456c);
  ::Reflex::Type type_4271 = ::Reflex::PointerBuilder(type_1318);
  ::Reflex::Type type_1318c = ::Reflex::ConstBuilder(type_1318);
  ::Reflex::Type type_4580 = ::Reflex::PointerBuilder(type_1318c);
  ::Reflex::Type type_4269 = ::Reflex::ReferenceBuilder(type_1318);
  ::Reflex::Type type_4583 = ::Reflex::ReferenceBuilder(type_1318c);
  ::Reflex::Type type_1700c = ::Reflex::ConstBuilder(type_1700);
  ::Reflex::Type type_9537 = ::Reflex::ReferenceBuilder(type_1700c);
  ::Reflex::Type type_1427c = ::Reflex::ConstBuilder(type_1427);
  ::Reflex::Type type_9452 = ::Reflex::ReferenceBuilder(type_1427c);
  ::Reflex::Type type_1515c = ::Reflex::ConstBuilder(type_1515);
  ::Reflex::Type type_9538 = ::Reflex::ReferenceBuilder(type_1515c);
  ::Reflex::Type type_9539 = ::Reflex::ReferenceBuilder(type_1515);
  ::Reflex::Type type_9588 = ::Reflex::ReferenceBuilder(type_1568);
  ::Reflex::Type type_1568c = ::Reflex::ConstBuilder(type_1568);
  ::Reflex::Type type_9589 = ::Reflex::ReferenceBuilder(type_1568c);
  ::Reflex::Type type_9599 = ::Reflex::ReferenceBuilder(type_1569);
  ::Reflex::Type type_1569c = ::Reflex::ConstBuilder(type_1569);
  ::Reflex::Type type_9600 = ::Reflex::ReferenceBuilder(type_1569c);
  ::Reflex::Type type_9610 = ::Reflex::ReferenceBuilder(type_1570);
  ::Reflex::Type type_1570c = ::Reflex::ConstBuilder(type_1570);
  ::Reflex::Type type_9611 = ::Reflex::ReferenceBuilder(type_1570c);
  ::Reflex::Type type_9621 = ::Reflex::ReferenceBuilder(type_1571);
  ::Reflex::Type type_1571c = ::Reflex::ConstBuilder(type_1571);
  ::Reflex::Type type_9622 = ::Reflex::ReferenceBuilder(type_1571c);
  ::Reflex::Type type_9632 = ::Reflex::ReferenceBuilder(type_1572);
  ::Reflex::Type type_1572c = ::Reflex::ConstBuilder(type_1572);
  ::Reflex::Type type_9633 = ::Reflex::ReferenceBuilder(type_1572c);
  ::Reflex::Type type_9643 = ::Reflex::ReferenceBuilder(type_1573);
  ::Reflex::Type type_1573c = ::Reflex::ConstBuilder(type_1573);
  ::Reflex::Type type_9644 = ::Reflex::ReferenceBuilder(type_1573c);
  ::Reflex::Type type_9654 = ::Reflex::ReferenceBuilder(type_1574);
  ::Reflex::Type type_1574c = ::Reflex::ConstBuilder(type_1574);
  ::Reflex::Type type_9655 = ::Reflex::ReferenceBuilder(type_1574c);
  ::Reflex::Type type_9665 = ::Reflex::ReferenceBuilder(type_1575);
  ::Reflex::Type type_1575c = ::Reflex::ConstBuilder(type_1575);
  ::Reflex::Type type_9666 = ::Reflex::ReferenceBuilder(type_1575c);
  ::Reflex::Type type_1592c = ::Reflex::ConstBuilder(type_1592);
  ::Reflex::Type type_9682 = ::Reflex::ReferenceBuilder(type_1592c);
  ::Reflex::Type type_9683 = ::Reflex::PointerBuilder(type_1592c);
  ::Reflex::Type type_1895 = ::Reflex::PointerBuilder(type_172);
  ::Reflex::Type type_2142c = ::Reflex::ConstBuilder(type_2142);
  ::Reflex::Type type_9684 = ::Reflex::PointerBuilder(type_2142c);
  ::Reflex::Type type_9782 = ::Reflex::ReferenceBuilder(type_1711);
  ::Reflex::Type type_1711c = ::Reflex::ConstBuilder(type_1711);
  ::Reflex::Type type_9783 = ::Reflex::ReferenceBuilder(type_1711c);
  ::Reflex::Type type_9784 = ::Reflex::ReferenceBuilder(type_1712);
  ::Reflex::Type type_1712c = ::Reflex::ConstBuilder(type_1712);
  ::Reflex::Type type_9785 = ::Reflex::ReferenceBuilder(type_1712c);
  ::Reflex::Type type_9786 = ::Reflex::ReferenceBuilder(type_1713);
  ::Reflex::Type type_1713c = ::Reflex::ConstBuilder(type_1713);
  ::Reflex::Type type_9787 = ::Reflex::ReferenceBuilder(type_1713c);
  ::Reflex::Type type_9828 = ::Reflex::ReferenceBuilder(type_1933);
  ::Reflex::Type type_1933c = ::Reflex::ConstBuilder(type_1933);
  ::Reflex::Type type_9829 = ::Reflex::ReferenceBuilder(type_1933c);
  ::Reflex::Type type_9830 = ::Reflex::ReferenceBuilder(type_1934);
  ::Reflex::Type type_1934c = ::Reflex::ConstBuilder(type_1934);
  ::Reflex::Type type_9831 = ::Reflex::ReferenceBuilder(type_1934c);
  ::Reflex::Type type_9832 = ::Reflex::ReferenceBuilder(type_1935);
  ::Reflex::Type type_1935c = ::Reflex::ConstBuilder(type_1935);
  ::Reflex::Type type_9833 = ::Reflex::ReferenceBuilder(type_1935c);
  ::Reflex::Type type_9834 = ::Reflex::ReferenceBuilder(type_1936);
  ::Reflex::Type type_1936c = ::Reflex::ConstBuilder(type_1936);
  ::Reflex::Type type_9835 = ::Reflex::ReferenceBuilder(type_1936c);
  ::Reflex::Type type_9836 = ::Reflex::ReferenceBuilder(type_1937);
  ::Reflex::Type type_1937c = ::Reflex::ConstBuilder(type_1937);
  ::Reflex::Type type_9837 = ::Reflex::ReferenceBuilder(type_1937c);
  ::Reflex::Type type_9838 = ::Reflex::ReferenceBuilder(type_1938);
  ::Reflex::Type type_1938c = ::Reflex::ConstBuilder(type_1938);
  ::Reflex::Type type_9839 = ::Reflex::ReferenceBuilder(type_1938c);
  ::Reflex::Type type_9842 = ::Reflex::ReferenceBuilder(type_1941);
  ::Reflex::Type type_1941c = ::Reflex::ConstBuilder(type_1941);
  ::Reflex::Type type_9843 = ::Reflex::ReferenceBuilder(type_1941c);
  ::Reflex::Type type_9844 = ::Reflex::ReferenceBuilder(type_1942);
  ::Reflex::Type type_1942c = ::Reflex::ConstBuilder(type_1942);
  ::Reflex::Type type_9845 = ::Reflex::ReferenceBuilder(type_1942c);
  ::Reflex::Type type_9854 = ::Reflex::ReferenceBuilder(type_1947);
  ::Reflex::Type type_1947c = ::Reflex::ConstBuilder(type_1947);
  ::Reflex::Type type_9855 = ::Reflex::ReferenceBuilder(type_1947c);
  ::Reflex::Type type_9856 = ::Reflex::ReferenceBuilder(type_1948);
  ::Reflex::Type type_1948c = ::Reflex::ConstBuilder(type_1948);
  ::Reflex::Type type_9857 = ::Reflex::ReferenceBuilder(type_1948c);
  ::Reflex::Type type_9858 = ::Reflex::ReferenceBuilder(type_1949);
  ::Reflex::Type type_1949c = ::Reflex::ConstBuilder(type_1949);
  ::Reflex::Type type_9859 = ::Reflex::ReferenceBuilder(type_1949c);
  ::Reflex::Type type_9860 = ::Reflex::ReferenceBuilder(type_1950);
  ::Reflex::Type type_1950c = ::Reflex::ConstBuilder(type_1950);
  ::Reflex::Type type_9861 = ::Reflex::ReferenceBuilder(type_1950c);
  ::Reflex::Type type_9862 = ::Reflex::ReferenceBuilder(type_1951);
  ::Reflex::Type type_1951c = ::Reflex::ConstBuilder(type_1951);
  ::Reflex::Type type_9863 = ::Reflex::ReferenceBuilder(type_1951c);
  ::Reflex::Type type_9864 = ::Reflex::ReferenceBuilder(type_1952);
  ::Reflex::Type type_1952c = ::Reflex::ConstBuilder(type_1952);
  ::Reflex::Type type_9865 = ::Reflex::ReferenceBuilder(type_1952c);
  ::Reflex::Type type_9870 = ::Reflex::ReferenceBuilder(type_1955);
  ::Reflex::Type type_1955c = ::Reflex::ConstBuilder(type_1955);
  ::Reflex::Type type_9871 = ::Reflex::ReferenceBuilder(type_1955c);
  ::Reflex::Type type_9872 = ::Reflex::ReferenceBuilder(type_1956);
  ::Reflex::Type type_1956c = ::Reflex::ConstBuilder(type_1956);
  ::Reflex::Type type_9873 = ::Reflex::ReferenceBuilder(type_1956c);
  ::Reflex::Type type_9882 = ::Reflex::ReferenceBuilder(type_1961);
  ::Reflex::Type type_1961c = ::Reflex::ConstBuilder(type_1961);
  ::Reflex::Type type_9883 = ::Reflex::ReferenceBuilder(type_1961c);
  ::Reflex::Type type_1862c = ::Reflex::ConstBuilder(type_1862);
  ::Reflex::Type type_1914 = ::Reflex::PointerBuilder(type_1862c);
  ::Reflex::Type type_9884 = ::Reflex::ReferenceBuilder(type_1962);
  ::Reflex::Type type_1962c = ::Reflex::ConstBuilder(type_1962);
  ::Reflex::Type type_9885 = ::Reflex::ReferenceBuilder(type_1962c);
  ::Reflex::Type type_9886 = ::Reflex::ReferenceBuilder(type_1963);
  ::Reflex::Type type_1963c = ::Reflex::ConstBuilder(type_1963);
  ::Reflex::Type type_9887 = ::Reflex::ReferenceBuilder(type_1963c);
  ::Reflex::Type type_9888 = ::Reflex::ReferenceBuilder(type_1964);
  ::Reflex::Type type_1964c = ::Reflex::ConstBuilder(type_1964);
  ::Reflex::Type type_9889 = ::Reflex::ReferenceBuilder(type_1964c);
  ::Reflex::Type type_9890 = ::Reflex::ReferenceBuilder(type_1965);
  ::Reflex::Type type_1965c = ::Reflex::ConstBuilder(type_1965);
  ::Reflex::Type type_9891 = ::Reflex::ReferenceBuilder(type_1965c);
  ::Reflex::Type type_9892 = ::Reflex::ReferenceBuilder(type_1966);
  ::Reflex::Type type_1966c = ::Reflex::ConstBuilder(type_1966);
  ::Reflex::Type type_9893 = ::Reflex::ReferenceBuilder(type_1966c);
  ::Reflex::Type type_9898 = ::Reflex::ReferenceBuilder(type_1969);
  ::Reflex::Type type_1969c = ::Reflex::ConstBuilder(type_1969);
  ::Reflex::Type type_9899 = ::Reflex::ReferenceBuilder(type_1969c);
  ::Reflex::Type type_9900 = ::Reflex::ReferenceBuilder(type_1970);
  ::Reflex::Type type_1970c = ::Reflex::ConstBuilder(type_1970);
  ::Reflex::Type type_9901 = ::Reflex::ReferenceBuilder(type_1970c);
  ::Reflex::Type type_9954 = ::Reflex::ReferenceBuilder(type_2005);
  ::Reflex::Type type_2005c = ::Reflex::ConstBuilder(type_2005);
  ::Reflex::Type type_9955 = ::Reflex::ReferenceBuilder(type_2005c);
  ::Reflex::Type type_9956 = ::Reflex::ReferenceBuilder(type_2006);
  ::Reflex::Type type_2006c = ::Reflex::ConstBuilder(type_2006);
  ::Reflex::Type type_9957 = ::Reflex::ReferenceBuilder(type_2006c);
  ::Reflex::Type type_9958 = ::Reflex::ReferenceBuilder(type_2007);
  ::Reflex::Type type_2007c = ::Reflex::ConstBuilder(type_2007);
  ::Reflex::Type type_9959 = ::Reflex::ReferenceBuilder(type_2007c);
  ::Reflex::Type type_9974 = ::Reflex::ReferenceBuilder(type_2021);
  ::Reflex::Type type_2021c = ::Reflex::ConstBuilder(type_2021);
  ::Reflex::Type type_9975 = ::Reflex::ReferenceBuilder(type_2021c);
  ::Reflex::Type type_3009c = ::Reflex::ConstBuilder(type_3009);
  ::Reflex::Type type_9976 = ::Reflex::ReferenceBuilder(type_3009c);
  ::Reflex::Type type_9977 = ::Reflex::ReferenceBuilder(type_2023);
  ::Reflex::Type type_2023c = ::Reflex::ConstBuilder(type_2023);
  ::Reflex::Type type_9978 = ::Reflex::ReferenceBuilder(type_2023c);
  ::Reflex::Type type_3020c = ::Reflex::ConstBuilder(type_3020);
  ::Reflex::Type type_9979 = ::Reflex::ReferenceBuilder(type_3020c);
  ::Reflex::Type type_9983 = ::Reflex::ReferenceBuilder(type_2034);
  ::Reflex::Type type_2034c = ::Reflex::ConstBuilder(type_2034);
  ::Reflex::Type type_7369 = ::Reflex::ReferenceBuilder(type_2034c);
  ::Reflex::Type type_3042c = ::Reflex::ConstBuilder(type_3042);
  ::Reflex::Type type_9984 = ::Reflex::ReferenceBuilder(type_3042c);
  ::Reflex::Type type_9985 = ::Reflex::ReferenceBuilder(type_2036);
  ::Reflex::Type type_2036c = ::Reflex::ConstBuilder(type_2036);
  ::Reflex::Type type_9986 = ::Reflex::ReferenceBuilder(type_2036c);
  ::Reflex::Type type_3054c = ::Reflex::ConstBuilder(type_3054);
  ::Reflex::Type type_9987 = ::Reflex::ReferenceBuilder(type_3054c);
  ::Reflex::Type type_9988 = ::Reflex::ReferenceBuilder(type_2037);
  ::Reflex::Type type_2037c = ::Reflex::ConstBuilder(type_2037);
  ::Reflex::Type type_7370 = ::Reflex::ReferenceBuilder(type_2037c);
  ::Reflex::Type type_3065c = ::Reflex::ConstBuilder(type_3065);
  ::Reflex::Type type_9989 = ::Reflex::ReferenceBuilder(type_3065c);
  ::Reflex::Type type_2210c = ::Reflex::ConstBuilder(type_2210);
  ::Reflex::Type type_8417 = ::Reflex::ReferenceBuilder(type_2210c);
  ::Reflex::Type type_2224c = ::Reflex::ConstBuilder(type_2224);
  ::Reflex::Type type_7597c = ::Reflex::ConstBuilder(type_7597);
  ::Reflex::Type type_2231c = ::Reflex::ConstBuilder(type_2231);
  ::Reflex::Type type_10015 = ::Reflex::ReferenceBuilder(type_2231c);
  ::Reflex::Type type_1730c = ::Reflex::ConstBuilder(type_1730);
  ::Reflex::Type type_10016 = ::Reflex::ReferenceBuilder(type_1730c);
  ::Reflex::Type type_1736c = ::Reflex::ConstBuilder(type_1736);
  ::Reflex::Type type_10017 = ::Reflex::ReferenceBuilder(type_1736c);
  ::Reflex::Type type_108c = ::Reflex::ConstBuilder(type_108);
  ::Reflex::Type type_10018 = ::Reflex::ReferenceBuilder(type_108c);
  ::Reflex::Type type_91c = ::Reflex::ConstBuilder(type_91);
  ::Reflex::Type type_10019 = ::Reflex::ReferenceBuilder(type_91c);
  ::Reflex::Type type_30c = ::Reflex::ConstBuilder(type_30);
  ::Reflex::Type type_5911 = ::Reflex::ReferenceBuilder(type_30c);
  ::Reflex::Type type_242c = ::Reflex::ConstBuilder(type_242);
  ::Reflex::Type type_10020 = ::Reflex::ReferenceBuilder(type_242c);
  ::Reflex::Type type_614c = ::Reflex::ConstBuilder(type_614);
  ::Reflex::Type type_10021 = ::Reflex::ReferenceBuilder(type_614c);
  ::Reflex::Type type_130c = ::Reflex::ConstBuilder(type_130);
  ::Reflex::Type type_10022 = ::Reflex::ReferenceBuilder(type_130c);
  ::Reflex::Type type_1770c = ::Reflex::ConstBuilder(type_1770);
  ::Reflex::Type type_5910 = ::Reflex::ReferenceBuilder(type_1770c);
  ::Reflex::Type type_10026 = ::Reflex::ReferenceBuilder(type_2155);
  ::Reflex::Type type_2155c = ::Reflex::ConstBuilder(type_2155);
  ::Reflex::Type type_10027 = ::Reflex::ReferenceBuilder(type_2155c);
  ::Reflex::Type type_2170c = ::Reflex::ConstBuilder(type_2170);
  ::Reflex::Type type_10028 = ::Reflex::ReferenceBuilder(type_2170c);
  ::Reflex::Type type_10029 = ::Reflex::ReferenceBuilder(type_2157);
  ::Reflex::Type type_2157c = ::Reflex::ConstBuilder(type_2157);
  ::Reflex::Type type_10030 = ::Reflex::ReferenceBuilder(type_2157c);
  ::Reflex::Type type_10031 = ::Reflex::ReferenceBuilder(type_2158);
  ::Reflex::Type type_2158c = ::Reflex::ConstBuilder(type_2158);
  ::Reflex::Type type_10032 = ::Reflex::ReferenceBuilder(type_2158c);
  ::Reflex::Type type_10033 = ::Reflex::ReferenceBuilder(type_2159);
  ::Reflex::Type type_2159c = ::Reflex::ConstBuilder(type_2159);
  ::Reflex::Type type_10034 = ::Reflex::ReferenceBuilder(type_2159c);
  ::Reflex::Type type_2205c = ::Reflex::ConstBuilder(type_2205);
  ::Reflex::Type type_10036 = ::Reflex::ReferenceBuilder(type_2205c);
  ::Reflex::Type type_2339c = ::Reflex::ConstBuilder(type_2339);
  ::Reflex::Type type_8804 = ::Reflex::ReferenceBuilder(type_2339c);
  ::Reflex::Type type_2296c = ::Reflex::ConstBuilder(type_2296);
  ::Reflex::Type type_10037 = ::Reflex::ReferenceBuilder(type_2296c);
  ::Reflex::Type type_2166 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Int64"), type_91);
  ::Reflex::Type type_2166c = ::Reflex::ConstBuilder(type_2166);
  ::Reflex::Type type_7605 = ::Reflex::ReferenceBuilder(type_2166c);
  ::Reflex::Type type_2256c = ::Reflex::ConstBuilder(type_2256);
  ::Reflex::Type type_7604 = ::Reflex::ReferenceBuilder(type_2256c);
  ::Reflex::Type type_2239 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Int32"), type_30);
  ::Reflex::Type type_2239c = ::Reflex::ConstBuilder(type_2239);
  ::Reflex::Type type_7602 = ::Reflex::ReferenceBuilder(type_2239c);
  ::Reflex::Type type_2221 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt16"), type_242);
  ::Reflex::Type type_2221c = ::Reflex::ConstBuilder(type_2221);
  ::Reflex::Type type_7636 = ::Reflex::ReferenceBuilder(type_2221c);
  ::Reflex::Type type_2219 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Int16"), type_614);
  ::Reflex::Type type_2219c = ::Reflex::ConstBuilder(type_2219);
  ::Reflex::Type type_7606 = ::Reflex::ReferenceBuilder(type_2219c);
  ::Reflex::Type type_2169 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UChar"), type_130);
  ::Reflex::Type type_2169c = ::Reflex::ConstBuilder(type_2169);
  ::Reflex::Type type_7608 = ::Reflex::ReferenceBuilder(type_2169c);
  ::Reflex::Type type_10039 = ::Reflex::PointerBuilder(type_1289);
  ::Reflex::Type type_2161c = ::Reflex::ConstBuilder(type_2161);
  ::Reflex::Type type_10041 = ::Reflex::ReferenceBuilder(type_2161c);
  ::Reflex::Type type_10042 = ::Reflex::ReferenceBuilder(type_2161);
  ::Reflex::Type type_10044 = ::Reflex::ReferenceBuilder(type_2164);
  ::Reflex::Type type_2164c = ::Reflex::ConstBuilder(type_2164);
  ::Reflex::Type type_10045 = ::Reflex::ReferenceBuilder(type_2164c);
  ::Reflex::Type type_10046 = ::Reflex::ReferenceBuilder(type_2165);
  ::Reflex::Type type_2165c = ::Reflex::ConstBuilder(type_2165);
  ::Reflex::Type type_10047 = ::Reflex::ReferenceBuilder(type_2165c);
  ::Reflex::Type type_792 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_75);
  ::Reflex::Type type_2225c = ::Reflex::ConstBuilder(type_2225);
  ::Reflex::Type type_10050 = ::Reflex::PointerBuilder(type_2225c);
  ::Reflex::Type type_1293c = ::Reflex::ConstBuilder(type_1293);
  ::Reflex::Type type_10051 = ::Reflex::ReferenceBuilder(type_1293c);
  ::Reflex::Type type_10054 = ::Reflex::ReferenceBuilder(type_7597c);
  ::Reflex::Type type_10057 = ::Reflex::PointerBuilder(type_2153);
  ::Reflex::Type type_2172c = ::Reflex::ConstBuilder(type_2172);
  ::Reflex::Type type_10059 = ::Reflex::ReferenceBuilder(type_2172c);
  ::Reflex::Type type_10060 = ::Reflex::ReferenceBuilder(type_2172);
  ::Reflex::Type type_10014 = ::Reflex::ReferenceBuilder(type_2153);
  ::Reflex::Type type_10061 = ::Reflex::ReferenceBuilder(type_2176);
  ::Reflex::Type type_2176c = ::Reflex::ConstBuilder(type_2176);
  ::Reflex::Type type_10062 = ::Reflex::ReferenceBuilder(type_2176c);
  ::Reflex::Type type_46c = ::Reflex::ConstBuilder(type_46);
  ::Reflex::Type type_10073 = ::Reflex::ReferenceBuilder(type_2179);
  ::Reflex::Type type_2179c = ::Reflex::ConstBuilder(type_2179);
  ::Reflex::Type type_10074 = ::Reflex::ReferenceBuilder(type_2179c);
  ::Reflex::Type type_10078 = ::Reflex::ReferenceBuilder(type_2182);
  ::Reflex::Type type_2182c = ::Reflex::ConstBuilder(type_2182);
  ::Reflex::Type type_10079 = ::Reflex::ReferenceBuilder(type_2182c);
  ::Reflex::Type type_10080 = ::Reflex::ReferenceBuilder(type_2186);
  ::Reflex::Type type_2186c = ::Reflex::ConstBuilder(type_2186);
  ::Reflex::Type type_10081 = ::Reflex::ReferenceBuilder(type_2186c);
  ::Reflex::Type type_10082 = ::Reflex::PointerBuilder(type_2167);
  ::Reflex::Type type_2187c = ::Reflex::ConstBuilder(type_2187);
  ::Reflex::Type type_10084 = ::Reflex::ReferenceBuilder(type_2187c);
  ::Reflex::Type type_10085 = ::Reflex::ReferenceBuilder(type_2187);
  ::Reflex::Type type_10049 = ::Reflex::ReferenceBuilder(type_2167);
  ::Reflex::Type type_10087 = ::Reflex::ReferenceBuilder(type_2192);
  ::Reflex::Type type_2192c = ::Reflex::ConstBuilder(type_2192);
  ::Reflex::Type type_10088 = ::Reflex::ReferenceBuilder(type_2192c);
  ::Reflex::Type type_2193c = ::Reflex::ConstBuilder(type_2193);
  ::Reflex::Type type_10089 = ::Reflex::ReferenceBuilder(type_2193c);
  ::Reflex::Type type_10090 = ::Reflex::ReferenceBuilder(type_2193);
  ::Reflex::Type type_10091 = ::Reflex::ReferenceBuilder(type_2194);
  ::Reflex::Type type_2194c = ::Reflex::ConstBuilder(type_2194);
  ::Reflex::Type type_10092 = ::Reflex::ReferenceBuilder(type_2194c);
  ::Reflex::Type type_10093 = ::Reflex::ReferenceBuilder(type_2196);
  ::Reflex::Type type_2196c = ::Reflex::ConstBuilder(type_2196);
  ::Reflex::Type type_10094 = ::Reflex::ReferenceBuilder(type_2196c);
  ::Reflex::Type type_10095 = ::Reflex::ReferenceBuilder(type_2197);
  ::Reflex::Type type_2197c = ::Reflex::ConstBuilder(type_2197);
  ::Reflex::Type type_10096 = ::Reflex::ReferenceBuilder(type_2197c);
  ::Reflex::Type type_10097 = ::Reflex::ReferenceBuilder(type_2198);
  ::Reflex::Type type_2198c = ::Reflex::ConstBuilder(type_2198);
  ::Reflex::Type type_10098 = ::Reflex::ReferenceBuilder(type_2198c);
  ::Reflex::Type type_2199c = ::Reflex::ConstBuilder(type_2199);
  ::Reflex::Type type_10099 = ::Reflex::ReferenceBuilder(type_2199c);
  ::Reflex::Type type_10100 = ::Reflex::ReferenceBuilder(type_2199);
  ::Reflex::Type type_10038 = ::Reflex::ReferenceBuilder(type_2160);
  ::Reflex::Type type_10101 = ::Reflex::ReferenceBuilder(type_2201);
  ::Reflex::Type type_2201c = ::Reflex::ConstBuilder(type_2201);
  ::Reflex::Type type_10102 = ::Reflex::ReferenceBuilder(type_2201c);
  ::Reflex::Type type_10103 = ::Reflex::ReferenceBuilder(type_2202);
  ::Reflex::Type type_2202c = ::Reflex::ConstBuilder(type_2202);
  ::Reflex::Type type_10104 = ::Reflex::ReferenceBuilder(type_2202c);
  ::Reflex::Type type_10105 = ::Reflex::ReferenceBuilder(type_2204);
  ::Reflex::Type type_2204c = ::Reflex::ConstBuilder(type_2204);
  ::Reflex::Type type_10106 = ::Reflex::ReferenceBuilder(type_2204c);
  ::Reflex::Type type_10108 = ::Reflex::ReferenceBuilder(type_2207);
  ::Reflex::Type type_2207c = ::Reflex::ConstBuilder(type_2207);
  ::Reflex::Type type_10109 = ::Reflex::ReferenceBuilder(type_2207c);
  ::Reflex::Type type_10115 = ::Reflex::ReferenceBuilder(type_2211);
  ::Reflex::Type type_2211c = ::Reflex::ConstBuilder(type_2211);
  ::Reflex::Type type_10116 = ::Reflex::ReferenceBuilder(type_2211c);
  ::Reflex::Type type_10117 = ::Reflex::ReferenceBuilder(type_2212);
  ::Reflex::Type type_2212c = ::Reflex::ConstBuilder(type_2212);
  ::Reflex::Type type_10118 = ::Reflex::ReferenceBuilder(type_2212c);
  ::Reflex::Type type_10119 = ::Reflex::ReferenceBuilder(type_2213);
  ::Reflex::Type type_2213c = ::Reflex::ConstBuilder(type_2213);
  ::Reflex::Type type_10120 = ::Reflex::ReferenceBuilder(type_2213c);
  ::Reflex::Type type_2286c = ::Reflex::ConstBuilder(type_2286);
  ::Reflex::Type type_10172 = ::Reflex::ReferenceBuilder(type_2286c);
  ::Reflex::Type type_2220c = ::Reflex::ConstBuilder(type_2220);
  ::Reflex::Type type_10121 = ::Reflex::PointerBuilder(type_2300);
  ::Reflex::Type type_2214c = ::Reflex::ConstBuilder(type_2214);
  ::Reflex::Type type_10123 = ::Reflex::ReferenceBuilder(type_2214c);
  ::Reflex::Type type_10124 = ::Reflex::ReferenceBuilder(type_2214);
  ::Reflex::Type type_10125 = ::Reflex::ReferenceBuilder(type_2300);
  ::Reflex::Type type_10126 = ::Reflex::ReferenceBuilder(type_2218);
  ::Reflex::Type type_2218c = ::Reflex::ConstBuilder(type_2218);
  ::Reflex::Type type_10127 = ::Reflex::ReferenceBuilder(type_2218c);
  ::Reflex::Type type_10128 = ::Reflex::ReferenceBuilder(type_2220c);
  ::Reflex::Type type_10129 = ::Reflex::ReferenceBuilder(type_2220);
  ::Reflex::Type type_10130 = ::Reflex::PointerBuilder(type_1290);
  ::Reflex::Type type_2223c = ::Reflex::ConstBuilder(type_2223);
  ::Reflex::Type type_10132 = ::Reflex::ReferenceBuilder(type_2223c);
  ::Reflex::Type type_10133 = ::Reflex::ReferenceBuilder(type_2223);
  ::Reflex::Type type_2292c = ::Reflex::ConstBuilder(type_2292);
  ::Reflex::Type type_10158 = ::Reflex::ReferenceBuilder(type_2292c);
  ::Reflex::Type type_10136 = ::Reflex::PointerBuilder(type_2250);
  ::Reflex::Type type_2226c = ::Reflex::ConstBuilder(type_2226);
  ::Reflex::Type type_10138 = ::Reflex::ReferenceBuilder(type_2226c);
  ::Reflex::Type type_10139 = ::Reflex::ReferenceBuilder(type_2226);
  ::Reflex::Type type_10140 = ::Reflex::ReferenceBuilder(type_2250);
  ::Reflex::Type type_10145 = ::Reflex::ReferenceBuilder(type_2230);
  ::Reflex::Type type_2230c = ::Reflex::ConstBuilder(type_2230);
  ::Reflex::Type type_10146 = ::Reflex::ReferenceBuilder(type_2230c);
  ::Reflex::Type type_10147 = ::Reflex::ReferenceBuilder(type_2231);
  ::Reflex::Type type_10149 = ::Reflex::ReferenceBuilder(type_2243);
  ::Reflex::Type type_10150 = ::Reflex::PointerBuilder(type_2134);
  ::Reflex::Type type_10151 = ::Reflex::ReferenceBuilder(type_2353);
  ::Reflex::Type type_10155 = ::Reflex::ReferenceBuilder(type_2242);
  ::Reflex::Type type_2242c = ::Reflex::ConstBuilder(type_2242);
  ::Reflex::Type type_10156 = ::Reflex::ReferenceBuilder(type_2242c);
  ::Reflex::Type type_2244c = ::Reflex::ConstBuilder(type_2244);
  ::Reflex::Type type_10159 = ::Reflex::ReferenceBuilder(type_2244c);
  ::Reflex::Type type_10161 = ::Reflex::ReferenceBuilder(type_2245);
  ::Reflex::Type type_2245c = ::Reflex::ConstBuilder(type_2245);
  ::Reflex::Type type_10162 = ::Reflex::ReferenceBuilder(type_2245c);
  ::Reflex::Type type_10163 = ::Reflex::ReferenceBuilder(type_2246);
  ::Reflex::Type type_2246c = ::Reflex::ConstBuilder(type_2246);
  ::Reflex::Type type_10164 = ::Reflex::ReferenceBuilder(type_2246c);
  ::Reflex::Type type_10165 = ::Reflex::ReferenceBuilder(type_2247);
  ::Reflex::Type type_2247c = ::Reflex::ConstBuilder(type_2247);
  ::Reflex::Type type_10166 = ::Reflex::ReferenceBuilder(type_2247c);
  ::Reflex::Type type_10167 = ::Reflex::ReferenceBuilder(type_2248);
  ::Reflex::Type type_2248c = ::Reflex::ConstBuilder(type_2248);
  ::Reflex::Type type_10168 = ::Reflex::ReferenceBuilder(type_2248c);
  ::Reflex::Type type_10169 = ::Reflex::ReferenceBuilder(type_2249);
  ::Reflex::Type type_2249c = ::Reflex::ConstBuilder(type_2249);
  ::Reflex::Type type_10170 = ::Reflex::ReferenceBuilder(type_2249c);
  ::Reflex::Type type_10173 = ::Reflex::ReferenceBuilder(type_2251);
  ::Reflex::Type type_2251c = ::Reflex::ConstBuilder(type_2251);
  ::Reflex::Type type_10174 = ::Reflex::ReferenceBuilder(type_2251c);
  ::Reflex::Type type_10175 = ::Reflex::ReferenceBuilder(type_2252);
  ::Reflex::Type type_2252c = ::Reflex::ConstBuilder(type_2252);
  ::Reflex::Type type_10176 = ::Reflex::ReferenceBuilder(type_2252c);
  ::Reflex::Type type_10177 = ::Reflex::ReferenceBuilder(type_2253);
  ::Reflex::Type type_2253c = ::Reflex::ConstBuilder(type_2253);
  ::Reflex::Type type_10178 = ::Reflex::ReferenceBuilder(type_2253c);
  ::Reflex::Type type_10179 = ::Reflex::ReferenceBuilder(type_2254);
  ::Reflex::Type type_2254c = ::Reflex::ConstBuilder(type_2254);
  ::Reflex::Type type_10180 = ::Reflex::ReferenceBuilder(type_2254c);
  ::Reflex::Type type_10181 = ::Reflex::ReferenceBuilder(type_2255);
  ::Reflex::Type type_2255c = ::Reflex::ConstBuilder(type_2255);
  ::Reflex::Type type_10182 = ::Reflex::ReferenceBuilder(type_2255c);
  ::Reflex::Type type_10183 = ::Reflex::ReferenceBuilder(type_2259);
  ::Reflex::Type type_2259c = ::Reflex::ConstBuilder(type_2259);
  ::Reflex::Type type_10184 = ::Reflex::ReferenceBuilder(type_2259c);
  ::Reflex::Type type_10185 = ::Reflex::ReferenceBuilder(type_2262);
  ::Reflex::Type type_2262c = ::Reflex::ConstBuilder(type_2262);
  ::Reflex::Type type_10186 = ::Reflex::ReferenceBuilder(type_2262c);
  ::Reflex::Type type_10187 = ::Reflex::ReferenceBuilder(type_2263);
  ::Reflex::Type type_2263c = ::Reflex::ConstBuilder(type_2263);
  ::Reflex::Type type_10188 = ::Reflex::ReferenceBuilder(type_2263c);
  ::Reflex::Type type_10189 = ::Reflex::ReferenceBuilder(type_2265);
  ::Reflex::Type type_2265c = ::Reflex::ConstBuilder(type_2265);
  ::Reflex::Type type_10190 = ::Reflex::ReferenceBuilder(type_2265c);
  ::Reflex::Type type_10191 = ::Reflex::ReferenceBuilder(type_2267);
  ::Reflex::Type type_2267c = ::Reflex::ConstBuilder(type_2267);
  ::Reflex::Type type_10192 = ::Reflex::ReferenceBuilder(type_2267c);
  ::Reflex::Type type_10193 = ::Reflex::ReferenceBuilder(type_2268);
  ::Reflex::Type type_2268c = ::Reflex::ConstBuilder(type_2268);
  ::Reflex::Type type_10194 = ::Reflex::ReferenceBuilder(type_2268c);
  ::Reflex::Type type_10195 = ::Reflex::PointerBuilder(type_2233);
  ::Reflex::Type type_10196 = ::Reflex::PointerBuilder(type_2353);
  ::Reflex::Type type_10199 = ::Reflex::ReferenceBuilder(type_2270);
  ::Reflex::Type type_2270c = ::Reflex::ConstBuilder(type_2270);
  ::Reflex::Type type_10200 = ::Reflex::ReferenceBuilder(type_2270c);
  ::Reflex::Type type_10206 = ::Reflex::ReferenceBuilder(type_2276);
  ::Reflex::Type type_2276c = ::Reflex::ConstBuilder(type_2276);
  ::Reflex::Type type_10207 = ::Reflex::ReferenceBuilder(type_2276c);
  ::Reflex::Type type_10208 = ::Reflex::ReferenceBuilder(type_2277);
  ::Reflex::Type type_2277c = ::Reflex::ConstBuilder(type_2277);
  ::Reflex::Type type_10209 = ::Reflex::ReferenceBuilder(type_2277c);
  ::Reflex::Type type_10214 = ::Reflex::ReferenceBuilder(type_2280);
  ::Reflex::Type type_2280c = ::Reflex::ConstBuilder(type_2280);
  ::Reflex::Type type_10215 = ::Reflex::ReferenceBuilder(type_2280c);
  ::Reflex::Type type_2162c = ::Reflex::ConstBuilder(type_2162);
  ::Reflex::Type type_10218 = ::Reflex::ReferenceBuilder(type_2282);
  ::Reflex::Type type_2282c = ::Reflex::ConstBuilder(type_2282);
  ::Reflex::Type type_10219 = ::Reflex::ReferenceBuilder(type_2282c);
  ::Reflex::Type type_10220 = ::Reflex::ReferenceBuilder(type_2283);
  ::Reflex::Type type_2283c = ::Reflex::ConstBuilder(type_2283);
  ::Reflex::Type type_10221 = ::Reflex::ReferenceBuilder(type_2283c);
  ::Reflex::Type type_10222 = ::Reflex::ReferenceBuilder(type_2284);
  ::Reflex::Type type_2284c = ::Reflex::ConstBuilder(type_2284);
  ::Reflex::Type type_10223 = ::Reflex::ReferenceBuilder(type_2284c);
  ::Reflex::Type type_8580c = ::Reflex::ConstBuilder(type_8580);
  ::Reflex::Type type_10224 = ::Reflex::ReferenceBuilder(type_8580c);
  ::Reflex::Type type_7924c = ::Reflex::ConstBuilder(type_7924);
  ::Reflex::Type type_10225 = ::Reflex::ReferenceBuilder(type_7924c);
  ::Reflex::Type type_10229 = ::Reflex::ReferenceBuilder(type_2291);
  ::Reflex::Type type_2291c = ::Reflex::ConstBuilder(type_2291);
  ::Reflex::Type type_10230 = ::Reflex::ReferenceBuilder(type_2291c);
  ::Reflex::Type type_10231 = ::Reflex::ReferenceBuilder(type_2294);
  ::Reflex::Type type_2294c = ::Reflex::ConstBuilder(type_2294);
  ::Reflex::Type type_10232 = ::Reflex::ReferenceBuilder(type_2294c);
  ::Reflex::Type type_2299c = ::Reflex::ConstBuilder(type_2299);
  ::Reflex::Type type_10233 = ::Reflex::ReferenceBuilder(type_2299c);
  ::Reflex::Type type_10234 = ::Reflex::ReferenceBuilder(type_2299);
  ::Reflex::Type type_10238 = ::Reflex::ReferenceBuilder(type_2302);
  ::Reflex::Type type_2302c = ::Reflex::ConstBuilder(type_2302);
  ::Reflex::Type type_10239 = ::Reflex::ReferenceBuilder(type_2302c);
  ::Reflex::Type type_2332c = ::Reflex::ConstBuilder(type_2332);
  ::Reflex::Type type_10253 = ::Reflex::ReferenceBuilder(type_2332c);
  ::Reflex::Type type_2335c = ::Reflex::ConstBuilder(type_2335);
  ::Reflex::Type type_10254 = ::Reflex::ReferenceBuilder(type_2335c);
  ::Reflex::Type type_10256 = ::Reflex::ReferenceBuilder(type_2335);
  ::Reflex::Type type_10257 = ::Reflex::ReferenceBuilder(type_2336);
  ::Reflex::Type type_2336c = ::Reflex::ConstBuilder(type_2336);
  ::Reflex::Type type_10258 = ::Reflex::ReferenceBuilder(type_2336c);
  ::Reflex::Type type_10259 = ::Reflex::ReferenceBuilder(type_2338);
  ::Reflex::Type type_10260 = ::Reflex::ReferenceBuilder(type_2341);
  ::Reflex::Type type_10261 = ::Reflex::ReferenceBuilder(type_2343);
  ::Reflex::Type type_10262 = ::Reflex::ReferenceBuilder(type_8750);
  ::Reflex::Type type_10263 = ::Reflex::ReferenceBuilder(type_2334);
  ::Reflex::Type type_10264 = ::Reflex::PointerBuilder(type_2334);
  ::Reflex::Type type_10265 = ::Reflex::PointerBuilder(type_2335c);
  ::Reflex::Type type_10266 = ::Reflex::PointerBuilder(type_2348);
  ::Reflex::Type type_10267 = ::Reflex::ReferenceBuilder(type_2339);
  ::Reflex::Type type_4514 = ::Reflex::ReferenceBuilder(type_1737);
  ::Reflex::Type type_4515 = ::Reflex::ReferenceBuilder(type_1730);
  ::Reflex::Type type_4516 = ::Reflex::ReferenceBuilder(type_1736);
  ::Reflex::Type type_9129 = ::Reflex::ReferenceBuilder(type_108);
  ::Reflex::Type type_9128 = ::Reflex::ReferenceBuilder(type_91);
  ::Reflex::Type type_9127 = ::Reflex::ReferenceBuilder(type_46);
  ::Reflex::Type type_9126 = ::Reflex::ReferenceBuilder(type_116);
  ::Reflex::Type type_9125 = ::Reflex::ReferenceBuilder(type_30);
  ::Reflex::Type type_9124 = ::Reflex::ReferenceBuilder(type_242);
  ::Reflex::Type type_9123 = ::Reflex::ReferenceBuilder(type_614);
  ::Reflex::Type type_5666 = ::Reflex::ReferenceBuilder(type_130);
  ::Reflex::Type type_4385 = ::Reflex::ReferenceBuilder(type_1770);
  ::Reflex::Type type_1737c = ::Reflex::ConstBuilder(type_1737);
  ::Reflex::Type type_10268 = ::Reflex::ReferenceBuilder(type_1737c);
  ::Reflex::Type type_10269 = ::Reflex::ReferenceBuilder(type_46c);
  ::Reflex::Type type_116c = ::Reflex::ConstBuilder(type_116);
  ::Reflex::Type type_10270 = ::Reflex::ReferenceBuilder(type_116c);
  ::Reflex::Type type_10271 = ::Reflex::PointerBuilder(type_2332);
  ::Reflex::Type type_10296 = ::Reflex::ReferenceBuilder(type_2342);
  ::Reflex::Type type_10297 = ::Reflex::ReferenceBuilder(type_2345);
  ::Reflex::Type type_2345c = ::Reflex::ConstBuilder(type_2345);
  ::Reflex::Type type_10298 = ::Reflex::ReferenceBuilder(type_2345c);
  ::Reflex::Type type_10299 = ::Reflex::ReferenceBuilder(type_2346);
  ::Reflex::Type type_2346c = ::Reflex::ConstBuilder(type_2346);
  ::Reflex::Type type_10300 = ::Reflex::ReferenceBuilder(type_2346c);
  ::Reflex::Type type_10301 = ::Reflex::ReferenceBuilder(type_2347);
  ::Reflex::Type type_2347c = ::Reflex::ConstBuilder(type_2347);
  ::Reflex::Type type_10302 = ::Reflex::ReferenceBuilder(type_2347c);
  ::Reflex::Type type_10305 = ::Reflex::ReferenceBuilder(type_2351);
  ::Reflex::Type type_2351c = ::Reflex::ConstBuilder(type_2351);
  ::Reflex::Type type_10306 = ::Reflex::ReferenceBuilder(type_2351c);
  ::Reflex::Type type_2353c = ::Reflex::ConstBuilder(type_2353);
  ::Reflex::Type type_10309 = ::Reflex::ReferenceBuilder(type_2353c);
  ::Reflex::Type type_10310 = ::Reflex::PointerBuilder(type_2337);
  ::Reflex::Type type_2344c = ::Reflex::ConstBuilder(type_2344);
  ::Reflex::Type type_10311 = ::Reflex::ReferenceBuilder(type_2344c);
  ::Reflex::Type type_8601c = ::Reflex::ConstBuilder(type_8601);
  ::Reflex::Type type_11329 = ::Reflex::ReferenceBuilder(type_8601c);
  ::Reflex::Type type_11330 = ::Reflex::ReferenceBuilder(type_8601);
  ::Reflex::Type type_8758c = ::Reflex::ConstBuilder(type_8758);
  ::Reflex::Type type_11336 = ::Reflex::ReferenceBuilder(type_8758c);
  ::Reflex::Type type_11338 = ::Reflex::ReferenceBuilder(type_8754);
  ::Reflex::Type type_8754c = ::Reflex::ConstBuilder(type_8754);
  ::Reflex::Type type_11339 = ::Reflex::ReferenceBuilder(type_8754c);
  ::Reflex::Type type_11340 = ::Reflex::ReferenceBuilder(type_8753);
  ::Reflex::Type type_8753c = ::Reflex::ConstBuilder(type_8753);
  ::Reflex::Type type_11341 = ::Reflex::ReferenceBuilder(type_8753c);
  ::Reflex::Type type_11342 = ::Reflex::PointerBuilder(type_2339c);
  ::Reflex::Type type_5149 = ::Reflex::PointerBuilder(type_8896);
  ::Reflex::Type type_8922c = ::Reflex::ConstBuilder(type_8922);
  ::Reflex::Type type_10547 = ::Reflex::ReferenceBuilder(type_8922c);
  ::Reflex::Type type_8968c = ::Reflex::ConstBuilder(type_8968);
  ::Reflex::Type type_10546 = ::Reflex::ReferenceBuilder(type_8968c);
  ::Reflex::Type type_11441 = ::Reflex::ReferenceBuilder(type_8922);
  ::Reflex::Type type_2287 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Bool"), type_1770);
  ::Reflex::Type type_2266 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Float"), type_1736);
  ::Reflex::Type type_2234 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Double"), type_1730);
  ::Reflex::Type type_11579 = ::Reflex::ReferenceBuilder(type_10064);
  ::Reflex::Type type_10064c = ::Reflex::ConstBuilder(type_10064);
  ::Reflex::Type type_11580 = ::Reflex::ReferenceBuilder(type_10064c);
  ::Reflex::Type type_3872 = ::Reflex::PointerBuilder(type_1604);
  ::Reflex::Type type_4276 = ::Reflex::PointerBuilder(type_1534);
  ::Reflex::Type type_9409 = ::Reflex::ReferenceBuilder(type_1367);
  ::Reflex::Type type_1367c = ::Reflex::ConstBuilder(type_1367);
  ::Reflex::Type type_9410 = ::Reflex::ReferenceBuilder(type_1367c);
  ::Reflex::Type type_1604c = ::Reflex::ConstBuilder(type_1604);
  ::Reflex::Type type_4550 = ::Reflex::PointerBuilder(type_1604c);
  ::Reflex::Type type_1534c = ::Reflex::ConstBuilder(type_1534);
  ::Reflex::Type type_4593 = ::Reflex::PointerBuilder(type_1534c);
  ::Reflex::Type type_9673 = ::Reflex::ReferenceBuilder(type_1586);
  ::Reflex::Type type_1586c = ::Reflex::ConstBuilder(type_1586);
  ::Reflex::Type type_9674 = ::Reflex::ReferenceBuilder(type_1586c);
  ::Reflex::Type type_11261 = ::Reflex::PointerBuilder(type_2243);
  ::Reflex::Type type_2261c = ::Reflex::ConstBuilder(type_2261);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __cool__IRecord
#undef __cool__IRecord
#endif
class __cool__IRecord {
  public:
  __cool__IRecord();
  virtual ~__cool__IRecord() throw();
};
#ifdef __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_
#undef __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_
#endif
struct __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_ {
  public:
  __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_();
};
#ifdef __cool__IObject
#undef __cool__IObject
#endif
class __cool__IObject {
  public:
  __cool__IObject();
  virtual ~__cool__IObject() throw();
};
#ifdef __std__iterator_traits_boost__shared_ptr_cool__IObject_p_
#undef __std__iterator_traits_boost__shared_ptr_cool__IObject_p_
#endif
struct __std__iterator_traits_boost__shared_ptr_cool__IObject_p_ {
  public:
  __std__iterator_traits_boost__shared_ptr_cool__IObject_p_();
};
#ifdef __std__iterator_traits_coral__AttributeSpecificationpsconstp_
#undef __std__iterator_traits_coral__AttributeSpecificationpsconstp_
#endif
struct __std__iterator_traits_coral__AttributeSpecificationpsconstp_ {
  public:
  __std__iterator_traits_coral__AttributeSpecificationpsconstp_();
};
#ifdef __std__iterator_traits_coral__Attributepp_
#undef __std__iterator_traits_coral__Attributepp_
#endif
struct __std__iterator_traits_coral__Attributepp_ {
  public:
  __std__iterator_traits_coral__Attributepp_();
};
#ifdef __std__iterator_traits_coral__Attributepsconstp_
#undef __std__iterator_traits_coral__Attributepsconstp_
#endif
struct __std__iterator_traits_coral__Attributepsconstp_ {
  public:
  __std__iterator_traits_coral__Attributepsconstp_();
};
#ifdef __std__basic_string_char_
#undef __std__basic_string_char_
#endif
struct __std__basic_string_char_ {
  public:
  __std__basic_string_char_();
#ifdef __std__basic_string_char____Rep_base
#undef __std__basic_string_char____Rep_base
#endif
  struct __std__basic_string_char____Rep_base {
    public:
    __std__basic_string_char____Rep_base();
    ::std::size_t _M_length;
    ::std::size_t _M_capacity;
    ::_Atomic_word _M_refcount;
  };
#ifdef __std__basic_string_char____Rep
#undef __std__basic_string_char____Rep
#endif
  struct __std__basic_string_char____Rep :   public __std__basic_string_char____Rep_base   {
    public:
    __std__basic_string_char____Rep();
  };
#ifdef __std__basic_string_char____Alloc_hider
#undef __std__basic_string_char____Alloc_hider
#endif
  struct __std__basic_string_char____Alloc_hider :   public ::std::allocator<char>   {
    public:
    __std__basic_string_char____Alloc_hider();
    void* _M_p;
  };
  __std__basic_string_char____Alloc_hider _M_dataplus;
};
#ifdef __std__vector_std__basic_string_char_s_
#undef __std__vector_std__basic_string_char_s_
#endif
class __std__vector_std__basic_string_char_s_ : protected ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > {
  public:
  __std__vector_std__basic_string_char_s_();
};
#ifdef __std__vector_unsignedsint_
#undef __std__vector_unsignedsint_
#endif
class __std__vector_unsignedsint_ : protected ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > {
  public:
  __std__vector_unsignedsint_();
};
#ifdef __boost__shared_ptr_cool__IRecord_
#undef __boost__shared_ptr_cool__IRecord_
#endif
class __boost__shared_ptr_cool__IRecord_ {
  public:
  __boost__shared_ptr_cool__IRecord_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __std__vector_boost__shared_ptr_cool__IRecord_s_
#undef __std__vector_boost__shared_ptr_cool__IRecord_s_
#endif
class __std__vector_boost__shared_ptr_cool__IRecord_s_ : protected ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > {
  public:
  __std__vector_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef __boost__shared_ptr_cool__IObject_
#undef __boost__shared_ptr_cool__IObject_
#endif
class __boost__shared_ptr_cool__IObject_ {
  public:
  __boost__shared_ptr_cool__IObject_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __std__vector_boost__shared_ptr_cool__IObject_s_
#undef __std__vector_boost__shared_ptr_cool__IObject_s_
#endif
class __std__vector_boost__shared_ptr_cool__IObject_s_ : protected ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > {
  public:
  __std__vector_boost__shared_ptr_cool__IObject_s_();
};
#ifdef __std__vector_cool__IFieldp_
#undef __std__vector_cool__IFieldp_
#endif
class __std__vector_cool__IFieldp_ : protected ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > {
  public:
  __std__vector_cool__IFieldp_();
};
#ifdef __std__vector_cool__IRecordSelectionp_
#undef __std__vector_cool__IRecordSelectionp_
#endif
class __std__vector_cool__IRecordSelectionp_ : protected ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > {
  public:
  __std__vector_cool__IRecordSelectionp_();
};
#ifdef __std__vector_cool__IFieldSpecificationp_
#undef __std__vector_cool__IFieldSpecificationp_
#endif
class __std__vector_cool__IFieldSpecificationp_ : protected ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > {
  public:
  __std__vector_cool__IFieldSpecificationp_();
};
#ifdef __cool__ChannelSelection
#undef __cool__ChannelSelection
#endif
class __cool__ChannelSelection {
  public:
  __cool__ChannelSelection();
  bool m_isNumeric;
  bool m_allChannels;
  ::std::vector<cool::ChannelSelection::ChannelRange> m_ranges;
  ::std::string m_channelName;
  ::cool::ChannelSelection::Order m_order;
};
#ifdef __cool__ChannelSelection__ChannelRange
#undef __cool__ChannelSelection__ChannelRange
#endif
class __cool__ChannelSelection__ChannelRange {
  public:
  __cool__ChannelSelection__ChannelRange();
  ::cool::ChannelId m_firstChannel;
  ::cool::ChannelId m_lastChannel;
};
#ifdef __std__vector_cool__ChannelSelection__ChannelRange_
#undef __std__vector_cool__ChannelSelection__ChannelRange_
#endif
class __std__vector_cool__ChannelSelection__ChannelRange_ : protected ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > {
  public:
  __std__vector_cool__ChannelSelection__ChannelRange_();
};
#ifdef __std__vector_coral__AttributeSpecificationp_
#undef __std__vector_coral__AttributeSpecificationp_
#endif
class __std__vector_coral__AttributeSpecificationp_ : protected ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > {
  public:
  __std__vector_coral__AttributeSpecificationp_();
};
#ifdef __std__vector_coral__Attributep_
#undef __std__vector_coral__Attributep_
#endif
class __std__vector_coral__Attributep_ : protected ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > {
  public:
  __std__vector_coral__Attributep_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IRecord_s_
#undef __std__allocator_boost__shared_ptr_cool__IRecord_s_
#endif
class __std__allocator_boost__shared_ptr_cool__IRecord_s_ : public ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > {
  public:
  __std__allocator_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IObject_s_
#undef __std__allocator_boost__shared_ptr_cool__IObject_s_
#endif
class __std__allocator_boost__shared_ptr_cool__IObject_s_ : public ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > {
  public:
  __std__allocator_boost__shared_ptr_cool__IObject_s_();
};
#ifdef __std__allocator_cool__IFieldp_
#undef __std__allocator_cool__IFieldp_
#endif
class __std__allocator_cool__IFieldp_ : public ::__gnu_cxx::new_allocator<cool::IField*> {
  public:
  __std__allocator_cool__IFieldp_();
};
#ifdef __std__allocator_cool__IRecordSelectionp_
#undef __std__allocator_cool__IRecordSelectionp_
#endif
class __std__allocator_cool__IRecordSelectionp_ : public ::__gnu_cxx::new_allocator<cool::IRecordSelection*> {
  public:
  __std__allocator_cool__IRecordSelectionp_();
};
#ifdef __std__allocator_cool__IFieldSpecificationp_
#undef __std__allocator_cool__IFieldSpecificationp_
#endif
class __std__allocator_cool__IFieldSpecificationp_ : public ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> {
  public:
  __std__allocator_cool__IFieldSpecificationp_();
};
#ifdef __std__allocator_cool__ChannelSelection__ChannelRange_
#undef __std__allocator_cool__ChannelSelection__ChannelRange_
#endif
class __std__allocator_cool__ChannelSelection__ChannelRange_ : public ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> {
  public:
  __std__allocator_cool__ChannelSelection__ChannelRange_();
};
#ifdef __std__allocator_coral__AttributeSpecificationp_
#undef __std__allocator_coral__AttributeSpecificationp_
#endif
class __std__allocator_coral__AttributeSpecificationp_ : public ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> {
  public:
  __std__allocator_coral__AttributeSpecificationp_();
};
#ifdef __std__allocator_coral__Attributep_
#undef __std__allocator_coral__Attributep_
#endif
class __std__allocator_coral__Attributep_ : public ::__gnu_cxx::new_allocator<coral::Attribute*> {
  public:
  __std__allocator_coral__Attributep_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_
#undef __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_
#endif
struct __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_ {
  public:
  __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_
#undef __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_
#endif
struct __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_ {
  public:
  __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_();
};
#ifdef __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_
#undef __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_
#endif
struct __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_ {
  public:
  __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_();
};
#ifdef __std__allocator_cool__IFieldp___rebind_cool__IFieldp_
#undef __std__allocator_cool__IFieldp___rebind_cool__IFieldp_
#endif
struct __std__allocator_cool__IFieldp___rebind_cool__IFieldp_ {
  public:
  __std__allocator_cool__IFieldp___rebind_cool__IFieldp_();
};
#ifdef __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_
#undef __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_
#endif
struct __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_ {
  public:
  __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_();
};
#ifdef __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_
#undef __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_
#endif
struct __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_ {
  public:
  __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_();
};
#ifdef __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_
#undef __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_
#endif
struct __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_ {
  public:
  __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_();
};
#ifdef __std__allocator_coral__Attributep___rebind_coral__Attributep_
#undef __std__allocator_coral__Attributep___rebind_coral__Attributep_
#endif
struct __std__allocator_coral__Attributep___rebind_coral__Attributep_ {
  public:
  __std__allocator_coral__Attributep___rebind_coral__Attributep_();
};
#ifdef __std__map_unsignedsint_std__basic_string_char_s_
#undef __std__map_unsignedsint_std__basic_string_char_s_
#endif
class __std__map_unsignedsint_std__basic_string_char_s_ {
  public:
  __std__map_unsignedsint_std__basic_string_char_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned int,std::basic_string<char> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::basic_string<char> > > > _M_t;
};
#ifdef __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#undef __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#endif
struct __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_();
  ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_
#undef __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_
#endif
struct __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_();
  ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_
#undef __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_
#endif
struct __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_ {
  public:
  __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_();
  ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_
#undef __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_
#endif
struct __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_ {
  public:
  __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_();
  ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_
#undef __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_
#endif
struct __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_ {
  public:
  __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_();
  ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_
#undef __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_
#endif
struct __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_ {
  public:
  __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_();
  ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_
#undef __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_
#endif
struct __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_ {
  public:
  __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_();
  ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_
#undef __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_
#endif
struct __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_ {
  public:
  __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_();
  ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::_Vector_impl _M_impl;
};
#ifdef __std__type_info
#undef __std__type_info
#endif
class __std__type_info {
  public:
  __std__type_info();
  virtual ~__std__type_info() throw();
  void* __name;
};
#ifdef __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_
#undef __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_
#endif
struct __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_ {
  public:
  __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_();
};
#ifdef __std____are_same_coral__Attributepsconstp_coral__Attributepp_
#undef __std____are_same_coral__Attributepsconstp_coral__Attributepp_
#endif
struct __std____are_same_coral__Attributepsconstp_coral__Attributepp_ {
  public:
  __std____are_same_coral__Attributepsconstp_coral__Attributepp_();
};
#ifdef __std____are_same_coral__Attributepp_coral__Attributepp_
#undef __std____are_same_coral__Attributepp_coral__Attributepp_
#endif
struct __std____are_same_coral__Attributepp_coral__Attributepp_ {
  public:
  __std____are_same_coral__Attributepp_coral__Attributepp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_();
};
#ifdef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_
#undef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_
#endif
class ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_ {
  public:
  ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_
#undef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_
#endif
class ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_ {
  public:
  ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_();
};
#ifdef ____gnu_cxx__new_allocator_cool__IRecordSelectionp_
#undef ____gnu_cxx__new_allocator_cool__IRecordSelectionp_
#endif
class ____gnu_cxx__new_allocator_cool__IRecordSelectionp_ {
  public:
  ____gnu_cxx__new_allocator_cool__IRecordSelectionp_();
};
#ifdef ____gnu_cxx__new_allocator_cool__IFieldp_
#undef ____gnu_cxx__new_allocator_cool__IFieldp_
#endif
class ____gnu_cxx__new_allocator_cool__IFieldp_ {
  public:
  ____gnu_cxx__new_allocator_cool__IFieldp_();
};
#ifdef ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_
#undef ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_
#endif
class ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_ {
  public:
  ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_();
};
#ifdef ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_
#undef ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_
#endif
class ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_ {
  public:
  ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_();
};
#ifdef ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_
#undef ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_
#endif
class ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_ {
  public:
  ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_();
};
#ifdef ____gnu_cxx__new_allocator_coral__Attributep_
#undef ____gnu_cxx__new_allocator_coral__Attributep_
#endif
class ____gnu_cxx__new_allocator_coral__Attributep_ {
  public:
  ____gnu_cxx__new_allocator_coral__Attributep_();
};
#ifdef ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_
#undef ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_
#endif
struct ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_ {
  public:
  ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_();
};
#ifdef ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_
#endif
struct ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_();
};
#ifdef ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_
#endif
struct ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_();
};
#ifdef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#undef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#endif
class ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_
#undef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_
#endif
class ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_
#undef ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_
#endif
class ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_ {
  public:
  ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_
#endif
class ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_
#endif
class ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_();
  void* _M_current;
};
#ifdef __cool__IObjectIterator
#undef __cool__IObjectIterator
#endif
class __cool__IObjectIterator {
  public:
  __cool__IObjectIterator();
  virtual ~__cool__IObjectIterator() throw();
};
#ifdef __cool__FieldSelection
#undef __cool__FieldSelection
#endif
class __cool__FieldSelection : virtual public ::cool::IRecordSelection {
  public:
  __cool__FieldSelection();
  virtual ~__cool__FieldSelection() throw();
  ::cool::Record m_refValue;
  ::cool::FieldSelection::Relation m_relation;
};
#ifdef __cool__FieldSpecificationWrongStorageType
#undef __cool__FieldSpecificationWrongStorageType
#endif
class __cool__FieldSpecificationWrongStorageType : public ::cool::RecordException {
  public:
  __cool__FieldSpecificationWrongStorageType();
  virtual ~__cool__FieldSpecificationWrongStorageType() throw();
};
#ifdef __cool__TagNotFound
#undef __cool__TagNotFound
#endif
class __cool__TagNotFound : public ::cool::Exception {
  public:
  __cool__TagNotFound();
  virtual ~__cool__TagNotFound() throw();
};
#ifdef __cool__PayloadSpecificationTooManyFields
#undef __cool__PayloadSpecificationTooManyFields
#endif
class __cool__PayloadSpecificationTooManyFields : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationTooManyFields();
  virtual ~__cool__PayloadSpecificationTooManyFields() throw();
};
#ifdef __cool__ChannelExists
#undef __cool__ChannelExists
#endif
class __cool__ChannelExists : public ::cool::Exception {
  public:
  __cool__ChannelExists();
  virtual ~__cool__ChannelExists() throw();
};
#ifdef __cool__IField
#undef __cool__IField
#endif
class __cool__IField {
  public:
  __cool__IField();
  virtual ~__cool__IField() throw();
};
#ifdef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#undef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#endif
class __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__InvalidChannelRange
#undef __cool__InvalidChannelRange
#endif
class __cool__InvalidChannelRange : public ::cool::Exception {
  public:
  __cool__InvalidChannelRange();
  virtual ~__cool__InvalidChannelRange() throw();
};
#ifdef __cool__StorageTypeStringTooLong
#undef __cool__StorageTypeStringTooLong
#endif
class __cool__StorageTypeStringTooLong : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeStringTooLong();
  virtual ~__cool__StorageTypeStringTooLong() throw();
};
#ifdef __cool__IFolderSet
#undef __cool__IFolderSet
#endif
class __cool__IFolderSet : virtual public ::cool::IHvsNode {
  public:
  __cool__IFolderSet();
  virtual ~__cool__IFolderSet() throw();
  virtual ::std::vector<std::basic_string<char> > listFolders(bool) throw();
  virtual const ::cool::IRecord& folderSetAttributes() const throw();
  virtual ::std::vector<std::basic_string<char> > listFolderSets(bool) throw();
};
#ifdef __cool__CompositeSelection
#undef __cool__CompositeSelection
#endif
class __cool__CompositeSelection : virtual public ::cool::IRecordSelection {
  public:
  __cool__CompositeSelection();
  virtual ~__cool__CompositeSelection() throw();
  ::cool::CompositeSelection::Connective m_conn;
  ::std::vector<cool::IRecordSelection*> m_selVec;
};
#ifdef __cool__StorageType
#undef __cool__StorageType
#endif
class __cool__StorageType {
  public:
  __cool__StorageType();
  virtual ~__cool__StorageType() throw();
  ::cool::StorageType::TypeId m_id;
};
#ifdef __cool__IRecordSpecification
#undef __cool__IRecordSpecification
#endif
class __cool__IRecordSpecification {
  public:
  __cool__IRecordSpecification();
  virtual ~__cool__IRecordSpecification() throw();
};
#ifdef __boost__shared_ptr_cool__IObjectIterator_
#undef __boost__shared_ptr_cool__IObjectIterator_
#endif
class __boost__shared_ptr_cool__IObjectIterator_ {
  public:
  __boost__shared_ptr_cool__IObjectIterator_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__RecordSpecificationUnknownField
#undef __cool__RecordSpecificationUnknownField
#endif
class __cool__RecordSpecificationUnknownField : public ::cool::RecordException {
  public:
  __cool__RecordSpecificationUnknownField();
  virtual ~__cool__RecordSpecificationUnknownField() throw();
};
#ifdef __cool__TagRelationNotFound
#undef __cool__TagRelationNotFound
#endif
class __cool__TagRelationNotFound : public ::cool::Exception {
  public:
  __cool__TagRelationNotFound();
  virtual ~__cool__TagRelationNotFound() throw();
};
#ifdef __cool__FolderSetNotFound
#undef __cool__FolderSetNotFound
#endif
class __cool__FolderSetNotFound : public ::cool::NodeNotFound {
  public:
  __cool__FolderSetNotFound();
  virtual ~__cool__FolderSetNotFound() throw();
  bool m_isFolder;
};
#ifdef __cool__FieldWrongCppType
#undef __cool__FieldWrongCppType
#endif
class __cool__FieldWrongCppType : public ::cool::RecordException {
  public:
  __cool__FieldWrongCppType();
  virtual ~__cool__FieldWrongCppType() throw();
};
#ifdef __boost__shared_ptr_cool__IFolderSet_
#undef __boost__shared_ptr_cool__IFolderSet_
#endif
class __boost__shared_ptr_cool__IFolderSet_ {
  public:
  __boost__shared_ptr_cool__IFolderSet_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__FieldSpecificationWrongName
#undef __cool__FieldSpecificationWrongName
#endif
class __cool__FieldSpecificationWrongName : public ::cool::RecordException {
  public:
  __cool__FieldSpecificationWrongName();
  virtual ~__cool__FieldSpecificationWrongName() throw();
};
#ifdef __cool__RecordSpecification
#undef __cool__RecordSpecification
#endif
class __cool__RecordSpecification : public ::cool::IRecordSpecification {
  public:
  __cool__RecordSpecification();
  virtual ~__cool__RecordSpecification() throw();
  ::std::vector<cool::IFieldSpecification*> m_fSpecs;
};
#ifdef __cool__ObjectNotFound
#undef __cool__ObjectNotFound
#endif
class __cool__ObjectNotFound : public ::cool::Exception {
  public:
  __cool__ObjectNotFound();
  virtual ~__cool__ObjectNotFound() throw();
};
#ifdef __cool__ChannelNotFound
#undef __cool__ChannelNotFound
#endif
class __cool__ChannelNotFound : public ::cool::Exception {
  public:
  __cool__ChannelNotFound();
  virtual ~__cool__ChannelNotFound() throw();
};
#ifdef __cool__StorageTypeException
#undef __cool__StorageTypeException
#endif
class __cool__StorageTypeException : public ::cool::RecordException {
  public:
  __cool__StorageTypeException();
  virtual ~__cool__StorageTypeException() throw();
};
#ifdef __cool__StorageTypeWrongCppType
#undef __cool__StorageTypeWrongCppType
#endif
class __cool__StorageTypeWrongCppType : public ::cool::StorageTypeException {
  public:
  __cool__StorageTypeWrongCppType();
  virtual ~__cool__StorageTypeWrongCppType() throw();
};
#ifdef __cool__Record
#undef __cool__Record
#endif
class __cool__Record : public ::cool::IRecord {
  public:
  __cool__Record();
  virtual ~__cool__Record() throw();
  ::cool::RecordSpecification m_spec;
  ::coral::AttributeList m_attrList;
  ::std::vector<cool::IField*> m_fields;
};
#ifdef __cool__ValidityKeyException
#undef __cool__ValidityKeyException
#endif
class __cool__ValidityKeyException : public ::cool::Exception {
  public:
  __cool__ValidityKeyException();
  virtual ~__cool__ValidityKeyException() throw();
};
#ifdef __cool__FieldIsNull
#undef __cool__FieldIsNull
#endif
class __cool__FieldIsNull : public ::cool::RecordException {
  public:
  __cool__FieldIsNull();
  virtual ~__cool__FieldIsNull() throw();
};
#ifdef __cool__InvalidPayloadSpecification
#undef __cool__InvalidPayloadSpecification
#endif
class __cool__InvalidPayloadSpecification : public ::cool::InvalidFolderSpecification {
  public:
  __cool__InvalidPayloadSpecification();
  virtual ~__cool__InvalidPayloadSpecification() throw();
};
#ifdef __cool__IFieldSpecification
#undef __cool__IFieldSpecification
#endif
class __cool__IFieldSpecification {
  public:
  __cool__IFieldSpecification();
  virtual ~__cool__IFieldSpecification() throw();
};
#ifdef __cool__FolderIsSingleVersion
#undef __cool__FolderIsSingleVersion
#endif
class __cool__FolderIsSingleVersion : public ::cool::NodeIsSingleVersion {
  public:
  __cool__FolderIsSingleVersion();
  virtual ~__cool__FolderIsSingleVersion() throw();
};
#ifdef __cool__ITime
#undef __cool__ITime
#endif
class __cool__ITime {
  public:
  __cool__ITime();
  virtual ~__cool__ITime() throw();
};
#ifdef __cool__ConstRecordAdapter
#undef __cool__ConstRecordAdapter
#endif
class __cool__ConstRecordAdapter : public ::cool::IRecord {
  public:
  __cool__ConstRecordAdapter();
  virtual ~__cool__ConstRecordAdapter() throw();
  ::cool::RecordSpecification m_spec;
  int& m_attrList;
  ::std::vector<cool::IField*> m_fields;
  ::coral::AttributeList m_publicAttrList;
};
#ifdef __cool__InvalidTagRelation
#undef __cool__InvalidTagRelation
#endif
class __cool__InvalidTagRelation : public ::cool::Exception {
  public:
  __cool__InvalidTagRelation();
  virtual ~__cool__InvalidTagRelation() throw();
};
#ifdef __cool__DatabaseNotOpen
#undef __cool__DatabaseNotOpen
#endif
class __cool__DatabaseNotOpen : public ::cool::Exception {
  public:
  __cool__DatabaseNotOpen();
  virtual ~__cool__DatabaseNotOpen() throw();
};
#ifdef __cool__DatabaseDoesNotExist
#undef __cool__DatabaseDoesNotExist
#endif
class __cool__DatabaseDoesNotExist : public ::cool::Exception {
  public:
  __cool__DatabaseDoesNotExist();
  virtual ~__cool__DatabaseDoesNotExist() throw();
};
#ifdef __cool__IFolder
#undef __cool__IFolder
#endif
class __cool__IFolder : virtual public ::cool::IHvsNode {
  public:
  __cool__IFolder();
  virtual ~__cool__IFolder() throw();
  virtual const ::cool::Time insertionTimeOfLastObjectInTag(std::string const&) const throw();
  virtual void storeObject(unsigned long long const&, unsigned long long const&, cool::IRecord const&, unsigned int const&, std::string const&, bool) throw();
  virtual ::cool::IObjectIteratorPtr findObjects(unsigned long long const&, cool::ChannelSelection const&, std::string const&) const throw();
  virtual void setupStorageBuffer(bool) throw();
  virtual bool existsUserTag(std::string const&) const throw();
  virtual const ::cool::IRecordSpecification& payloadSpecification() const throw();
  virtual ::cool::ChannelId channelId(std::string const&) const throw();
  virtual void storeObject(unsigned long long const&, unsigned long long const&, coral::AttributeList const&, unsigned int const&, std::string const&, bool) throw();
  virtual void tagHeadAsOfDate(cool::ITime const&, std::string const&, std::string const&) const throw();
  virtual void createChannel(unsigned int const&, std::string const&, std::string const&) throw();
  virtual const ::std::map<unsigned int,std::basic_string<char> > listChannelsWithNames() const throw();
  virtual void deleteTag(std::string const&) throw();
  virtual const ::std::string channelName(unsigned int const&) const throw();
  virtual void renamePayload(std::string const&, std::string const&) throw();
  virtual void flushStorageBuffer() throw();
  virtual const ::cool::IRecord& folderAttributes() const throw();
  virtual void setChannelDescription(unsigned int const&, std::string const&) throw();
  virtual void cloneTagAsUserTag(std::string const&, std::string const&, std::string const&, bool) throw();
  virtual ::cool::IObjectPtr findObject(unsigned long long const&, unsigned int const&, std::string const&) const throw();
  virtual bool existsChannel(std::string const&) const throw();
  virtual void setPrefetchAll(bool) throw();
  virtual const ::cool::IFolderSpecification& folderSpecification() const throw();
  virtual const ::std::string channelDescription(unsigned int const&) const throw();
  virtual bool dropChannel(unsigned int const&) throw();
  virtual const ::std::vector<unsigned int> listChannels() const throw();
  virtual void tagCurrentHead(std::string const&, std::string const&) const throw();
  virtual ::cool::IObjectIteratorPtr browseObjects(unsigned long long const&, unsigned long long const&, cool::ChannelSelection const&, std::string const&, cool::IRecordSelection const*) const throw();
  virtual ::cool::FolderVersioning::Mode versioningMode() const throw();
  virtual void setChannelName(unsigned int const&, std::string const&) throw();
  virtual void storeObject(unsigned long long const&, unsigned long long const&, std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > const&, unsigned int const&, std::string const&, bool) throw();
  virtual void extendPayloadSpecification(cool::IRecord const&) throw();
  virtual bool existsChannel(unsigned int const&) const throw();
  virtual int truncateObjectValidity(unsigned long long const&, cool::ChannelSelection const&) throw();
  virtual unsigned int countObjects(unsigned long long const&, unsigned long long const&, cool::ChannelSelection const&, std::string const&, cool::IRecordSelection const*) const throw();
};
#ifdef __boost__shared_ptr_cool__IFolder_
#undef __boost__shared_ptr_cool__IFolder_
#endif
class __boost__shared_ptr_cool__IFolder_ {
  public:
  __boost__shared_ptr_cool__IFolder_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__ValidityIntervalBackwards
#undef __cool__ValidityIntervalBackwards
#endif
class __cool__ValidityIntervalBackwards : public ::cool::ValidityKeyException {
  public:
  __cool__ValidityIntervalBackwards();
  virtual ~__cool__ValidityIntervalBackwards() throw();
};
#ifdef __cool__Time
#undef __cool__Time
#endif
class __cool__Time : public ::cool::ITime {
  public:
  __cool__Time();
  virtual ~__cool__Time() throw();
  int m_year;
  int m_month;
  int m_day;
  int m_hour;
  int m_minute;
  int m_second;
  long m_nanosecond;
};
#ifdef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_
#undef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_
#endif
class __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__IRecordSelection
#undef __cool__IRecordSelection
#endif
class __cool__IRecordSelection {
  public:
  __cool__IRecordSelection();
  virtual ~__cool__IRecordSelection() throw();
};
#ifdef __cool__IDatabase
#undef __cool__IDatabase
#endif
class __cool__IDatabase {
  public:
  __cool__IDatabase();
  virtual ~__cool__IDatabase() throw();
};
#ifdef __boost__shared_ptr_cool__IDatabase_
#undef __boost__shared_ptr_cool__IDatabase_
#endif
class __boost__shared_ptr_cool__IDatabase_ {
  public:
  __boost__shared_ptr_cool__IDatabase_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__IHvsNode
#undef __cool__IHvsNode
#endif
class __cool__IHvsNode : virtual public ::cool::IHvsNodeRecord {
  public:
  __cool__IHvsNode();
  virtual ~__cool__IHvsNode() throw();
};
#ifdef __cool__RecordSpecificationCannotExtend
#undef __cool__RecordSpecificationCannotExtend
#endif
class __cool__RecordSpecificationCannotExtend : public ::cool::RecordException {
  public:
  __cool__RecordSpecificationCannotExtend();
  virtual ~__cool__RecordSpecificationCannotExtend() throw();
};
#ifdef __coral__Blob
#undef __coral__Blob
#endif
class __coral__Blob {
  public:
  __coral__Blob();
  long m_size;
  void* m_data;
};
#ifdef __cool__IApplication
#undef __cool__IApplication
#endif
class __cool__IApplication {
  public:
  __cool__IApplication();
  virtual ~__cool__IApplication() throw();
};
#ifdef __cool__IHvsNodeRecord
#undef __cool__IHvsNodeRecord
#endif
class __cool__IHvsNodeRecord {
  public:
  __cool__IHvsNodeRecord();
  virtual ~__cool__IHvsNodeRecord() throw();
};
#ifdef __cool__TagExists
#undef __cool__TagExists
#endif
class __cool__TagExists : public ::cool::Exception {
  public:
  __cool__TagExists();
  virtual ~__cool__TagExists() throw();
};
#ifdef __cool__IDatabaseSvc
#undef __cool__IDatabaseSvc
#endif
class __cool__IDatabaseSvc {
  public:
  __cool__IDatabaseSvc();
  virtual ~__cool__IDatabaseSvc() throw();
};
#ifdef __cool__FieldSpecification
#undef __cool__FieldSpecification
#endif
class __cool__FieldSpecification : public ::cool::IFieldSpecification {
  public:
  __cool__FieldSpecification();
  virtual ~__cool__FieldSpecification() throw();
  ::std::string m_name;
  int& m_type;
};
#ifdef __cool__RecordException
#undef __cool__RecordException
#endif
class __cool__RecordException : public ::cool::Exception {
  public:
  __cool__RecordException();
  virtual ~__cool__RecordException() throw();
};
#ifdef __cool__ReservedHeadTag
#undef __cool__ReservedHeadTag
#endif
class __cool__ReservedHeadTag : public ::cool::Exception {
  public:
  __cool__ReservedHeadTag();
  virtual ~__cool__ReservedHeadTag() throw();
};
#ifdef __cool__ValidityKeyOutOfBoundaries
#undef __cool__ValidityKeyOutOfBoundaries
#endif
class __cool__ValidityKeyOutOfBoundaries : public ::cool::ValidityKeyException {
  public:
  __cool__ValidityKeyOutOfBoundaries();
  virtual ~__cool__ValidityKeyOutOfBoundaries() throw();
};
#ifdef __cool__FieldSpecificationInvalidName
#undef __cool__FieldSpecificationInvalidName
#endif
class __cool__FieldSpecificationInvalidName : public ::cool::RecordException {
  public:
  __cool__FieldSpecificationInvalidName();
  virtual ~__cool__FieldSpecificationInvalidName() throw();
};
#ifdef __cool__StorageTypeDoubleIsNaN
#undef __cool__StorageTypeDoubleIsNaN
#endif
class __cool__StorageTypeDoubleIsNaN : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeDoubleIsNaN();
  virtual ~__cool__StorageTypeDoubleIsNaN() throw();
};
#ifdef __cool__TagRelationExists
#undef __cool__TagRelationExists
#endif
class __cool__TagRelationExists : public ::cool::Exception {
  public:
  __cool__TagRelationExists();
  virtual ~__cool__TagRelationExists() throw();
};
#ifdef __cool__InvalidFolderSpecification
#undef __cool__InvalidFolderSpecification
#endif
class __cool__InvalidFolderSpecification : public ::cool::Exception {
  public:
  __cool__InvalidFolderSpecification();
  virtual ~__cool__InvalidFolderSpecification() throw();
};
#ifdef __cool__StorageTypeStringContainsNullChar
#undef __cool__StorageTypeStringContainsNullChar
#endif
class __cool__StorageTypeStringContainsNullChar : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeStringContainsNullChar();
  virtual ~__cool__StorageTypeStringContainsNullChar() throw();
};
#ifdef __cool__StorageTypeInvalidUInt63
#undef __cool__StorageTypeInvalidUInt63
#endif
class __cool__StorageTypeInvalidUInt63 : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeInvalidUInt63();
  virtual ~__cool__StorageTypeInvalidUInt63() throw();
};
#ifdef __cool__DatabaseSvcFactory
#undef __cool__DatabaseSvcFactory
#endif
class __cool__DatabaseSvcFactory {
  public:
  __cool__DatabaseSvcFactory();
};
#ifdef __cool__InvalidChannelName
#undef __cool__InvalidChannelName
#endif
class __cool__InvalidChannelName : public ::cool::Exception {
  public:
  __cool__InvalidChannelName();
  virtual ~__cool__InvalidChannelName() throw();
};
#ifdef __cool__StorageTypeBlobTooLong
#undef __cool__StorageTypeBlobTooLong
#endif
class __cool__StorageTypeBlobTooLong : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeBlobTooLong();
  virtual ~__cool__StorageTypeBlobTooLong() throw();
};
#ifdef __cool__PayloadSpecificationInvalidFieldName
#undef __cool__PayloadSpecificationInvalidFieldName
#endif
class __cool__PayloadSpecificationInvalidFieldName : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationInvalidFieldName();
  virtual ~__cool__PayloadSpecificationInvalidFieldName() throw();
};
#ifdef __cool__DatabaseOpenInReadOnlyMode
#undef __cool__DatabaseOpenInReadOnlyMode
#endif
class __cool__DatabaseOpenInReadOnlyMode : public ::cool::Exception {
  public:
  __cool__DatabaseOpenInReadOnlyMode();
  virtual ~__cool__DatabaseOpenInReadOnlyMode() throw();
};
#ifdef __cool__StorageTypeFloatIsNaN
#undef __cool__StorageTypeFloatIsNaN
#endif
class __cool__StorageTypeFloatIsNaN : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeFloatIsNaN();
  virtual ~__cool__StorageTypeFloatIsNaN() throw();
};
#ifdef __cool__NodeNotFound
#undef __cool__NodeNotFound
#endif
class __cool__NodeNotFound : public ::cool::Exception {
  public:
  __cool__NodeNotFound();
  virtual ~__cool__NodeNotFound() throw();
};
#ifdef __cool__Application
#undef __cool__Application
#endif
class __cool__Application : public ::cool::IApplication {
  public:
  __cool__Application();
  virtual ~__cool__Application() throw();
  void* m_application;
};
#ifdef __cool__NodeIsSingleVersion
#undef __cool__NodeIsSingleVersion
#endif
class __cool__NodeIsSingleVersion : public ::cool::Exception {
  public:
  __cool__NodeIsSingleVersion();
  virtual ~__cool__NodeIsSingleVersion() throw();
};
#ifdef __cool__NodeExists
#undef __cool__NodeExists
#endif
class __cool__NodeExists : public ::cool::Exception {
  public:
  __cool__NodeExists();
  virtual ~__cool__NodeExists() throw();
};
#ifdef __cool__StorageTypeInvalidValue
#undef __cool__StorageTypeInvalidValue
#endif
class __cool__StorageTypeInvalidValue : public ::cool::StorageTypeException {
  public:
  __cool__StorageTypeInvalidValue();
  virtual ~__cool__StorageTypeInvalidValue() throw();
};
#ifdef __cool__TagIsLocked
#undef __cool__TagIsLocked
#endif
class __cool__TagIsLocked : public ::cool::Exception {
  public:
  __cool__TagIsLocked();
  virtual ~__cool__TagIsLocked() throw();
};
#ifdef __cool__IRecordIterator
#undef __cool__IRecordIterator
#endif
class __cool__IRecordIterator {
  public:
  __cool__IRecordIterator();
  virtual ~__cool__IRecordIterator() throw();
};
#ifdef __cool__NodeRelationNotFound
#undef __cool__NodeRelationNotFound
#endif
class __cool__NodeRelationNotFound : public ::cool::Exception {
  public:
  __cool__NodeRelationNotFound();
  virtual ~__cool__NodeRelationNotFound() throw();
  bool m_parentOnly;
};
#ifdef __cool__FolderNotFound
#undef __cool__FolderNotFound
#endif
class __cool__FolderNotFound : public ::cool::NodeNotFound {
  public:
  __cool__FolderNotFound();
  virtual ~__cool__FolderNotFound() throw();
  bool m_isFolderSet;
};
#ifdef __cool__RecordSpecificationWrongSize
#undef __cool__RecordSpecificationWrongSize
#endif
class __cool__RecordSpecificationWrongSize : public ::cool::RecordException {
  public:
  __cool__RecordSpecificationWrongSize();
  virtual ~__cool__RecordSpecificationWrongSize() throw();
};
#ifdef __cool__IFolderSpecification
#undef __cool__IFolderSpecification
#endif
class __cool__IFolderSpecification {
  public:
  __cool__IFolderSpecification();
  virtual ~__cool__IFolderSpecification() throw();
};
#ifdef __cool__Exception
#undef __cool__Exception
#endif
class __cool__Exception : public ::std::exception {
  public:
  __cool__Exception();
  virtual ~__cool__Exception() throw();
  ::std::string m_message;
  ::std::string m_domain;
};
#ifdef __cool__PayloadSpecificationTooManyBlobFields
#undef __cool__PayloadSpecificationTooManyBlobFields
#endif
class __cool__PayloadSpecificationTooManyBlobFields : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationTooManyBlobFields();
  virtual ~__cool__PayloadSpecificationTooManyBlobFields() throw();
};
#ifdef __cool__FolderSpecification
#undef __cool__FolderSpecification
#endif
class __cool__FolderSpecification : public ::cool::IFolderSpecification {
  public:
  __cool__FolderSpecification();
  virtual ~__cool__FolderSpecification() throw();
  ::cool::FolderVersioning::Mode m_versioningMode;
  ::cool::RecordSpecification m_payloadSpec;
  ::cool::PayloadMode::Mode m_payloadMode;
};
#ifdef __cool__PayloadSpecificationTooManyString255Fields
#undef __cool__PayloadSpecificationTooManyString255Fields
#endif
class __cool__PayloadSpecificationTooManyString255Fields : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationTooManyString255Fields();
  virtual ~__cool__PayloadSpecificationTooManyString255Fields() throw();
};
#ifdef __coral__AttributeListSpecification
#undef __coral__AttributeListSpecification
#endif
class __coral__AttributeListSpecification {
  public:
  __coral__AttributeListSpecification();
  int m_counter;
  ::std::vector<coral::AttributeSpecification*> m_attributeSpecifications;
  ::std::map<std::basic_string<char>,int> m_mapOfNameToIndex;
};
#ifdef __coral__AttributeSpecification
#undef __coral__AttributeSpecification
#endif
class __coral__AttributeSpecification {
  public:
  __coral__AttributeSpecification();
  ::std::string m_name;
  void* m_type;
};
#ifdef __coral__IConnectionServiceConfiguration
#undef __coral__IConnectionServiceConfiguration
#endif
class __coral__IConnectionServiceConfiguration {
  public:
  __coral__IConnectionServiceConfiguration();
  virtual ~__coral__IConnectionServiceConfiguration() throw();
};
#ifdef __coral__Attribute
#undef __coral__Attribute
#endif
class __coral__Attribute {
  public:
  __coral__Attribute();
  void* m_specification;
  void* m_data;
};
#ifdef __coral__AttributeList
#undef __coral__AttributeList
#endif
class __coral__AttributeList {
  public:
  __coral__AttributeList();
  void* m_specification;
  bool m_ownSpecification;
  ::std::vector<coral::Attribute*> m_data;
};
#ifdef __coral__IWebCacheInfo
#undef __coral__IWebCacheInfo
#endif
class __coral__IWebCacheInfo {
  public:
  __coral__IWebCacheInfo();
  virtual ~__coral__IWebCacheInfo() throw();
};
#ifdef __coral__IWebCacheControl
#undef __coral__IWebCacheControl
#endif
class __coral__IWebCacheControl {
  public:
  __coral__IWebCacheControl();
  virtual ~__coral__IWebCacheControl() throw();
};
#ifdef __coral__AttributeListException
#undef __coral__AttributeListException
#endif
class __coral__AttributeListException : public ::coral::Exception {
  public:
  __coral__AttributeListException();
  virtual ~__coral__AttributeListException() throw();
};
#ifdef __coral__AttributeException
#undef __coral__AttributeException
#endif
class __coral__AttributeException : public ::coral::Exception {
  public:
  __coral__AttributeException();
  virtual ~__coral__AttributeException() throw();
};
#ifdef __coral__IConnectionService
#undef __coral__IConnectionService
#endif
class __coral__IConnectionService {
  public:
  __coral__IConnectionService();
  virtual ~__coral__IConnectionService() throw();
};
#ifdef __coral__AttributeListSpecification__const_iterator
#undef __coral__AttributeListSpecification__const_iterator
#endif
class __coral__AttributeListSpecification__const_iterator {
  public:
  __coral__AttributeListSpecification__const_iterator();
  ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > m_iterator;
};
#ifdef __coral__AttributeList__iterator_base
#undef __coral__AttributeList__iterator_base
#endif
class __coral__AttributeList__iterator_base {
  public:
  __coral__AttributeList__iterator_base();
  virtual ~__coral__AttributeList__iterator_base() throw();
  ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > m_iterator;
};
#ifdef __coral__AttributeList__iterator
#undef __coral__AttributeList__iterator
#endif
class __coral__AttributeList__iterator : public ::coral::AttributeList::iterator_base {
  public:
  __coral__AttributeList__iterator();
  virtual ~__coral__AttributeList__iterator() throw();
};
#ifdef __coral__AttributeList__const_iterator
#undef __coral__AttributeList__const_iterator
#endif
class __coral__AttributeList__const_iterator : public ::coral::AttributeList::iterator_base {
  public:
  __coral__AttributeList__const_iterator();
  virtual ~__coral__AttributeList__const_iterator() throw();
};
#ifdef __boost__detail__shared_count
#undef __boost__detail__shared_count
#endif
class __boost__detail__shared_count {
  public:
  __boost__detail__shared_count();
  void* pi_;
};
#ifdef __cool__PyCool__Helpers__Typedefs
#undef __cool__PyCool__Helpers__Typedefs
#endif
struct __cool__PyCool__Helpers__Typedefs {
  public:
  __cool__PyCool__Helpers__Typedefs();
};
#ifdef __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#undef __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#endif
struct __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_ {
  public:
  __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_();
  void* _M_node;
};
#ifdef __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#undef __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#endif
struct __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_ {
  public:
  __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_();
  void* _M_node;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class IRecord -------------------------------
static void destructor_7954(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecord*)o)->::cool::IRecord::~IRecord();
}
static  void method_7955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->specification)();
  else   (((const ::cool::IRecord*)o)->specification)();
}

static  void method_7956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecord*)o)->size)());
  else   (((const ::cool::IRecord*)o)->size)();
}

static  void method_7957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecord*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IRecord*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void operator_7958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::IRecord*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_7959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::IRecord*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_7960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecord*)o)->operator==)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::IRecord*)o)->operator==)(*(const ::cool::IRecord*)arg[0]);
}

static  void operator_7961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecord*)o)->operator!=)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::IRecord*)o)->operator!=)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_7962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IRecord*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void method_7963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->attributeList)();
  else   (((const ::cool::IRecord*)o)->attributeList)();
}

//------Dictionary for class IRecord -------------------------------
void __cool__IRecord_db_datamem(Reflex::Class*);
void __cool__IRecord_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecord_datamem_bld(&__cool__IRecord_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecord_funcmem_bld(&__cool__IRecord_db_funcmem);
void __cool__IRecord_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecord"), typeid(::cool::IRecord), sizeof(::cool::IRecord), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecord"), destructor_7954, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecord_funcmem_bld);
}

//------Delayed data member builder for class IRecord -------------------
void __cool__IRecord_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecord -------------------
void __cool__IRecord_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10023), Reflex::Literal("specification"), method_7955, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("size"), method_7956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256, type_4025), Reflex::Literal("index"), method_7957, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420, type_4025), Reflex::Literal("operator[]"), operator_7958, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420, type_2256), Reflex::Literal("operator[]"), operator_7959, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8419), Reflex::Literal("operator=="), operator_7960, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8419), Reflex::Literal("operator!="), operator_7961, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415), Reflex::Literal("print"), method_7962, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8803), Reflex::Literal("attributeList"), method_7963, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------------------
static void destructor_3013(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)o)->::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::~iterator_traits();
}
static  void operator_3014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
  else   (((::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
}

static void constructor_3015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
}

static void constructor_3016( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>();
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>();
}

static void method_newdel_1279( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------------------
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_datamem(Reflex::Class*);
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__datamem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__funcmem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_funcmem);
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>"), typeid(::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>), sizeof(::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1423, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::iterator_category"))
  .AddTypedef(type_2288, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::difference_type"))
  .AddTypedef(type_3009, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::pointer"))
  .AddTypedef(type_3011, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3013, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9172, type_9173), Reflex::Literal("operator="), operator_3014, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9173), Reflex::Literal("iterator_traits"), constructor_3015, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3016, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1279, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IObject -------------------------------
static void destructor_8098(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IObject*)o)->::cool::IObject::~IObject();
}
static  void method_8099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IObject*)o)->clone)());
  else   (((const ::cool::IObject*)o)->clone)();
}

static  void method_8100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->channelId)();
  else   (((const ::cool::IObject*)o)->channelId)();
}

static  void method_8101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->since)();
  else   (((const ::cool::IObject*)o)->since)();
}

static  void method_8102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->until)();
  else   (((const ::cool::IObject*)o)->until)();
}

static  void method_8103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->payload)();
  else   (((const ::cool::IObject*)o)->payload)();
}

static  void method_8104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->payloadIterator)();
  else   (((const ::cool::IObject*)o)->payloadIterator)();
}

static  void method_8105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IObject*)o)->payloadValue)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IObject*)o)->payloadValue)(*(const ::std::string*)arg[0]);
}

static  void method_8106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IObject*)o)->isStored)());
  else   (((const ::cool::IObject*)o)->isStored)();
}

static  void method_8107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->objectId)());
  else   (((const ::cool::IObject*)o)->objectId)();
}

static  void method_8108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->payloadId)());
  else   (((const ::cool::IObject*)o)->payloadId)();
}

static  void method_8109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->payloadSetId)());
  else   (((const ::cool::IObject*)o)->payloadSetId)();
}

static  void method_8110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->payloadSize)());
  else   (((const ::cool::IObject*)o)->payloadSize)();
}

static  void method_8111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->insertionTime)();
  else   (((const ::cool::IObject*)o)->insertionTime)();
}

static  void method_8112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IObject*)o)->print)(*(::std::ostream*)arg[0]);
}

//------Dictionary for class IObject -------------------------------
void __cool__IObject_db_datamem(Reflex::Class*);
void __cool__IObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IObject_datamem_bld(&__cool__IObject_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IObject_funcmem_bld(&__cool__IObject_db_funcmem);
void __cool__IObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IObject"), typeid(::cool::IObject), sizeof(::cool::IObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IObject"), destructor_8098, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IObject_funcmem_bld);
}

//------Delayed data member builder for class IObject -------------------
void __cool__IObject_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IObject -------------------
void __cool__IObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10075), Reflex::Literal("clone"), method_8099, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10035), Reflex::Literal("channelId"), method_8100, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10113), Reflex::Literal("since"), method_8101, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10113), Reflex::Literal("until"), method_8102, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8419), Reflex::Literal("payload"), method_8103, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10114), Reflex::Literal("payloadIterator"), method_8104, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_4025), Reflex::Literal("payloadValue"), method_8105, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isStored"), method_8106, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("objectId"), method_8107, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("payloadId"), method_8108, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("payloadSetId"), method_8109, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("payloadSize"), method_8110, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8416), Reflex::Literal("insertionTime"), method_8111, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415), Reflex::Literal("print"), method_8112, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------------------
static void destructor_3024(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)o)->::std::iterator_traits<boost::shared_ptr<cool::IObject>*>::~iterator_traits();
}
static  void operator_3025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
  else   (((::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
}

static void constructor_3026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
}

static void constructor_3027( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>();
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>();
}

static void method_newdel_1280( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------------------
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_datamem(Reflex::Class*);
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IObject_p__datamem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IObject_p__funcmem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_funcmem);
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>"), typeid(::std::iterator_traits<boost::shared_ptr<cool::IObject>*>), sizeof(::std::iterator_traits<boost::shared_ptr<cool::IObject>*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1423, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::iterator_category"))
  .AddTypedef(type_2180, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::difference_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::pointer"))
  .AddTypedef(type_3022, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3024, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9174, type_9175), Reflex::Literal("operator="), operator_3025, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9175), Reflex::Literal("iterator_traits"), constructor_3026, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3027, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1280, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class iterator_traits<coral::AttributeSpecification* const*> -------------------------------
static void destructor_3046(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<coral::AttributeSpecification* const*>*)o)->::std::iterator_traits<coral::AttributeSpecification* const*>::~iterator_traits();
}
static  void operator_3047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<coral::AttributeSpecification* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
  else   (((::std::iterator_traits<coral::AttributeSpecification* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
}

static void constructor_3048( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
}

static void constructor_3049( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>();
  else ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>();
}

static void method_newdel_1282( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<coral::AttributeSpecification* const*> -------------------------------
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_datamem(Reflex::Class*);
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__AttributeSpecificationpsconstp__datamem_bld(&__std__iterator_traits_coral__AttributeSpecificationpsconstp__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__AttributeSpecificationpsconstp__funcmem_bld(&__std__iterator_traits_coral__AttributeSpecificationpsconstp__db_funcmem);
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>"), typeid(::std::iterator_traits<coral::AttributeSpecification* const*>), sizeof(::std::iterator_traits<coral::AttributeSpecification* const*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1423, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::iterator_category"))
  .AddTypedef(type_3039, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::difference_type"))
  .AddTypedef(type_3042, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::pointer"))
  .AddTypedef(type_3044, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3046, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9179, type_9180), Reflex::Literal("operator="), operator_3047, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9180), Reflex::Literal("iterator_traits"), constructor_3048, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3049, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1282, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<coral::AttributeSpecification* const*> -------------------
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<coral::AttributeSpecification* const*> -------------------
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class iterator_traits<coral::Attribute**> -------------------------------
static void destructor_3058(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<coral::Attribute**>*)o)->::std::iterator_traits<coral::Attribute**>::~iterator_traits();
}
static  void operator_3059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<coral::Attribute**>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
  else   (((::std::iterator_traits<coral::Attribute**>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
}

static void constructor_3060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute**>(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<coral::Attribute**>(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
}

static void constructor_3061( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute**>();
  else ::new(mem) ::std::iterator_traits<coral::Attribute**>();
}

static void method_newdel_1283( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<coral::Attribute**> -------------------------------
void __std__iterator_traits_coral__Attributepp__db_datamem(Reflex::Class*);
void __std__iterator_traits_coral__Attributepp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepp__datamem_bld(&__std__iterator_traits_coral__Attributepp__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepp__funcmem_bld(&__std__iterator_traits_coral__Attributepp__db_funcmem);
void __std__iterator_traits_coral__Attributepp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute**>"), typeid(::std::iterator_traits<coral::Attribute**>), sizeof(::std::iterator_traits<coral::Attribute**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1423, Reflex::Literal("std::iterator_traits<coral::Attribute**>::iterator_category"))
  .AddTypedef(type_3051, Reflex::Literal("std::iterator_traits<coral::Attribute**>::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::iterator_traits<coral::Attribute**>::difference_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::iterator_traits<coral::Attribute**>::pointer"))
  .AddTypedef(type_3056, Reflex::Literal("std::iterator_traits<coral::Attribute**>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3058, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9181, type_9182), Reflex::Literal("operator="), operator_3059, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9182), Reflex::Literal("iterator_traits"), constructor_3060, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3061, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1283, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<coral::Attribute**> -------------------
void __std__iterator_traits_coral__Attributepp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<coral::Attribute**> -------------------
void __std__iterator_traits_coral__Attributepp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class iterator_traits<coral::Attribute* const*> -------------------------------
static void destructor_3069(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<coral::Attribute* const*>*)o)->::std::iterator_traits<coral::Attribute* const*>::~iterator_traits();
}
static  void operator_3070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<coral::Attribute* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
  else   (((::std::iterator_traits<coral::Attribute* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
}

static void constructor_3071( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute* const*>(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<coral::Attribute* const*>(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
}

static void constructor_3072( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute* const*>();
  else ::new(mem) ::std::iterator_traits<coral::Attribute* const*>();
}

static void method_newdel_1284( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<coral::Attribute* const*> -------------------------------
void __std__iterator_traits_coral__Attributepsconstp__db_datamem(Reflex::Class*);
void __std__iterator_traits_coral__Attributepsconstp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepsconstp__datamem_bld(&__std__iterator_traits_coral__Attributepsconstp__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepsconstp__funcmem_bld(&__std__iterator_traits_coral__Attributepsconstp__db_funcmem);
void __std__iterator_traits_coral__Attributepsconstp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute* const*>"), typeid(::std::iterator_traits<coral::Attribute* const*>), sizeof(::std::iterator_traits<coral::Attribute* const*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1423, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::iterator_category"))
  .AddTypedef(type_3051, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::difference_type"))
  .AddTypedef(type_3065, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::pointer"))
  .AddTypedef(type_3067, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3069, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9184, type_9185), Reflex::Literal("operator="), operator_3070, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9185), Reflex::Literal("iterator_traits"), constructor_3071, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3072, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1284, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<coral::Attribute* const*> -------------------
void __std__iterator_traits_coral__Attributepsconstp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<coral::Attribute* const*> -------------------
void __std__iterator_traits_coral__Attributepsconstp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
static void constructor_3915( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>();
  else ::new(mem) ::std::basic_string<char>();
}

static void constructor_3916( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_3917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
}

static void constructor_3918( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static void constructor_3919( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
}

static void constructor_3920( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_3921( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  }
}

static void constructor_3922( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void destructor_3923(void*, void * o, const std::vector<void*>&, void *) {
((::std::basic_string<char>*)o)->::std::basic_string<char>::~basic_string();
}
static  void operator_3924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_3925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
}

static  void operator_3926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
}

static  void method_3927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->begin)());
  else   (((::std::basic_string<char>*)o)->begin)();
}

static  void method_3928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->begin)());
  else   (((const ::std::basic_string<char>*)o)->begin)();
}

static  void method_3929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->end)());
  else   (((::std::basic_string<char>*)o)->end)();
}

static  void method_3930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->end)());
  else   (((const ::std::basic_string<char>*)o)->end)();
}

static  void method_3935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->size)());
  else   (((const ::std::basic_string<char>*)o)->size)();
}

static  void method_3936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->length)());
  else   (((const ::std::basic_string<char>*)o)->length)();
}

static  void method_3937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->max_size)());
  else   (((const ::std::basic_string<char>*)o)->max_size)();
}

static  void method_3938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_3939( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0]);
}

static  void method_3940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->capacity)());
  else   (((const ::std::basic_string<char>*)o)->capacity)();
}

static  void method_3941( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::basic_string<char>*)o)->reserve)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::basic_string<char>*)o)->reserve)(*(::std::size_t*)arg[0]);
  }
}

static  void method_3942( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::basic_string<char>*)o)->clear)();
}

static  void method_3943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::basic_string<char>*)o)->empty)());
  else   (((const ::std::basic_string<char>*)o)->empty)();
}

static  void operator_3944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void operator_3948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_3949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_3950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
}

static  void method_3951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_3952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_3953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_3954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
}

static  void method_3955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_3956( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->push_back)(*(char*)arg[0]);
}

static  void method_3957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_3958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_3959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_3960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
}

static  void method_3961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_3962( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_3963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_3964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_3965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_3966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_3967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_3968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]));
  else   (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]);
}

static  void method_3969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)();
    else     (((::std::basic_string<char>*)o)->erase)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_3970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]);
}

static  void method_3971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]);
}

static  void method_3972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_3973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_3974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_3975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_3976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_3977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_3978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_3979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
}

static  void method_3980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_3981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
}

static  void method_3982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
}

static  void method_3983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
}

static  void method_3984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
}

static  void method_3989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static  void method_3990( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->swap)(*(::std::basic_string<char>*)arg[0]);
}

static  void method_3991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->c_str)());
  else   (((const ::std::basic_string<char>*)o)->c_str)();
}

static  void method_3992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->data)());
  else   (((const ::std::basic_string<char>*)o)->data)();
}

static  void method_3993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<char>)((((const ::std::basic_string<char>*)o)->get_allocator)());
  else   (((const ::std::basic_string<char>*)o)->get_allocator)();
}

static  void method_3994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_3995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_3996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_3997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_3998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_3999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4000( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4015( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)());
    else     (((const ::std::basic_string<char>*)o)->substr)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_4020( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_4021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_4022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]);
}

static  void method_4023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_4024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static void method_newdel_1333( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
void __std__basic_string_char__db_datamem(Reflex::Class*);
void __std__basic_string_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__basic_string_char__datamem_bld(&__std__basic_string_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__basic_string_char__funcmem_bld(&__std__basic_string_char__db_funcmem);
void __std__basic_string_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::basic_string<char>"), typeid(::std::basic_string<char>), sizeof(::std::basic_string<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddDataMember(type_1527c, Reflex::Literal("npos"), (size_t)&std::basic_string<char>::npos, ::Reflex::PUBLIC | Reflex::STATIC | Reflex::CONST)
  .AddTypedef(type_1425, Reflex::Literal("std::basic_string<char>::_CharT_alloc_type"))
  .AddTypedef(type_1488, Reflex::Literal("std::basic_string<char>::traits_type"))
  .AddTypedef(type_2380, Reflex::Literal("std::basic_string<char>::value_type"))
  .AddTypedef(type_1425, Reflex::Literal("std::basic_string<char>::allocator_type"))
  .AddTypedef(type_1527, Reflex::Literal("std::basic_string<char>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::basic_string<char>::difference_type"))
  .AddTypedef(type_3032, Reflex::Literal("std::basic_string<char>::reference"))
  .AddTypedef(type_3883, Reflex::Literal("std::basic_string<char>::const_reference"))
  .AddTypedef(type_744, Reflex::Literal("std::basic_string<char>::pointer"))
  .AddTypedef(type_1731, Reflex::Literal("std::basic_string<char>::const_pointer"))
  .AddTypedef(type_2025, Reflex::Literal("std::basic_string<char>::iterator"))
  .AddTypedef(type_2040, Reflex::Literal("std::basic_string<char>::const_iterator"))
  .AddTypedef(type_1562, Reflex::Literal("std::basic_string<char>::const_reverse_iterator"))
  .AddTypedef(type_1563, Reflex::Literal("std::basic_string<char>::reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("basic_string"), constructor_3915, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9299), Reflex::Literal("basic_string"), constructor_3916, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103), Reflex::Literal("basic_string"), constructor_3917, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_1527, type_1527), Reflex::Literal("basic_string"), constructor_3918, 0, "__str;__pos;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_1527, type_1527, type_9299), Reflex::Literal("basic_string"), constructor_3919, 0, "__str;__pos;__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1731, type_1527, type_9299), Reflex::Literal("basic_string"), constructor_3920, 0, "__s;__n;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1731, type_9299), Reflex::Literal("basic_string"), constructor_3921, 0, "__s;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_2380, type_9299), Reflex::Literal("basic_string"), constructor_3922, 0, "__n;__c;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~basic_string"), destructor_3923, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1333, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__basic_string_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__basic_string_char__funcmem_bld);
}

//------Delayed data member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3893, Reflex::Literal("_M_dataplus"), OffsetOf(__shadow__::__std__basic_string_char_, _M_dataplus), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3103), Reflex::Literal("operator="), operator_3924, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1731), Reflex::Literal("operator="), operator_3925, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2380), Reflex::Literal("operator="), operator_3926, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2025), Reflex::Literal("begin"), method_3927, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2040), Reflex::Literal("begin"), method_3928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2025), Reflex::Literal("end"), method_3929, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2040), Reflex::Literal("end"), method_3930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("length"), method_3936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_2380), Reflex::Literal("resize"), method_3938, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("resize"), method_3939, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3941, 0, "__res=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3942, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3883, type_1527), Reflex::Literal("operator[]"), operator_3944, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3032, type_1527), Reflex::Literal("operator[]"), operator_3945, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3883, type_1527), Reflex::Literal("at"), method_3946, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3032, type_1527), Reflex::Literal("at"), method_3947, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3103), Reflex::Literal("operator+="), operator_3948, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1731), Reflex::Literal("operator+="), operator_3949, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2380), Reflex::Literal("operator+="), operator_3950, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3103), Reflex::Literal("append"), method_3951, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3103, type_1527, type_1527), Reflex::Literal("append"), method_3952, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1731, type_1527), Reflex::Literal("append"), method_3953, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1731), Reflex::Literal("append"), method_3954, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_2380), Reflex::Literal("append"), method_3955, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2380), Reflex::Literal("push_back"), method_3956, 0, "__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3103), Reflex::Literal("assign"), method_3957, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3103, type_1527, type_1527), Reflex::Literal("assign"), method_3958, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1731, type_1527), Reflex::Literal("assign"), method_3959, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1731), Reflex::Literal("assign"), method_3960, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_2380), Reflex::Literal("assign"), method_3961, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2025, type_1527, type_2380), Reflex::Literal("insert"), method_3962, 0, "__p;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_3103), Reflex::Literal("insert"), method_3963, 0, "__pos1;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_3103, type_1527, type_1527), Reflex::Literal("insert"), method_3964, 0, "__pos1;__str;__pos2;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1731, type_1527), Reflex::Literal("insert"), method_3965, 0, "__pos;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1731), Reflex::Literal("insert"), method_3966, 0, "__pos;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1527, type_2380), Reflex::Literal("insert"), method_3967, 0, "__pos;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2025, type_2025, type_2380), Reflex::Literal("insert"), method_3968, 0, "__p;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1527), Reflex::Literal("erase"), method_3969, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2025, type_2025), Reflex::Literal("erase"), method_3970, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2025, type_2025, type_2025), Reflex::Literal("erase"), method_3971, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1527, type_3103), Reflex::Literal("replace"), method_3972, 0, "__pos;__n;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1527, type_3103, type_1527, type_1527), Reflex::Literal("replace"), method_3973, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1527, type_1731, type_1527), Reflex::Literal("replace"), method_3974, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1527, type_1731), Reflex::Literal("replace"), method_3975, 0, "__pos;__n1;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527, type_1527, type_1527, type_2380), Reflex::Literal("replace"), method_3976, 0, "__pos;__n1;__n2;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_3103), Reflex::Literal("replace"), method_3977, 0, "__i1;__i2;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_1731, type_1527), Reflex::Literal("replace"), method_3978, 0, "__i1;__i2;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_1731), Reflex::Literal("replace"), method_3979, 0, "__i1;__i2;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_1527, type_2380), Reflex::Literal("replace"), method_3980, 0, "__i1;__i2;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_744, type_744), Reflex::Literal("replace"), method_3981, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_1731, type_1731), Reflex::Literal("replace"), method_3982, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_2025, type_2025), Reflex::Literal("replace"), method_3983, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_2025, type_2025, type_2040, type_2040), Reflex::Literal("replace"), method_3984, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_744, type_1527, type_1527), Reflex::Literal("copy"), method_3989, 0, "__s;__n;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2946), Reflex::Literal("swap"), method_3990, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1731), Reflex::Literal("c_str"), method_3991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1731), Reflex::Literal("data"), method_3992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1425), Reflex::Literal("get_allocator"), method_3993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527, type_1527), Reflex::Literal("find"), method_3994, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3103, type_1527), Reflex::Literal("find"), method_3995, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527), Reflex::Literal("find"), method_3996, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_2380, type_1527), Reflex::Literal("find"), method_3997, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3103, type_1527), Reflex::Literal("rfind"), method_3998, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527, type_1527), Reflex::Literal("rfind"), method_3999, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527), Reflex::Literal("rfind"), method_4000, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_2380, type_1527), Reflex::Literal("rfind"), method_4001, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3103, type_1527), Reflex::Literal("find_first_of"), method_4002, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527, type_1527), Reflex::Literal("find_first_of"), method_4003, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527), Reflex::Literal("find_first_of"), method_4004, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_2380, type_1527), Reflex::Literal("find_first_of"), method_4005, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3103, type_1527), Reflex::Literal("find_last_of"), method_4006, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527, type_1527), Reflex::Literal("find_last_of"), method_4007, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527), Reflex::Literal("find_last_of"), method_4008, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_2380, type_1527), Reflex::Literal("find_last_of"), method_4009, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3103, type_1527), Reflex::Literal("find_first_not_of"), method_4010, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527, type_1527), Reflex::Literal("find_first_not_of"), method_4011, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527), Reflex::Literal("find_first_not_of"), method_4012, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_2380, type_1527), Reflex::Literal("find_first_not_of"), method_4013, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3103, type_1527), Reflex::Literal("find_last_not_of"), method_4014, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527, type_1527), Reflex::Literal("find_last_not_of"), method_4015, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_1731, type_1527), Reflex::Literal("find_last_not_of"), method_4016, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_2380, type_1527), Reflex::Literal("find_last_not_of"), method_4017, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1333, type_1527, type_1527), Reflex::Literal("substr"), method_4018, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_3103), Reflex::Literal("compare"), method_4019, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_1527, type_1527, type_3103), Reflex::Literal("compare"), method_4020, 0, "__pos;__n;__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_1527, type_1527, type_3103, type_1527, type_1527), Reflex::Literal("compare"), method_4021, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_1731), Reflex::Literal("compare"), method_4022, 0, "__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_1527, type_1527, type_1731), Reflex::Literal("compare"), method_4023, 0, "__pos;__n1;__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_1527, type_1527, type_1731, type_1527), Reflex::Literal("compare"), method_4024, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void constructor_3112( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >();
  else ::new(mem) ::std::vector<std::basic_string<char> >();
}

static void constructor_3113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
}

static void constructor_3114( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  }
}

static void constructor_3115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static void destructor_3116(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<std::basic_string<char> >*)o)->::std::vector<std::basic_string<char> >::~vector();
}
static  void operator_3117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_3118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_3119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_3120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_3121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_3122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_3127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->size)();
}

static  void method_3128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->max_size)();
}

static  void method_3129( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::basic_string<char>*)arg[1]);
  }
}

static  void method_3130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->capacity)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->capacity)();
}

static  void method_3131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->empty)();
}

static  void method_3132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_3139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_3140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_3141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_3142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_3143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_3144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->push_back)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_3145( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->pop_back)();
}

static  void method_3146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_3147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_3148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_3149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]);
}

static  void method_3150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->swap)(*(::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_3151( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->clear)();
}

static void method_newdel_1287( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >")), ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >,::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
}

//------Dictionary for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__datamem_bld(&__std__vector_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__funcmem_bld(&__std__vector_std__basic_string_char_s__db_funcmem);
void __std__vector_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"), typeid(::std::vector<std::basic_string<char> >), sizeof(::std::vector<std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddBase(type_1566, ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >, ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1333, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1566, Reflex::Literal("std::vector<std::basic_string<char> >::_Base"))
  .AddTypedef(type_1426, Reflex::Literal("std::vector<std::basic_string<char> >::_Tp_alloc_type"))
  .AddTypedef(type_1929, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_traits"))
  .AddTypedef(type_1333, Reflex::Literal("std::vector<std::basic_string<char> >::value_type"))
  .AddTypedef(type_3098, Reflex::Literal("std::vector<std::basic_string<char> >::pointer"))
  .AddTypedef(type_3100, Reflex::Literal("std::vector<std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<std::basic_string<char> >::reference"))
  .AddTypedef(type_3103, Reflex::Literal("std::vector<std::basic_string<char> >::const_reference"))
  .AddTypedef(type_2017, Reflex::Literal("std::vector<std::basic_string<char> >::iterator"))
  .AddTypedef(type_2018, Reflex::Literal("std::vector<std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1536, Reflex::Literal("std::vector<std::basic_string<char> >::const_reverse_iterator"))
  .AddTypedef(type_1537, Reflex::Literal("std::vector<std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<std::basic_string<char> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1426, Reflex::Literal("std::vector<std::basic_string<char> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3112, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9191), Reflex::Literal("vector"), constructor_3113, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3103, type_9191), Reflex::Literal("vector"), constructor_3114, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9192), Reflex::Literal("vector"), constructor_3115, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3116, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1287, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9193, type_9192), Reflex::Literal("operator="), operator_3117, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3103), Reflex::Literal("assign"), method_3118, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017), Reflex::Literal("begin"), method_3119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2018), Reflex::Literal("begin"), method_3120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017), Reflex::Literal("end"), method_3121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2018), Reflex::Literal("end"), method_3122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_1333), Reflex::Literal("resize"), method_3129, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3132, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527), Reflex::Literal("operator[]"), operator_3133, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103, type_1527), Reflex::Literal("operator[]"), operator_3134, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_1527), Reflex::Literal("at"), method_3136, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103, type_1527), Reflex::Literal("at"), method_3137, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946), Reflex::Literal("front"), method_3138, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103), Reflex::Literal("front"), method_3139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946), Reflex::Literal("back"), method_3140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103), Reflex::Literal("back"), method_3141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3098), Reflex::Literal("data"), method_3142, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3100), Reflex::Literal("data"), method_3143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3103), Reflex::Literal("push_back"), method_3144, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3145, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017, type_2017, type_3103), Reflex::Literal("insert"), method_3146, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2017, type_1527, type_3103), Reflex::Literal("insert"), method_3147, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017, type_2017), Reflex::Literal("erase"), method_3148, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017, type_2017, type_2017), Reflex::Literal("erase"), method_3149, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9193), Reflex::Literal("swap"), method_3150, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3151, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
static void constructor_3179( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>();
  else ::new(mem) ::std::vector<unsigned int>();
}

static void constructor_3180( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
}

static void constructor_3181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  }
}

static void constructor_3182( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
}

static void destructor_3183(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<unsigned int>*)o)->::std::vector<unsigned int>::~vector();
}
static  void operator_3184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
}

static  void method_3185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->begin)());
  else   (((::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->begin)());
  else   (((const ::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->end)());
  else   (((::std::vector<unsigned int>*)o)->end)();
}

static  void method_3189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->end)());
  else   (((const ::std::vector<unsigned int>*)o)->end)();
}

static  void method_3194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->size)());
  else   (((const ::std::vector<unsigned int>*)o)->size)();
}

static  void method_3195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->max_size)());
  else   (((const ::std::vector<unsigned int>*)o)->max_size)();
}

static  void method_3196( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_3197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->capacity)());
  else   (((const ::std::vector<unsigned int>*)o)->capacity)();
}

static  void method_3198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned int>*)o)->empty)());
  else   (((const ::std::vector<unsigned int>*)o)->empty)();
}

static  void method_3199( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->front)();
  else   (((::std::vector<unsigned int>*)o)->front)();
}

static  void method_3206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->front)();
  else   (((const ::std::vector<unsigned int>*)o)->front)();
}

static  void method_3207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->back)();
  else   (((::std::vector<unsigned int>*)o)->back)();
}

static  void method_3208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->back)();
  else   (((const ::std::vector<unsigned int>*)o)->back)();
}

static  void method_3209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned int>*)o)->data)());
  else   (((::std::vector<unsigned int>*)o)->data)();
}

static  void method_3210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned int>*)o)->data)());
  else   (((const ::std::vector<unsigned int>*)o)->data)();
}

static  void method_3211( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->push_back)(*(const unsigned int*)arg[0]);
}

static  void method_3212( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->pop_back)();
}

static  void method_3213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3214( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned int*)arg[2]);
}

static  void method_3215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]);
}

static  void method_3216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void method_3217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->swap)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_3218( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->clear)();
}

static void method_newdel_1288( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >")), ::Reflex::BaseOffset< ::std::vector<unsigned int>,::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
}

//------Dictionary for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*);
void __std__vector_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__datamem_bld(&__std__vector_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__funcmem_bld(&__std__vector_unsignedsint__db_funcmem);
void __std__vector_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned int>"), typeid(::std::vector<unsigned int>), sizeof(::std::vector<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddBase(type_1567, ::Reflex::BaseOffset< ::std::vector<unsigned int>, ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_75, Reflex::Literal("std::vector<unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1567, Reflex::Literal("std::vector<unsigned int>::_Base"))
  .AddTypedef(type_1429, Reflex::Literal("std::vector<unsigned int>::_Tp_alloc_type"))
  .AddTypedef(type_1932, Reflex::Literal("std::vector<unsigned int>::_Alloc_traits"))
  .AddTypedef(type_75, Reflex::Literal("std::vector<unsigned int>::value_type"))
  .AddTypedef(type_2378, Reflex::Literal("std::vector<unsigned int>::pointer"))
  .AddTypedef(type_3166, Reflex::Literal("std::vector<unsigned int>::const_pointer"))
  .AddTypedef(type_3168, Reflex::Literal("std::vector<unsigned int>::reference"))
  .AddTypedef(type_3170, Reflex::Literal("std::vector<unsigned int>::const_reference"))
  .AddTypedef(type_2019, Reflex::Literal("std::vector<unsigned int>::iterator"))
  .AddTypedef(type_2020, Reflex::Literal("std::vector<unsigned int>::const_iterator"))
  .AddTypedef(type_1540, Reflex::Literal("std::vector<unsigned int>::const_reverse_iterator"))
  .AddTypedef(type_1541, Reflex::Literal("std::vector<unsigned int>::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<unsigned int>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<unsigned int>::difference_type"))
  .AddTypedef(type_1429, Reflex::Literal("std::vector<unsigned int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3179, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9195), Reflex::Literal("vector"), constructor_3180, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3170, type_9195), Reflex::Literal("vector"), constructor_3181, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9196), Reflex::Literal("vector"), constructor_3182, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3183, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1288, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9197, type_9196), Reflex::Literal("operator="), operator_3184, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3170), Reflex::Literal("assign"), method_3185, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2019), Reflex::Literal("begin"), method_3186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2020), Reflex::Literal("begin"), method_3187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2019), Reflex::Literal("end"), method_3188, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2020), Reflex::Literal("end"), method_3189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_75), Reflex::Literal("resize"), method_3196, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3199, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3168, type_1527), Reflex::Literal("operator[]"), operator_3200, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3170, type_1527), Reflex::Literal("operator[]"), operator_3201, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3168, type_1527), Reflex::Literal("at"), method_3203, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3170, type_1527), Reflex::Literal("at"), method_3204, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3168), Reflex::Literal("front"), method_3205, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3170), Reflex::Literal("front"), method_3206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3168), Reflex::Literal("back"), method_3207, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3170), Reflex::Literal("back"), method_3208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2378), Reflex::Literal("data"), method_3209, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3166), Reflex::Literal("data"), method_3210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3170), Reflex::Literal("push_back"), method_3211, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3212, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2019, type_2019, type_3170), Reflex::Literal("insert"), method_3213, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2019, type_1527, type_3170), Reflex::Literal("insert"), method_3214, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2019, type_2019), Reflex::Literal("erase"), method_3215, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2019, type_2019, type_2019), Reflex::Literal("erase"), method_3216, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9197), Reflex::Literal("swap"), method_3217, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3218, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class shared_ptr<cool::IRecord> -------------------------------
static void destructor_8500(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IRecord>*)o)->::boost::shared_ptr<cool::IRecord>::~shared_ptr();
}
static void constructor_8501( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IRecord>(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IRecord>(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static void constructor_8502( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IRecord>();
  else ::new(mem) ::boost::shared_ptr<cool::IRecord>();
}

static  void operator_8503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IRecord>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IRecord>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_8504( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IRecord>*)o)->reset)();
}

static  void operator_8505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IRecord>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator*)();
}

static  void operator_8506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator->)();
}

static  void method_8508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->get)();
}

static  void converter_8509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IRecord* boost::shared_ptr<cool::IRecord>::*)((((const ::boost::shared_ptr<cool::IRecord>*)o)->operator cool::IRecord* boost::shared_ptr<cool::IRecord>::*)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator cool::IRecord* boost::shared_ptr<cool::IRecord>::*)();
}

static  void operator_8510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IRecord>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator!)();
}

static  void method_8511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IRecord>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->unique)();
}

static  void method_8512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IRecord>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->use_count)();
}

static  void method_8513( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IRecord>*)o)->swap)(*(::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_8514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static void method_newdel_2288( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IRecord> -------------------------------
void __boost__shared_ptr_cool__IRecord__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IRecord__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IRecord__datamem_bld(&__boost__shared_ptr_cool__IRecord__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IRecord__funcmem_bld(&__boost__shared_ptr_cool__IRecord__db_funcmem);
void __boost__shared_ptr_cool__IRecord__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IRecord>"), typeid(::boost::shared_ptr<cool::IRecord>), sizeof(::boost::shared_ptr<cool::IRecord>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2191, Reflex::Literal("boost::shared_ptr<cool::IRecord>::element_type"))
  .AddTypedef(type_10228, Reflex::Literal("boost::shared_ptr<cool::IRecord>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8500, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3236), Reflex::Literal("shared_ptr"), constructor_8501, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8502, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2288, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IRecord__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IRecord__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IRecord> -------------------
void __boost__shared_ptr_cool__IRecord__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10227, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IRecord_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IRecord_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IRecord> -------------------
void __boost__shared_ptr_cool__IRecord__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011, type_3236), Reflex::Literal("operator="), operator_8503, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_8504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10086), Reflex::Literal("operator*"), operator_8505, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10227), Reflex::Literal("operator->"), operator_8506, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10227), Reflex::Literal("get"), method_8508, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10228), Reflex::Literal("operator cool::IRecord* boost::shared_ptr<cool::IRecord>::*"), converter_8509, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_8510, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_8511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_8512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3011), Reflex::Literal("swap"), method_8513, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_8514, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_8515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_3236), Reflex::Literal("_internal_equiv"), method_8516, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
static void constructor_3245( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >();
}

static void constructor_3246( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_3247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[2]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[2]);
  }
}

static void constructor_3248( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void destructor_3249(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->::std::vector<boost::shared_ptr<cool::IRecord> >::~vector();
}
static  void operator_3250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_3251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_3252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)());
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)();
}

static  void method_3253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)();
}

static  void method_3254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)());
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)();
}

static  void method_3255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)();
}

static  void method_3260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->size)();
}

static  void method_3261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->max_size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->max_size)();
}

static  void method_3262( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::boost::shared_ptr<cool::IRecord>*)arg[1]);
  }
}

static  void method_3263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->capacity)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->capacity)();
}

static  void method_3264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->empty)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->empty)();
}

static  void method_3265( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
}

static  void method_3272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
}

static  void method_3273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
}

static  void method_3274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
}

static  void method_3275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)());
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)();
}

static  void method_3276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)();
}

static  void method_3277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->push_back)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_3278( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->pop_back)();
}

static  void method_3279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_3280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[2]);
}

static  void method_3281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]));
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_3282( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[1]);
}

static  void method_3283( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->swap)(*(::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_3284( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->clear)();
}

static void method_newdel_1289( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >")), ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IRecord> >,::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IRecord> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IRecord> > >::Generate();
}

//------Dictionary for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IRecord_s__datamem_bld(&__std__vector_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&__std__vector_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void __std__vector_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >"), typeid(::std::vector<boost::shared_ptr<cool::IRecord> >), sizeof(::std::vector<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_1568, ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IRecord> >, ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2288, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Alloc_value_type"))
  .AddTypedef(type_1568, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Base"))
  .AddTypedef(type_1430, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Tp_alloc_type"))
  .AddTypedef(type_1933, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Alloc_traits"))
  .AddTypedef(type_2288, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::value_type"))
  .AddTypedef(type_3009, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::pointer"))
  .AddTypedef(type_3233, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_pointer"))
  .AddTypedef(type_3011, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::reference"))
  .AddTypedef(type_3236, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_reference"))
  .AddTypedef(type_2021, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::iterator"))
  .AddTypedef(type_2022, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_iterator"))
  .AddTypedef(type_1542, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_reverse_iterator"))
  .AddTypedef(type_1543, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::difference_type"))
  .AddTypedef(type_1430, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3245, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9199), Reflex::Literal("vector"), constructor_3246, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3236, type_9199), Reflex::Literal("vector"), constructor_3247, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9200), Reflex::Literal("vector"), constructor_3248, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3249, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1289, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_boost__shared_ptr_cool__IRecord_s__funcmem_bld);
}

//------Delayed data member builder for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9201, type_9200), Reflex::Literal("operator="), operator_3250, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3236), Reflex::Literal("assign"), method_3251, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("begin"), method_3252, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2022), Reflex::Literal("begin"), method_3253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("end"), method_3254, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2022), Reflex::Literal("end"), method_3255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_2288), Reflex::Literal("resize"), method_3262, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3265, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011, type_1527), Reflex::Literal("operator[]"), operator_3266, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236, type_1527), Reflex::Literal("operator[]"), operator_3267, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011, type_1527), Reflex::Literal("at"), method_3269, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236, type_1527), Reflex::Literal("at"), method_3270, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011), Reflex::Literal("front"), method_3271, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("front"), method_3272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011), Reflex::Literal("back"), method_3273, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("back"), method_3274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3009), Reflex::Literal("data"), method_3275, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233), Reflex::Literal("data"), method_3276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3236), Reflex::Literal("push_back"), method_3277, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3278, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021, type_2021, type_3236), Reflex::Literal("insert"), method_3279, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2021, type_1527, type_3236), Reflex::Literal("insert"), method_3280, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021, type_2021), Reflex::Literal("erase"), method_3281, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021, type_2021, type_2021), Reflex::Literal("erase"), method_3282, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9201), Reflex::Literal("swap"), method_3283, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3284, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class shared_ptr<cool::IObject> -------------------------------
static void destructor_7901(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IObject>*)o)->::boost::shared_ptr<cool::IObject>::~shared_ptr();
}
static void constructor_7902( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObject>(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IObject>(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static void constructor_7903( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObject>();
  else ::new(mem) ::boost::shared_ptr<cool::IObject>();
}

static  void operator_7904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IObject>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IObject>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_7905( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IObject>*)o)->reset)();
}

static  void operator_7906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IObject>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator*)();
}

static  void operator_7907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator->)();
}

static  void method_7909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->get)();
}

static  void converter_7910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IObject* boost::shared_ptr<cool::IObject>::*)((((const ::boost::shared_ptr<cool::IObject>*)o)->operator cool::IObject* boost::shared_ptr<cool::IObject>::*)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator cool::IObject* boost::shared_ptr<cool::IObject>::*)();
}

static  void operator_7911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObject>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator!)();
}

static  void method_7912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObject>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->unique)();
}

static  void method_7913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IObject>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->use_count)();
}

static  void method_7914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IObject>*)o)->swap)(*(::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_7915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_7916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_untyped_deleter)();
}

static  void method_7917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static void method_newdel_2180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IObject> -------------------------------
void __boost__shared_ptr_cool__IObject__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObject__datamem_bld(&__boost__shared_ptr_cool__IObject__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObject__funcmem_bld(&__boost__shared_ptr_cool__IObject__db_funcmem);
void __boost__shared_ptr_cool__IObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IObject>"), typeid(::boost::shared_ptr<cool::IObject>), sizeof(::boost::shared_ptr<cool::IObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2210, Reflex::Literal("boost::shared_ptr<cool::IObject>::element_type"))
  .AddTypedef(type_10076, Reflex::Literal("boost::shared_ptr<cool::IObject>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_7901, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3302), Reflex::Literal("shared_ptr"), constructor_7902, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_7903, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IObject__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IObject> -------------------
void __boost__shared_ptr_cool__IObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10075, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObject_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObject_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IObject> -------------------
void __boost__shared_ptr_cool__IObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022, type_3302), Reflex::Literal("operator="), operator_7904, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_7905, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10077), Reflex::Literal("operator*"), operator_7906, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10075), Reflex::Literal("operator->"), operator_7907, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10075), Reflex::Literal("get"), method_7909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10076), Reflex::Literal("operator cool::IObject* boost::shared_ptr<cool::IObject>::*"), converter_7910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_7911, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_7912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_7913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3022), Reflex::Literal("swap"), method_7914, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_7915, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_7916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_3302), Reflex::Literal("_internal_equiv"), method_7917, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
static void constructor_3311( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >();
}

static void constructor_3312( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_3313( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[2]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[2]);
  }
}

static void constructor_3314( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void destructor_3315(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->::std::vector<boost::shared_ptr<cool::IObject> >::~vector();
}
static  void operator_3316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_3317( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_3318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)());
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)();
}

static  void method_3319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)();
}

static  void method_3320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)());
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)();
}

static  void method_3321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)();
}

static  void method_3326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->size)();
}

static  void method_3327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->max_size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->max_size)();
}

static  void method_3328( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::boost::shared_ptr<cool::IObject>*)arg[1]);
  }
}

static  void method_3329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->capacity)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->capacity)();
}

static  void method_3330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->empty)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->empty)();
}

static  void method_3331( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
}

static  void method_3338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
}

static  void method_3339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
}

static  void method_3340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
}

static  void method_3341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)());
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)();
}

static  void method_3342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)();
}

static  void method_3343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->push_back)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_3344( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->pop_back)();
}

static  void method_3345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_3346( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[2]);
}

static  void method_3347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]));
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_3348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[1]);
}

static  void method_3349( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->swap)(*(::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_3350( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->clear)();
}

static void method_newdel_1290( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >")), ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IObject> >,::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IObject> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IObject> > >::Generate();
}

//------Dictionary for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
void __std__vector_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void __std__vector_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IObject_s__datamem_bld(&__std__vector_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IObject_s__funcmem_bld(&__std__vector_boost__shared_ptr_cool__IObject_s__db_funcmem);
void __std__vector_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >"), typeid(::std::vector<boost::shared_ptr<cool::IObject> >), sizeof(::std::vector<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_1569, ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IObject> >, ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2180, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Alloc_value_type"))
  .AddTypedef(type_1569, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Base"))
  .AddTypedef(type_1431, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Tp_alloc_type"))
  .AddTypedef(type_1934, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Alloc_traits"))
  .AddTypedef(type_2180, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::value_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::pointer"))
  .AddTypedef(type_3299, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_pointer"))
  .AddTypedef(type_3022, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::reference"))
  .AddTypedef(type_3302, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_reference"))
  .AddTypedef(type_2023, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::iterator"))
  .AddTypedef(type_2024, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_iterator"))
  .AddTypedef(type_1544, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_reverse_iterator"))
  .AddTypedef(type_1545, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::difference_type"))
  .AddTypedef(type_1431, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3311, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9203), Reflex::Literal("vector"), constructor_3312, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3302, type_9203), Reflex::Literal("vector"), constructor_3313, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9204), Reflex::Literal("vector"), constructor_3314, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3315, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1290, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_boost__shared_ptr_cool__IObject_s__funcmem_bld);
}

//------Delayed data member builder for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std__vector_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std__vector_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9205, type_9204), Reflex::Literal("operator="), operator_3316, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3302), Reflex::Literal("assign"), method_3317, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("begin"), method_3318, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("begin"), method_3319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("end"), method_3320, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("end"), method_3321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_2180), Reflex::Literal("resize"), method_3328, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3331, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022, type_1527), Reflex::Literal("operator[]"), operator_3332, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3302, type_1527), Reflex::Literal("operator[]"), operator_3333, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022, type_1527), Reflex::Literal("at"), method_3335, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3302, type_1527), Reflex::Literal("at"), method_3336, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022), Reflex::Literal("front"), method_3337, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3302), Reflex::Literal("front"), method_3338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022), Reflex::Literal("back"), method_3339, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3302), Reflex::Literal("back"), method_3340, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020), Reflex::Literal("data"), method_3341, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299), Reflex::Literal("data"), method_3342, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3302), Reflex::Literal("push_back"), method_3343, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3344, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023, type_2023, type_3302), Reflex::Literal("insert"), method_3345, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2023, type_1527, type_3302), Reflex::Literal("insert"), method_3346, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023, type_2023), Reflex::Literal("erase"), method_3347, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023, type_2023, type_2023), Reflex::Literal("erase"), method_3348, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9205), Reflex::Literal("swap"), method_3349, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3350, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------------------
static void constructor_3380( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>();
  else ::new(mem) ::std::vector<cool::IField*>();
}

static void constructor_3381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void constructor_3382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1]);
  else ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1],
      *(const ::std::allocator<cool::IField*>*)arg[2]);
  else ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1],
      *(const ::std::allocator<cool::IField*>*)arg[2]);
  }
}

static void constructor_3383( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(const ::std::vector<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IField*>(*(const ::std::vector<cool::IField*>*)arg[0]);
}

static void destructor_3384(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::IField*>*)o)->::std::vector<cool::IField*>::~vector();
}
static  void operator_3385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->operator=)(*(const ::std::vector<cool::IField*>*)arg[0]);
  else   (((::std::vector<cool::IField*>*)o)->operator=)(*(const ::std::vector<cool::IField*>*)arg[0]);
}

static  void method_3386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::cool::IField* const*)arg[1]);
}

static  void method_3387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->begin)());
  else   (((::std::vector<cool::IField*>*)o)->begin)();
}

static  void method_3388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> >)((((const ::std::vector<cool::IField*>*)o)->begin)());
  else   (((const ::std::vector<cool::IField*>*)o)->begin)();
}

static  void method_3389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->end)());
  else   (((::std::vector<cool::IField*>*)o)->end)();
}

static  void method_3390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> >)((((const ::std::vector<cool::IField*>*)o)->end)());
  else   (((const ::std::vector<cool::IField*>*)o)->end)();
}

static  void method_3395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IField*>*)o)->size)());
  else   (((const ::std::vector<cool::IField*>*)o)->size)();
}

static  void method_3396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IField*>*)o)->max_size)());
  else   (((const ::std::vector<cool::IField*>*)o)->max_size)();
}

static  void method_3397( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::IField*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::IField*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::cool::IField*)arg[1]);
  }
}

static  void method_3398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IField*>*)o)->capacity)());
  else   (((const ::std::vector<cool::IField*>*)o)->capacity)();
}

static  void method_3399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::IField*>*)o)->empty)());
  else   (((const ::std::vector<cool::IField*>*)o)->empty)();
}

static  void method_3400( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->front)();
  else   (((::std::vector<cool::IField*>*)o)->front)();
}

static  void method_3407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->front)();
  else   (((const ::std::vector<cool::IField*>*)o)->front)();
}

static  void method_3408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->back)();
  else   (((::std::vector<cool::IField*>*)o)->back)();
}

static  void method_3409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->back)();
  else   (((const ::std::vector<cool::IField*>*)o)->back)();
}

static  void method_3410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::IField*>*)o)->data)());
  else   (((::std::vector<cool::IField*>*)o)->data)();
}

static  void method_3411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::IField*>*)o)->data)());
  else   (((const ::std::vector<cool::IField*>*)o)->data)();
}

static  void method_3412( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->push_back)(*(::cool::IField* const*)arg[0]);
}

static  void method_3413( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IField*>*)o)->pop_back)();
}

static  void method_3414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::cool::IField* const*)arg[1]));
  else   (((::std::vector<cool::IField*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::cool::IField* const*)arg[1]);
}

static  void method_3415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::cool::IField* const*)arg[2]);
}

static  void method_3416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0]));
  else   (((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0]);
}

static  void method_3417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[1]));
  else   (((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[1]);
}

static  void method_3418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->swap)(*(::std::vector<cool::IField*>*)arg[0]);
}

static  void method_3419( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IField*>*)o)->clear)();
}

static void method_newdel_1291( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >")), ::Reflex::BaseOffset< ::std::vector<cool::IField*>,::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::IField*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::IField*> >::Generate();
}

//------Dictionary for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------------------
void __std__vector_cool__IFieldp__db_datamem(Reflex::Class*);
void __std__vector_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldp__datamem_bld(&__std__vector_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldp__funcmem_bld(&__std__vector_cool__IFieldp__db_funcmem);
void __std__vector_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::IField*>"), typeid(::std::vector<cool::IField*>), sizeof(::std::vector<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1571, ::Reflex::BaseOffset< ::std::vector<cool::IField*>, ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3359, Reflex::Literal("std::vector<cool::IField*>::_Alloc_value_type"))
  .AddTypedef(type_1571, Reflex::Literal("std::vector<cool::IField*>::_Base"))
  .AddTypedef(type_1432, Reflex::Literal("std::vector<cool::IField*>::_Tp_alloc_type"))
  .AddTypedef(type_1936, Reflex::Literal("std::vector<cool::IField*>::_Alloc_traits"))
  .AddTypedef(type_3359, Reflex::Literal("std::vector<cool::IField*>::value_type"))
  .AddTypedef(type_3365, Reflex::Literal("std::vector<cool::IField*>::pointer"))
  .AddTypedef(type_3367, Reflex::Literal("std::vector<cool::IField*>::const_pointer"))
  .AddTypedef(type_3369, Reflex::Literal("std::vector<cool::IField*>::reference"))
  .AddTypedef(type_3371, Reflex::Literal("std::vector<cool::IField*>::const_reference"))
  .AddTypedef(type_2028, Reflex::Literal("std::vector<cool::IField*>::iterator"))
  .AddTypedef(type_2029, Reflex::Literal("std::vector<cool::IField*>::const_iterator"))
  .AddTypedef(type_1548, Reflex::Literal("std::vector<cool::IField*>::const_reverse_iterator"))
  .AddTypedef(type_1549, Reflex::Literal("std::vector<cool::IField*>::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<cool::IField*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<cool::IField*>::difference_type"))
  .AddTypedef(type_1432, Reflex::Literal("std::vector<cool::IField*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3380, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9207), Reflex::Literal("vector"), constructor_3381, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3371, type_9207), Reflex::Literal("vector"), constructor_3382, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9208), Reflex::Literal("vector"), constructor_3383, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3384, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1291, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__IFieldp__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std__vector_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std__vector_cool__IFieldp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9209, type_9208), Reflex::Literal("operator="), operator_3385, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3371), Reflex::Literal("assign"), method_3386, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2028), Reflex::Literal("begin"), method_3387, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("begin"), method_3388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2028), Reflex::Literal("end"), method_3389, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("end"), method_3390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3359), Reflex::Literal("resize"), method_3397, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3400, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3369, type_1527), Reflex::Literal("operator[]"), operator_3401, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3371, type_1527), Reflex::Literal("operator[]"), operator_3402, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3369, type_1527), Reflex::Literal("at"), method_3404, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3371, type_1527), Reflex::Literal("at"), method_3405, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3369), Reflex::Literal("front"), method_3406, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3371), Reflex::Literal("front"), method_3407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3369), Reflex::Literal("back"), method_3408, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3371), Reflex::Literal("back"), method_3409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3365), Reflex::Literal("data"), method_3410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3367), Reflex::Literal("data"), method_3411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3371), Reflex::Literal("push_back"), method_3412, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3413, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2028, type_2028, type_3371), Reflex::Literal("insert"), method_3414, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2028, type_1527, type_3371), Reflex::Literal("insert"), method_3415, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2028, type_2028), Reflex::Literal("erase"), method_3416, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2028, type_2028, type_2028), Reflex::Literal("erase"), method_3417, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9209), Reflex::Literal("swap"), method_3418, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3419, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
static void constructor_3449( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>();
  else ::new(mem) ::std::vector<cool::IRecordSelection*>();
}

static void constructor_3450( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_3451( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[2]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[2]);
  }
}

static void constructor_3452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
}

static void destructor_3453(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::IRecordSelection*>*)o)->::std::vector<cool::IRecordSelection*>::~vector();
}
static  void operator_3454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
  else   (((::std::vector<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
}

static  void method_3455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]);
}

static  void method_3456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->begin)());
  else   (((::std::vector<cool::IRecordSelection*>*)o)->begin)();
}

static  void method_3457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> >)((((const ::std::vector<cool::IRecordSelection*>*)o)->begin)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->begin)();
}

static  void method_3458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->end)());
  else   (((::std::vector<cool::IRecordSelection*>*)o)->end)();
}

static  void method_3459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> >)((((const ::std::vector<cool::IRecordSelection*>*)o)->end)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->end)();
}

static  void method_3464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IRecordSelection*>*)o)->size)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->size)();
}

static  void method_3465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IRecordSelection*>*)o)->max_size)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->max_size)();
}

static  void method_3466( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::IRecordSelection*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::IRecordSelection*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::cool::IRecordSelection*)arg[1]);
  }
}

static  void method_3467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IRecordSelection*>*)o)->capacity)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->capacity)();
}

static  void method_3468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::IRecordSelection*>*)o)->empty)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->empty)();
}

static  void method_3469( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->front)();
  else   (((::std::vector<cool::IRecordSelection*>*)o)->front)();
}

static  void method_3476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->front)();
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->front)();
}

static  void method_3477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->back)();
  else   (((::std::vector<cool::IRecordSelection*>*)o)->back)();
}

static  void method_3478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->back)();
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->back)();
}

static  void method_3479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::IRecordSelection*>*)o)->data)());
  else   (((::std::vector<cool::IRecordSelection*>*)o)->data)();
}

static  void method_3480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::IRecordSelection*>*)o)->data)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->data)();
}

static  void method_3481( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->push_back)(*(::cool::IRecordSelection* const*)arg[0]);
}

static  void method_3482( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->pop_back)();
}

static  void method_3483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]));
  else   (((::std::vector<cool::IRecordSelection*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]);
}

static  void method_3484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::cool::IRecordSelection* const*)arg[2]);
}

static  void method_3485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0]));
  else   (((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0]);
}

static  void method_3486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[1]));
  else   (((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[1]);
}

static  void method_3487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->swap)(*(::std::vector<cool::IRecordSelection*>*)arg[0]);
}

static  void method_3488( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->clear)();
}

static void method_newdel_1292( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >")), ::Reflex::BaseOffset< ::std::vector<cool::IRecordSelection*>,::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::IRecordSelection*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::IRecordSelection*> >::Generate();
}

//------Dictionary for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
void __std__vector_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void __std__vector_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__IRecordSelectionp__datamem_bld(&__std__vector_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__IRecordSelectionp__funcmem_bld(&__std__vector_cool__IRecordSelectionp__db_funcmem);
void __std__vector_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::IRecordSelection*>"), typeid(::std::vector<cool::IRecordSelection*>), sizeof(::std::vector<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1570, ::Reflex::BaseOffset< ::std::vector<cool::IRecordSelection*>, ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3428, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Alloc_value_type"))
  .AddTypedef(type_1570, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Base"))
  .AddTypedef(type_1433, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Tp_alloc_type"))
  .AddTypedef(type_1935, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Alloc_traits"))
  .AddTypedef(type_3428, Reflex::Literal("std::vector<cool::IRecordSelection*>::value_type"))
  .AddTypedef(type_3434, Reflex::Literal("std::vector<cool::IRecordSelection*>::pointer"))
  .AddTypedef(type_3436, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_pointer"))
  .AddTypedef(type_3438, Reflex::Literal("std::vector<cool::IRecordSelection*>::reference"))
  .AddTypedef(type_3440, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_reference"))
  .AddTypedef(type_2026, Reflex::Literal("std::vector<cool::IRecordSelection*>::iterator"))
  .AddTypedef(type_2027, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_iterator"))
  .AddTypedef(type_1546, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_reverse_iterator"))
  .AddTypedef(type_1547, Reflex::Literal("std::vector<cool::IRecordSelection*>::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<cool::IRecordSelection*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<cool::IRecordSelection*>::difference_type"))
  .AddTypedef(type_1433, Reflex::Literal("std::vector<cool::IRecordSelection*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3449, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9211), Reflex::Literal("vector"), constructor_3450, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3440, type_9211), Reflex::Literal("vector"), constructor_3451, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9212), Reflex::Literal("vector"), constructor_3452, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3453, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1292, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__IRecordSelectionp__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std__vector_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std__vector_cool__IRecordSelectionp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9213, type_9212), Reflex::Literal("operator="), operator_3454, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3440), Reflex::Literal("assign"), method_3455, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026), Reflex::Literal("begin"), method_3456, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2027), Reflex::Literal("begin"), method_3457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026), Reflex::Literal("end"), method_3458, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2027), Reflex::Literal("end"), method_3459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3428), Reflex::Literal("resize"), method_3466, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3469, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438, type_1527), Reflex::Literal("operator[]"), operator_3470, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3440, type_1527), Reflex::Literal("operator[]"), operator_3471, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438, type_1527), Reflex::Literal("at"), method_3473, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3440, type_1527), Reflex::Literal("at"), method_3474, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("front"), method_3475, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3440), Reflex::Literal("front"), method_3476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3438), Reflex::Literal("back"), method_3477, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3440), Reflex::Literal("back"), method_3478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434), Reflex::Literal("data"), method_3479, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3436), Reflex::Literal("data"), method_3480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3440), Reflex::Literal("push_back"), method_3481, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3482, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026, type_2026, type_3440), Reflex::Literal("insert"), method_3483, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2026, type_1527, type_3440), Reflex::Literal("insert"), method_3484, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026, type_2026), Reflex::Literal("erase"), method_3485, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026, type_2026, type_2026), Reflex::Literal("erase"), method_3486, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9213), Reflex::Literal("swap"), method_3487, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3488, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
static void constructor_3518( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>();
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>();
}

static void constructor_3519( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_3520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[2]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[2]);
  }
}

static void constructor_3521( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
}

static void destructor_3522(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::IFieldSpecification*>*)o)->::std::vector<cool::IFieldSpecification*>::~vector();
}
static  void operator_3523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_3524( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]);
}

static  void method_3525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->begin)());
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->begin)();
}

static  void method_3526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> >)((((const ::std::vector<cool::IFieldSpecification*>*)o)->begin)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->begin)();
}

static  void method_3527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->end)());
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->end)();
}

static  void method_3528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> >)((((const ::std::vector<cool::IFieldSpecification*>*)o)->end)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->end)();
}

static  void method_3533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IFieldSpecification*>*)o)->size)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->size)();
}

static  void method_3534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IFieldSpecification*>*)o)->max_size)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->max_size)();
}

static  void method_3535( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::IFieldSpecification*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::IFieldSpecification*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::cool::IFieldSpecification*)arg[1]);
  }
}

static  void method_3536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IFieldSpecification*>*)o)->capacity)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->capacity)();
}

static  void method_3537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::IFieldSpecification*>*)o)->empty)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->empty)();
}

static  void method_3538( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->front)();
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->front)();
}

static  void method_3545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->front)();
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->front)();
}

static  void method_3546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->back)();
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->back)();
}

static  void method_3547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->back)();
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->back)();
}

static  void method_3548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::IFieldSpecification*>*)o)->data)());
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->data)();
}

static  void method_3549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::IFieldSpecification*>*)o)->data)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->data)();
}

static  void method_3550( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->push_back)(*(::cool::IFieldSpecification* const*)arg[0]);
}

static  void method_3551( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->pop_back)();
}

static  void method_3552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]));
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]);
}

static  void method_3553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::cool::IFieldSpecification* const*)arg[2]);
}

static  void method_3554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0]));
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0]);
}

static  void method_3555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[1]));
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[1]);
}

static  void method_3556( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->swap)(*(::std::vector<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_3557( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->clear)();
}

static void method_newdel_1294( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >")), ::Reflex::BaseOffset< ::std::vector<cool::IFieldSpecification*>,::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::IFieldSpecification*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::IFieldSpecification*> >::Generate();
}

//------Dictionary for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
void __std__vector_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void __std__vector_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldSpecificationp__datamem_bld(&__std__vector_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldSpecificationp__funcmem_bld(&__std__vector_cool__IFieldSpecificationp__db_funcmem);
void __std__vector_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::IFieldSpecification*>"), typeid(::std::vector<cool::IFieldSpecification*>), sizeof(::std::vector<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1572, ::Reflex::BaseOffset< ::std::vector<cool::IFieldSpecification*>, ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3497, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Alloc_value_type"))
  .AddTypedef(type_1572, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Base"))
  .AddTypedef(type_1435, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Tp_alloc_type"))
  .AddTypedef(type_1937, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Alloc_traits"))
  .AddTypedef(type_3497, Reflex::Literal("std::vector<cool::IFieldSpecification*>::value_type"))
  .AddTypedef(type_3503, Reflex::Literal("std::vector<cool::IFieldSpecification*>::pointer"))
  .AddTypedef(type_3505, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_pointer"))
  .AddTypedef(type_3507, Reflex::Literal("std::vector<cool::IFieldSpecification*>::reference"))
  .AddTypedef(type_3509, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_reference"))
  .AddTypedef(type_2030, Reflex::Literal("std::vector<cool::IFieldSpecification*>::iterator"))
  .AddTypedef(type_2031, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_iterator"))
  .AddTypedef(type_1550, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_reverse_iterator"))
  .AddTypedef(type_1551, Reflex::Literal("std::vector<cool::IFieldSpecification*>::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<cool::IFieldSpecification*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<cool::IFieldSpecification*>::difference_type"))
  .AddTypedef(type_1435, Reflex::Literal("std::vector<cool::IFieldSpecification*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3518, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9215), Reflex::Literal("vector"), constructor_3519, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3509, type_9215), Reflex::Literal("vector"), constructor_3520, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9216), Reflex::Literal("vector"), constructor_3521, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3522, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1294, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__IFieldSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std__vector_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std__vector_cool__IFieldSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9217, type_9216), Reflex::Literal("operator="), operator_3523, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3509), Reflex::Literal("assign"), method_3524, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2030), Reflex::Literal("begin"), method_3525, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2031), Reflex::Literal("begin"), method_3526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2030), Reflex::Literal("end"), method_3527, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2031), Reflex::Literal("end"), method_3528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3497), Reflex::Literal("resize"), method_3535, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3538, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3507, type_1527), Reflex::Literal("operator[]"), operator_3539, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3509, type_1527), Reflex::Literal("operator[]"), operator_3540, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3507, type_1527), Reflex::Literal("at"), method_3542, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3509, type_1527), Reflex::Literal("at"), method_3543, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3507), Reflex::Literal("front"), method_3544, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3509), Reflex::Literal("front"), method_3545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3507), Reflex::Literal("back"), method_3546, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3509), Reflex::Literal("back"), method_3547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3503), Reflex::Literal("data"), method_3548, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505), Reflex::Literal("data"), method_3549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3509), Reflex::Literal("push_back"), method_3550, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3551, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2030, type_2030, type_3509), Reflex::Literal("insert"), method_3552, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2030, type_1527, type_3509), Reflex::Literal("insert"), method_3553, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2030, type_2030), Reflex::Literal("erase"), method_3554, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2030, type_2030, type_2030), Reflex::Literal("erase"), method_3555, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9217), Reflex::Literal("swap"), method_3556, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3557, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class ChannelSelection -------------------------------
static void destructor_8435(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelSelection*)o)->::cool::ChannelSelection::~ChannelSelection();
}
static  void operator_8436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelSelection*)o)->operator=)(*(const ::cool::ChannelSelection*)arg[0]);
  else   (((::cool::ChannelSelection*)o)->operator=)(*(const ::cool::ChannelSelection*)arg[0]);
}

static void constructor_8437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection*)arg[0]);
}

static void constructor_8438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection();
  else ::new(mem) ::cool::ChannelSelection();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection::Order*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection::Order*)arg[0]);
  }
}

static void constructor_8439( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0]);
}

static void constructor_8440( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::cool::ChannelSelection::Order*)arg[2]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::cool::ChannelSelection::Order*)arg[2]);
  }
}

static void constructor_8441( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelSelection::Order*)arg[1]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelSelection::Order*)arg[1]);
  }
}

static  void method_8442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->allChannels)());
  else   (((const ::cool::ChannelSelection*)o)->allChannels)();
}

static  void method_8443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection*)o)->firstChannel)());
  else   (((const ::cool::ChannelSelection*)o)->firstChannel)();
}

static  void method_8444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection*)o)->lastChannel)());
  else   (((const ::cool::ChannelSelection*)o)->lastChannel)();
}

static  void method_8445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ChannelSelection*)o)->order)());
  else   (((const ::cool::ChannelSelection*)o)->order)();
}

static  void method_8446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (cool::ChannelSelection)((((::cool::ChannelSelection*)o)->all)());
    else     (((::cool::ChannelSelection*)o)->all)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (cool::ChannelSelection)((((::cool::ChannelSelection*)o)->all)(*(const ::cool::ChannelSelection::Order*)arg[0]));
    else     (((::cool::ChannelSelection*)o)->all)(*(const ::cool::ChannelSelection::Order*)arg[0]);
  }
}

static  void method_8447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8448( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::std::string*)arg[0]);
}

static  void method_8449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->isContiguous)());
  else   (((const ::cool::ChannelSelection*)o)->isContiguous)();
}

static  void method_8450( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::ChannelSelection*)o)->addRange)(*(const ::cool::ChannelId*)arg[0],
    *(const ::cool::ChannelId*)arg[1]);
}

static  void method_8451( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::ChannelSelection*)o)->addChannel)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->isNumeric)());
  else   (((const ::cool::ChannelSelection*)o)->isNumeric)();
}

static  void method_8453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ChannelSelection*)o)->channelName)();
  else   (((const ::cool::ChannelSelection*)o)->channelName)();
}

static  void method_8454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::cool::ChannelSelection*)o)->begin)());
  else   (((const ::cool::ChannelSelection*)o)->begin)();
}

static  void method_8455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::cool::ChannelSelection*)o)->end)());
  else   (((const ::cool::ChannelSelection*)o)->end)();
}

static  void method_8456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::ChannelSelection*)o)->rangeCount)());
  else   (((const ::cool::ChannelSelection*)o)->rangeCount)();
}

static void constructor_x29( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection();
  else ::new(mem) ::cool::ChannelSelection();
}

static void method_newdel_2278( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ChannelSelection -------------------------------
void __cool__ChannelSelection_db_datamem(Reflex::Class*);
void __cool__ChannelSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection_datamem_bld(&__cool__ChannelSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection_funcmem_bld(&__cool__ChannelSelection_db_funcmem);
void __cool__ChannelSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelSelection"), typeid(::cool::ChannelSelection), sizeof(::cool::ChannelSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddEnum(Reflex::Literal("cool::ChannelSelection::Order"), Reflex::Literal("channelBeforeSince=0;sinceBeforeChannel=1;channelBeforeSinceDesc=2;sinceDescBeforeChannel=3"), &typeid(cool::ChannelSelection::Order), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelSelection"), destructor_8435, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10210, type_10211), Reflex::Literal("operator="), operator_8436, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10211), Reflex::Literal("ChannelSelection"), constructor_8437, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10212), Reflex::Literal("ChannelSelection"), constructor_8438, 0, "order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10035), Reflex::Literal("ChannelSelection"), constructor_8439, 0, "channel", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10035, type_10035, type_10212), Reflex::Literal("ChannelSelection"), constructor_8440, 0, "firstChannel;lastChannel;order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10212), Reflex::Literal("ChannelSelection"), constructor_8441, 0, "channelName;order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ChannelSelection"), constructor_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2278, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__ChannelSelection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__ChannelSelection_funcmem_bld);
}

//------Delayed data member builder for class ChannelSelection -------------------
void __cool__ChannelSelection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1770, Reflex::Literal("m_isNumeric"), OffsetOf(__shadow__::__cool__ChannelSelection, m_isNumeric), ::Reflex::PRIVATE)
  .AddDataMember(type_1770, Reflex::Literal("m_allChannels"), OffsetOf(__shadow__::__cool__ChannelSelection, m_allChannels), ::Reflex::PRIVATE)
  .AddDataMember(type_1295, Reflex::Literal("m_ranges"), OffsetOf(__shadow__::__cool__ChannelSelection, m_ranges), ::Reflex::PRIVATE)
  .AddDataMember(type_1340, Reflex::Literal("m_channelName"), OffsetOf(__shadow__::__cool__ChannelSelection, m_channelName), ::Reflex::PRIVATE)
  .AddDataMember(type_8434, Reflex::Literal("m_order"), OffsetOf(__shadow__::__cool__ChannelSelection, m_order), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ChannelSelection -------------------
void __cool__ChannelSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("allChannels"), method_8442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2203), Reflex::Literal("firstChannel"), method_8443, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2203), Reflex::Literal("lastChannel"), method_8444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8434), Reflex::Literal("order"), method_8445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2278c, type_10212), Reflex::Literal("all"), method_8446, 0, "order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10035), Reflex::Literal("inSelection"), method_8447, 0, "channel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("inSelection"), method_8448, 0, "channelName", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isContiguous"), method_8449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10035, type_10035), Reflex::Literal("addRange"), method_8450, 0, "firstChannel;lastChannel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10035), Reflex::Literal("addChannel"), method_8451, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isNumeric"), method_8452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("channelName"), method_8453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2033), Reflex::Literal("begin"), method_8454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2033), Reflex::Literal("end"), method_8455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75), Reflex::Literal("rangeCount"), method_8456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ChannelRange -------------------------------
static void destructor_9220(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelSelection::ChannelRange*)o)->::cool::ChannelSelection::ChannelRange::~ChannelRange();
}
static  void operator_9221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelSelection::ChannelRange*)o)->operator=)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
  else   (((::cool::ChannelSelection::ChannelRange*)o)->operator=)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static void constructor_9222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static void constructor_9223( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection::ChannelRange();
  else ::new(mem) ::cool::ChannelSelection::ChannelRange();
}

static void constructor_9224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  else ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
}

static  void method_9225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection::ChannelRange*)o)->firstChannel)());
  else   (((const ::cool::ChannelSelection::ChannelRange*)o)->firstChannel)();
}

static  void method_9226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection::ChannelRange*)o)->lastChannel)());
  else   (((const ::cool::ChannelSelection::ChannelRange*)o)->lastChannel)();
}

static  void method_9227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection::ChannelRange*)o)->inRange)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::ChannelSelection::ChannelRange*)o)->inRange)(*(const ::cool::ChannelId*)arg[0]);
}

static void method_newdel_3566( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ChannelRange -------------------------------
void __cool__ChannelSelection__ChannelRange_db_datamem(Reflex::Class*);
void __cool__ChannelSelection__ChannelRange_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection__ChannelRange_datamem_bld(&__cool__ChannelSelection__ChannelRange_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection__ChannelRange_funcmem_bld(&__cool__ChannelSelection__ChannelRange_db_funcmem);
void __cool__ChannelSelection__ChannelRange_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelSelection::ChannelRange"), typeid(::cool::ChannelSelection::ChannelRange), sizeof(::cool::ChannelSelection::ChannelRange), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelRange"), destructor_9220, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3576, type_3578), Reflex::Literal("operator="), operator_9221, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3578), Reflex::Literal("ChannelRange"), constructor_9222, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ChannelRange"), constructor_9223, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10035, type_10035), Reflex::Literal("ChannelRange"), constructor_9224, 0, "firstChannel;lastChannel", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3566, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__ChannelSelection__ChannelRange_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__ChannelSelection__ChannelRange_funcmem_bld);
}

//------Delayed data member builder for class ChannelRange -------------------
void __cool__ChannelSelection__ChannelRange_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2203, Reflex::Literal("m_firstChannel"), OffsetOf(__shadow__::__cool__ChannelSelection__ChannelRange, m_firstChannel), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("m_lastChannel"), OffsetOf(__shadow__::__cool__ChannelSelection__ChannelRange, m_lastChannel), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ChannelRange -------------------
void __cool__ChannelSelection__ChannelRange_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2203), Reflex::Literal("firstChannel"), method_9225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2203), Reflex::Literal("lastChannel"), method_9226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10035), Reflex::Literal("inRange"), method_9227, 0, "channel", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
static void constructor_3587( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>();
}

static void constructor_3588( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_3589( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[2]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[2]);
  }
}

static void constructor_3590( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void destructor_3591(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->::std::vector<cool::ChannelSelection::ChannelRange>::~vector();
}
static  void operator_3592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_3593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_3594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)());
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)();
}

static  void method_3595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)();
}

static  void method_3596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)());
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)();
}

static  void method_3597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)();
}

static  void method_3602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->size)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->size)();
}

static  void method_3603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->max_size)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->max_size)();
}

static  void method_3604( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::cool::ChannelSelection::ChannelRange*)arg[1]);
  }
}

static  void method_3605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->capacity)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->capacity)();
}

static  void method_3606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->empty)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->empty)();
}

static  void method_3607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
}

static  void method_3614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
}

static  void method_3615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
}

static  void method_3616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
}

static  void method_3617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)());
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)();
}

static  void method_3618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)();
}

static  void method_3619( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->push_back)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static  void method_3620( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->pop_back)();
}

static  void method_3621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]));
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_3622( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[2]);
}

static  void method_3623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0]));
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static  void method_3624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[1]));
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[1]);
}

static  void method_3625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->swap)(*(::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_3626( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->clear)();
}

static void method_newdel_1295( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >")), ::Reflex::BaseOffset< ::std::vector<cool::ChannelSelection::ChannelRange>,::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::ChannelSelection::ChannelRange> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::ChannelSelection::ChannelRange> >::Generate();
}

//------Dictionary for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
void __std__vector_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void __std__vector_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__ChannelSelection__ChannelRange__datamem_bld(&__std__vector_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__ChannelSelection__ChannelRange__funcmem_bld(&__std__vector_cool__ChannelSelection__ChannelRange__db_funcmem);
void __std__vector_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>"), typeid(::std::vector<cool::ChannelSelection::ChannelRange>), sizeof(::std::vector<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1573, ::Reflex::BaseOffset< ::std::vector<cool::ChannelSelection::ChannelRange>, ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3566, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Alloc_value_type"))
  .AddTypedef(type_1573, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Base"))
  .AddTypedef(type_1436, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Tp_alloc_type"))
  .AddTypedef(type_1938, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Alloc_traits"))
  .AddTypedef(type_3566, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::value_type"))
  .AddTypedef(type_3572, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::pointer"))
  .AddTypedef(type_3574, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_pointer"))
  .AddTypedef(type_3576, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::reference"))
  .AddTypedef(type_3578, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_reference"))
  .AddTypedef(type_2032, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::iterator"))
  .AddTypedef(type_2033, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_iterator"))
  .AddTypedef(type_1552, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_reverse_iterator"))
  .AddTypedef(type_1553, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::difference_type"))
  .AddTypedef(type_1436, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3587, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9229), Reflex::Literal("vector"), constructor_3588, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3578, type_9229), Reflex::Literal("vector"), constructor_3589, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9230), Reflex::Literal("vector"), constructor_3590, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3591, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1295, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__ChannelSelection__ChannelRange__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std__vector_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std__vector_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9231, type_9230), Reflex::Literal("operator="), operator_3592, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3578), Reflex::Literal("assign"), method_3593, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2032), Reflex::Literal("begin"), method_3594, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2033), Reflex::Literal("begin"), method_3595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2032), Reflex::Literal("end"), method_3596, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2033), Reflex::Literal("end"), method_3597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3566), Reflex::Literal("resize"), method_3604, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3607, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3576, type_1527), Reflex::Literal("operator[]"), operator_3608, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578, type_1527), Reflex::Literal("operator[]"), operator_3609, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3576, type_1527), Reflex::Literal("at"), method_3611, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578, type_1527), Reflex::Literal("at"), method_3612, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3576), Reflex::Literal("front"), method_3613, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578), Reflex::Literal("front"), method_3614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3576), Reflex::Literal("back"), method_3615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578), Reflex::Literal("back"), method_3616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572), Reflex::Literal("data"), method_3617, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3574), Reflex::Literal("data"), method_3618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3578), Reflex::Literal("push_back"), method_3619, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3620, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2032, type_2032, type_3578), Reflex::Literal("insert"), method_3621, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2032, type_1527, type_3578), Reflex::Literal("insert"), method_3622, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2032, type_2032), Reflex::Literal("erase"), method_3623, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2032, type_2032, type_2032), Reflex::Literal("erase"), method_3624, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9231), Reflex::Literal("swap"), method_3625, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3626, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
static void constructor_3653( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>();
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>();
}

static void constructor_3654( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_3655( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[2]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[2]);
  }
}

static void constructor_3656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
}

static void destructor_3657(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<coral::AttributeSpecification*>*)o)->::std::vector<coral::AttributeSpecification*>::~vector();
}
static  void operator_3658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_3659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]);
}

static  void method_3660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->begin)());
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->begin)();
}

static  void method_3661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::std::vector<coral::AttributeSpecification*>*)o)->begin)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->begin)();
}

static  void method_3662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->end)());
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->end)();
}

static  void method_3663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::std::vector<coral::AttributeSpecification*>*)o)->end)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->end)();
}

static  void method_3668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::AttributeSpecification*>*)o)->size)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->size)();
}

static  void method_3669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::AttributeSpecification*>*)o)->max_size)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->max_size)();
}

static  void method_3670( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<coral::AttributeSpecification*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<coral::AttributeSpecification*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::coral::AttributeSpecification*)arg[1]);
  }
}

static  void method_3671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::AttributeSpecification*>*)o)->capacity)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->capacity)();
}

static  void method_3672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<coral::AttributeSpecification*>*)o)->empty)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->empty)();
}

static  void method_3673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->front)();
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->front)();
}

static  void method_3680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->front)();
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->front)();
}

static  void method_3681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->back)();
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->back)();
}

static  void method_3682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->back)();
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->back)();
}

static  void method_3683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<coral::AttributeSpecification*>*)o)->data)());
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->data)();
}

static  void method_3684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<coral::AttributeSpecification*>*)o)->data)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->data)();
}

static  void method_3685( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->push_back)(*(::coral::AttributeSpecification* const*)arg[0]);
}

static  void method_3686( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->pop_back)();
}

static  void method_3687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]));
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]);
}

static  void method_3688( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::coral::AttributeSpecification* const*)arg[2]);
}

static  void method_3689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0]));
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static  void method_3690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[1]));
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[1]);
}

static  void method_3691( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->swap)(*(::std::vector<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_3692( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->clear)();
}

static void method_newdel_1296( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >")), ::Reflex::BaseOffset< ::std::vector<coral::AttributeSpecification*>,::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<coral::AttributeSpecification*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<coral::AttributeSpecification*> >::Generate();
}

//------Dictionary for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
void __std__vector_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void __std__vector_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_coral__AttributeSpecificationp__datamem_bld(&__std__vector_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_coral__AttributeSpecificationp__funcmem_bld(&__std__vector_coral__AttributeSpecificationp__db_funcmem);
void __std__vector_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<coral::AttributeSpecification*>"), typeid(::std::vector<coral::AttributeSpecification*>), sizeof(::std::vector<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_1574, ::Reflex::BaseOffset< ::std::vector<coral::AttributeSpecification*>, ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3039, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Alloc_value_type"))
  .AddTypedef(type_1574, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Base"))
  .AddTypedef(type_1437, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Tp_alloc_type"))
  .AddTypedef(type_1941, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Alloc_traits"))
  .AddTypedef(type_3039, Reflex::Literal("std::vector<coral::AttributeSpecification*>::value_type"))
  .AddTypedef(type_3640, Reflex::Literal("std::vector<coral::AttributeSpecification*>::pointer"))
  .AddTypedef(type_3042, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_pointer"))
  .AddTypedef(type_3643, Reflex::Literal("std::vector<coral::AttributeSpecification*>::reference"))
  .AddTypedef(type_3044, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_reference"))
  .AddTypedef(type_2035, Reflex::Literal("std::vector<coral::AttributeSpecification*>::iterator"))
  .AddTypedef(type_2034, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_iterator"))
  .AddTypedef(type_1556, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_reverse_iterator"))
  .AddTypedef(type_1557, Reflex::Literal("std::vector<coral::AttributeSpecification*>::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<coral::AttributeSpecification*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<coral::AttributeSpecification*>::difference_type"))
  .AddTypedef(type_1437, Reflex::Literal("std::vector<coral::AttributeSpecification*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3653, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9232), Reflex::Literal("vector"), constructor_3654, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3044, type_9232), Reflex::Literal("vector"), constructor_3655, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9233), Reflex::Literal("vector"), constructor_3656, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3657, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1296, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_coral__AttributeSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std__vector_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std__vector_coral__AttributeSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9234, type_9233), Reflex::Literal("operator="), operator_3658, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3044), Reflex::Literal("assign"), method_3659, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2035), Reflex::Literal("begin"), method_3660, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2034), Reflex::Literal("begin"), method_3661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2035), Reflex::Literal("end"), method_3662, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2034), Reflex::Literal("end"), method_3663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3039), Reflex::Literal("resize"), method_3670, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3673, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3643, type_1527), Reflex::Literal("operator[]"), operator_3674, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044, type_1527), Reflex::Literal("operator[]"), operator_3675, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3643, type_1527), Reflex::Literal("at"), method_3677, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044, type_1527), Reflex::Literal("at"), method_3678, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3643), Reflex::Literal("front"), method_3679, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044), Reflex::Literal("front"), method_3680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3643), Reflex::Literal("back"), method_3681, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044), Reflex::Literal("back"), method_3682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3640), Reflex::Literal("data"), method_3683, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3042), Reflex::Literal("data"), method_3684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3044), Reflex::Literal("push_back"), method_3685, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3686, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2035, type_2035, type_3044), Reflex::Literal("insert"), method_3687, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2035, type_1527, type_3044), Reflex::Literal("insert"), method_3688, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2035, type_2035), Reflex::Literal("erase"), method_3689, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2035, type_2035, type_2035), Reflex::Literal("erase"), method_3690, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9234), Reflex::Literal("swap"), method_3691, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3692, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
static void constructor_3717( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>();
  else ::new(mem) ::std::vector<coral::Attribute*>();
}

static void constructor_3718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_3719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1],
      *(const ::std::allocator<coral::Attribute*>*)arg[2]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1],
      *(const ::std::allocator<coral::Attribute*>*)arg[2]);
  }
}

static void constructor_3720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::vector<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::vector<coral::Attribute*>*)arg[0]);
}

static void destructor_3721(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<coral::Attribute*>*)o)->::std::vector<coral::Attribute*>::~vector();
}
static  void operator_3722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->operator=)(*(const ::std::vector<coral::Attribute*>*)arg[0]);
  else   (((::std::vector<coral::Attribute*>*)o)->operator=)(*(const ::std::vector<coral::Attribute*>*)arg[0]);
}

static  void method_3723( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::coral::Attribute* const*)arg[1]);
}

static  void method_3724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->begin)());
  else   (((::std::vector<coral::Attribute*>*)o)->begin)();
}

static  void method_3725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::std::vector<coral::Attribute*>*)o)->begin)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->begin)();
}

static  void method_3726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->end)());
  else   (((::std::vector<coral::Attribute*>*)o)->end)();
}

static  void method_3727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::std::vector<coral::Attribute*>*)o)->end)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->end)();
}

static  void method_3732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::Attribute*>*)o)->size)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->size)();
}

static  void method_3733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::Attribute*>*)o)->max_size)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->max_size)();
}

static  void method_3734( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<coral::Attribute*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<coral::Attribute*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::coral::Attribute*)arg[1]);
  }
}

static  void method_3735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::Attribute*>*)o)->capacity)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->capacity)();
}

static  void method_3736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<coral::Attribute*>*)o)->empty)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->empty)();
}

static  void method_3737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->front)();
  else   (((::std::vector<coral::Attribute*>*)o)->front)();
}

static  void method_3744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->front)();
  else   (((const ::std::vector<coral::Attribute*>*)o)->front)();
}

static  void method_3745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->back)();
  else   (((::std::vector<coral::Attribute*>*)o)->back)();
}

static  void method_3746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->back)();
  else   (((const ::std::vector<coral::Attribute*>*)o)->back)();
}

static  void method_3747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<coral::Attribute*>*)o)->data)());
  else   (((::std::vector<coral::Attribute*>*)o)->data)();
}

static  void method_3748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<coral::Attribute*>*)o)->data)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->data)();
}

static  void method_3749( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->push_back)(*(::coral::Attribute* const*)arg[0]);
}

static  void method_3750( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->pop_back)();
}

static  void method_3751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::coral::Attribute* const*)arg[1]));
  else   (((::std::vector<coral::Attribute*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::coral::Attribute* const*)arg[1]);
}

static  void method_3752( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::coral::Attribute* const*)arg[2]);
}

static  void method_3753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]));
  else   (((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
}

static  void method_3754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[1]));
  else   (((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[1]);
}

static  void method_3755( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->swap)(*(::std::vector<coral::Attribute*>*)arg[0]);
}

static  void method_3756( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->clear)();
}

static void method_newdel_1297( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >")), ::Reflex::BaseOffset< ::std::vector<coral::Attribute*>,::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<coral::Attribute*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<coral::Attribute*> >::Generate();
}

//------Dictionary for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
void __std__vector_coral__Attributep__db_datamem(Reflex::Class*);
void __std__vector_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_coral__Attributep__datamem_bld(&__std__vector_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_coral__Attributep__funcmem_bld(&__std__vector_coral__Attributep__db_funcmem);
void __std__vector_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<coral::Attribute*>"), typeid(::std::vector<coral::Attribute*>), sizeof(::std::vector<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_1575, ::Reflex::BaseOffset< ::std::vector<coral::Attribute*>, ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3051, Reflex::Literal("std::vector<coral::Attribute*>::_Alloc_value_type"))
  .AddTypedef(type_1575, Reflex::Literal("std::vector<coral::Attribute*>::_Base"))
  .AddTypedef(type_1440, Reflex::Literal("std::vector<coral::Attribute*>::_Tp_alloc_type"))
  .AddTypedef(type_1942, Reflex::Literal("std::vector<coral::Attribute*>::_Alloc_traits"))
  .AddTypedef(type_3051, Reflex::Literal("std::vector<coral::Attribute*>::value_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::vector<coral::Attribute*>::pointer"))
  .AddTypedef(type_3065, Reflex::Literal("std::vector<coral::Attribute*>::const_pointer"))
  .AddTypedef(type_3056, Reflex::Literal("std::vector<coral::Attribute*>::reference"))
  .AddTypedef(type_3067, Reflex::Literal("std::vector<coral::Attribute*>::const_reference"))
  .AddTypedef(type_2036, Reflex::Literal("std::vector<coral::Attribute*>::iterator"))
  .AddTypedef(type_2037, Reflex::Literal("std::vector<coral::Attribute*>::const_iterator"))
  .AddTypedef(type_1558, Reflex::Literal("std::vector<coral::Attribute*>::const_reverse_iterator"))
  .AddTypedef(type_1559, Reflex::Literal("std::vector<coral::Attribute*>::reverse_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::vector<coral::Attribute*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::vector<coral::Attribute*>::difference_type"))
  .AddTypedef(type_1440, Reflex::Literal("std::vector<coral::Attribute*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3717, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9235), Reflex::Literal("vector"), constructor_3718, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_3067, type_9235), Reflex::Literal("vector"), constructor_3719, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9236), Reflex::Literal("vector"), constructor_3720, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3721, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1297, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_coral__Attributep__funcmem_bld);
}

//------Delayed data member builder for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std__vector_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std__vector_coral__Attributep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9237, type_9236), Reflex::Literal("operator="), operator_3722, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3067), Reflex::Literal("assign"), method_3723, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036), Reflex::Literal("begin"), method_3724, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2037), Reflex::Literal("begin"), method_3725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036), Reflex::Literal("end"), method_3726, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2037), Reflex::Literal("end"), method_3727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_3732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_3733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527, type_3051), Reflex::Literal("resize"), method_3734, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("capacity"), method_3735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_3736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1527), Reflex::Literal("reserve"), method_3737, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1527), Reflex::Literal("operator[]"), operator_3738, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3067, type_1527), Reflex::Literal("operator[]"), operator_3739, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1527), Reflex::Literal("at"), method_3741, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3067, type_1527), Reflex::Literal("at"), method_3742, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("front"), method_3743, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3067), Reflex::Literal("front"), method_3744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("back"), method_3745, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3067), Reflex::Literal("back"), method_3746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054), Reflex::Literal("data"), method_3747, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3065), Reflex::Literal("data"), method_3748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3067), Reflex::Literal("push_back"), method_3749, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("pop_back"), method_3750, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036, type_2036, type_3067), Reflex::Literal("insert"), method_3751, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_2036, type_1527, type_3067), Reflex::Literal("insert"), method_3752, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036, type_2036), Reflex::Literal("erase"), method_3753, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036, type_2036, type_2036), Reflex::Literal("erase"), method_3754, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9237), Reflex::Literal("swap"), method_3755, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_3756, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
static  void operator_4622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_4623( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >();
}

static void constructor_4624( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void destructor_4625(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IRecord> >*)o)->::std::allocator<boost::shared_ptr<cool::IRecord> >::~allocator();
}
static void method_newdel_1430( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >")), ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IRecord> >,::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >"), typeid(::std::allocator<boost::shared_ptr<cool::IRecord> >), sizeof(::std::allocator<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1961, ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IRecord> >, ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::difference_type"))
  .AddTypedef(type_3009, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::pointer"))
  .AddTypedef(type_3233, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::const_pointer"))
  .AddTypedef(type_3011, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::reference"))
  .AddTypedef(type_3236, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::const_reference"))
  .AddTypedef(type_2288, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9457, type_9199), Reflex::Literal("operator="), operator_4622, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4623, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9199), Reflex::Literal("allocator"), constructor_4624, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4625, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1430, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<boost::shared_ptr<cool::IObject> > -------------------------------
static  void operator_4633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_4634( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >();
}

static void constructor_4635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void destructor_4636(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IObject> >*)o)->::std::allocator<boost::shared_ptr<cool::IObject> >::~allocator();
}
static void method_newdel_1431( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >")), ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IObject> >,::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<boost::shared_ptr<cool::IObject> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >"), typeid(::std::allocator<boost::shared_ptr<cool::IObject> >), sizeof(::std::allocator<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1962, ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IObject> >, ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::difference_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::pointer"))
  .AddTypedef(type_3299, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::const_pointer"))
  .AddTypedef(type_3022, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::reference"))
  .AddTypedef(type_3302, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::const_reference"))
  .AddTypedef(type_2180, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9458, type_9203), Reflex::Literal("operator="), operator_4633, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4634, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9203), Reflex::Literal("allocator"), constructor_4635, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4636, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1431, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::IField*> -------------------------------
static  void operator_4644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else   (((::std::allocator<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void constructor_4645( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>();
  else ::new(mem) ::std::allocator<cool::IField*>();
}

static void constructor_4646( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void destructor_4647(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IField*>*)o)->::std::allocator<cool::IField*>::~allocator();
}
static void method_newdel_1432( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>")), ::Reflex::BaseOffset< ::std::allocator<cool::IField*>,::__gnu_cxx::new_allocator<cool::IField*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::IField*> -------------------------------
void __std__allocator_cool__IFieldp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp__datamem_bld(&__std__allocator_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp__funcmem_bld(&__std__allocator_cool__IFieldp__db_funcmem);
void __std__allocator_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IField*>"), typeid(::std::allocator<cool::IField*>), sizeof(::std::allocator<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1964, ::Reflex::BaseOffset< ::std::allocator<cool::IField*>, ::__gnu_cxx::new_allocator<cool::IField*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<cool::IField*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<cool::IField*>::difference_type"))
  .AddTypedef(type_3365, Reflex::Literal("std::allocator<cool::IField*>::pointer"))
  .AddTypedef(type_3367, Reflex::Literal("std::allocator<cool::IField*>::const_pointer"))
  .AddTypedef(type_3369, Reflex::Literal("std::allocator<cool::IField*>::reference"))
  .AddTypedef(type_3371, Reflex::Literal("std::allocator<cool::IField*>::const_reference"))
  .AddTypedef(type_3359, Reflex::Literal("std::allocator<cool::IField*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9459, type_9207), Reflex::Literal("operator="), operator_4644, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4645, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9207), Reflex::Literal("allocator"), constructor_4646, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4647, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1432, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::IField*> -------------------
void __std__allocator_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::IField*> -------------------
void __std__allocator_cool__IFieldp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::IRecordSelection*> -------------------------------
static  void operator_4655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else   (((::std::allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_4656( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>();
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>();
}

static void constructor_4657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void destructor_4658(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IRecordSelection*>*)o)->::std::allocator<cool::IRecordSelection*>::~allocator();
}
static void method_newdel_1433( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>")), ::Reflex::BaseOffset< ::std::allocator<cool::IRecordSelection*>,::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::IRecordSelection*> -------------------------------
void __std__allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp__datamem_bld(&__std__allocator_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp__funcmem_bld(&__std__allocator_cool__IRecordSelectionp__db_funcmem);
void __std__allocator_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>"), typeid(::std::allocator<cool::IRecordSelection*>), sizeof(::std::allocator<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1963, ::Reflex::BaseOffset< ::std::allocator<cool::IRecordSelection*>, ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<cool::IRecordSelection*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<cool::IRecordSelection*>::difference_type"))
  .AddTypedef(type_3434, Reflex::Literal("std::allocator<cool::IRecordSelection*>::pointer"))
  .AddTypedef(type_3436, Reflex::Literal("std::allocator<cool::IRecordSelection*>::const_pointer"))
  .AddTypedef(type_3438, Reflex::Literal("std::allocator<cool::IRecordSelection*>::reference"))
  .AddTypedef(type_3440, Reflex::Literal("std::allocator<cool::IRecordSelection*>::const_reference"))
  .AddTypedef(type_3428, Reflex::Literal("std::allocator<cool::IRecordSelection*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9460, type_9211), Reflex::Literal("operator="), operator_4655, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4656, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9211), Reflex::Literal("allocator"), constructor_4657, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4658, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1433, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::IFieldSpecification*> -------------------------------
static  void operator_4666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else   (((::std::allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_4667( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>();
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>();
}

static void constructor_4668( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void destructor_4669(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IFieldSpecification*>*)o)->::std::allocator<cool::IFieldSpecification*>::~allocator();
}
static void method_newdel_1435( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>")), ::Reflex::BaseOffset< ::std::allocator<cool::IFieldSpecification*>,::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::IFieldSpecification*> -------------------------------
void __std__allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp__datamem_bld(&__std__allocator_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp__funcmem_bld(&__std__allocator_cool__IFieldSpecificationp__db_funcmem);
void __std__allocator_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>"), typeid(::std::allocator<cool::IFieldSpecification*>), sizeof(::std::allocator<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1965, ::Reflex::BaseOffset< ::std::allocator<cool::IFieldSpecification*>, ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::difference_type"))
  .AddTypedef(type_3503, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::pointer"))
  .AddTypedef(type_3505, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::const_pointer"))
  .AddTypedef(type_3507, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::reference"))
  .AddTypedef(type_3509, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::const_reference"))
  .AddTypedef(type_3497, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9461, type_9215), Reflex::Literal("operator="), operator_4666, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4667, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9215), Reflex::Literal("allocator"), constructor_4668, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4669, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1435, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::ChannelSelection::ChannelRange> -------------------------------
static  void operator_4677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::std::allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_4678( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>();
}

static void constructor_4679( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void destructor_4680(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::ChannelSelection::ChannelRange>*)o)->::std::allocator<cool::ChannelSelection::ChannelRange>::~allocator();
}
static void method_newdel_1436( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>")), ::Reflex::BaseOffset< ::std::allocator<cool::ChannelSelection::ChannelRange>,::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::ChannelSelection::ChannelRange> -------------------------------
void __std__allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void __std__allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange__datamem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange__funcmem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange__db_funcmem);
void __std__allocator_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>"), typeid(::std::allocator<cool::ChannelSelection::ChannelRange>), sizeof(::std::allocator<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1966, ::Reflex::BaseOffset< ::std::allocator<cool::ChannelSelection::ChannelRange>, ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::difference_type"))
  .AddTypedef(type_3572, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::pointer"))
  .AddTypedef(type_3574, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::const_pointer"))
  .AddTypedef(type_3576, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::reference"))
  .AddTypedef(type_3578, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::const_reference"))
  .AddTypedef(type_3566, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9462, type_9229), Reflex::Literal("operator="), operator_4677, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4678, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9229), Reflex::Literal("allocator"), constructor_4679, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4680, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1436, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<coral::AttributeSpecification*> -------------------------------
static  void operator_4688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else   (((::std::allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_4689( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>();
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>();
}

static void constructor_4690( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void destructor_4691(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::AttributeSpecification*>*)o)->::std::allocator<coral::AttributeSpecification*>::~allocator();
}
static void method_newdel_1437( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>")), ::Reflex::BaseOffset< ::std::allocator<coral::AttributeSpecification*>,::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<coral::AttributeSpecification*> -------------------------------
void __std__allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp__datamem_bld(&__std__allocator_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp__funcmem_bld(&__std__allocator_coral__AttributeSpecificationp__db_funcmem);
void __std__allocator_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>"), typeid(::std::allocator<coral::AttributeSpecification*>), sizeof(::std::allocator<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_1969, ::Reflex::BaseOffset< ::std::allocator<coral::AttributeSpecification*>, ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::difference_type"))
  .AddTypedef(type_3640, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::pointer"))
  .AddTypedef(type_3042, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::const_pointer"))
  .AddTypedef(type_3643, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::reference"))
  .AddTypedef(type_3044, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::const_reference"))
  .AddTypedef(type_3039, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9463, type_9232), Reflex::Literal("operator="), operator_4688, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4689, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9232), Reflex::Literal("allocator"), constructor_4690, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4691, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1437, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<coral::Attribute*> -------------------------------
static  void operator_4729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else   (((::std::allocator<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_4730( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>();
  else ::new(mem) ::std::allocator<coral::Attribute*>();
}

static void constructor_4731( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void destructor_4732(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::Attribute*>*)o)->::std::allocator<coral::Attribute*>::~allocator();
}
static void method_newdel_1440( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x56( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>")), ::Reflex::BaseOffset< ::std::allocator<coral::Attribute*>,::__gnu_cxx::new_allocator<coral::Attribute*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<coral::Attribute*> -------------------------------
void __std__allocator_coral__Attributep__db_datamem(Reflex::Class*);
void __std__allocator_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep__datamem_bld(&__std__allocator_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep__funcmem_bld(&__std__allocator_coral__Attributep__db_funcmem);
void __std__allocator_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::Attribute*>"), typeid(::std::allocator<coral::Attribute*>), sizeof(::std::allocator<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_1970, ::Reflex::BaseOffset< ::std::allocator<coral::Attribute*>, ::__gnu_cxx::new_allocator<coral::Attribute*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1527, Reflex::Literal("std::allocator<coral::Attribute*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::allocator<coral::Attribute*>::difference_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::allocator<coral::Attribute*>::pointer"))
  .AddTypedef(type_3065, Reflex::Literal("std::allocator<coral::Attribute*>::const_pointer"))
  .AddTypedef(type_3056, Reflex::Literal("std::allocator<coral::Attribute*>::reference"))
  .AddTypedef(type_3067, Reflex::Literal("std::allocator<coral::Attribute*>::const_reference"))
  .AddTypedef(type_3051, Reflex::Literal("std::allocator<coral::Attribute*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9470, type_9235), Reflex::Literal("operator="), operator_4729, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4730, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9235), Reflex::Literal("allocator"), constructor_4731, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4732, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1440, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x56, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
static void destructor_4774(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >::~rebind();
}
static  void operator_4775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_4776( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_4777( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >();
}

static void method_newdel_1447( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >"), typeid(::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >), sizeof(::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1430, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4774, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9482, type_9483), Reflex::Literal("operator="), operator_4775, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9483), Reflex::Literal("rebind"), constructor_4776, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4777, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1447, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
static void destructor_4779(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)o)->::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >::~rebind();
}
static  void operator_4780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_4781( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_4782( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >();
}

static void method_newdel_1448( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >"), typeid(::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >), sizeof(::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1431, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4779, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9484, type_9485), Reflex::Literal("operator="), operator_4780, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9485), Reflex::Literal("rebind"), constructor_4781, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4782, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1448, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IRecordSelection*> -------------------------------
static void destructor_4784(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)o)->::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>::~rebind();
}
static  void operator_4785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
  else   (((::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_4786( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_4787( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>();
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>();
}

static void method_newdel_1449( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IRecordSelection*> -------------------------------
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__datamem_bld(&__std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__funcmem_bld(&__std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_funcmem);
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>"), typeid(::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>), sizeof(::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1433, Reflex::Literal("std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4784, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9486, type_9487), Reflex::Literal("operator="), operator_4785, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9487), Reflex::Literal("rebind"), constructor_4786, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4787, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1449, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IField*> -------------------------------
static void destructor_4789(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IField*>::rebind<cool::IField*>*)o)->::std::allocator<cool::IField*>::rebind<cool::IField*>::~rebind();
}
static  void operator_4790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IField*>::rebind<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
  else   (((::std::allocator<cool::IField*>::rebind<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
}

static void constructor_4791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
}

static void constructor_4792( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>();
  else ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>();
}

static void method_newdel_1450( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IField*> -------------------------------
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp___rebind_cool__IFieldp__datamem_bld(&__std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp___rebind_cool__IFieldp__funcmem_bld(&__std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_funcmem);
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IField*>::rebind<cool::IField*>"), typeid(::std::allocator<cool::IField*>::rebind<cool::IField*>), sizeof(::std::allocator<cool::IField*>::rebind<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1432, Reflex::Literal("std::allocator<cool::IField*>::rebind<cool::IField*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4789, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9488, type_9489), Reflex::Literal("operator="), operator_4790, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9489), Reflex::Literal("rebind"), constructor_4791, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IField*> -------------------
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IField*> -------------------
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IFieldSpecification*> -------------------------------
static void destructor_4794(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)o)->::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>::~rebind();
}
static  void operator_4795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
  else   (((::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_4796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_4797( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>();
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>();
}

static void method_newdel_1451( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IFieldSpecification*> -------------------------------
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__datamem_bld(&__std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__funcmem_bld(&__std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_funcmem);
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>"), typeid(::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>), sizeof(::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1435, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4794, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9490, type_9491), Reflex::Literal("operator="), operator_4795, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9491), Reflex::Literal("rebind"), constructor_4796, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4797, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1451, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
static void destructor_4799(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)o)->::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>::~rebind();
}
static  void operator_4800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_4801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_4802( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>();
}

static void method_newdel_1452( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__datamem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__funcmem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_funcmem);
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>"), typeid(::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>), sizeof(::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1436, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4799, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9492, type_9493), Reflex::Literal("operator="), operator_4800, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9493), Reflex::Literal("rebind"), constructor_4801, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4802, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1452, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::AttributeSpecification*> -------------------------------
static void destructor_4814(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)o)->::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>::~rebind();
}
static  void operator_4815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
  else   (((::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_4816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_4817( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>();
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>();
}

static void method_newdel_1455( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::AttributeSpecification*> -------------------------------
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__datamem_bld(&__std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__funcmem_bld(&__std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_funcmem);
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>"), typeid(::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>), sizeof(::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1437, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4814, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9498, type_9499), Reflex::Literal("operator="), operator_4815, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9499), Reflex::Literal("rebind"), constructor_4816, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4817, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1455, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::Attribute*> -------------------------------
static void destructor_4819(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)o)->::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>::~rebind();
}
static  void operator_4820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
  else   (((::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_4821( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_4822( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>();
  else ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>();
}

static void method_newdel_1456( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::Attribute*> -------------------------------
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_datamem(Reflex::Class*);
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep___rebind_coral__Attributep__datamem_bld(&__std__allocator_coral__Attributep___rebind_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep___rebind_coral__Attributep__funcmem_bld(&__std__allocator_coral__Attributep___rebind_coral__Attributep__db_funcmem);
void __std__allocator_coral__Attributep___rebind_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::Attribute*>::rebind<coral::Attribute*>"), typeid(::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>), sizeof(::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1440, Reflex::Literal("std::allocator<coral::Attribute*>::rebind<coral::Attribute*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4819, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9500, type_9501), Reflex::Literal("operator="), operator_4820, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9501), Reflex::Literal("rebind"), constructor_4821, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4822, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1456, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_5041(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<unsigned int,std::basic_string<char> >*)o)->::std::map<unsigned int,std::basic_string<char> >::~map();
}
static void constructor_5042( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >();
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >();
}

static void constructor_5043( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
  }
}

static void constructor_5044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void operator_5045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_5046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->get_allocator)();
}

static  void method_5047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->begin)();
}

static  void method_5048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->begin)();
}

static  void method_5049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->end)());
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->end)();
}

static  void method_5050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->end)();
}

static  void method_5055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->empty)();
}

static  void method_5056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->size)();
}

static  void method_5057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->max_size)();
}

static  void operator_5058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_5059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_5060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_5061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,bool>)((((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_5062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[1]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[1]);
}

static  void method_5063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void method_5064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_5065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
}

static  void method_5066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->swap)(*(::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_5067( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->clear)();
}

static  void method_5068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->key_comp)();
}

static  void method_5070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_5071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_5072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_5073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_5078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1515( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x66( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::basic_string<char> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__basic_string_char_s__datamem_bld(&__std__map_unsignedsint_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__basic_string_char_s__funcmem_bld(&__std__map_unsignedsint_std__basic_string_char_s__db_funcmem);
void __std__map_unsignedsint_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >"), typeid(::std::map<unsigned int,std::basic_string<char> >), sizeof(::std::map<unsigned int,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddTypedef(type_75, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::key_type"))
  .AddTypedef(type_1333, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::mapped_type"))
  .AddTypedef(type_1318, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::value_type"))
  .AddTypedef(type_1700, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::key_compare"))
  .AddTypedef(type_1427, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::allocator_type"))
  .AddTypedef(type_1318, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1427, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Pair_alloc_type"))
  .AddTypedef(type_1651, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Rep_type"))
  .AddTypedef(type_1930, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Alloc_traits"))
  .AddTypedef(type_4271, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::pointer"))
  .AddTypedef(type_4580, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_4269, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::reference"))
  .AddTypedef(type_4583, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_reference"))
  .AddTypedef(type_1367, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::iterator"))
  .AddTypedef(type_1586, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1527, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1539, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1538, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_5041, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_5042, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9537, type_9452), Reflex::Literal("map"), constructor_5043, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9538), Reflex::Literal("map"), constructor_5044, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1515, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x66, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__basic_string_char_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1651, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__basic_string_char_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9539, type_9538), Reflex::Literal("operator="), operator_5045, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1427), Reflex::Literal("get_allocator"), method_5046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367), Reflex::Literal("begin"), method_5047, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1586), Reflex::Literal("begin"), method_5048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367), Reflex::Literal("end"), method_5049, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1586), Reflex::Literal("end"), method_5050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_5055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("size"), method_5056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_5057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3170), Reflex::Literal("operator[]"), operator_5058, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946, type_3170), Reflex::Literal("at"), method_5059, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103, type_3170), Reflex::Literal("at"), method_5060, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1321, type_4583), Reflex::Literal("insert"), method_5061, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367, type_1367, type_4583), Reflex::Literal("insert"), method_5062, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1367), Reflex::Literal("erase"), method_5063, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3170), Reflex::Literal("erase"), method_5064, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1367, type_1367), Reflex::Literal("erase"), method_5065, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9539), Reflex::Literal("swap"), method_5066, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("clear"), method_5067, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1700), Reflex::Literal("key_comp"), method_5068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367, type_3170), Reflex::Literal("find"), method_5070, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1586, type_3170), Reflex::Literal("find"), method_5071, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_3170), Reflex::Literal("count"), method_5072, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367, type_3170), Reflex::Literal("lower_bound"), method_5073, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1586, type_3170), Reflex::Literal("lower_bound"), method_5074, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367, type_3170), Reflex::Literal("upper_bound"), method_5075, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1586, type_3170), Reflex::Literal("upper_bound"), method_5076, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1320, type_3170), Reflex::Literal("equal_range"), method_5077, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1319, type_3170), Reflex::Literal("equal_range"), method_5078, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
static  void operator_5275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_5276( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_5277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<boost::shared_ptr<cool::IRecord> >)((((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->get_allocator)();
}

static void constructor_5280( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >();
}

static void constructor_5281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_5282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0]);
}

static void constructor_5283( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[1]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[1]);
}

static void destructor_5284(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::~_Vector_base();
}
static  void method_5285( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5286( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_deallocate)((::boost::shared_ptr<cool::IRecord>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1568( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >"), typeid(::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >), sizeof(::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1430, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::_Tp_alloc_type"))
  .AddTypedef(type_3009, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::pointer"))
  .AddTypedef(type_1430, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9588, type_9589), Reflex::Literal("operator="), operator_5275, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9589), Reflex::Literal("_Vector_base"), constructor_5276, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5280, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9199), Reflex::Literal("_Vector_base"), constructor_5281, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5282, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9199), Reflex::Literal("_Vector_base"), constructor_5283, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5284, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1568, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5273, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9457), Reflex::Literal("_M_get_Tp_allocator"), method_5277, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9199), Reflex::Literal("_M_get_Tp_allocator"), method_5278, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1430), Reflex::Literal("get_allocator"), method_5279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3009, type_1527), Reflex::Literal("_M_allocate"), method_5285, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3009, type_1527), Reflex::Literal("_M_deallocate"), method_5286, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
static  void operator_5293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_5294( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_5295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<boost::shared_ptr<cool::IObject> >)((((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->get_allocator)();
}

static void constructor_5298( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >();
}

static void constructor_5299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_5300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0]);
}

static void constructor_5301( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[1]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[1]);
}

static void destructor_5302(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::~_Vector_base();
}
static  void method_5303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5304( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_deallocate)((::boost::shared_ptr<cool::IObject>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1569( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >"), typeid(::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >), sizeof(::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1431, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::_Tp_alloc_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::pointer"))
  .AddTypedef(type_1431, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9599, type_9600), Reflex::Literal("operator="), operator_5293, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9600), Reflex::Literal("_Vector_base"), constructor_5294, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5298, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9203), Reflex::Literal("_Vector_base"), constructor_5299, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5300, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9203), Reflex::Literal("_Vector_base"), constructor_5301, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5302, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1569, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5291, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9458), Reflex::Literal("_M_get_Tp_allocator"), method_5295, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9203), Reflex::Literal("_M_get_Tp_allocator"), method_5296, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1431), Reflex::Literal("get_allocator"), method_5297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020, type_1527), Reflex::Literal("_M_allocate"), method_5303, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3020, type_1527), Reflex::Literal("_M_deallocate"), method_5304, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
static  void operator_5311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else   (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static void constructor_5312( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static  void method_5313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::IRecordSelection*>)((((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->get_allocator)();
}

static void constructor_5316( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >();
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >();
}

static void constructor_5317( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_5318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5319( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[1]);
}

static void destructor_5320(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::~_Vector_base();
}
static  void method_5321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_deallocate)((::cool::IRecordSelection**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1570( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__datamem_bld(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__funcmem_bld(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_funcmem);
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >"), typeid(::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >), sizeof(::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1433, Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::_Tp_alloc_type"))
  .AddTypedef(type_3434, Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::pointer"))
  .AddTypedef(type_1433, Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9610, type_9611), Reflex::Literal("operator="), operator_5311, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9611), Reflex::Literal("_Vector_base"), constructor_5312, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5316, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9211), Reflex::Literal("_Vector_base"), constructor_5317, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5318, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9211), Reflex::Literal("_Vector_base"), constructor_5319, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5320, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1570, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5309, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9460), Reflex::Literal("_M_get_Tp_allocator"), method_5313, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9211), Reflex::Literal("_M_get_Tp_allocator"), method_5314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1433), Reflex::Literal("get_allocator"), method_5315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434, type_1527), Reflex::Literal("_M_allocate"), method_5321, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3434, type_1527), Reflex::Literal("_M_deallocate"), method_5322, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------------------
static  void operator_5329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
  else   (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
}

static void constructor_5330( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
}

static  void method_5331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::IField*>)((((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->get_allocator)();
}

static void constructor_5334( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >();
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >();
}

static void constructor_5335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void constructor_5336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IField*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IField*>*)arg[1]);
}

static void destructor_5338(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::~_Vector_base();
}
static  void method_5339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5340( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_deallocate)((::cool::IField**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1571( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------------------
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__datamem_bld(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__funcmem_bld(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_funcmem);
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >"), typeid(::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >), sizeof(::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1432, Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::_Tp_alloc_type"))
  .AddTypedef(type_3365, Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::pointer"))
  .AddTypedef(type_1432, Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9621, type_9622), Reflex::Literal("operator="), operator_5329, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9622), Reflex::Literal("_Vector_base"), constructor_5330, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5334, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9207), Reflex::Literal("_Vector_base"), constructor_5335, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5336, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9207), Reflex::Literal("_Vector_base"), constructor_5337, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5338, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1571, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5327, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9459), Reflex::Literal("_M_get_Tp_allocator"), method_5331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9207), Reflex::Literal("_M_get_Tp_allocator"), method_5332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1432), Reflex::Literal("get_allocator"), method_5333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3365, type_1527), Reflex::Literal("_M_allocate"), method_5339, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3365, type_1527), Reflex::Literal("_M_deallocate"), method_5340, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
static  void operator_5347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else   (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static void constructor_5348( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static  void method_5349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::IFieldSpecification*>)((((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->get_allocator)();
}

static void constructor_5352( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >();
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >();
}

static void constructor_5353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_5354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[1]);
}

static void destructor_5356(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::~_Vector_base();
}
static  void method_5357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_deallocate)((::cool::IFieldSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1572( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__datamem_bld(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_funcmem);
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >"), typeid(::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >), sizeof(::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1435, Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::_Tp_alloc_type"))
  .AddTypedef(type_3503, Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::pointer"))
  .AddTypedef(type_1435, Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9632, type_9633), Reflex::Literal("operator="), operator_5347, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9633), Reflex::Literal("_Vector_base"), constructor_5348, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5352, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9215), Reflex::Literal("_Vector_base"), constructor_5353, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5354, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9215), Reflex::Literal("_Vector_base"), constructor_5355, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5356, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1572, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5345, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9461), Reflex::Literal("_M_get_Tp_allocator"), method_5349, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9215), Reflex::Literal("_M_get_Tp_allocator"), method_5350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1435), Reflex::Literal("get_allocator"), method_5351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3503, type_1527), Reflex::Literal("_M_allocate"), method_5357, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3503, type_1527), Reflex::Literal("_M_deallocate"), method_5358, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
static  void operator_5365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else   (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static void constructor_5366( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static  void method_5367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::ChannelSelection::ChannelRange>)((((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->get_allocator)();
}

static void constructor_5370( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >();
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >();
}

static void constructor_5371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_5372( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0]);
}

static void constructor_5373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[1]);
}

static void destructor_5374(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::~_Vector_base();
}
static  void method_5375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_deallocate)((::cool::ChannelSelection::ChannelRange*)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1573( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__datamem_bld(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem);
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >"), typeid(::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >), sizeof(::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1436, Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::_Tp_alloc_type"))
  .AddTypedef(type_3572, Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::pointer"))
  .AddTypedef(type_1436, Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9643, type_9644), Reflex::Literal("operator="), operator_5365, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9644), Reflex::Literal("_Vector_base"), constructor_5366, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5370, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9229), Reflex::Literal("_Vector_base"), constructor_5371, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5372, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9229), Reflex::Literal("_Vector_base"), constructor_5373, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5374, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1573, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5363, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9462), Reflex::Literal("_M_get_Tp_allocator"), method_5367, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9229), Reflex::Literal("_M_get_Tp_allocator"), method_5368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1436), Reflex::Literal("get_allocator"), method_5369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572, type_1527), Reflex::Literal("_M_allocate"), method_5375, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3572, type_1527), Reflex::Literal("_M_deallocate"), method_5376, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
static  void operator_5383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_5384( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static  void method_5385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<coral::AttributeSpecification*>)((((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->get_allocator)();
}

static void constructor_5388( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >();
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >();
}

static void constructor_5389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_5390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[1]);
}

static void destructor_5392(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::~_Vector_base();
}
static  void method_5393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5394( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_deallocate)((::coral::AttributeSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1574( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__datamem_bld(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_funcmem);
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >"), typeid(::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >), sizeof(::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1437, Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::_Tp_alloc_type"))
  .AddTypedef(type_3640, Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::pointer"))
  .AddTypedef(type_1437, Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9654, type_9655), Reflex::Literal("operator="), operator_5383, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9655), Reflex::Literal("_Vector_base"), constructor_5384, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5388, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9232), Reflex::Literal("_Vector_base"), constructor_5389, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5390, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9232), Reflex::Literal("_Vector_base"), constructor_5391, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5392, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1574, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5381, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9463), Reflex::Literal("_M_get_Tp_allocator"), method_5385, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9232), Reflex::Literal("_M_get_Tp_allocator"), method_5386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1437), Reflex::Literal("get_allocator"), method_5387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3640, type_1527), Reflex::Literal("_M_allocate"), method_5393, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3640, type_1527), Reflex::Literal("_M_deallocate"), method_5394, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
static  void operator_5401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
  else   (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
}

static void constructor_5402( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
}

static  void method_5403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<coral::Attribute*>)((((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->get_allocator)();
}

static void constructor_5406( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >();
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >();
}

static void constructor_5407( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_5408( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5409( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::Attribute*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::Attribute*>*)arg[1]);
}

static void destructor_5410(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::~_Vector_base();
}
static  void method_5411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5412( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_deallocate)((::coral::Attribute**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1575( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class*);
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__datamem_bld(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__funcmem_bld(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_funcmem);
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >"), typeid(::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >), sizeof(::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1440, Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::_Tp_alloc_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::pointer"))
  .AddTypedef(type_1440, Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9665, type_9666), Reflex::Literal("operator="), operator_5401, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9666), Reflex::Literal("_Vector_base"), constructor_5402, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5406, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9235), Reflex::Literal("_Vector_base"), constructor_5407, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527), Reflex::Literal("_Vector_base"), constructor_5408, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1527, type_9235), Reflex::Literal("_Vector_base"), constructor_5409, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5410, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1575, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5399, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9470), Reflex::Literal("_M_get_Tp_allocator"), method_5403, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9235), Reflex::Literal("_M_get_Tp_allocator"), method_5404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1440), Reflex::Literal("get_allocator"), method_5405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054, type_1527), Reflex::Literal("_M_allocate"), method_5411, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3054, type_1527), Reflex::Literal("_M_deallocate"), method_5412, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class type_info -------------------------------
static void destructor_5521(void*, void * o, const std::vector<void*>&, void *) {
((::std::type_info*)o)->::std::type_info::~type_info();
}
static  void method_5522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::type_info*)o)->name)());
  else   (((const ::std::type_info*)o)->name)();
}

static  void method_5523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->before)(*(const ::std::type_info*)arg[0]));
  else   (((const ::std::type_info*)o)->before)(*(const ::std::type_info*)arg[0]);
}

static  void operator_5524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->operator==)(*(const ::std::type_info*)arg[0]));
  else   (((const ::std::type_info*)o)->operator==)(*(const ::std::type_info*)arg[0]);
}

static  void operator_5525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->operator!=)(*(const ::std::type_info*)arg[0]));
  else   (((const ::std::type_info*)o)->operator!=)(*(const ::std::type_info*)arg[0]);
}

static  void method_5526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__is_pointer_p)());
  else   (((const ::std::type_info*)o)->__is_pointer_p)();
}

static  void method_5527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__is_function_p)());
  else   (((const ::std::type_info*)o)->__is_function_p)();
}

static  void method_5528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__do_catch)((const ::std::type_info*)arg[0],
    (void**)arg[1],
    *(unsigned int*)arg[2]));
  else   (((const ::std::type_info*)o)->__do_catch)((const ::std::type_info*)arg[0],
    (void**)arg[1],
    *(unsigned int*)arg[2]);
}

static  void method_5529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__do_upcast)((const ::__cxxabiv1::__class_type_info*)arg[0],
    (void**)arg[1]));
  else   (((const ::std::type_info*)o)->__do_upcast)((const ::__cxxabiv1::__class_type_info*)arg[0],
    (void**)arg[1]);
}

//------Dictionary for class type_info -------------------------------
void __std__type_info_db_datamem(Reflex::Class*);
void __std__type_info_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__type_info_datamem_bld(&__std__type_info_db_datamem);
Reflex::GenreflexMemberBuilder __std__type_info_funcmem_bld(&__std__type_info_db_funcmem);
void __std__type_info_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::type_info"), typeid(::std::type_info), sizeof(::std::type_info), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~type_info"), destructor_5521, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__std__type_info_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__type_info_funcmem_bld);
}

//------Delayed data member builder for class type_info -------------------
void __std__type_info_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1731, Reflex::Literal("__name"), OffsetOf(__shadow__::__std__type_info, __name), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class type_info -------------------
void __std__type_info_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1731), Reflex::Literal("name"), method_5522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9682), Reflex::Literal("before"), method_5523, 0, "__arg", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9682), Reflex::Literal("operator=="), operator_5524, 0, "__arg", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9682), Reflex::Literal("operator!="), operator_5525, 0, "__arg", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("__is_pointer_p"), method_5526, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("__is_function_p"), method_5527, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9683, type_1895, type_75), Reflex::Literal("__do_catch"), method_5528, 0, "__thr_type;__thr_obj;__outer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9684, type_1895), Reflex::Literal("__do_upcast"), method_5529, 0, "__target;__obj_ptr", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------------------
static void destructor_6574(void*, void * o, const std::vector<void*>&, void *) {
((::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)o)->::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>::~__are_same();
}
static  void operator_6575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)o)->operator=)(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
  else   (((::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)o)->operator=)(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
}

static void constructor_6576( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
  else ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
}

static void constructor_6577( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>();
  else ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>();
}

static void method_newdel_1711( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------------------
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_datamem(Reflex::Class*);
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__datamem_bld(&__std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_datamem);
Reflex::GenreflexMemberBuilder __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__funcmem_bld(&__std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_funcmem);
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>"), typeid(::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>), sizeof(::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddEnum(Reflex::Literal("_1"), Reflex::Literal("__value=0"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1257, Reflex::Literal("std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__are_same"), destructor_6574, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9782, type_9783), Reflex::Literal("operator="), operator_6575, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9783), Reflex::Literal("__are_same"), constructor_6576, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__are_same"), constructor_6577, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1711, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------------------
static void destructor_6580(void*, void * o, const std::vector<void*>&, void *) {
((::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)o)->::std::__are_same<coral::Attribute* const*,coral::Attribute**>::~__are_same();
}
static  void operator_6581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
  else   (((::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
}

static void constructor_6582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
  else ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
}

static void constructor_6583( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>();
  else ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>();
}

static void method_newdel_1712( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------------------
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_datamem(Reflex::Class*);
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepsconstp_coral__Attributepp__datamem_bld(&__std____are_same_coral__Attributepsconstp_coral__Attributepp__db_datamem);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepsconstp_coral__Attributepp__funcmem_bld(&__std____are_same_coral__Attributepsconstp_coral__Attributepp__db_funcmem);
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::__are_same<coral::Attribute* const*,coral::Attribute**>"), typeid(::std::__are_same<coral::Attribute* const*,coral::Attribute**>), sizeof(::std::__are_same<coral::Attribute* const*,coral::Attribute**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddEnum(Reflex::Literal("_1"), Reflex::Literal("__value=0"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1257, Reflex::Literal("std::__are_same<coral::Attribute* const*,coral::Attribute**>::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__are_same"), destructor_6580, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9784, type_9785), Reflex::Literal("operator="), operator_6581, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9785), Reflex::Literal("__are_same"), constructor_6582, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__are_same"), constructor_6583, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1712, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __are_same<coral::Attribute**,coral::Attribute**> -------------------------------
static void destructor_6586(void*, void * o, const std::vector<void*>&, void *) {
((::std::__are_same<coral::Attribute**,coral::Attribute**>*)o)->::std::__are_same<coral::Attribute**,coral::Attribute**>::~__are_same();
}
static  void operator_6587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::__are_same<coral::Attribute**,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
  else   (((::std::__are_same<coral::Attribute**,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
}

static void constructor_6588( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
  else ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
}

static void constructor_6589( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>();
  else ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>();
}

static void method_newdel_1713( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __are_same<coral::Attribute**,coral::Attribute**> -------------------------------
void __std____are_same_coral__Attributepp_coral__Attributepp__db_datamem(Reflex::Class*);
void __std____are_same_coral__Attributepp_coral__Attributepp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepp_coral__Attributepp__datamem_bld(&__std____are_same_coral__Attributepp_coral__Attributepp__db_datamem);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepp_coral__Attributepp__funcmem_bld(&__std____are_same_coral__Attributepp_coral__Attributepp__db_funcmem);
void __std____are_same_coral__Attributepp_coral__Attributepp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::__are_same<coral::Attribute**,coral::Attribute**>"), typeid(::std::__are_same<coral::Attribute**,coral::Attribute**>), sizeof(::std::__are_same<coral::Attribute**,coral::Attribute**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddEnum(Reflex::Literal("_2"), Reflex::Literal("__value=1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1699, Reflex::Literal("std::__are_same<coral::Attribute**,coral::Attribute**>::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__are_same"), destructor_6586, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9786, type_9787), Reflex::Literal("operator="), operator_6587, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9787), Reflex::Literal("__are_same"), constructor_6588, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__are_same"), constructor_6589, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1713, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __are_same<coral::Attribute**,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepp_coral__Attributepp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __are_same<coral::Attribute**,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepp_coral__Attributepp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
static void destructor_6798(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::~__alloc_traits();
}
static  void operator_6799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_6800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_6801( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >();
}

static  void method_6802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->deallocate)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    (::boost::shared_ptr<cool::IRecord>*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6804( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->destroy)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    (::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_6805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_6806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_6807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_S_on_swap)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    *(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[1]);
}

static void method_newdel_1933( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1430, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::allocator_type"))
  .AddTypedef(type_3009, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::pointer"))
  .AddTypedef(type_3233, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::const_pointer"))
  .AddTypedef(type_2288, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::value_type"))
  .AddTypedef(type_3011, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::reference"))
  .AddTypedef(type_3236, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6798, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9828, type_9829), Reflex::Literal("operator="), operator_6799, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9829), Reflex::Literal("__alloc_traits"), constructor_6800, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6801, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1933, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3009, type_9457, type_1527), Reflex::Literal("allocate"), method_6802, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9457, type_3009, type_1527), Reflex::Literal("deallocate"), method_6803, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9457, type_3009), Reflex::Literal("destroy"), method_6804, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9199), Reflex::Literal("max_size"), method_6805, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9199, type_9199), Reflex::Literal("_S_select_on_copy"), method_6806, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9457, type_9457), Reflex::Literal("_S_on_swap"), method_6807, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
static void destructor_6816(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::~__alloc_traits();
}
static  void operator_6817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_6818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_6819( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >();
}

static  void method_6820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->deallocate)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    (::boost::shared_ptr<cool::IObject>*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->destroy)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    (::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_6823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_6824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_6825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_S_on_swap)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    *(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[1]);
}

static void method_newdel_1934( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1431, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::allocator_type"))
  .AddTypedef(type_3020, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::pointer"))
  .AddTypedef(type_3299, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::const_pointer"))
  .AddTypedef(type_2180, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::value_type"))
  .AddTypedef(type_3022, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::reference"))
  .AddTypedef(type_3302, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6816, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9830, type_9831), Reflex::Literal("operator="), operator_6817, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9831), Reflex::Literal("__alloc_traits"), constructor_6818, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6819, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1934, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020, type_9458, type_1527), Reflex::Literal("allocate"), method_6820, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9458, type_3020, type_1527), Reflex::Literal("deallocate"), method_6821, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9458, type_3020), Reflex::Literal("destroy"), method_6822, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9203), Reflex::Literal("max_size"), method_6823, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9203, type_9203), Reflex::Literal("_S_select_on_copy"), method_6824, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9458, type_9458), Reflex::Literal("_S_on_swap"), method_6825, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------------------
static void destructor_6834(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::~__alloc_traits();
}
static  void operator_6835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static void constructor_6836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static void constructor_6837( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >();
}

static  void method_6838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->allocate)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->allocate)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->deallocate)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    (::cool::IRecordSelection**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->destroy)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    (::cool::IRecordSelection**)arg[1]);
}

static  void method_6841( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->max_size)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->max_size)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static  void method_6842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static  void method_6843( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->_S_on_swap)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    *(::std::allocator<cool::IRecordSelection*>*)arg[1]);
}

static void method_newdel_1935( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1433, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::allocator_type"))
  .AddTypedef(type_3434, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::pointer"))
  .AddTypedef(type_3436, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::const_pointer"))
  .AddTypedef(type_3428, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::value_type"))
  .AddTypedef(type_3438, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::reference"))
  .AddTypedef(type_3440, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6834, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9832, type_9833), Reflex::Literal("operator="), operator_6835, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9833), Reflex::Literal("__alloc_traits"), constructor_6836, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6837, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1935, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434, type_9460, type_1527), Reflex::Literal("allocate"), method_6838, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9460, type_3434, type_1527), Reflex::Literal("deallocate"), method_6839, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9460, type_3434), Reflex::Literal("destroy"), method_6840, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9211), Reflex::Literal("max_size"), method_6841, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9211, type_9211), Reflex::Literal("_S_select_on_copy"), method_6842, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9460, type_9460), Reflex::Literal("_S_on_swap"), method_6843, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::IField*> > -------------------------------
static void destructor_6852(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::~__alloc_traits();
}
static  void operator_6853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
}

static void constructor_6854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
}

static void constructor_6855( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >();
}

static  void method_6856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->allocate)(*(::std::allocator<cool::IField*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->allocate)(*(::std::allocator<cool::IField*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->deallocate)(*(::std::allocator<cool::IField*>*)arg[0],
    (::cool::IField**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->destroy)(*(::std::allocator<cool::IField*>*)arg[0],
    (::cool::IField**)arg[1]);
}

static  void method_6859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->max_size)(*(const ::std::allocator<cool::IField*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->max_size)(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static  void method_6860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static  void method_6861( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->_S_on_swap)(*(::std::allocator<cool::IField*>*)arg[0],
    *(::std::allocator<cool::IField*>*)arg[1]);
}

static void method_newdel_1936( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::IField*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1432, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::allocator_type"))
  .AddTypedef(type_3365, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::pointer"))
  .AddTypedef(type_3367, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::const_pointer"))
  .AddTypedef(type_3359, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::value_type"))
  .AddTypedef(type_3369, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::reference"))
  .AddTypedef(type_3371, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6852, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9834, type_9835), Reflex::Literal("operator="), operator_6853, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9835), Reflex::Literal("__alloc_traits"), constructor_6854, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6855, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1936, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::IField*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::IField*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3365, type_9459, type_1527), Reflex::Literal("allocate"), method_6856, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9459, type_3365, type_1527), Reflex::Literal("deallocate"), method_6857, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9459, type_3365), Reflex::Literal("destroy"), method_6858, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9207), Reflex::Literal("max_size"), method_6859, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9207, type_9207), Reflex::Literal("_S_select_on_copy"), method_6860, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9459, type_9459), Reflex::Literal("_S_on_swap"), method_6861, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------------------
static void destructor_6870(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::~__alloc_traits();
}
static  void operator_6871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static void constructor_6872( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static void constructor_6873( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >();
}

static  void method_6874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->allocate)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->allocate)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->deallocate)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    (::cool::IFieldSpecification**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6876( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->destroy)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    (::cool::IFieldSpecification**)arg[1]);
}

static  void method_6877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->max_size)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->max_size)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_6878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_6879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->_S_on_swap)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    *(::std::allocator<cool::IFieldSpecification*>*)arg[1]);
}

static void method_newdel_1937( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1435, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::allocator_type"))
  .AddTypedef(type_3503, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::pointer"))
  .AddTypedef(type_3505, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::const_pointer"))
  .AddTypedef(type_3497, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::value_type"))
  .AddTypedef(type_3507, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::reference"))
  .AddTypedef(type_3509, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6870, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9836, type_9837), Reflex::Literal("operator="), operator_6871, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9837), Reflex::Literal("__alloc_traits"), constructor_6872, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6873, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1937, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3503, type_9461, type_1527), Reflex::Literal("allocate"), method_6874, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9461, type_3503, type_1527), Reflex::Literal("deallocate"), method_6875, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9461, type_3503), Reflex::Literal("destroy"), method_6876, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9215), Reflex::Literal("max_size"), method_6877, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9215, type_9215), Reflex::Literal("_S_select_on_copy"), method_6878, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9461, type_9461), Reflex::Literal("_S_on_swap"), method_6879, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
static void destructor_6888(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::~__alloc_traits();
}
static  void operator_6889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static void constructor_6890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static void constructor_6891( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >();
}

static  void method_6892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->allocate)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->allocate)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6893( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->deallocate)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    (::cool::ChannelSelection::ChannelRange*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6894( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->destroy)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    (::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_6895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->max_size)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->max_size)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_6896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_6897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_S_on_swap)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    *(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[1]);
}

static void method_newdel_1938( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1436, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::allocator_type"))
  .AddTypedef(type_3572, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::pointer"))
  .AddTypedef(type_3574, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::const_pointer"))
  .AddTypedef(type_3566, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::value_type"))
  .AddTypedef(type_3576, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::reference"))
  .AddTypedef(type_3578, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9838, type_9839), Reflex::Literal("operator="), operator_6889, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9839), Reflex::Literal("__alloc_traits"), constructor_6890, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6891, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1938, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572, type_9462, type_1527), Reflex::Literal("allocate"), method_6892, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9462, type_3572, type_1527), Reflex::Literal("deallocate"), method_6893, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9462, type_3572), Reflex::Literal("destroy"), method_6894, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9229), Reflex::Literal("max_size"), method_6895, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9229, type_9229), Reflex::Literal("_S_select_on_copy"), method_6896, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9462, type_9462), Reflex::Literal("_S_on_swap"), method_6897, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------------------
static void destructor_6924(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::~__alloc_traits();
}
static  void operator_6925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_6926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_6927( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >();
}

static  void method_6928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->allocate)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->allocate)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6929( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->deallocate)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    (::coral::AttributeSpecification**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6930( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->destroy)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    (::coral::AttributeSpecification**)arg[1]);
}

static  void method_6931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->max_size)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->max_size)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_6932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_6933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->_S_on_swap)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    *(::std::allocator<coral::AttributeSpecification*>*)arg[1]);
}

static void method_newdel_1941( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1437, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::allocator_type"))
  .AddTypedef(type_3640, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::pointer"))
  .AddTypedef(type_3042, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::const_pointer"))
  .AddTypedef(type_3039, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::value_type"))
  .AddTypedef(type_3643, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::reference"))
  .AddTypedef(type_3044, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6924, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9842, type_9843), Reflex::Literal("operator="), operator_6925, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9843), Reflex::Literal("__alloc_traits"), constructor_6926, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3640, type_9463, type_1527), Reflex::Literal("allocate"), method_6928, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9463, type_3640, type_1527), Reflex::Literal("deallocate"), method_6929, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9463, type_3640), Reflex::Literal("destroy"), method_6930, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9232), Reflex::Literal("max_size"), method_6931, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9232, type_9232), Reflex::Literal("_S_select_on_copy"), method_6932, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9463, type_9463), Reflex::Literal("_S_on_swap"), method_6933, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------------------
static void destructor_6942(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::~__alloc_traits();
}
static  void operator_6943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
}

static void constructor_6944( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
}

static void constructor_6945( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >();
}

static  void method_6946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->allocate)(*(::std::allocator<coral::Attribute*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->allocate)(*(::std::allocator<coral::Attribute*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->deallocate)(*(::std::allocator<coral::Attribute*>*)arg[0],
    (::coral::Attribute**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6948( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->destroy)(*(::std::allocator<coral::Attribute*>*)arg[0],
    (::coral::Attribute**)arg[1]);
}

static  void method_6949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->max_size)(*(const ::std::allocator<coral::Attribute*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->max_size)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static  void method_6950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static  void method_6951( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->_S_on_swap)(*(::std::allocator<coral::Attribute*>*)arg[0],
    *(::std::allocator<coral::Attribute*>*)arg[1]);
}

static void method_newdel_1942( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1440, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::allocator_type"))
  .AddTypedef(type_3054, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::pointer"))
  .AddTypedef(type_3065, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::const_pointer"))
  .AddTypedef(type_3051, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::value_type"))
  .AddTypedef(type_3056, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::reference"))
  .AddTypedef(type_3067, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::const_reference"))
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6942, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9844, type_9845), Reflex::Literal("operator="), operator_6943, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9845), Reflex::Literal("__alloc_traits"), constructor_6944, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6945, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1942, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054, type_9470, type_1527), Reflex::Literal("allocate"), method_6946, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9470, type_3054, type_1527), Reflex::Literal("deallocate"), method_6947, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9470, type_3054), Reflex::Literal("destroy"), method_6948, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527, type_9235), Reflex::Literal("max_size"), method_6949, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9235, type_9235), Reflex::Literal("_S_select_on_copy"), method_6950, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9470, type_9470), Reflex::Literal("_S_on_swap"), method_6951, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
static void destructor_6973(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >::~rebind();
}
static  void operator_6974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_6975( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_6976( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >();
}

static void method_newdel_1947( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1430, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_6973, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9854, type_9855), Reflex::Literal("operator="), operator_6974, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9855), Reflex::Literal("rebind"), constructor_6975, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_6976, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1947, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
static void destructor_6978(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >::~rebind();
}
static  void operator_6979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_6980( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_6981( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >();
}

static void method_newdel_1948( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1431, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_6978, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9856, type_9857), Reflex::Literal("operator="), operator_6979, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9857), Reflex::Literal("rebind"), constructor_6980, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_6981, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1948, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IRecordSelection*> -------------------------------
static void destructor_6983(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>::~rebind();
}
static  void operator_6984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_6985( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_6986( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>();
}

static void method_newdel_1949( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IRecordSelection*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1433, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_6983, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9858, type_9859), Reflex::Literal("operator="), operator_6984, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9859), Reflex::Literal("rebind"), constructor_6985, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_6986, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1949, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IRecordSelection*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IRecordSelection*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IField*> -------------------------------
static void destructor_6988(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>::~rebind();
}
static  void operator_6989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
}

static void constructor_6990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
}

static void constructor_6991( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>();
}

static void method_newdel_1950( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IField*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1432, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_6988, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9860, type_9861), Reflex::Literal("operator="), operator_6989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9861), Reflex::Literal("rebind"), constructor_6990, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_6991, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1950, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IField*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IField*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IFieldSpecification*> -------------------------------
static void destructor_6993(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>::~rebind();
}
static  void operator_6994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_6995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_6996( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>();
}

static void method_newdel_1951( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IFieldSpecification*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1435, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_6993, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9862, type_9863), Reflex::Literal("operator="), operator_6994, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9863), Reflex::Literal("rebind"), constructor_6995, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_6996, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1951, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IFieldSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IFieldSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
static void destructor_6998(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>::~rebind();
}
static  void operator_6999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_7000( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_7001( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>();
}

static void method_newdel_1952( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1436, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_6998, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9864, type_9865), Reflex::Literal("operator="), operator_6999, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9865), Reflex::Literal("rebind"), constructor_7000, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7001, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1952, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::AttributeSpecification*> -------------------------------
static void destructor_7013(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>::~rebind();
}
static  void operator_7014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_7015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_7016( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>();
}

static void method_newdel_1955( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::AttributeSpecification*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1437, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7013, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9870, type_9871), Reflex::Literal("operator="), operator_7014, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9871), Reflex::Literal("rebind"), constructor_7015, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7016, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1955, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::AttributeSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::AttributeSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::Attribute*> -------------------------------
static void destructor_7018(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>::~rebind();
}
static  void operator_7019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_7020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_7021( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>();
}

static void method_newdel_1956( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::Attribute*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1440, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7018, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9872, type_9873), Reflex::Literal("operator="), operator_7019, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9873), Reflex::Literal("rebind"), constructor_7020, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7021, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1956, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::Attribute*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::Attribute*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
static  void operator_7101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_7102( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >();
}

static void constructor_7103( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void destructor_7104(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::~new_allocator();
}
static  void method_7105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(::boost::shared_ptr<cool::IRecord>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_7106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_7107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7108( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->deallocate)((::boost::shared_ptr<cool::IRecord>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->max_size)();
}

static  void method_7110( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->construct)((::boost::shared_ptr<cool::IRecord>*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_7111( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->destroy)((::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static void method_newdel_1961( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__datamem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >"), typeid(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >), sizeof(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::difference_type"))
  .AddTypedef(type_3009, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::pointer"))
  .AddTypedef(type_3233, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::const_pointer"))
  .AddTypedef(type_3011, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::reference"))
  .AddTypedef(type_3236, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::const_reference"))
  .AddTypedef(type_2288, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9882, type_9883), Reflex::Literal("operator="), operator_7101, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7102, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9883), Reflex::Literal("new_allocator"), constructor_7103, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7104, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1961, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3009, type_3011), Reflex::Literal("address"), method_7105, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3233, type_3236), Reflex::Literal("address"), method_7106, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3009, type_1527, type_1914), Reflex::Literal("allocate"), method_7107, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3009, type_1527), Reflex::Literal("deallocate"), method_7108, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3009, type_3236), Reflex::Literal("construct"), method_7110, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3009), Reflex::Literal("destroy"), method_7111, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------------------
static  void operator_7119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_7120( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >();
}

static void constructor_7121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void destructor_7122(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::~new_allocator();
}
static  void method_7123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(::boost::shared_ptr<cool::IObject>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_7124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_7125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->deallocate)((::boost::shared_ptr<cool::IObject>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->max_size)();
}

static  void method_7128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->construct)((::boost::shared_ptr<cool::IObject>*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_7129( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->destroy)((::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static void method_newdel_1962( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__datamem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__funcmem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_funcmem);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >"), typeid(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >), sizeof(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::difference_type"))
  .AddTypedef(type_3020, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::pointer"))
  .AddTypedef(type_3299, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::const_pointer"))
  .AddTypedef(type_3022, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::reference"))
  .AddTypedef(type_3302, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::const_reference"))
  .AddTypedef(type_2180, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9884, type_9885), Reflex::Literal("operator="), operator_7119, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7120, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9885), Reflex::Literal("new_allocator"), constructor_7121, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7122, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1962, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020, type_3022), Reflex::Literal("address"), method_7123, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3299, type_3302), Reflex::Literal("address"), method_7124, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020, type_1527, type_1914), Reflex::Literal("allocate"), method_7125, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3020, type_1527), Reflex::Literal("deallocate"), method_7126, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3020, type_3302), Reflex::Literal("construct"), method_7128, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3020), Reflex::Literal("destroy"), method_7129, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::IRecordSelection*> -------------------------------
static  void operator_7137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_7138( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>();
}

static void constructor_7139( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
}

static void destructor_7140(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->::__gnu_cxx::new_allocator<cool::IRecordSelection*>::~new_allocator();
}
static  void method_7141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection**)arg[0]);
}

static  void method_7142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection* const*)arg[0]);
}

static  void method_7143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->deallocate)((::cool::IRecordSelection**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->max_size)();
}

static  void method_7146( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->construct)((::cool::IRecordSelection**)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]);
}

static  void method_7147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->destroy)((::cool::IRecordSelection**)arg[0]);
}

static void method_newdel_1963( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::IRecordSelection*> -------------------------------
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IRecordSelectionp__datamem_bld(&____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IRecordSelectionp__funcmem_bld(&____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_funcmem);
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>"), typeid(::__gnu_cxx::new_allocator<cool::IRecordSelection*>), sizeof(::__gnu_cxx::new_allocator<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::difference_type"))
  .AddTypedef(type_3434, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::pointer"))
  .AddTypedef(type_3436, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::const_pointer"))
  .AddTypedef(type_3438, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::reference"))
  .AddTypedef(type_3440, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::const_reference"))
  .AddTypedef(type_3428, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9886, type_9887), Reflex::Literal("operator="), operator_7137, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7138, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9887), Reflex::Literal("new_allocator"), constructor_7139, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7140, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1963, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__IRecordSelectionp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::IRecordSelection*> -------------------
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::IRecordSelection*> -------------------
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434, type_3438), Reflex::Literal("address"), method_7141, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3436, type_3440), Reflex::Literal("address"), method_7142, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3434, type_1527, type_1914), Reflex::Literal("allocate"), method_7143, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3434, type_1527), Reflex::Literal("deallocate"), method_7144, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3434, type_3440), Reflex::Literal("construct"), method_7146, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3434), Reflex::Literal("destroy"), method_7147, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::IField*> -------------------------------
static  void operator_7155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
}

static void constructor_7156( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>();
}

static void constructor_7157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
}

static void destructor_7158(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::IField*>*)o)->::__gnu_cxx::new_allocator<cool::IField*>::~new_allocator();
}
static  void method_7159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField**)arg[0]);
}

static  void method_7160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField* const*)arg[0]);
}

static  void method_7161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->deallocate)((::cool::IField**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->max_size)();
}

static  void method_7164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->construct)((::cool::IField**)arg[0],
    *(::cool::IField* const*)arg[1]);
}

static  void method_7165( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->destroy)((::cool::IField**)arg[0]);
}

static void method_newdel_1964( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::IField*> -------------------------------
void ____gnu_cxx__new_allocator_cool__IFieldp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldp__datamem_bld(&____gnu_cxx__new_allocator_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldp__funcmem_bld(&____gnu_cxx__new_allocator_cool__IFieldp__db_funcmem);
void ____gnu_cxx__new_allocator_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>"), typeid(::__gnu_cxx::new_allocator<cool::IField*>), sizeof(::__gnu_cxx::new_allocator<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::difference_type"))
  .AddTypedef(type_3365, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::pointer"))
  .AddTypedef(type_3367, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::const_pointer"))
  .AddTypedef(type_3369, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::reference"))
  .AddTypedef(type_3371, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::const_reference"))
  .AddTypedef(type_3359, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9888, type_9889), Reflex::Literal("operator="), operator_7155, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7156, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9889), Reflex::Literal("new_allocator"), constructor_7157, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7158, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1964, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__IFieldp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::IField*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::IField*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3365, type_3369), Reflex::Literal("address"), method_7159, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3367, type_3371), Reflex::Literal("address"), method_7160, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3365, type_1527, type_1914), Reflex::Literal("allocate"), method_7161, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3365, type_1527), Reflex::Literal("deallocate"), method_7162, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3365, type_3371), Reflex::Literal("construct"), method_7164, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3365), Reflex::Literal("destroy"), method_7165, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::IFieldSpecification*> -------------------------------
static  void operator_7173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_7174( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>();
}

static void constructor_7175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void destructor_7176(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->::__gnu_cxx::new_allocator<cool::IFieldSpecification*>::~new_allocator();
}
static  void method_7177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification**)arg[0]);
}

static  void method_7178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification* const*)arg[0]);
}

static  void method_7179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7180( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->deallocate)((::cool::IFieldSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->max_size)();
}

static  void method_7182( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->construct)((::cool::IFieldSpecification**)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]);
}

static  void method_7183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->destroy)((::cool::IFieldSpecification**)arg[0]);
}

static void method_newdel_1965( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::IFieldSpecification*> -------------------------------
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__datamem_bld(&____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__funcmem_bld(&____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_funcmem);
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>"), typeid(::__gnu_cxx::new_allocator<cool::IFieldSpecification*>), sizeof(::__gnu_cxx::new_allocator<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::difference_type"))
  .AddTypedef(type_3503, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::pointer"))
  .AddTypedef(type_3505, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::const_pointer"))
  .AddTypedef(type_3507, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::reference"))
  .AddTypedef(type_3509, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::const_reference"))
  .AddTypedef(type_3497, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9890, type_9891), Reflex::Literal("operator="), operator_7173, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7174, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9891), Reflex::Literal("new_allocator"), constructor_7175, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7176, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1965, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__IFieldSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::IFieldSpecification*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::IFieldSpecification*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3503, type_3507), Reflex::Literal("address"), method_7177, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_3509), Reflex::Literal("address"), method_7178, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3503, type_1527, type_1914), Reflex::Literal("allocate"), method_7179, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3503, type_1527), Reflex::Literal("deallocate"), method_7180, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3503, type_3509), Reflex::Literal("construct"), method_7182, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3503), Reflex::Literal("destroy"), method_7183, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------------------
static  void operator_7191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_7192( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>();
}

static void constructor_7193( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void destructor_7194(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::~new_allocator();
}
static  void method_7195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(::cool::ChannelSelection::ChannelRange*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static  void method_7196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static  void method_7197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->deallocate)((::cool::ChannelSelection::ChannelRange*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->max_size)();
}

static  void method_7200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->construct)((::cool::ChannelSelection::ChannelRange*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_7201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->destroy)((::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static void method_newdel_1966( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------------------
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__datamem_bld(&____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__funcmem_bld(&____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_funcmem);
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>"), typeid(::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>), sizeof(::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::difference_type"))
  .AddTypedef(type_3572, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::pointer"))
  .AddTypedef(type_3574, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::const_pointer"))
  .AddTypedef(type_3576, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::reference"))
  .AddTypedef(type_3578, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::const_reference"))
  .AddTypedef(type_3566, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9892, type_9893), Reflex::Literal("operator="), operator_7191, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7192, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9893), Reflex::Literal("new_allocator"), constructor_7193, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7194, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1966, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572, type_3576), Reflex::Literal("address"), method_7195, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3574, type_3578), Reflex::Literal("address"), method_7196, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572, type_1527, type_1914), Reflex::Literal("allocate"), method_7197, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3572, type_1527), Reflex::Literal("deallocate"), method_7198, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3572, type_3578), Reflex::Literal("construct"), method_7200, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3572), Reflex::Literal("destroy"), method_7201, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<coral::AttributeSpecification*> -------------------------------
static  void operator_7245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_7246( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>();
}

static void constructor_7247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void destructor_7248(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->::__gnu_cxx::new_allocator<coral::AttributeSpecification*>::~new_allocator();
}
static  void method_7249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification**)arg[0]);
}

static  void method_7250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification* const*)arg[0]);
}

static  void method_7251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7252( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->deallocate)((::coral::AttributeSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->max_size)();
}

static  void method_7254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->construct)((::coral::AttributeSpecification**)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]);
}

static  void method_7255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->destroy)((::coral::AttributeSpecification**)arg[0]);
}

static void method_newdel_1969( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<coral::AttributeSpecification*> -------------------------------
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__datamem_bld(&____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__funcmem_bld(&____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_funcmem);
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>"), typeid(::__gnu_cxx::new_allocator<coral::AttributeSpecification*>), sizeof(::__gnu_cxx::new_allocator<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::difference_type"))
  .AddTypedef(type_3640, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::pointer"))
  .AddTypedef(type_3042, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::const_pointer"))
  .AddTypedef(type_3643, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::reference"))
  .AddTypedef(type_3044, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::const_reference"))
  .AddTypedef(type_3039, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9898, type_9899), Reflex::Literal("operator="), operator_7245, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7246, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9899), Reflex::Literal("new_allocator"), constructor_7247, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7248, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1969, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_coral__AttributeSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<coral::AttributeSpecification*> -------------------
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<coral::AttributeSpecification*> -------------------
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3640, type_3643), Reflex::Literal("address"), method_7249, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3042, type_3044), Reflex::Literal("address"), method_7250, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3640, type_1527, type_1914), Reflex::Literal("allocate"), method_7251, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3640, type_1527), Reflex::Literal("deallocate"), method_7252, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3640, type_3044), Reflex::Literal("construct"), method_7254, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3640), Reflex::Literal("destroy"), method_7255, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<coral::Attribute*> -------------------------------
static  void operator_7263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_7264( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>();
}

static void constructor_7265( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
}

static void destructor_7266(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->::__gnu_cxx::new_allocator<coral::Attribute*>::~new_allocator();
}
static  void method_7267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute**)arg[0]);
}

static  void method_7268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute* const*)arg[0]);
}

static  void method_7269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7270( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->deallocate)((::coral::Attribute**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->max_size)();
}

static  void method_7272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->construct)((::coral::Attribute**)arg[0],
    *(::coral::Attribute* const*)arg[1]);
}

static  void method_7273( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->destroy)((::coral::Attribute**)arg[0]);
}

static void method_newdel_1970( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<coral::Attribute*> -------------------------------
void ____gnu_cxx__new_allocator_coral__Attributep__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__Attributep__datamem_bld(&____gnu_cxx__new_allocator_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__Attributep__funcmem_bld(&____gnu_cxx__new_allocator_coral__Attributep__db_funcmem);
void ____gnu_cxx__new_allocator_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>"), typeid(::__gnu_cxx::new_allocator<coral::Attribute*>), sizeof(::__gnu_cxx::new_allocator<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1527, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::size_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::difference_type"))
  .AddTypedef(type_3054, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::pointer"))
  .AddTypedef(type_3065, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::const_pointer"))
  .AddTypedef(type_3056, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::reference"))
  .AddTypedef(type_3067, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::const_reference"))
  .AddTypedef(type_3051, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9900, type_9901), Reflex::Literal("operator="), operator_7263, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7264, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9901), Reflex::Literal("new_allocator"), constructor_7265, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7266, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1970, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_coral__Attributep__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<coral::Attribute*> -------------------
void ____gnu_cxx__new_allocator_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<coral::Attribute*> -------------------
void ____gnu_cxx__new_allocator_coral__Attributep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054, type_3056), Reflex::Literal("address"), method_7267, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3065, type_3067), Reflex::Literal("address"), method_7268, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054, type_1527, type_1914), Reflex::Literal("allocate"), method_7269, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3054, type_1527), Reflex::Literal("deallocate"), method_7270, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1527), Reflex::Literal("max_size"), method_7271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3054, type_3067), Reflex::Literal("construct"), method_7272, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3054), Reflex::Literal("destroy"), method_7273, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
static void destructor_7386(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)o)->::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >::~__enable_if();
}
static  void operator_7387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7388( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7389( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >();
}

static void method_newdel_2005( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__datamem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__funcmem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_funcmem);
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >"), typeid(::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >), sizeof(::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__enable_if"), destructor_7386, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9954, type_9955), Reflex::Literal("operator="), operator_7387, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9955), Reflex::Literal("__enable_if"), constructor_7388, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__enable_if"), constructor_7389, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2005, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7390(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >::~__enable_if();
}
static  void operator_7391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7393( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >();
}

static void method_newdel_2006( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__enable_if"), destructor_7390, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9956, type_9957), Reflex::Literal("operator="), operator_7391, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9957), Reflex::Literal("__enable_if"), constructor_7392, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__enable_if"), constructor_7393, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2006, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7395(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >::~__enable_if();
}
static  void operator_7396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7397( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7398( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >();
}

static void method_newdel_2007( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1297, Reflex::Literal("__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__enable_if"), destructor_7395, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9958, type_9959), Reflex::Literal("operator="), operator_7396, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9959), Reflex::Literal("__enable_if"), constructor_7397, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__enable_if"), constructor_7398, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2007, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
static void destructor_7442(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::~__normal_iterator();
}
static  void operator_7443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_7444( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_7445( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >();
}

static void constructor_7446( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(::boost::shared_ptr<cool::IRecord>* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(::boost::shared_ptr<cool::IRecord>* const*)arg[0]);
}

static  void operator_7447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
}

static  void operator_7448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)();
}

static  void operator_7449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)();
}

static  void operator_7450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)();
}

static  void operator_7452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->base)();
}

static void method_newdel_2021( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >"), typeid(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >), sizeof(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1279, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::__traits_type"))
  .AddTypedef(type_3009, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::iterator_type"))
  .AddTypedef(type_1423, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::iterator_category"))
  .AddTypedef(type_2288, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::difference_type"))
  .AddTypedef(type_3011, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::reference"))
  .AddTypedef(type_3009, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7442, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9974, type_9975), Reflex::Literal("operator="), operator_7443, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9975), Reflex::Literal("__normal_iterator"), constructor_7444, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7445, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9976), Reflex::Literal("__normal_iterator"), constructor_7446, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2021, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3009, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011), Reflex::Literal("operator*"), operator_7447, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3009), Reflex::Literal("operator->"), operator_7448, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9974), Reflex::Literal("operator++"), operator_7449, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021, type_30), Reflex::Literal("operator++"), operator_7450, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9974), Reflex::Literal("operator--"), operator_7451, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021, type_30), Reflex::Literal("operator--"), operator_7452, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3011, type_1471), Reflex::Literal("operator[]"), operator_7453, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9974, type_1471), Reflex::Literal("operator+="), operator_7454, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021, type_1471), Reflex::Literal("operator+"), operator_7455, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9974, type_1471), Reflex::Literal("operator-="), operator_7456, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021, type_1471), Reflex::Literal("operator-"), operator_7457, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9976), Reflex::Literal("base"), method_7458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
static void destructor_7467(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::~__normal_iterator();
}
static  void operator_7468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_7469( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_7470( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >();
}

static void constructor_7471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(::boost::shared_ptr<cool::IObject>* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(::boost::shared_ptr<cool::IObject>* const*)arg[0]);
}

static  void operator_7472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
}

static  void operator_7473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)();
}

static  void operator_7474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)();
}

static  void operator_7475( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)();
}

static  void operator_7477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7478( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7480( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->base)();
}

static void method_newdel_2023( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >"), typeid(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >), sizeof(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1280, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::__traits_type"))
  .AddTypedef(type_3020, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::iterator_type"))
  .AddTypedef(type_1423, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::iterator_category"))
  .AddTypedef(type_2180, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::difference_type"))
  .AddTypedef(type_3022, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::reference"))
  .AddTypedef(type_3020, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7467, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9977, type_9978), Reflex::Literal("operator="), operator_7468, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9978), Reflex::Literal("__normal_iterator"), constructor_7469, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7470, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9979), Reflex::Literal("__normal_iterator"), constructor_7471, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2023, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3020, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022), Reflex::Literal("operator*"), operator_7472, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3020), Reflex::Literal("operator->"), operator_7473, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9977), Reflex::Literal("operator++"), operator_7474, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023, type_30), Reflex::Literal("operator++"), operator_7475, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9977), Reflex::Literal("operator--"), operator_7476, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023, type_30), Reflex::Literal("operator--"), operator_7477, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3022, type_1471), Reflex::Literal("operator[]"), operator_7478, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9977, type_1471), Reflex::Literal("operator+="), operator_7479, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023, type_1471), Reflex::Literal("operator+"), operator_7480, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9977, type_1471), Reflex::Literal("operator-="), operator_7481, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023, type_1471), Reflex::Literal("operator-"), operator_7482, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9979), Reflex::Literal("base"), method_7483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
static void destructor_7517(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::~__normal_iterator();
}
static  void operator_7518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7519( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7520( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >();
}

static void constructor_7521( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(::coral::AttributeSpecification* const* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(::coral::AttributeSpecification* const* const*)arg[0]);
}

static  void operator_7522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator*)();
}

static  void operator_7523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator->)();
}

static  void operator_7524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)();
}

static  void operator_7525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)();
}

static  void operator_7527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->base)();
}

static void method_newdel_2034( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__datamem_bld(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__funcmem_bld(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_funcmem);
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >"), typeid(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >), sizeof(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1282, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::__traits_type"))
  .AddTypedef(type_3042, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::iterator_type"))
  .AddTypedef(type_1423, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::iterator_category"))
  .AddTypedef(type_3039, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::difference_type"))
  .AddTypedef(type_3044, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::reference"))
  .AddTypedef(type_3042, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7517, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9983, type_7369), Reflex::Literal("operator="), operator_7518, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7369), Reflex::Literal("__normal_iterator"), constructor_7519, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7520, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9984), Reflex::Literal("__normal_iterator"), constructor_7521, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2034, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3042, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044), Reflex::Literal("operator*"), operator_7522, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3042), Reflex::Literal("operator->"), operator_7523, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9983), Reflex::Literal("operator++"), operator_7524, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2034, type_30), Reflex::Literal("operator++"), operator_7525, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9983), Reflex::Literal("operator--"), operator_7526, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2034, type_30), Reflex::Literal("operator--"), operator_7527, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044, type_1471), Reflex::Literal("operator[]"), operator_7528, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9983, type_1471), Reflex::Literal("operator+="), operator_7529, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2034, type_1471), Reflex::Literal("operator+"), operator_7530, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9983, type_1471), Reflex::Literal("operator-="), operator_7531, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2034, type_1471), Reflex::Literal("operator-"), operator_7532, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9984), Reflex::Literal("base"), method_7533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7542(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::~__normal_iterator();
}
static  void operator_7543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7545( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >();
}

static void constructor_7546( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(::coral::Attribute** const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(::coral::Attribute** const*)arg[0]);
}

static  void operator_7547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator*)();
}

static  void operator_7548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator->)();
}

static  void operator_7549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)();
}

static  void operator_7550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)();
}

static  void operator_7552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->base)();
}

static void method_newdel_2036( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1283, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::__traits_type"))
  .AddTypedef(type_3054, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::iterator_type"))
  .AddTypedef(type_1423, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::iterator_category"))
  .AddTypedef(type_3051, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::difference_type"))
  .AddTypedef(type_3056, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::reference"))
  .AddTypedef(type_3054, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7542, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9985, type_9986), Reflex::Literal("operator="), operator_7543, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9986), Reflex::Literal("__normal_iterator"), constructor_7544, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7545, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9987), Reflex::Literal("__normal_iterator"), constructor_7546, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2036, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3054, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("operator*"), operator_7547, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054), Reflex::Literal("operator->"), operator_7548, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9985), Reflex::Literal("operator++"), operator_7549, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036, type_30), Reflex::Literal("operator++"), operator_7550, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9985), Reflex::Literal("operator--"), operator_7551, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036, type_30), Reflex::Literal("operator--"), operator_7552, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1471), Reflex::Literal("operator[]"), operator_7553, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9985, type_1471), Reflex::Literal("operator+="), operator_7554, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036, type_1471), Reflex::Literal("operator+"), operator_7555, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9985, type_1471), Reflex::Literal("operator-="), operator_7556, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2036, type_1471), Reflex::Literal("operator-"), operator_7557, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9987), Reflex::Literal("base"), method_7558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7567(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::~__normal_iterator();
}
static  void operator_7568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7569( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7570( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >();
}

static void constructor_7571( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(::coral::Attribute* const* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(::coral::Attribute* const* const*)arg[0]);
}

static  void operator_7572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator*)();
}

static  void operator_7573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator->)();
}

static  void operator_7574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)();
}

static  void operator_7575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)();
}

static  void operator_7577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7579( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->base)();
}

static void method_newdel_2037( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1284, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::__traits_type"))
  .AddTypedef(type_3065, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::iterator_type"))
  .AddTypedef(type_1423, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::iterator_category"))
  .AddTypedef(type_3051, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::value_type"))
  .AddTypedef(type_1471, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::difference_type"))
  .AddTypedef(type_3067, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::reference"))
  .AddTypedef(type_3065, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7567, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9988, type_7370), Reflex::Literal("operator="), operator_7568, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7370), Reflex::Literal("__normal_iterator"), constructor_7569, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7570, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9989), Reflex::Literal("__normal_iterator"), constructor_7571, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2037, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3065, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3067), Reflex::Literal("operator*"), operator_7572, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3065), Reflex::Literal("operator->"), operator_7573, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9988), Reflex::Literal("operator++"), operator_7574, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2037, type_30), Reflex::Literal("operator++"), operator_7575, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9988), Reflex::Literal("operator--"), operator_7576, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2037, type_30), Reflex::Literal("operator--"), operator_7577, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3067, type_1471), Reflex::Literal("operator[]"), operator_7578, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9988, type_1471), Reflex::Literal("operator+="), operator_7579, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2037, type_1471), Reflex::Literal("operator+"), operator_7580, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9988, type_1471), Reflex::Literal("operator-="), operator_7581, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2037, type_1471), Reflex::Literal("operator-"), operator_7582, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9989), Reflex::Literal("base"), method_7583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IObjectIterator -------------------------------
static void destructor_7681(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IObjectIterator*)o)->::cool::IObjectIterator::~IObjectIterator();
}
static  void method_7682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IObjectIterator*)o)->isEmpty)());
  else   (((::cool::IObjectIterator*)o)->isEmpty)();
}

static  void method_7683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IObjectIterator*)o)->goToNext)());
  else   (((::cool::IObjectIterator*)o)->goToNext)();
}

static  void method_7684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::IObjectIterator*)o)->currentRef)();
  else   (((::cool::IObjectIterator*)o)->currentRef)();
}

static  void method_7685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::cool::IObjectIterator*)o)->size)());
  else   (((::cool::IObjectIterator*)o)->size)();
}

static  void method_7686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IObjectVectorPtr)((((::cool::IObjectIterator*)o)->fetchAllAsVector)());
  else   (((::cool::IObjectIterator*)o)->fetchAllAsVector)();
}

static  void method_7687( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IObjectIterator*)o)->close)();
}

//------Dictionary for class IObjectIterator -------------------------------
void __cool__IObjectIterator_db_datamem(Reflex::Class*);
void __cool__IObjectIterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IObjectIterator_datamem_bld(&__cool__IObjectIterator_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IObjectIterator_funcmem_bld(&__cool__IObjectIterator_db_funcmem);
void __cool__IObjectIterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IObjectIterator"), typeid(::cool::IObjectIterator), sizeof(::cool::IObjectIterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IObjectIterator"), destructor_7681, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IObjectIterator_funcmem_bld);
}

//------Delayed data member builder for class IObjectIterator -------------------
void __cool__IObjectIterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IObjectIterator -------------------
void __cool__IObjectIterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isEmpty"), method_7682, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("goToNext"), method_7683, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8417), Reflex::Literal("currentRef"), method_7684, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75), Reflex::Literal("size"), method_7685, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2224c), Reflex::Literal("fetchAllAsVector"), method_7686, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("close"), method_7687, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class FieldSelection -------------------------------
static  void method_7692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Relation*)arg[0]));
  else   (((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Relation*)arg[0]);
}

static  void method_7693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Nullness*)arg[0]));
  else   (((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Nullness*)arg[0]);
}

static void destructor_7694(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSelection*)o)->::cool::FieldSelection::~FieldSelection();
}
static void constructor_7707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Nullness*)arg[2]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Nullness*)arg[2]);
}

static  void method_7708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::FieldSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::FieldSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_7710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::FieldSelection*)o)->clone)());
  else   (((const ::cool::FieldSelection*)o)->clone)();
}

static  void method_7711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::FieldSelection*)o)->nullness)());
  else   (((const ::cool::FieldSelection*)o)->nullness)();
}

static  void method_7712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::FieldSelection*)o)->relation)());
  else   (((const ::cool::FieldSelection*)o)->relation)();
}

static  void method_7713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FieldSelection*)o)->referenceValue)();
  else   (((const ::cool::FieldSelection*)o)->referenceValue)();
}

static void constructor_7695( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::coral::Blob*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::coral::Blob*)arg[3]);
}

static void constructor_7696( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
}

static void constructor_7697( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const double*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const double*)arg[3]);
}

static void constructor_7698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const float*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const float*)arg[3]);
}

static void constructor_7699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned long long*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned long long*)arg[3]);
}

static void constructor_7700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const long long*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const long long*)arg[3]);
}

static void constructor_7701( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned int*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned int*)arg[3]);
}

static void constructor_7702( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const int*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const int*)arg[3]);
}

static void constructor_7703( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned short*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned short*)arg[3]);
}

static void constructor_7704( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const short*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const short*)arg[3]);
}

static void constructor_7705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned char*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned char*)arg[3]);
}

static void constructor_7706( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const bool*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const bool*)arg[3]);
}

static void method_x110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSelection")), ::Reflex::BaseOffset< ::cool::FieldSelection,::cool::IRecordSelection >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSelection -------------------------------
void __cool__FieldSelection_db_datamem(Reflex::Class*);
void __cool__FieldSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSelection_datamem_bld(&__cool__FieldSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSelection_funcmem_bld(&__cool__FieldSelection_db_funcmem);
void __cool__FieldSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSelection"), typeid(::cool::FieldSelection), sizeof(::cool::FieldSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2225, ::Reflex::BaseOffset< ::cool::FieldSelection, ::cool::IRecordSelection >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("cool::FieldSelection::Relation"), Reflex::Literal("EQ=0;NE=1;GT=2;GE=3;LT=4;LE=5"), &typeid(cool::FieldSelection::Relation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("cool::FieldSelection::Nullness"), Reflex::Literal("IS_NULL=0;IS_NOT_NULL=1"), &typeid(cool::FieldSelection::Nullness), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSelection"), destructor_7694, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_7597c, type_7691), Reflex::Literal("FieldSelection"), constructor_7707, 0, "name;typeId;nullness", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10015), Reflex::Literal("FieldSelection<coral::Blob>"), constructor_7695, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_3103), Reflex::Literal("FieldSelection<std::string>"), constructor_7696, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10016), Reflex::Literal("FieldSelection<double>"), constructor_7697, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10017), Reflex::Literal("FieldSelection<float>"), constructor_7698, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10018), Reflex::Literal("FieldSelection<unsigned long long>"), constructor_7699, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10019), Reflex::Literal("FieldSelection<long long>"), constructor_7700, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_3170), Reflex::Literal("FieldSelection<unsigned int>"), constructor_7701, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_5911), Reflex::Literal("FieldSelection<int>"), constructor_7702, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10020), Reflex::Literal("FieldSelection<unsigned short>"), constructor_7703, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10021), Reflex::Literal("FieldSelection<short>"), constructor_7704, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_10022), Reflex::Literal("FieldSelection<unsigned char>"), constructor_7705, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103, type_7597c, type_7599, type_5910), Reflex::Literal("FieldSelection<bool>"), constructor_7706, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FieldSelection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FieldSelection_funcmem_bld);
}

//------Delayed data member builder for class FieldSelection -------------------
void __cool__FieldSelection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2199, Reflex::Literal("m_refValue"), OffsetOf(__shadow__::__cool__FieldSelection, m_refValue), ::Reflex::PRIVATE)
  .AddDataMember(type_7599, Reflex::Literal("m_relation"), OffsetOf(__shadow__::__cool__FieldSelection, m_relation), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FieldSelection -------------------
void __cool__FieldSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_7599), Reflex::Literal("describe"), method_7692, 0, "relation", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_7691), Reflex::Literal("describe"), method_7693, 0, "nullness", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10023), Reflex::Literal("canSelect"), method_7708, 0, "spec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8419), Reflex::Literal("select"), method_7709, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3428), Reflex::Literal("clone"), method_7710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7691), Reflex::Literal("nullness"), method_7711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7599), Reflex::Literal("relation"), method_7712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420), Reflex::Literal("referenceValue"), method_7713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FieldSpecificationWrongStorageType -------------------------------
static  void operator_7718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldSpecificationWrongStorageType*)o)->operator=)(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
  else   (((::cool::FieldSpecificationWrongStorageType*)o)->operator=)(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
}

static void constructor_7719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
  else ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
}

static void constructor_7720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::cool::StorageType*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::cool::StorageType*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_7721(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecificationWrongStorageType*)o)->::cool::FieldSpecificationWrongStorageType::~FieldSpecificationWrongStorageType();
}
static void method_x111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecificationWrongStorageType -------------------------------
void __cool__FieldSpecificationWrongStorageType_db_datamem(Reflex::Class*);
void __cool__FieldSpecificationWrongStorageType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongStorageType_datamem_bld(&__cool__FieldSpecificationWrongStorageType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongStorageType_funcmem_bld(&__cool__FieldSpecificationWrongStorageType_db_funcmem);
void __cool__FieldSpecificationWrongStorageType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecificationWrongStorageType"), typeid(::cool::FieldSpecificationWrongStorageType), sizeof(::cool::FieldSpecificationWrongStorageType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10026, type_10027), Reflex::Literal("operator="), operator_7718, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10027), Reflex::Literal("FieldSpecificationWrongStorageType"), constructor_7719, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10028, type_10028, type_4025), Reflex::Literal("FieldSpecificationWrongStorageType"), constructor_7720, 0, "expectedName;expectedStorageType;actualStorageType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecificationWrongStorageType"), destructor_7721, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldSpecificationWrongStorageType -------------------
void __cool__FieldSpecificationWrongStorageType_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldSpecificationWrongStorageType -------------------
void __cool__FieldSpecificationWrongStorageType_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagNotFound -------------------------------
static  void operator_7723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagNotFound*)o)->operator=)(*(const ::cool::TagNotFound*)arg[0]);
  else   (((::cool::TagNotFound*)o)->operator=)(*(const ::cool::TagNotFound*)arg[0]);
}

static void constructor_7724( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::cool::TagNotFound*)arg[0]);
  else ::new(mem) ::cool::TagNotFound(*(const ::cool::TagNotFound*)arg[0]);
}

static void constructor_7725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_7726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_7727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_7728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::TagNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7729(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagNotFound*)o)->::cool::TagNotFound::~TagNotFound();
}
static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagNotFound -------------------------------
void __cool__TagNotFound_db_datamem(Reflex::Class*);
void __cool__TagNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagNotFound_datamem_bld(&__cool__TagNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagNotFound_funcmem_bld(&__cool__TagNotFound_db_funcmem);
void __cool__TagNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagNotFound"), typeid(::cool::TagNotFound), sizeof(::cool::TagNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::TagNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10029, type_10030), Reflex::Literal("operator="), operator_7723, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10030), Reflex::Literal("TagNotFound"), constructor_7724, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("TagNotFound"), constructor_7725, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_4025), Reflex::Literal("TagNotFound"), constructor_7726, 0, "tagName;nodeName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_2256, type_4025), Reflex::Literal("TagNotFound"), constructor_7727, 0, "tagName;nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_2256, type_4025), Reflex::Literal("TagNotFound"), constructor_7728, 0, "tagId;nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagNotFound"), destructor_7729, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagNotFound -------------------
void __cool__TagNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagNotFound -------------------
void __cool__TagNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PayloadSpecificationTooManyFields -------------------------------
static  void operator_7730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationTooManyFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
  else   (((::cool::PayloadSpecificationTooManyFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
}

static void constructor_7731( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
}

static void constructor_7732( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_7733(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationTooManyFields*)o)->::cool::PayloadSpecificationTooManyFields::~PayloadSpecificationTooManyFields();
}
static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationTooManyFields -------------------------------
void __cool__PayloadSpecificationTooManyFields_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationTooManyFields_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyFields_datamem_bld(&__cool__PayloadSpecificationTooManyFields_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyFields_funcmem_bld(&__cool__PayloadSpecificationTooManyFields_db_funcmem);
void __cool__PayloadSpecificationTooManyFields_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyFields"), typeid(::cool::PayloadSpecificationTooManyFields), sizeof(::cool::PayloadSpecificationTooManyFields), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2204, ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10031, type_10032), Reflex::Literal("operator="), operator_7730, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10032), Reflex::Literal("PayloadSpecificationTooManyFields"), constructor_7731, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_4025), Reflex::Literal("PayloadSpecificationTooManyFields"), constructor_7732, 0, "nFields;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationTooManyFields"), destructor_7733, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationTooManyFields -------------------
void __cool__PayloadSpecificationTooManyFields_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationTooManyFields -------------------
void __cool__PayloadSpecificationTooManyFields_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ChannelExists -------------------------------
static  void operator_7734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelExists*)o)->operator=)(*(const ::cool::ChannelExists*)arg[0]);
  else   (((::cool::ChannelExists*)o)->operator=)(*(const ::cool::ChannelExists*)arg[0]);
}

static void constructor_7735( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelExists(*(const ::cool::ChannelExists*)arg[0]);
  else ::new(mem) ::cool::ChannelExists(*(const ::cool::ChannelExists*)arg[0]);
}

static void constructor_7736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_7737( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7738(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelExists*)o)->::cool::ChannelExists::~ChannelExists();
}
static void method_x114( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ChannelExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ChannelExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ChannelExists -------------------------------
void __cool__ChannelExists_db_datamem(Reflex::Class*);
void __cool__ChannelExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelExists_datamem_bld(&__cool__ChannelExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelExists_funcmem_bld(&__cool__ChannelExists_db_funcmem);
void __cool__ChannelExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelExists"), typeid(::cool::ChannelExists), sizeof(::cool::ChannelExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::ChannelExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10033, type_10034), Reflex::Literal("operator="), operator_7734, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10034), Reflex::Literal("ChannelExists"), constructor_7735, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_4025), Reflex::Literal("ChannelExists"), constructor_7736, 0, "folderName;channelName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10035, type_4025), Reflex::Literal("ChannelExists"), constructor_7737, 0, "folderName;channelId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelExists"), destructor_7738, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ChannelExists -------------------
void __cool__ChannelExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ChannelExists -------------------
void __cool__ChannelExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IField -------------------------------
static void destructor_7741(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IField*)o)->::cool::IField::~IField();
}
static  void method_7742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->specification)();
  else   (((const ::cool::IField*)o)->specification)();
}

static  void method_7743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->name)();
  else   (((const ::cool::IField*)o)->name)();
}

static  void method_7744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->storageType)();
  else   (((const ::cool::IField*)o)->storageType)();
}

static  void method_7745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IField*)o)->isNull)());
  else   (((const ::cool::IField*)o)->isNull)();
}

static  void method_7758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IField*)o)->addressOfData)());
  else   (((const ::cool::IField*)o)->addressOfData)();
}

static  void method_7759( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IField*)o)->setNull)();
}

static  void method_7772( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue)(*(const ::cool::IField*)arg[0]);
}

static  void operator_7773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IField*)o)->operator==)(*(const ::cool::IField*)arg[0]));
  else   (((const ::cool::IField*)o)->operator==)(*(const ::cool::IField*)arg[0]);
}

static  void operator_7774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IField*)o)->operator!=)(*(const ::cool::IField*)arg[0]));
  else   (((const ::cool::IField*)o)->operator!=)(*(const ::cool::IField*)arg[0]);
}

static  void method_7775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IField*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void method_7776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->printValue)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IField*)o)->printValue)(*(::std::ostream*)arg[0]);
}

static  void method_7777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->attribute)();
  else   (((const ::cool::IField*)o)->attribute)();
}

static  void method_7746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<coral::Blob>)();
  else   (((const ::cool::IField*)o)->data<coral::Blob>)();
}

static  void method_7747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<std::string>)();
  else   (((const ::cool::IField*)o)->data<std::string>)();
}

static  void method_7748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<double>)();
  else   (((const ::cool::IField*)o)->data<double>)();
}

static  void method_7749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<float>)();
  else   (((const ::cool::IField*)o)->data<float>)();
}

static  void method_7750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned long long>)();
  else   (((const ::cool::IField*)o)->data<unsigned long long>)();
}

static  void method_7751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<long long>)();
  else   (((const ::cool::IField*)o)->data<long long>)();
}

static  void method_7752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned int>)();
  else   (((const ::cool::IField*)o)->data<unsigned int>)();
}

static  void method_7753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<int>)();
  else   (((const ::cool::IField*)o)->data<int>)();
}

static  void method_7754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned short>)();
  else   (((const ::cool::IField*)o)->data<unsigned short>)();
}

static  void method_7755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<short>)();
  else   (((const ::cool::IField*)o)->data<short>)();
}

static  void method_7756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned char>)();
  else   (((const ::cool::IField*)o)->data<unsigned char>)();
}

static  void method_7757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<bool>)();
  else   (((const ::cool::IField*)o)->data<bool>)();
}

static  void method_7760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<coral::Blob>)(*(const ::coral::Blob*)arg[0]);
}

static  void method_7761( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<std::string>)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_7762( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<double>)(*(const double*)arg[0]);
}

static  void method_7763( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<float>)(*(const float*)arg[0]);
}

static  void method_7764( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned long long>)(*(const ::cool::UInt63*)arg[0]);
}

static  void method_7765( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<long long>)(*(const ::cool::Int64*)arg[0]);
}

static  void method_7766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned int>)(*(const ::cool::UInt32*)arg[0]);
}

static  void method_7767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<int>)(*(const ::cool::Int32*)arg[0]);
}

static  void method_7768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned short>)(*(const ::cool::UInt16*)arg[0]);
}

static  void method_7769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<short>)(*(const ::cool::Int16*)arg[0]);
}

static  void method_7770( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned char>)(*(const ::cool::UChar*)arg[0]);
}

static  void method_7771( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<bool>)(*(const bool*)arg[0]);
}

//------Dictionary for class IField -------------------------------
void __cool__IField_db_datamem(Reflex::Class*);
void __cool__IField_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IField_datamem_bld(&__cool__IField_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IField_funcmem_bld(&__cool__IField_db_funcmem);
void __cool__IField_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IField"), typeid(::cool::IField), sizeof(::cool::IField), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IField"), destructor_7741, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IField_funcmem_bld);
}

//------Delayed data member builder for class IField -------------------
void __cool__IField_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IField -------------------
void __cool__IField_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10036), Reflex::Literal("specification"), method_7742, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("name"), method_7743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10028), Reflex::Literal("storageType"), method_7744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isNull"), method_7745, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914), Reflex::Literal("addressOfData"), method_7758, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("setNull"), method_7759, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8420), Reflex::Literal("setValue"), method_7772, 0, "field", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8420), Reflex::Literal("operator=="), operator_7773, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8420), Reflex::Literal("operator!="), operator_7774, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415), Reflex::Literal("print"), method_7775, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415), Reflex::Literal("printValue"), method_7776, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8804), Reflex::Literal("attribute"), method_7777, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10015), Reflex::Literal("data<coral::Blob>"), method_7746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103), Reflex::Literal("data<std::string>"), method_7747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10016), Reflex::Literal("data<double>"), method_7748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10017), Reflex::Literal("data<float>"), method_7749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10018), Reflex::Literal("data<unsigned long long>"), method_7750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10019), Reflex::Literal("data<long long>"), method_7751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3170), Reflex::Literal("data<unsigned int>"), method_7752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5911), Reflex::Literal("data<int>"), method_7753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10020), Reflex::Literal("data<unsigned short>"), method_7754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10021), Reflex::Literal("data<short>"), method_7755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10022), Reflex::Literal("data<unsigned char>"), method_7756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5910), Reflex::Literal("data<bool>"), method_7757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10015), Reflex::Literal("setValue<coral::Blob>"), method_7760, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3103), Reflex::Literal("setValue<std::string>"), method_7761, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10016), Reflex::Literal("setValue<double>"), method_7762, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10017), Reflex::Literal("setValue<float>"), method_7763, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10037), Reflex::Literal("setValue<unsigned long long>"), method_7764, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7605), Reflex::Literal("setValue<long long>"), method_7765, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7604), Reflex::Literal("setValue<unsigned int>"), method_7766, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7602), Reflex::Literal("setValue<int>"), method_7767, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7636), Reflex::Literal("setValue<unsigned short>"), method_7768, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7606), Reflex::Literal("setValue<short>"), method_7769, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7608), Reflex::Literal("setValue<unsigned char>"), method_7770, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_5910), Reflex::Literal("setValue<bool>"), method_7771, 0, "value", ::Reflex::PUBLIC);
}
//------Stub functions for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
static void destructor_7785(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::~shared_ptr();
}
static void constructor_7786( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_7787( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >();
}

static  void operator_7788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_7789( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->reset)();
}

static  void operator_7790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
}

static  void operator_7791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)();
}

static  void method_7793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->get)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->get)();
}

static  void converter_7794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*)();
}

static  void operator_7795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator!)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator!)();
}

static  void method_7796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->unique)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->unique)();
}

static  void method_7797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->use_count)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->use_count)();
}

static  void method_7798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->swap)(*(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_7799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_7800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_untyped_deleter)();
}

static  void method_7801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void method_newdel_2161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >"), typeid(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >), sizeof(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_1289, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::element_type"))
  .AddTypedef(type_10040, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_7785, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10041), Reflex::Literal("shared_ptr"), constructor_7786, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_7787, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10039, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10042, type_10041), Reflex::Literal("operator="), operator_7788, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_7789, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9201), Reflex::Literal("operator*"), operator_7790, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10039), Reflex::Literal("operator->"), operator_7791, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10039), Reflex::Literal("get"), method_7793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10040), Reflex::Literal("operator std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*"), converter_7794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_7795, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_7796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_7797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10042), Reflex::Literal("swap"), method_7798, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_7799, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_7800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10041), Reflex::Literal("_internal_equiv"), method_7801, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class InvalidChannelRange -------------------------------
static  void operator_7802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidChannelRange*)o)->operator=)(*(const ::cool::InvalidChannelRange*)arg[0]);
  else   (((::cool::InvalidChannelRange*)o)->operator=)(*(const ::cool::InvalidChannelRange*)arg[0]);
}

static void constructor_7803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::InvalidChannelRange*)arg[0]);
  else ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::InvalidChannelRange*)arg[0]);
}

static void constructor_7804( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7805(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidChannelRange*)o)->::cool::InvalidChannelRange::~InvalidChannelRange();
}
static void method_x116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelRange,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelRange,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidChannelRange -------------------------------
void __cool__InvalidChannelRange_db_datamem(Reflex::Class*);
void __cool__InvalidChannelRange_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelRange_datamem_bld(&__cool__InvalidChannelRange_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelRange_funcmem_bld(&__cool__InvalidChannelRange_db_funcmem);
void __cool__InvalidChannelRange_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidChannelRange"), typeid(::cool::InvalidChannelRange), sizeof(::cool::InvalidChannelRange), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::InvalidChannelRange, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10044, type_10045), Reflex::Literal("operator="), operator_7802, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10045), Reflex::Literal("InvalidChannelRange"), constructor_7803, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10035, type_10035, type_4025), Reflex::Literal("InvalidChannelRange"), constructor_7804, 0, "firstChannel;lastChannel;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidChannelRange"), destructor_7805, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidChannelRange -------------------
void __cool__InvalidChannelRange_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidChannelRange -------------------
void __cool__InvalidChannelRange_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeStringTooLong -------------------------------
static  void operator_7806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeStringTooLong*)o)->operator=)(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
  else   (((::cool::StorageTypeStringTooLong*)o)->operator=)(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
}

static void constructor_7807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
  else ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
}

static void constructor_7808( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_7809(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeStringTooLong*)o)->::cool::StorageTypeStringTooLong::~StorageTypeStringTooLong();
}
static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeStringTooLong -------------------------------
void __cool__StorageTypeStringTooLong_db_datamem(Reflex::Class*);
void __cool__StorageTypeStringTooLong_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringTooLong_datamem_bld(&__cool__StorageTypeStringTooLong_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringTooLong_funcmem_bld(&__cool__StorageTypeStringTooLong_db_funcmem);
void __cool__StorageTypeStringTooLong_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeStringTooLong"), typeid(::cool::StorageTypeStringTooLong), sizeof(::cool::StorageTypeStringTooLong), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2277, ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10046, type_10047), Reflex::Literal("operator="), operator_7806, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10047), Reflex::Literal("StorageTypeStringTooLong"), constructor_7807, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10028, type_792, type_4025), Reflex::Literal("StorageTypeStringTooLong"), constructor_7808, 0, "expectedName;expectedStorageType;actualSize;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeStringTooLong"), destructor_7809, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeStringTooLong -------------------
void __cool__StorageTypeStringTooLong_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeStringTooLong -------------------
void __cool__StorageTypeStringTooLong_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFolderSet -------------------------------
static void destructor_7812(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFolderSet*)o)->::cool::IFolderSet::~IFolderSet();
}
static  void method_7813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolders)());
    else     (((::cool::IFolderSet*)o)->listFolders)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolders)(*(bool*)arg[0]));
    else     (((::cool::IFolderSet*)o)->listFolders)(*(bool*)arg[0]);
  }
}

static  void method_7814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolderSets)());
    else     (((::cool::IFolderSet*)o)->listFolderSets)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolderSets)(*(bool*)arg[0]));
    else     (((::cool::IFolderSet*)o)->listFolderSets)(*(bool*)arg[0]);
  }
}

static  void method_7815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSet*)o)->folderSetAttributes)();
  else   (((const ::cool::IFolderSet*)o)->folderSetAttributes)();
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNode")), ::Reflex::BaseOffset< ::cool::IFolderSet,::cool::IHvsNode >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord")), ::Reflex::BaseOffset< ::cool::IFolderSet,::cool::IHvsNodeRecord >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IFolderSet -------------------------------
void __cool__IFolderSet_db_datamem(Reflex::Class*);
void __cool__IFolderSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFolderSet_datamem_bld(&__cool__IFolderSet_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFolderSet_funcmem_bld(&__cool__IFolderSet_db_funcmem);
void __cool__IFolderSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFolderSet"), typeid(::cool::IFolderSet), sizeof(::cool::IFolderSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2228, ::Reflex::BaseOffset< ::cool::IFolderSet, ::cool::IHvsNode >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFolderSet"), destructor_7812, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__IFolderSet_funcmem_bld);
}

//------Delayed data member builder for class IFolderSet -------------------
void __cool__IFolderSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFolderSet -------------------
void __cool__IFolderSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1287, type_1770), Reflex::Literal("listFolders"), method_7813, 0, "ascending=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1287, type_1770), Reflex::Literal("listFolderSets"), method_7814, 0, "ascending=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8419), Reflex::Literal("folderSetAttributes"), method_7815, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class CompositeSelection -------------------------------
static  void method_7820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::CompositeSelection*)o)->describe)(*(::cool::CompositeSelection::Connective*)arg[0]));
  else   (((::cool::CompositeSelection*)o)->describe)(*(::cool::CompositeSelection::Connective*)arg[0]);
}

static void destructor_7821(void*, void * o, const std::vector<void*>&, void *) {
((::cool::CompositeSelection*)o)->::cool::CompositeSelection::~CompositeSelection();
}
static void constructor_7822( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::CompositeSelection((const ::cool::IRecordSelection*)arg[0],
      *(::cool::CompositeSelection::Connective*)arg[1],
      (const ::cool::IRecordSelection*)arg[2]);
  else ::new(mem) ::cool::CompositeSelection((const ::cool::IRecordSelection*)arg[0],
      *(::cool::CompositeSelection::Connective*)arg[1],
      (const ::cool::IRecordSelection*)arg[2]);
}

static void constructor_7823( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::CompositeSelection(*(::cool::CompositeSelection::Connective*)arg[0],
      *(const ::std::vector<const cool::IRecordSelection*>*)arg[1]);
  else ::new(mem) ::cool::CompositeSelection(*(::cool::CompositeSelection::Connective*)arg[0],
      *(const ::std::vector<const cool::IRecordSelection*>*)arg[1]);
}

static  void method_7824( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::CompositeSelection*)o)->connect)(*(::cool::CompositeSelection::Connective*)arg[0],
    (const ::cool::IRecordSelection*)arg[1]);
}

static  void method_7825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::CompositeSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::CompositeSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::CompositeSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::CompositeSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_7827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::CompositeSelection*)o)->clone)());
  else   (((const ::cool::CompositeSelection*)o)->clone)();
}

static  void method_7828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::CompositeSelection*)o)->connective)());
  else   (((const ::cool::CompositeSelection*)o)->connective)();
}

static  void method_7829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::CompositeSelection*)o)->size)());
  else   (((const ::cool::CompositeSelection*)o)->size)();
}

static  void operator_7830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::CompositeSelection*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::cool::CompositeSelection*)o)->operator[])(*(unsigned int*)arg[0]);
}

static void method_x119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSelection")), ::Reflex::BaseOffset< ::cool::CompositeSelection,::cool::IRecordSelection >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CompositeSelection -------------------------------
void __cool__CompositeSelection_db_datamem(Reflex::Class*);
void __cool__CompositeSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__CompositeSelection_datamem_bld(&__cool__CompositeSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__CompositeSelection_funcmem_bld(&__cool__CompositeSelection_db_funcmem);
void __cool__CompositeSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::CompositeSelection"), typeid(::cool::CompositeSelection), sizeof(::cool::CompositeSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2225, ::Reflex::BaseOffset< ::cool::CompositeSelection, ::cool::IRecordSelection >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("cool::CompositeSelection::Connective"), Reflex::Literal("AND=0;OR=1"), &typeid(cool::CompositeSelection::Connective), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CompositeSelection"), destructor_7821, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10050, type_7819, type_10050), Reflex::Literal("CompositeSelection"), constructor_7822, 0, "sel1;conn;sel2", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7819, type_10051), Reflex::Literal("CompositeSelection"), constructor_7823, 0, "conn;selVec", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__CompositeSelection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__CompositeSelection_funcmem_bld);
}

//------Delayed data member builder for class CompositeSelection -------------------
void __cool__CompositeSelection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7819, Reflex::Literal("m_conn"), OffsetOf(__shadow__::__cool__CompositeSelection, m_conn), ::Reflex::PRIVATE)
  .AddDataMember(type_1292, Reflex::Literal("m_selVec"), OffsetOf(__shadow__::__cool__CompositeSelection, m_selVec), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class CompositeSelection -------------------
void __cool__CompositeSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_7819), Reflex::Literal("describe"), method_7820, 0, "conn", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7819, type_10050), Reflex::Literal("connect"), method_7824, 0, "conn;sel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10023), Reflex::Literal("canSelect"), method_7825, 0, "spec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8419), Reflex::Literal("select"), method_7826, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3428), Reflex::Literal("clone"), method_7827, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7819), Reflex::Literal("connective"), method_7828, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75), Reflex::Literal("size"), method_7829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10050, type_75), Reflex::Literal("operator[]"), operator_7830, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class StorageType -------------------------------
static void destructor_7836(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageType*)o)->::cool::StorageType::~StorageType();
}
static  void method_7837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageType*)o)->storageType)(*(const ::cool::StorageType::TypeId*)arg[0]);
  else   (((::cool::StorageType*)o)->storageType)(*(const ::cool::StorageType::TypeId*)arg[0]);
}

static  void method_7838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::StorageType*)o)->id)();
  else   (((const ::cool::StorageType*)o)->id)();
}

static  void method_7839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::StorageType*)o)->name)());
  else   (((const ::cool::StorageType*)o)->name)();
}

static  void method_7840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::StorageType*)o)->cppType)();
  else   (((const ::cool::StorageType*)o)->cppType)();
}

static  void method_7841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::cool::StorageType*)o)->maxSize)());
  else   (((const ::cool::StorageType*)o)->maxSize)();
}

static  void operator_7842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType*)arg[0]);
}

static  void operator_7843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType*)arg[0]);
}

static  void operator_7844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType::TypeId*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType::TypeId*)arg[0]);
}

static  void operator_7845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType::TypeId*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType::TypeId*)arg[0]);
}

//------Dictionary for class StorageType -------------------------------
void __cool__StorageType_db_datamem(Reflex::Class*);
void __cool__StorageType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageType_datamem_bld(&__cool__StorageType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageType_funcmem_bld(&__cool__StorageType_db_funcmem);
void __cool__StorageType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageType"), typeid(::cool::StorageType), sizeof(::cool::StorageType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddEnum(Reflex::Literal("cool::StorageType::TypeId"), Reflex::Literal("Bool=0;UChar=1;Int16=2;UInt16=3;Int32=4;UInt32=5;UInt63=6;Int64=7;Float=8;Double=9;String255=10;String4k=11;String64k=12;String16M=13;Blob64k=14;Blob16M=15"), &typeid(cool::StorageType::TypeId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageType"), destructor_7836, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__cool__StorageType_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__StorageType_funcmem_bld);
}

//------Delayed data member builder for class StorageType -------------------
void __cool__StorageType_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7597c, Reflex::Literal("m_id"), OffsetOf(__shadow__::__cool__StorageType, m_id), ::Reflex::PRIVATE | ::Reflex::CONST);
}
//------Delayed function member builder for class StorageType -------------------
void __cool__StorageType_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10028, type_10054), Reflex::Literal("storageType"), method_7837, 0, "id", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10054), Reflex::Literal("id"), method_7838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c), Reflex::Literal("name"), method_7839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9682), Reflex::Literal("cppType"), method_7840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_792), Reflex::Literal("maxSize"), method_7841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10028), Reflex::Literal("operator=="), operator_7842, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10028), Reflex::Literal("operator!="), operator_7843, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10054), Reflex::Literal("operator=="), operator_7844, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10054), Reflex::Literal("operator!="), operator_7845, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class IRecordSpecification -------------------------------
static void destructor_7853(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecordSpecification*)o)->::cool::IRecordSpecification::~IRecordSpecification();
}
static  void method_7854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecordSpecification*)o)->size)());
  else   (((const ::cool::IRecordSpecification*)o)->size)();
}

static  void operator_7855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void operator_7856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void operator_7858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::IRecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_7859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::IRecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void method_7860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecordSpecification*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void method_7861( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_7862( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0],
      *(bool*)arg[1]);
  }
}

//------Dictionary for class IRecordSpecification -------------------------------
void __cool__IRecordSpecification_db_datamem(Reflex::Class*);
void __cool__IRecordSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecordSpecification_datamem_bld(&__cool__IRecordSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecordSpecification_funcmem_bld(&__cool__IRecordSpecification_db_funcmem);
void __cool__IRecordSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecordSpecification"), typeid(::cool::IRecordSpecification), sizeof(::cool::IRecordSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecordSpecification"), destructor_7853, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecordSpecification_funcmem_bld);
}

//------Delayed data member builder for class IRecordSpecification -------------------
void __cool__IRecordSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecordSpecification -------------------
void __cool__IRecordSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("size"), method_7854, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10023), Reflex::Literal("operator=="), operator_7855, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10023), Reflex::Literal("operator!="), operator_7856, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("exists"), method_7857, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10036, type_2256), Reflex::Literal("operator[]"), operator_7858, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10036, type_4025), Reflex::Literal("operator[]"), operator_7859, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256, type_4025), Reflex::Literal("index"), method_7860, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8419, type_1770), Reflex::Literal("validate"), method_7861, 0, "record;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8803, type_1770), Reflex::Literal("validate"), method_7862, 0, "attributeList;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<cool::IObjectIterator> -------------------------------
static void destructor_7868(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IObjectIterator>*)o)->::boost::shared_ptr<cool::IObjectIterator>::~shared_ptr();
}
static void constructor_7869( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static void constructor_7870( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>();
  else ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>();
}

static  void operator_7871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IObjectIterator>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IObjectIterator>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static  void method_7872( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IObjectIterator>*)o)->reset)();
}

static  void operator_7873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator*)();
}

static  void operator_7874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator->)();
}

static  void method_7876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->get)();
}

static  void converter_7877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*)();
}

static  void operator_7878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator!)();
}

static  void method_7879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->unique)();
}

static  void method_7880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->use_count)();
}

static  void method_7881( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IObjectIterator>*)o)->swap)(*(::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static  void method_7882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_7883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_untyped_deleter)();
}

static  void method_7884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static void method_newdel_2172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IObjectIterator> -------------------------------
void __boost__shared_ptr_cool__IObjectIterator__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IObjectIterator__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObjectIterator__datamem_bld(&__boost__shared_ptr_cool__IObjectIterator__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObjectIterator__funcmem_bld(&__boost__shared_ptr_cool__IObjectIterator__db_funcmem);
void __boost__shared_ptr_cool__IObjectIterator__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>"), typeid(::boost::shared_ptr<cool::IObjectIterator>), sizeof(::boost::shared_ptr<cool::IObjectIterator>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2153, Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>::element_type"))
  .AddTypedef(type_10058, Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_7868, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10059), Reflex::Literal("shared_ptr"), constructor_7869, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_7870, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IObjectIterator__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IObjectIterator__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IObjectIterator> -------------------
void __boost__shared_ptr_cool__IObjectIterator__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10057, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObjectIterator_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObjectIterator_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IObjectIterator> -------------------
void __boost__shared_ptr_cool__IObjectIterator__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10060, type_10059), Reflex::Literal("operator="), operator_7871, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_7872, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10014), Reflex::Literal("operator*"), operator_7873, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10057), Reflex::Literal("operator->"), operator_7874, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10057), Reflex::Literal("get"), method_7876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10058), Reflex::Literal("operator cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*"), converter_7877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_7878, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_7879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_7880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10060), Reflex::Literal("swap"), method_7881, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_7882, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_7883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10059), Reflex::Literal("_internal_equiv"), method_7884, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RecordSpecificationUnknownField -------------------------------
static  void operator_7886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecificationUnknownField*)o)->operator=)(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
  else   (((::cool::RecordSpecificationUnknownField*)o)->operator=)(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
}

static void constructor_7887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
  else ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
}

static void constructor_7888( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_7889( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationUnknownField(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::RecordSpecificationUnknownField(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7890(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecificationUnknownField*)o)->::cool::RecordSpecificationUnknownField::~RecordSpecificationUnknownField();
}
static void method_x121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecificationUnknownField -------------------------------
void __cool__RecordSpecificationUnknownField_db_datamem(Reflex::Class*);
void __cool__RecordSpecificationUnknownField_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationUnknownField_datamem_bld(&__cool__RecordSpecificationUnknownField_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationUnknownField_funcmem_bld(&__cool__RecordSpecificationUnknownField_db_funcmem);
void __cool__RecordSpecificationUnknownField_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecificationUnknownField"), typeid(::cool::RecordSpecificationUnknownField), sizeof(::cool::RecordSpecificationUnknownField), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10061, type_10062), Reflex::Literal("operator="), operator_7886, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10062), Reflex::Literal("RecordSpecificationUnknownField"), constructor_7887, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("RecordSpecificationUnknownField"), constructor_7888, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46c, type_46c, type_4025), Reflex::Literal("RecordSpecificationUnknownField"), constructor_7889, 0, "index;size;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecificationUnknownField"), destructor_7890, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordSpecificationUnknownField -------------------
void __cool__RecordSpecificationUnknownField_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordSpecificationUnknownField -------------------
void __cool__RecordSpecificationUnknownField_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagRelationNotFound -------------------------------
static  void operator_7893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagRelationNotFound*)o)->operator=)(*(const ::cool::TagRelationNotFound*)arg[0]);
  else   (((::cool::TagRelationNotFound*)o)->operator=)(*(const ::cool::TagRelationNotFound*)arg[0]);
}

static void constructor_7894( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationNotFound(*(const ::cool::TagRelationNotFound*)arg[0]);
  else ::new(mem) ::cool::TagRelationNotFound(*(const ::cool::TagRelationNotFound*)arg[0]);
}

static void constructor_7895( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::TagRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_7896(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagRelationNotFound*)o)->::cool::TagRelationNotFound::~TagRelationNotFound();
}
static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagRelationNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagRelationNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagRelationNotFound -------------------------------
void __cool__TagRelationNotFound_db_datamem(Reflex::Class*);
void __cool__TagRelationNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagRelationNotFound_datamem_bld(&__cool__TagRelationNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagRelationNotFound_funcmem_bld(&__cool__TagRelationNotFound_db_funcmem);
void __cool__TagRelationNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagRelationNotFound"), typeid(::cool::TagRelationNotFound), sizeof(::cool::TagRelationNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::TagRelationNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10073, type_10074), Reflex::Literal("operator="), operator_7893, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10074), Reflex::Literal("TagRelationNotFound"), constructor_7894, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_2256, type_2256, type_4025), Reflex::Literal("TagRelationNotFound"), constructor_7895, 0, "parentNodeId;parentTagId;childNodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagRelationNotFound"), destructor_7896, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagRelationNotFound -------------------
void __cool__TagRelationNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagRelationNotFound -------------------
void __cool__TagRelationNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FolderSetNotFound -------------------------------
static  void operator_7919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderSetNotFound*)o)->operator=)(*(const ::cool::FolderSetNotFound*)arg[0]);
  else   (((::cool::FolderSetNotFound*)o)->operator=)(*(const ::cool::FolderSetNotFound*)arg[0]);
}

static void constructor_7920( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSetNotFound(*(const ::cool::FolderSetNotFound*)arg[0]);
  else ::new(mem) ::cool::FolderSetNotFound(*(const ::cool::FolderSetNotFound*)arg[0]);
}

static void constructor_7921( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static void destructor_7922(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderSetNotFound*)o)->::cool::FolderSetNotFound::~FolderSetNotFound();
}
static  void method_7923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FolderSetNotFound*)o)->isFolder)());
  else   (((const ::cool::FolderSetNotFound*)o)->isFolder)();
}

static void method_x123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeNotFound")), ::Reflex::BaseOffset< ::cool::FolderSetNotFound,::cool::NodeNotFound >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FolderSetNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FolderSetNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderSetNotFound -------------------------------
void __cool__FolderSetNotFound_db_datamem(Reflex::Class*);
void __cool__FolderSetNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderSetNotFound_datamem_bld(&__cool__FolderSetNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderSetNotFound_funcmem_bld(&__cool__FolderSetNotFound_db_funcmem);
void __cool__FolderSetNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderSetNotFound"), typeid(::cool::FolderSetNotFound), sizeof(::cool::FolderSetNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2268, ::Reflex::BaseOffset< ::cool::FolderSetNotFound, ::cool::NodeNotFound >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10078, type_10079), Reflex::Literal("operator="), operator_7919, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10079), Reflex::Literal("FolderSetNotFound"), constructor_7920, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_1770), Reflex::Literal("FolderSetNotFound"), constructor_7921, 0, "fullPath;domain;isFolder=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderSetNotFound"), destructor_7922, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FolderSetNotFound_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FolderSetNotFound_funcmem_bld);
}

//------Delayed data member builder for class FolderSetNotFound -------------------
void __cool__FolderSetNotFound_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1770, Reflex::Literal("m_isFolder"), OffsetOf(__shadow__::__cool__FolderSetNotFound, m_isFolder), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FolderSetNotFound -------------------
void __cool__FolderSetNotFound_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isFolder"), method_7923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FieldWrongCppType -------------------------------
static  void operator_7926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldWrongCppType*)o)->operator=)(*(const ::cool::FieldWrongCppType*)arg[0]);
  else   (((::cool::FieldWrongCppType*)o)->operator=)(*(const ::cool::FieldWrongCppType*)arg[0]);
}

static void constructor_7927( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldWrongCppType(*(const ::cool::FieldWrongCppType*)arg[0]);
  else ::new(mem) ::cool::FieldWrongCppType(*(const ::cool::FieldWrongCppType*)arg[0]);
}

static void constructor_7928( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::FieldWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_7929(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldWrongCppType*)o)->::cool::FieldWrongCppType::~FieldWrongCppType();
}
static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldWrongCppType,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldWrongCppType,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldWrongCppType,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldWrongCppType -------------------------------
void __cool__FieldWrongCppType_db_datamem(Reflex::Class*);
void __cool__FieldWrongCppType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldWrongCppType_datamem_bld(&__cool__FieldWrongCppType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldWrongCppType_funcmem_bld(&__cool__FieldWrongCppType_db_funcmem);
void __cool__FieldWrongCppType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldWrongCppType"), typeid(::cool::FieldWrongCppType), sizeof(::cool::FieldWrongCppType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::FieldWrongCppType, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10080, type_10081), Reflex::Literal("operator="), operator_7926, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10081), Reflex::Literal("FieldWrongCppType"), constructor_7927, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10028, type_9682, type_4025), Reflex::Literal("FieldWrongCppType"), constructor_7928, 0, "name;storageType;templateCppType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldWrongCppType"), destructor_7929, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldWrongCppType -------------------
void __cool__FieldWrongCppType_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldWrongCppType -------------------
void __cool__FieldWrongCppType_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class shared_ptr<cool::IFolderSet> -------------------------------
static void destructor_7934(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IFolderSet>*)o)->::boost::shared_ptr<cool::IFolderSet>::~shared_ptr();
}
static void constructor_7935( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolderSet>(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IFolderSet>(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static void constructor_7936( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolderSet>();
  else ::new(mem) ::boost::shared_ptr<cool::IFolderSet>();
}

static  void operator_7937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IFolderSet>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IFolderSet>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static  void method_7938( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IFolderSet>*)o)->reset)();
}

static  void operator_7939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator*)();
}

static  void operator_7940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator->)();
}

static  void method_7942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->get)();
}

static  void converter_7943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*)();
}

static  void operator_7944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator!)();
}

static  void method_7945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->unique)();
}

static  void method_7946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->use_count)();
}

static  void method_7947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IFolderSet>*)o)->swap)(*(::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static  void method_7948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_7949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_untyped_deleter)();
}

static  void method_7950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static void method_newdel_2187( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IFolderSet> -------------------------------
void __boost__shared_ptr_cool__IFolderSet__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IFolderSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolderSet__datamem_bld(&__boost__shared_ptr_cool__IFolderSet__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolderSet__funcmem_bld(&__boost__shared_ptr_cool__IFolderSet__db_funcmem);
void __boost__shared_ptr_cool__IFolderSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolderSet>"), typeid(::boost::shared_ptr<cool::IFolderSet>), sizeof(::boost::shared_ptr<cool::IFolderSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2167, Reflex::Literal("boost::shared_ptr<cool::IFolderSet>::element_type"))
  .AddTypedef(type_10083, Reflex::Literal("boost::shared_ptr<cool::IFolderSet>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_7934, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10084), Reflex::Literal("shared_ptr"), constructor_7935, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_7936, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2187, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IFolderSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IFolderSet__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IFolderSet> -------------------
void __boost__shared_ptr_cool__IFolderSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10082, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolderSet_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolderSet_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IFolderSet> -------------------
void __boost__shared_ptr_cool__IFolderSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10085, type_10084), Reflex::Literal("operator="), operator_7937, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_7938, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10049), Reflex::Literal("operator*"), operator_7939, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10082), Reflex::Literal("operator->"), operator_7940, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10082), Reflex::Literal("get"), method_7942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10083), Reflex::Literal("operator cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*"), converter_7943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_7944, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_7945, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_7946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10085), Reflex::Literal("swap"), method_7947, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_7948, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_7949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10084), Reflex::Literal("_internal_equiv"), method_7950, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FieldSpecificationWrongName -------------------------------
static  void operator_7969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldSpecificationWrongName*)o)->operator=)(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
  else   (((::cool::FieldSpecificationWrongName*)o)->operator=)(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
}

static void constructor_7970( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
  else ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
}

static void constructor_7971( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7972(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecificationWrongName*)o)->::cool::FieldSpecificationWrongName::~FieldSpecificationWrongName();
}
static void method_x126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecificationWrongName -------------------------------
void __cool__FieldSpecificationWrongName_db_datamem(Reflex::Class*);
void __cool__FieldSpecificationWrongName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongName_datamem_bld(&__cool__FieldSpecificationWrongName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongName_funcmem_bld(&__cool__FieldSpecificationWrongName_db_funcmem);
void __cool__FieldSpecificationWrongName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecificationWrongName"), typeid(::cool::FieldSpecificationWrongName), sizeof(::cool::FieldSpecificationWrongName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10087, type_10088), Reflex::Literal("operator="), operator_7969, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10088), Reflex::Literal("FieldSpecificationWrongName"), constructor_7970, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_4025), Reflex::Literal("FieldSpecificationWrongName"), constructor_7971, 0, "expectedName;actualName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecificationWrongName"), destructor_7972, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldSpecificationWrongName -------------------
void __cool__FieldSpecificationWrongName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldSpecificationWrongName -------------------
void __cool__FieldSpecificationWrongName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RecordSpecification -------------------------------
static void destructor_7974(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecification*)o)->::cool::RecordSpecification::~RecordSpecification();
}
static void constructor_7975( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecification();
  else ::new(mem) ::cool::RecordSpecification();
}

static void constructor_7976( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecification(*(const ::cool::RecordSpecification*)arg[0]);
  else ::new(mem) ::cool::RecordSpecification(*(const ::cool::RecordSpecification*)arg[0]);
}

static void constructor_7977( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
  else ::new(mem) ::cool::RecordSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void operator_7978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::RecordSpecification*)arg[0]);
  else   (((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::RecordSpecification*)arg[0]);
}

static  void operator_7979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::IRecordSpecification*)arg[0]);
  else   (((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::cool::StorageType::TypeId*)arg[1]);
}

static  void method_7981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::cool::StorageType*)arg[1]);
}

static  void method_7982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void method_7983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::RecordSpecification*)o)->size)());
  else   (((const ::cool::RecordSpecification*)o)->size)();
}

static  void operator_7985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::RecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void operator_7986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::RecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::RecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void operator_7988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::RecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::RecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_7989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::RecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::RecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void method_7990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::RecordSpecification*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void method_7991( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_7992( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0],
      *(bool*)arg[1]);
  }
}

static void method_newdel_2193( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSpecification")), ::Reflex::BaseOffset< ::cool::RecordSpecification,::cool::IRecordSpecification >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecification -------------------------------
void __cool__RecordSpecification_db_datamem(Reflex::Class*);
void __cool__RecordSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecification_datamem_bld(&__cool__RecordSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecification_funcmem_bld(&__cool__RecordSpecification_db_funcmem);
void __cool__RecordSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecification"), typeid(::cool::RecordSpecification), sizeof(::cool::RecordSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2171, ::Reflex::BaseOffset< ::cool::RecordSpecification, ::cool::IRecordSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecification"), destructor_7974, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RecordSpecification"), constructor_7975, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10089), Reflex::Literal("RecordSpecification"), constructor_7976, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10023), Reflex::Literal("RecordSpecification"), constructor_7977, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2193, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__RecordSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__RecordSpecification_funcmem_bld);
}

//------Delayed data member builder for class RecordSpecification -------------------
void __cool__RecordSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1294, Reflex::Literal("m_fSpecs"), OffsetOf(__shadow__::__cool__RecordSpecification, m_fSpecs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RecordSpecification -------------------
void __cool__RecordSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10090, type_10089), Reflex::Literal("operator="), operator_7978, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10090, type_10023), Reflex::Literal("operator="), operator_7979, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_7597c), Reflex::Literal("extend"), method_7980, 0, "name;typeId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_10028), Reflex::Literal("extend"), method_7981, 0, "name;type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10036), Reflex::Literal("extend"), method_7982, 0, "fldSpec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10023), Reflex::Literal("extend"), method_7983, 0, "recSpec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("size"), method_7984, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10023), Reflex::Literal("operator=="), operator_7985, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10023), Reflex::Literal("operator!="), operator_7986, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("exists"), method_7987, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10036, type_2256), Reflex::Literal("operator[]"), operator_7988, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10036, type_4025), Reflex::Literal("operator[]"), operator_7989, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256, type_4025), Reflex::Literal("index"), method_7990, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8419, type_1770), Reflex::Literal("validate"), method_7991, 0, "record;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8803, type_1770), Reflex::Literal("validate"), method_7992, 0, "attributeList;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class ObjectNotFound -------------------------------
static  void operator_7994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ObjectNotFound*)o)->operator=)(*(const ::cool::ObjectNotFound*)arg[0]);
  else   (((::cool::ObjectNotFound*)o)->operator=)(*(const ::cool::ObjectNotFound*)arg[0]);
}

static void constructor_7995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ObjectNotFound(*(const ::cool::ObjectNotFound*)arg[0]);
  else ::new(mem) ::cool::ObjectNotFound(*(const ::cool::ObjectNotFound*)arg[0]);
}

static void constructor_7996( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_7997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_7998(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ObjectNotFound*)o)->::cool::ObjectNotFound::~ObjectNotFound();
}
static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ObjectNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ObjectNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ObjectNotFound -------------------------------
void __cool__ObjectNotFound_db_datamem(Reflex::Class*);
void __cool__ObjectNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ObjectNotFound_datamem_bld(&__cool__ObjectNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ObjectNotFound_funcmem_bld(&__cool__ObjectNotFound_db_funcmem);
void __cool__ObjectNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ObjectNotFound"), typeid(::cool::ObjectNotFound), sizeof(::cool::ObjectNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::ObjectNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10091, type_10092), Reflex::Literal("operator="), operator_7994, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10092), Reflex::Literal("ObjectNotFound"), constructor_7995, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_4025), Reflex::Literal("ObjectNotFound"), constructor_7996, 0, "objectIdentity;objectContainer;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("ObjectNotFound"), constructor_7997, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ObjectNotFound"), destructor_7998, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ObjectNotFound -------------------
void __cool__ObjectNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ObjectNotFound -------------------
void __cool__ObjectNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ChannelNotFound -------------------------------
static  void operator_8000( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelNotFound*)o)->operator=)(*(const ::cool::ChannelNotFound*)arg[0]);
  else   (((::cool::ChannelNotFound*)o)->operator=)(*(const ::cool::ChannelNotFound*)arg[0]);
}

static void constructor_8001( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelNotFound*)arg[0]);
  else ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelNotFound*)arg[0]);
}

static void constructor_8002( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ChannelNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8003( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8004(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelNotFound*)o)->::cool::ChannelNotFound::~ChannelNotFound();
}
static void method_x130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ChannelNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ChannelNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ChannelNotFound -------------------------------
void __cool__ChannelNotFound_db_datamem(Reflex::Class*);
void __cool__ChannelNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelNotFound_datamem_bld(&__cool__ChannelNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelNotFound_funcmem_bld(&__cool__ChannelNotFound_db_funcmem);
void __cool__ChannelNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelNotFound"), typeid(::cool::ChannelNotFound), sizeof(::cool::ChannelNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::ChannelNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10093, type_10094), Reflex::Literal("operator="), operator_8000, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10094), Reflex::Literal("ChannelNotFound"), constructor_8001, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("ChannelNotFound"), constructor_8002, 0, "channelName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10035, type_4025), Reflex::Literal("ChannelNotFound"), constructor_8003, 0, "channelId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelNotFound"), destructor_8004, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ChannelNotFound -------------------
void __cool__ChannelNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ChannelNotFound -------------------
void __cool__ChannelNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeException -------------------------------
static  void operator_8005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeException*)o)->operator=)(*(const ::cool::StorageTypeException*)arg[0]);
  else   (((::cool::StorageTypeException*)o)->operator=)(*(const ::cool::StorageTypeException*)arg[0]);
}

static void constructor_8006( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeException(*(const ::cool::StorageTypeException*)arg[0]);
  else ::new(mem) ::cool::StorageTypeException(*(const ::cool::StorageTypeException*)arg[0]);
}

static void method_x131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeException,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeException,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeException,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeException -------------------------------
void __cool__StorageTypeException_db_datamem(Reflex::Class*);
void __cool__StorageTypeException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeException_datamem_bld(&__cool__StorageTypeException_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeException_funcmem_bld(&__cool__StorageTypeException_db_funcmem);
void __cool__StorageTypeException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeException"), typeid(::cool::StorageTypeException), sizeof(::cool::StorageTypeException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::StorageTypeException, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10095, type_10096), Reflex::Literal("operator="), operator_8005, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10096), Reflex::Literal("StorageTypeException"), constructor_8006, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeException -------------------
void __cool__StorageTypeException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeException -------------------
void __cool__StorageTypeException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeWrongCppType -------------------------------
static  void operator_8009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeWrongCppType*)o)->operator=)(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
  else   (((::cool::StorageTypeWrongCppType*)o)->operator=)(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
}

static void constructor_8010( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
  else ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
}

static void constructor_8011( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8012(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeWrongCppType*)o)->::cool::StorageTypeWrongCppType::~StorageTypeWrongCppType();
}
static void method_x132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::cool::RecordException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeWrongCppType -------------------------------
void __cool__StorageTypeWrongCppType_db_datamem(Reflex::Class*);
void __cool__StorageTypeWrongCppType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeWrongCppType_datamem_bld(&__cool__StorageTypeWrongCppType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeWrongCppType_funcmem_bld(&__cool__StorageTypeWrongCppType_db_funcmem);
void __cool__StorageTypeWrongCppType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeWrongCppType"), typeid(::cool::StorageTypeWrongCppType), sizeof(::cool::StorageTypeWrongCppType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2197, ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType, ::cool::StorageTypeException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10097, type_10098), Reflex::Literal("operator="), operator_8009, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10098), Reflex::Literal("StorageTypeWrongCppType"), constructor_8010, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10028, type_9682, type_4025), Reflex::Literal("StorageTypeWrongCppType"), constructor_8011, 0, "expectedName;expectedStorageType;actualCppType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeWrongCppType"), destructor_8012, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeWrongCppType -------------------
void __cool__StorageTypeWrongCppType_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeWrongCppType -------------------
void __cool__StorageTypeWrongCppType_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Record -------------------------------
static void destructor_8016(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Record*)o)->::cool::Record::~Record();
}
static void constructor_8017( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record();
  else ::new(mem) ::cool::Record();
}

static void constructor_8018( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0]);
}

static void constructor_8019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IFieldSpecification*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::IFieldSpecification*)arg[0]);
}

static void constructor_8020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
  else ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
}

static void constructor_8021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::Record*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::Record*)arg[0]);
}

static void constructor_8022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IRecord*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::IRecord*)arg[0]);
}

static  void operator_8023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator=)(*(const ::cool::Record*)arg[0]);
  else   (((::cool::Record*)o)->operator=)(*(const ::cool::Record*)arg[0]);
}

static  void operator_8024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator=)(*(const ::cool::IRecord*)arg[0]);
  else   (((::cool::Record*)o)->operator=)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::Record*)o)->extend)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->specification)();
  else   (((const ::cool::Record*)o)->specification)();
}

static  void operator_8027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8028( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8029( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_8030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void method_8031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->attributeList)();
  else   (((const ::cool::Record*)o)->attributeList)();
}

static void method_newdel_2199( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::Record >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::Record >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::Record >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::Record >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::Record >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord")), ::Reflex::BaseOffset< ::cool::Record,::cool::IRecord >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Record -------------------------------
void __cool__Record_db_datamem(Reflex::Class*);
void __cool__Record_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Record_datamem_bld(&__cool__Record_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Record_funcmem_bld(&__cool__Record_db_funcmem);
void __cool__Record_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Record"), typeid(::cool::Record), sizeof(::cool::Record), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2191, ::Reflex::BaseOffset< ::cool::Record, ::cool::IRecord >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Record"), destructor_8016, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Record"), constructor_8017, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10023), Reflex::Literal("Record"), constructor_8018, 0, "spec", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10036), Reflex::Literal("Record"), constructor_8019, 0, "spec", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10023, type_8803), Reflex::Literal("Record"), constructor_8020, 0, "spec;al", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10099), Reflex::Literal("Record"), constructor_8021, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8419), Reflex::Literal("Record"), constructor_8022, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2199, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Record_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Record_funcmem_bld);
}

//------Delayed data member builder for class Record -------------------
void __cool__Record_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2193, Reflex::Literal("m_spec"), OffsetOf(__shadow__::__cool__Record, m_spec), ::Reflex::PRIVATE)
  .AddDataMember(type_2342, Reflex::Literal("m_attrList"), OffsetOf(__shadow__::__cool__Record, m_attrList), ::Reflex::PRIVATE)
  .AddDataMember(type_1291, Reflex::Literal("m_fields"), OffsetOf(__shadow__::__cool__Record, m_fields), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Record -------------------
void __cool__Record_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10100, type_10099), Reflex::Literal("operator="), operator_8023, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10100, type_8419), Reflex::Literal("operator="), operator_8024, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8419), Reflex::Literal("extend"), method_8025, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10023), Reflex::Literal("specification"), method_8026, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420, type_4025), Reflex::Literal("operator[]"), operator_8027, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10038, type_4025), Reflex::Literal("operator[]"), operator_8028, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420, type_2256), Reflex::Literal("operator[]"), operator_8029, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10038, type_2256), Reflex::Literal("operator[]"), operator_8030, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8803), Reflex::Literal("attributeList"), method_8031, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class ValidityKeyException -------------------------------
static  void operator_8035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ValidityKeyException*)o)->operator=)(*(const ::cool::ValidityKeyException*)arg[0]);
  else   (((::cool::ValidityKeyException*)o)->operator=)(*(const ::cool::ValidityKeyException*)arg[0]);
}

static void constructor_8036( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyException(*(const ::cool::ValidityKeyException*)arg[0]);
  else ::new(mem) ::cool::ValidityKeyException(*(const ::cool::ValidityKeyException*)arg[0]);
}

static void constructor_8037( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ValidityKeyException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8038(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ValidityKeyException*)o)->::cool::ValidityKeyException::~ValidityKeyException();
}
static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyException,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ValidityKeyException -------------------------------
void __cool__ValidityKeyException_db_datamem(Reflex::Class*);
void __cool__ValidityKeyException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyException_datamem_bld(&__cool__ValidityKeyException_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyException_funcmem_bld(&__cool__ValidityKeyException_db_funcmem);
void __cool__ValidityKeyException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ValidityKeyException"), typeid(::cool::ValidityKeyException), sizeof(::cool::ValidityKeyException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::ValidityKeyException, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10101, type_10102), Reflex::Literal("operator="), operator_8035, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10102), Reflex::Literal("ValidityKeyException"), constructor_8036, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("ValidityKeyException"), constructor_8037, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValidityKeyException"), destructor_8038, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ValidityKeyException -------------------
void __cool__ValidityKeyException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ValidityKeyException -------------------
void __cool__ValidityKeyException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FieldIsNull -------------------------------
static  void operator_8039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldIsNull*)o)->operator=)(*(const ::cool::FieldIsNull*)arg[0]);
  else   (((::cool::FieldIsNull*)o)->operator=)(*(const ::cool::FieldIsNull*)arg[0]);
}

static void constructor_8040( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldIsNull(*(const ::cool::FieldIsNull*)arg[0]);
  else ::new(mem) ::cool::FieldIsNull(*(const ::cool::FieldIsNull*)arg[0]);
}

static void constructor_8041( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldIsNull(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::FieldIsNull(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8042(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldIsNull*)o)->::cool::FieldIsNull::~FieldIsNull();
}
static void method_x136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldIsNull,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldIsNull,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldIsNull,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldIsNull -------------------------------
void __cool__FieldIsNull_db_datamem(Reflex::Class*);
void __cool__FieldIsNull_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldIsNull_datamem_bld(&__cool__FieldIsNull_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldIsNull_funcmem_bld(&__cool__FieldIsNull_db_funcmem);
void __cool__FieldIsNull_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldIsNull"), typeid(::cool::FieldIsNull), sizeof(::cool::FieldIsNull), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::FieldIsNull, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10103, type_10104), Reflex::Literal("operator="), operator_8039, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10104), Reflex::Literal("FieldIsNull"), constructor_8040, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10028, type_4025), Reflex::Literal("FieldIsNull"), constructor_8041, 0, "name;storageType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldIsNull"), destructor_8042, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldIsNull -------------------
void __cool__FieldIsNull_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldIsNull -------------------
void __cool__FieldIsNull_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class InvalidPayloadSpecification -------------------------------
static  void operator_8043( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidPayloadSpecification*)o)->operator=)(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
  else   (((::cool::InvalidPayloadSpecification*)o)->operator=)(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
}

static void constructor_8044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
  else ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
}

static void constructor_8045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8046(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidPayloadSpecification*)o)->::cool::InvalidPayloadSpecification::~InvalidPayloadSpecification();
}
static void method_x137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidPayloadSpecification -------------------------------
void __cool__InvalidPayloadSpecification_db_datamem(Reflex::Class*);
void __cool__InvalidPayloadSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidPayloadSpecification_datamem_bld(&__cool__InvalidPayloadSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidPayloadSpecification_funcmem_bld(&__cool__InvalidPayloadSpecification_db_funcmem);
void __cool__InvalidPayloadSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidPayloadSpecification"), typeid(::cool::InvalidPayloadSpecification), sizeof(::cool::InvalidPayloadSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2252, ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification, ::cool::InvalidFolderSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10105, type_10106), Reflex::Literal("operator="), operator_8043, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10106), Reflex::Literal("InvalidPayloadSpecification"), constructor_8044, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("InvalidPayloadSpecification"), constructor_8045, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidPayloadSpecification"), destructor_8046, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidPayloadSpecification -------------------
void __cool__InvalidPayloadSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidPayloadSpecification -------------------
void __cool__InvalidPayloadSpecification_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFieldSpecification -------------------------------
static void destructor_8049(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFieldSpecification*)o)->::cool::IFieldSpecification::~IFieldSpecification();
}
static  void method_8050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFieldSpecification*)o)->name)();
  else   (((const ::cool::IFieldSpecification*)o)->name)();
}

static  void method_8051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFieldSpecification*)o)->storageType)();
  else   (((const ::cool::IFieldSpecification*)o)->storageType)();
}

static  void operator_8052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::IFieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void operator_8053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::IFieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void method_8054( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8055( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0],
      *(bool*)arg[1]);
  }
}

//------Dictionary for class IFieldSpecification -------------------------------
void __cool__IFieldSpecification_db_datamem(Reflex::Class*);
void __cool__IFieldSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFieldSpecification_datamem_bld(&__cool__IFieldSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFieldSpecification_funcmem_bld(&__cool__IFieldSpecification_db_funcmem);
void __cool__IFieldSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFieldSpecification"), typeid(::cool::IFieldSpecification), sizeof(::cool::IFieldSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFieldSpecification"), destructor_8049, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IFieldSpecification_funcmem_bld);
}

//------Delayed data member builder for class IFieldSpecification -------------------
void __cool__IFieldSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFieldSpecification -------------------
void __cool__IFieldSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("name"), method_8050, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10028), Reflex::Literal("storageType"), method_8051, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10036), Reflex::Literal("operator=="), operator_8052, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10036), Reflex::Literal("operator!="), operator_8053, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8420, type_1770), Reflex::Literal("validate"), method_8054, 0, "field;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8804, type_1770), Reflex::Literal("validate"), method_8055, 0, "attribute;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class FolderIsSingleVersion -------------------------------
static  void operator_8057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderIsSingleVersion*)o)->operator=)(*(const ::cool::FolderIsSingleVersion*)arg[0]);
  else   (((::cool::FolderIsSingleVersion*)o)->operator=)(*(const ::cool::FolderIsSingleVersion*)arg[0]);
}

static void constructor_8058( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(const ::cool::FolderIsSingleVersion*)arg[0]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(const ::cool::FolderIsSingleVersion*)arg[0]);
}

static void constructor_8059( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_8061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8062(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderIsSingleVersion*)o)->::cool::FolderIsSingleVersion::~FolderIsSingleVersion();
}
static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeIsSingleVersion")), ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion,::cool::NodeIsSingleVersion >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderIsSingleVersion -------------------------------
void __cool__FolderIsSingleVersion_db_datamem(Reflex::Class*);
void __cool__FolderIsSingleVersion_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderIsSingleVersion_datamem_bld(&__cool__FolderIsSingleVersion_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderIsSingleVersion_funcmem_bld(&__cool__FolderIsSingleVersion_db_funcmem);
void __cool__FolderIsSingleVersion_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderIsSingleVersion"), typeid(::cool::FolderIsSingleVersion), sizeof(::cool::FolderIsSingleVersion), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2270, ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion, ::cool::NodeIsSingleVersion >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10108, type_10109), Reflex::Literal("operator="), operator_8057, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10109), Reflex::Literal("FolderIsSingleVersion"), constructor_8058, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("FolderIsSingleVersion"), constructor_8059, 0, "fullPath;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_4025), Reflex::Literal("FolderIsSingleVersion"), constructor_8060, 0, "fullPath;message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_4025), Reflex::Literal("FolderIsSingleVersion"), constructor_8061, 0, "nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderIsSingleVersion"), destructor_8062, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FolderIsSingleVersion -------------------
void __cool__FolderIsSingleVersion_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FolderIsSingleVersion -------------------
void __cool__FolderIsSingleVersion_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ITime -------------------------------
static void destructor_8065(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ITime*)o)->::cool::ITime::~ITime();
}
static  void method_8066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->year)());
  else   (((const ::cool::ITime*)o)->year)();
}

static  void method_8067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->month)());
  else   (((const ::cool::ITime*)o)->month)();
}

static  void method_8068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->day)());
  else   (((const ::cool::ITime*)o)->day)();
}

static  void method_8069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->hour)());
  else   (((const ::cool::ITime*)o)->hour)();
}

static  void method_8070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->minute)());
  else   (((const ::cool::ITime*)o)->minute)();
}

static  void method_8071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->second)());
  else   (((const ::cool::ITime*)o)->second)();
}

static  void method_8072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::cool::ITime*)o)->nanosecond)());
  else   (((const ::cool::ITime*)o)->nanosecond)();
}

static  void method_8073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ITime*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::ITime*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void operator_8074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator==)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator==)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator>)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator>)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator>=)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator>=)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator<)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator<)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator<=)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator<=)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator!=)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator!=)(*(const ::cool::ITime*)arg[0]);
}

//------Dictionary for class ITime -------------------------------
void __cool__ITime_db_datamem(Reflex::Class*);
void __cool__ITime_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ITime_datamem_bld(&__cool__ITime_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ITime_funcmem_bld(&__cool__ITime_db_funcmem);
void __cool__ITime_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ITime"), typeid(::cool::ITime), sizeof(::cool::ITime), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ITime"), destructor_8065, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__ITime_funcmem_bld);
}

//------Delayed data member builder for class ITime -------------------
void __cool__ITime_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ITime -------------------
void __cool__ITime_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("year"), method_8066, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("month"), method_8067, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("day"), method_8068, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("hour"), method_8069, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("minute"), method_8070, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("second"), method_8071, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("nanosecond"), method_8072, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415), Reflex::Literal("print"), method_8073, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator=="), operator_8074, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator>"), operator_8075, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator>="), operator_8076, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator<"), operator_8077, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator<="), operator_8078, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator!="), operator_8079, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class ConstRecordAdapter -------------------------------
static void destructor_8085(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ConstRecordAdapter*)o)->::cool::ConstRecordAdapter::~ConstRecordAdapter();
}
static void constructor_8086( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ConstRecordAdapter(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
  else ::new(mem) ::cool::ConstRecordAdapter(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
}

static  void method_8087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->specification)();
  else   (((const ::cool::ConstRecordAdapter*)o)->specification)();
}

static  void operator_8088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::ConstRecordAdapter*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::ConstRecordAdapter*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void method_8090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->attributeList)();
  else   (((const ::cool::ConstRecordAdapter*)o)->attributeList)();
}

static void method_x139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord")), ::Reflex::BaseOffset< ::cool::ConstRecordAdapter,::cool::IRecord >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ConstRecordAdapter -------------------------------
void __cool__ConstRecordAdapter_db_datamem(Reflex::Class*);
void __cool__ConstRecordAdapter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ConstRecordAdapter_datamem_bld(&__cool__ConstRecordAdapter_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ConstRecordAdapter_funcmem_bld(&__cool__ConstRecordAdapter_db_funcmem);
void __cool__ConstRecordAdapter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ConstRecordAdapter"), typeid(::cool::ConstRecordAdapter), sizeof(::cool::ConstRecordAdapter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2191, ::Reflex::BaseOffset< ::cool::ConstRecordAdapter, ::cool::IRecord >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ConstRecordAdapter"), destructor_8085, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10023, type_8803), Reflex::Literal("ConstRecordAdapter"), constructor_8086, 0, "spec;al", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__ConstRecordAdapter_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__ConstRecordAdapter_funcmem_bld);
}

//------Delayed data member builder for class ConstRecordAdapter -------------------
void __cool__ConstRecordAdapter_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2193, Reflex::Literal("m_spec"), OffsetOf(__shadow__::__cool__ConstRecordAdapter, m_spec), ::Reflex::PRIVATE)
  .AddDataMember(type_1291, Reflex::Literal("m_fields"), OffsetOf(__shadow__::__cool__ConstRecordAdapter, m_fields), ::Reflex::PRIVATE)
  .AddDataMember(type_2342, Reflex::Literal("m_publicAttrList"), OffsetOf(__shadow__::__cool__ConstRecordAdapter, m_publicAttrList), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ConstRecordAdapter -------------------
void __cool__ConstRecordAdapter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10023), Reflex::Literal("specification"), method_8087, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420, type_4025), Reflex::Literal("operator[]"), operator_8088, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420, type_2256), Reflex::Literal("operator[]"), operator_8089, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8803), Reflex::Literal("attributeList"), method_8090, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class InvalidTagRelation -------------------------------
static  void operator_8114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidTagRelation*)o)->operator=)(*(const ::cool::InvalidTagRelation*)arg[0]);
  else   (((::cool::InvalidTagRelation*)o)->operator=)(*(const ::cool::InvalidTagRelation*)arg[0]);
}

static void constructor_8115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidTagRelation(*(const ::cool::InvalidTagRelation*)arg[0]);
  else ::new(mem) ::cool::InvalidTagRelation(*(const ::cool::InvalidTagRelation*)arg[0]);
}

static void constructor_8116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidTagRelation(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::cool::InvalidTagRelation(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]);
}

static void destructor_8117(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidTagRelation*)o)->::cool::InvalidTagRelation::~InvalidTagRelation();
}
static void method_x140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidTagRelation,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidTagRelation,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidTagRelation -------------------------------
void __cool__InvalidTagRelation_db_datamem(Reflex::Class*);
void __cool__InvalidTagRelation_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidTagRelation_datamem_bld(&__cool__InvalidTagRelation_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidTagRelation_funcmem_bld(&__cool__InvalidTagRelation_db_funcmem);
void __cool__InvalidTagRelation_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidTagRelation"), typeid(::cool::InvalidTagRelation), sizeof(::cool::InvalidTagRelation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::InvalidTagRelation, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10115, type_10116), Reflex::Literal("operator="), operator_8114, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10116), Reflex::Literal("InvalidTagRelation"), constructor_8115, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_2256, type_4025, type_4025), Reflex::Literal("InvalidTagRelation"), constructor_8116, 0, "parentTagName;childTagName;childNodeId;details;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidTagRelation"), destructor_8117, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidTagRelation -------------------
void __cool__InvalidTagRelation_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidTagRelation -------------------
void __cool__InvalidTagRelation_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseNotOpen -------------------------------
static  void operator_8118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseNotOpen*)o)->operator=)(*(const ::cool::DatabaseNotOpen*)arg[0]);
  else   (((::cool::DatabaseNotOpen*)o)->operator=)(*(const ::cool::DatabaseNotOpen*)arg[0]);
}

static void constructor_8119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseNotOpen(*(const ::cool::DatabaseNotOpen*)arg[0]);
  else ::new(mem) ::cool::DatabaseNotOpen(*(const ::cool::DatabaseNotOpen*)arg[0]);
}

static void constructor_8120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseNotOpen(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::DatabaseNotOpen(*(const ::std::string*)arg[0]);
}

static void destructor_8121(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseNotOpen*)o)->::cool::DatabaseNotOpen::~DatabaseNotOpen();
}
static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::DatabaseNotOpen,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::DatabaseNotOpen,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DatabaseNotOpen -------------------------------
void __cool__DatabaseNotOpen_db_datamem(Reflex::Class*);
void __cool__DatabaseNotOpen_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseNotOpen_datamem_bld(&__cool__DatabaseNotOpen_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseNotOpen_funcmem_bld(&__cool__DatabaseNotOpen_db_funcmem);
void __cool__DatabaseNotOpen_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseNotOpen"), typeid(::cool::DatabaseNotOpen), sizeof(::cool::DatabaseNotOpen), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::DatabaseNotOpen, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10117, type_10118), Reflex::Literal("operator="), operator_8118, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10118), Reflex::Literal("DatabaseNotOpen"), constructor_8119, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025), Reflex::Literal("DatabaseNotOpen"), constructor_8120, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseNotOpen"), destructor_8121, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DatabaseNotOpen -------------------
void __cool__DatabaseNotOpen_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseNotOpen -------------------
void __cool__DatabaseNotOpen_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseDoesNotExist -------------------------------
static  void operator_8122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseDoesNotExist*)o)->operator=)(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
  else   (((::cool::DatabaseDoesNotExist*)o)->operator=)(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
}

static void constructor_8123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
  else ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
}

static void constructor_8124( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::std::string*)arg[0]);
}

static void destructor_8125(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseDoesNotExist*)o)->::cool::DatabaseDoesNotExist::~DatabaseDoesNotExist();
}
static void method_x142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::DatabaseDoesNotExist,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::DatabaseDoesNotExist,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DatabaseDoesNotExist -------------------------------
void __cool__DatabaseDoesNotExist_db_datamem(Reflex::Class*);
void __cool__DatabaseDoesNotExist_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseDoesNotExist_datamem_bld(&__cool__DatabaseDoesNotExist_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseDoesNotExist_funcmem_bld(&__cool__DatabaseDoesNotExist_db_funcmem);
void __cool__DatabaseDoesNotExist_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseDoesNotExist"), typeid(::cool::DatabaseDoesNotExist), sizeof(::cool::DatabaseDoesNotExist), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::DatabaseDoesNotExist, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10119, type_10120), Reflex::Literal("operator="), operator_8122, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10120), Reflex::Literal("DatabaseDoesNotExist"), constructor_8123, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025), Reflex::Literal("DatabaseDoesNotExist"), constructor_8124, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseDoesNotExist"), destructor_8125, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DatabaseDoesNotExist -------------------
void __cool__DatabaseDoesNotExist_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseDoesNotExist -------------------
void __cool__DatabaseDoesNotExist_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFolder -------------------------------
static void destructor_8544(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFolder*)o)->::cool::IFolder::~IFolder();
}
static  void method_8545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolder*)o)->folderSpecification)();
  else   (((const ::cool::IFolder*)o)->folderSpecification)();
}

static  void method_8546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolder*)o)->payloadSpecification)();
  else   (((const ::cool::IFolder*)o)->payloadSpecification)();
}

static  void method_8547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::IFolder*)o)->versioningMode)());
  else   (((const ::cool::IFolder*)o)->versioningMode)();
}

static  void method_8548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolder*)o)->folderAttributes)();
  else   (((const ::cool::IFolder*)o)->folderAttributes)();
}

static  void method_8549( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::cool::IFolder*)o)->setupStorageBuffer)();
  }
  else if ( arg.size() == 1 ) { 
    (((::cool::IFolder*)o)->setupStorageBuffer)(*(bool*)arg[0]);
  }
}

static  void method_8550( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IFolder*)o)->flushStorageBuffer)();
}

static  void method_8551( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::IRecord*)arg[2],
      *(const ::cool::ChannelId*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::IRecord*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::IRecord*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_8552( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[2],
      *(const ::cool::ChannelId*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_8553( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::coral::AttributeList*)arg[2],
      *(const ::cool::ChannelId*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::coral::AttributeList*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::coral::AttributeList*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_8554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::cool::IFolder*)o)->truncateObjectValidity)(*(const ::cool::ValidityKey*)arg[0],
    *(const ::cool::ChannelSelection*)arg[1]));
  else   (((::cool::IFolder*)o)->truncateObjectValidity)(*(const ::cool::ValidityKey*)arg[0],
    *(const ::cool::ChannelSelection*)arg[1]);
}

static  void method_8555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IObjectPtr)((((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1]));
    else     (((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IObjectPtr)((((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1]));
    else     (((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]));
    else     (((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]));
    else     (((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]));
    else     (((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]);
  }
}

static  void method_8558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (unsigned int)((((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]));
    else     (((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (unsigned int)((((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]));
    else     (((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (unsigned int)((((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]));
    else     (((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]);
  }
}

static  void method_8559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->setPrefetchAll)(*(bool*)arg[0]);
}

static  void method_8560( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->renamePayload)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->extendPayloadSpecification)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8562( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IFolder*)o)->tagCurrentHead)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IFolder*)o)->tagCurrentHead)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_8563( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::cool::IFolder*)o)->cloneTagAsUserTag)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::cool::IFolder*)o)->cloneTagAsUserTag)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::cool::IFolder*)o)->cloneTagAsUserTag)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_8564( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((const ::cool::IFolder*)o)->tagHeadAsOfDate)(*(const ::cool::ITime*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((const ::cool::IFolder*)o)->tagHeadAsOfDate)(*(const ::cool::ITime*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::Time)((((const ::cool::IFolder*)o)->insertionTimeOfLastObjectInTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->insertionTimeOfLastObjectInTag)(*(const ::std::string*)arg[0]);
}

static  void method_8566( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->deleteTag)(*(const ::std::string*)arg[0]);
}

static  void method_8567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolder*)o)->existsUserTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->existsUserTag)(*(const ::std::string*)arg[0]);
}

static  void method_8568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<unsigned int>)((((const ::cool::IFolder*)o)->listChannels)());
  else   (((const ::cool::IFolder*)o)->listChannels)();
}

static  void method_8569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::map<unsigned int,std::basic_string<char> >)((((const ::cool::IFolder*)o)->listChannelsWithNames)());
  else   (((const ::cool::IFolder*)o)->listChannelsWithNames)();
}

static  void method_8570( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::cool::IFolder*)o)->createChannel)(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::cool::IFolder*)o)->createChannel)(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IFolder*)o)->dropChannel)(*(const ::cool::ChannelId*)arg[0]));
  else   (((::cool::IFolder*)o)->dropChannel)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8572( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->setChannelName)(*(const ::cool::ChannelId*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IFolder*)o)->channelName)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::IFolder*)o)->channelName)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::IFolder*)o)->channelId)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->channelId)(*(const ::std::string*)arg[0]);
}

static  void method_8575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolder*)o)->existsChannel)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::IFolder*)o)->existsChannel)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolder*)o)->existsChannel)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->existsChannel)(*(const ::std::string*)arg[0]);
}

static  void method_8577( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->setChannelDescription)(*(const ::cool::ChannelId*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IFolder*)o)->channelDescription)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::IFolder*)o)->channelDescription)(*(const ::cool::ChannelId*)arg[0]);
}

static void method_x143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNode")), ::Reflex::BaseOffset< ::cool::IFolder,::cool::IHvsNode >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord")), ::Reflex::BaseOffset< ::cool::IFolder,::cool::IHvsNodeRecord >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IFolder -------------------------------
void __cool__IFolder_db_datamem(Reflex::Class*);
void __cool__IFolder_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFolder_datamem_bld(&__cool__IFolder_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFolder_funcmem_bld(&__cool__IFolder_db_funcmem);
void __cool__IFolder_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFolder"), typeid(::cool::IFolder), sizeof(::cool::IFolder), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2228, ::Reflex::BaseOffset< ::cool::IFolder, ::cool::IHvsNode >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFolder"), destructor_8544, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__IFolder_funcmem_bld);
}

//------Delayed data member builder for class IFolder -------------------
void __cool__IFolder_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFolder -------------------
void __cool__IFolder_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10172), Reflex::Literal("folderSpecification"), method_8545, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10023), Reflex::Literal("payloadSpecification"), method_8546, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8580), Reflex::Literal("versioningMode"), method_8547, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8419), Reflex::Literal("folderAttributes"), method_8548, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1770), Reflex::Literal("setupStorageBuffer"), method_8549, 0, "useBuffer=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("flushStorageBuffer"), method_8550, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10113, type_10113, type_8419, type_10035, type_4025, type_1770), Reflex::Literal("storeObject"), method_8551, 0, "since;until;payload;channelId;userTagName=\"\";userTagOnly=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10113, type_10113, type_9200, type_10035, type_4025, type_1770), Reflex::Literal("storeObject"), method_8552, 0, "since;until;payload;channelId;userTagName=\"\";userTagOnly=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10113, type_10113, type_8803, type_10035, type_4025, type_1770), Reflex::Literal("storeObject"), method_8553, 0, "since;until;payload;channelId;userTagName=\"\";userTagOnly=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_10113, type_10211), Reflex::Literal("truncateObjectValidity"), method_8554, 0, "until;channels", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2181, type_10113, type_10035, type_4025), Reflex::Literal("findObject"), method_8555, 0, "pointInTime;channelId;tagName=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2173, type_10113, type_10211, type_4025), Reflex::Literal("findObjects"), method_8556, 0, "pointInTime;channels;tagName=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2173, type_10113, type_10113, type_10211, type_4025, type_10050), Reflex::Literal("browseObjects"), method_8557, 0, "since;until;channels;tagName=\"\";payloadQuery=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75, type_10113, type_10113, type_10211, type_4025, type_10050), Reflex::Literal("countObjects"), method_8558, 0, "since;until;channels;tagName=\"\";payloadQuery=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1770), Reflex::Literal("setPrefetchAll"), method_8559, 0, "prefetchAll", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025), Reflex::Literal("renamePayload"), method_8560, 0, "oldName;newName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8419), Reflex::Literal("extendPayloadSpecification"), method_8561, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025), Reflex::Literal("tagCurrentHead"), method_8562, 0, "tagName;description=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025, type_4025, type_1770), Reflex::Literal("cloneTagAsUserTag"), method_8563, 0, "tagName;tagClone;description=\"\";forceOverwriteTag=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8416, type_4025, type_4025), Reflex::Literal("tagHeadAsOfDate"), method_8564, 0, "asOfDate;tagName;description=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2220c, type_4025), Reflex::Literal("insertionTimeOfLastObjectInTag"), method_8565, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025), Reflex::Literal("deleteTag"), method_8566, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("existsUserTag"), method_8567, 0, "userTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1288c), Reflex::Literal("listChannels"), method_8568, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1515c), Reflex::Literal("listChannelsWithNames"), method_8569, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10035, type_4025, type_4025), Reflex::Literal("createChannel"), method_8570, 0, "channelId;channelName;description=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10035), Reflex::Literal("dropChannel"), method_8571, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10035, type_4025), Reflex::Literal("setChannelName"), method_8572, 0, "channelId;channelName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_10035), Reflex::Literal("channelName"), method_8573, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2203, type_4025), Reflex::Literal("channelId"), method_8574, 0, "channelName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10035), Reflex::Literal("existsChannel"), method_8575, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("existsChannel"), method_8576, 0, "channelName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10035, type_4025), Reflex::Literal("setChannelDescription"), method_8577, 0, "channelId;description", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_10035), Reflex::Literal("channelDescription"), method_8578, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<cool::IFolder> -------------------------------
static void destructor_8130(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IFolder>*)o)->::boost::shared_ptr<cool::IFolder>::~shared_ptr();
}
static void constructor_8131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolder>(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IFolder>(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static void constructor_8132( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolder>();
  else ::new(mem) ::boost::shared_ptr<cool::IFolder>();
}

static  void operator_8133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IFolder>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IFolder>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static  void method_8134( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IFolder>*)o)->reset)();
}

static  void operator_8135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IFolder>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator*)();
}

static  void operator_8136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator->)();
}

static  void method_8138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->get)();
}

static  void converter_8139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IFolder* boost::shared_ptr<cool::IFolder>::*)((((const ::boost::shared_ptr<cool::IFolder>*)o)->operator cool::IFolder* boost::shared_ptr<cool::IFolder>::*)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator cool::IFolder* boost::shared_ptr<cool::IFolder>::*)();
}

static  void operator_8140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolder>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator!)();
}

static  void method_8141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolder>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->unique)();
}

static  void method_8142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IFolder>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->use_count)();
}

static  void method_8143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IFolder>*)o)->swap)(*(::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static  void method_8144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static void method_newdel_2214( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IFolder> -------------------------------
void __boost__shared_ptr_cool__IFolder__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IFolder__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolder__datamem_bld(&__boost__shared_ptr_cool__IFolder__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolder__funcmem_bld(&__boost__shared_ptr_cool__IFolder__db_funcmem);
void __boost__shared_ptr_cool__IFolder__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolder>"), typeid(::boost::shared_ptr<cool::IFolder>), sizeof(::boost::shared_ptr<cool::IFolder>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2300, Reflex::Literal("boost::shared_ptr<cool::IFolder>::element_type"))
  .AddTypedef(type_10122, Reflex::Literal("boost::shared_ptr<cool::IFolder>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10123), Reflex::Literal("shared_ptr"), constructor_8131, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8132, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2214, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IFolder__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IFolder__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IFolder> -------------------
void __boost__shared_ptr_cool__IFolder__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10121, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolder_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolder_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IFolder> -------------------
void __boost__shared_ptr_cool__IFolder__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10124, type_10123), Reflex::Literal("operator="), operator_8133, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_8134, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10125), Reflex::Literal("operator*"), operator_8135, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10121), Reflex::Literal("operator->"), operator_8136, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10121), Reflex::Literal("get"), method_8138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10122), Reflex::Literal("operator cool::IFolder* boost::shared_ptr<cool::IFolder>::*"), converter_8139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_8140, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_8141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_8142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10124), Reflex::Literal("swap"), method_8143, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_8144, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_8145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10123), Reflex::Literal("_internal_equiv"), method_8146, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValidityIntervalBackwards -------------------------------
static  void operator_8149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ValidityIntervalBackwards*)o)->operator=)(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
  else   (((::cool::ValidityIntervalBackwards*)o)->operator=)(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
}

static void constructor_8150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
  else ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
}

static void constructor_8151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8152(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ValidityIntervalBackwards*)o)->::cool::ValidityIntervalBackwards::~ValidityIntervalBackwards();
}
static void method_x145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyException")), ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards,::cool::ValidityKeyException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ValidityIntervalBackwards -------------------------------
void __cool__ValidityIntervalBackwards_db_datamem(Reflex::Class*);
void __cool__ValidityIntervalBackwards_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ValidityIntervalBackwards_datamem_bld(&__cool__ValidityIntervalBackwards_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ValidityIntervalBackwards_funcmem_bld(&__cool__ValidityIntervalBackwards_db_funcmem);
void __cool__ValidityIntervalBackwards_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ValidityIntervalBackwards"), typeid(::cool::ValidityIntervalBackwards), sizeof(::cool::ValidityIntervalBackwards), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2201, ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards, ::cool::ValidityKeyException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10126, type_10127), Reflex::Literal("operator="), operator_8149, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10127), Reflex::Literal("ValidityIntervalBackwards"), constructor_8150, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10113, type_10113, type_4025), Reflex::Literal("ValidityIntervalBackwards"), constructor_8151, 0, "since;until;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValidityIntervalBackwards"), destructor_8152, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ValidityIntervalBackwards -------------------
void __cool__ValidityIntervalBackwards_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ValidityIntervalBackwards -------------------
void __cool__ValidityIntervalBackwards_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Time -------------------------------
static void destructor_8160(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Time*)o)->::cool::Time::~Time();
}
static void constructor_8161( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time();
  else ::new(mem) ::cool::Time();
}

static void constructor_8162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(long*)arg[6]);
  else ::new(mem) ::cool::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(long*)arg[6]);
}

static void constructor_8163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time(*(const ::cool::Time*)arg[0]);
  else ::new(mem) ::cool::Time(*(const ::cool::Time*)arg[0]);
}

static  void operator_8164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Time*)o)->operator=)(*(const ::cool::Time*)arg[0]);
  else   (((::cool::Time*)o)->operator=)(*(const ::cool::Time*)arg[0]);
}

static void constructor_8165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time(*(const ::cool::ITime*)arg[0]);
  else ::new(mem) ::cool::Time(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Time*)o)->operator=)(*(const ::cool::ITime*)arg[0]);
  else   (((::cool::Time*)o)->operator=)(*(const ::cool::ITime*)arg[0]);
}

static  void method_8167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->year)());
  else   (((const ::cool::Time*)o)->year)();
}

static  void method_8168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->month)());
  else   (((const ::cool::Time*)o)->month)();
}

static  void method_8169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->day)());
  else   (((const ::cool::Time*)o)->day)();
}

static  void method_8170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->hour)());
  else   (((const ::cool::Time*)o)->hour)();
}

static  void method_8171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->minute)());
  else   (((const ::cool::Time*)o)->minute)();
}

static  void method_8172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->second)());
  else   (((const ::cool::Time*)o)->second)();
}

static  void method_8173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::cool::Time*)o)->nanosecond)());
  else   (((const ::cool::Time*)o)->nanosecond)();
}

static  void method_8174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Time*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::Time*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void operator_8175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::Time*)o)->operator==)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::Time*)o)->operator==)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::Time*)o)->operator>)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::Time*)o)->operator>)(*(const ::cool::ITime*)arg[0]);
}

static void method_newdel_2220( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::Time >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::Time >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::Time >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::Time >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::Time >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::ITime")), ::Reflex::BaseOffset< ::cool::Time,::cool::ITime >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Time -------------------------------
void __cool__Time_db_datamem(Reflex::Class*);
void __cool__Time_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Time_datamem_bld(&__cool__Time_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Time_funcmem_bld(&__cool__Time_db_funcmem);
void __cool__Time_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Time"), typeid(::cool::Time), sizeof(::cool::Time), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2208, ::Reflex::BaseOffset< ::cool::Time, ::cool::ITime >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Time"), destructor_8160, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Time"), constructor_8161, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30, type_30, type_30, type_30, type_30, type_30, type_116), Reflex::Literal("Time"), constructor_8162, 0, "year;month;day;hour;minute;second;nanosecond", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10128), Reflex::Literal("Time"), constructor_8163, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8416), Reflex::Literal("Time"), constructor_8165, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2220, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Time_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Time_funcmem_bld);
}

//------Delayed data member builder for class Time -------------------
void __cool__Time_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_30, Reflex::Literal("m_year"), OffsetOf(__shadow__::__cool__Time, m_year), ::Reflex::PRIVATE)
  .AddDataMember(type_30, Reflex::Literal("m_month"), OffsetOf(__shadow__::__cool__Time, m_month), ::Reflex::PRIVATE)
  .AddDataMember(type_30, Reflex::Literal("m_day"), OffsetOf(__shadow__::__cool__Time, m_day), ::Reflex::PRIVATE)
  .AddDataMember(type_30, Reflex::Literal("m_hour"), OffsetOf(__shadow__::__cool__Time, m_hour), ::Reflex::PRIVATE)
  .AddDataMember(type_30, Reflex::Literal("m_minute"), OffsetOf(__shadow__::__cool__Time, m_minute), ::Reflex::PRIVATE)
  .AddDataMember(type_30, Reflex::Literal("m_second"), OffsetOf(__shadow__::__cool__Time, m_second), ::Reflex::PRIVATE)
  .AddDataMember(type_116, Reflex::Literal("m_nanosecond"), OffsetOf(__shadow__::__cool__Time, m_nanosecond), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Time -------------------
void __cool__Time_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10129, type_10128), Reflex::Literal("operator="), operator_8164, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10129, type_8416), Reflex::Literal("operator="), operator_8166, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("year"), method_8167, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("month"), method_8168, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("day"), method_8169, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("hour"), method_8170, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("minute"), method_8171, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("second"), method_8172, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("nanosecond"), method_8173, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415), Reflex::Literal("print"), method_8174, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator=="), operator_8175, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8416), Reflex::Literal("operator>"), operator_8176, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
static void destructor_8181(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::~shared_ptr();
}
static void constructor_8182( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_8183( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >();
}

static  void operator_8184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_8185( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->reset)();
}

static  void operator_8186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
}

static  void operator_8187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)();
}

static  void method_8189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->get)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->get)();
}

static  void converter_8190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*)();
}

static  void operator_8191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator!)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator!)();
}

static  void method_8192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->unique)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->unique)();
}

static  void method_8193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->use_count)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->use_count)();
}

static  void method_8194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->swap)(*(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_8195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_untyped_deleter)();
}

static  void method_8197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void method_newdel_2223( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >"), typeid(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >), sizeof(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_1290, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::element_type"))
  .AddTypedef(type_10131, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10132), Reflex::Literal("shared_ptr"), constructor_8182, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8183, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10130, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10133, type_10132), Reflex::Literal("operator="), operator_8184, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_8185, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9205), Reflex::Literal("operator*"), operator_8186, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10130), Reflex::Literal("operator->"), operator_8187, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10130), Reflex::Literal("get"), method_8189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10131), Reflex::Literal("operator std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*"), converter_8190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_8191, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_8192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_8193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10133), Reflex::Literal("swap"), method_8194, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_8195, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_8196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10132), Reflex::Literal("_internal_equiv"), method_8197, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IRecordSelection -------------------------------
static void destructor_8200(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecordSelection*)o)->::cool::IRecordSelection::~IRecordSelection();
}
static  void method_8201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::IRecordSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_8202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::IRecordSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IRecordSelection*)o)->clone)());
  else   (((const ::cool::IRecordSelection*)o)->clone)();
}

//------Dictionary for class IRecordSelection -------------------------------
void __cool__IRecordSelection_db_datamem(Reflex::Class*);
void __cool__IRecordSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecordSelection_datamem_bld(&__cool__IRecordSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecordSelection_funcmem_bld(&__cool__IRecordSelection_db_funcmem);
void __cool__IRecordSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecordSelection"), typeid(::cool::IRecordSelection), sizeof(::cool::IRecordSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecordSelection"), destructor_8200, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecordSelection_funcmem_bld);
}

//------Delayed data member builder for class IRecordSelection -------------------
void __cool__IRecordSelection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecordSelection -------------------
void __cool__IRecordSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10023), Reflex::Literal("canSelect"), method_8201, 0, "spec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8419), Reflex::Literal("select"), method_8202, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3428), Reflex::Literal("clone"), method_8203, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IDatabase -------------------------------
static void destructor_8332(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IDatabase*)o)->::cool::IDatabase::~IDatabase();
}
static  void method_8333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IDatabase*)o)->databaseId)();
  else   (((const ::cool::IDatabase*)o)->databaseId)();
}

static  void method_8334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IDatabase*)o)->databaseAttributes)();
  else   (((const ::cool::IDatabase*)o)->databaseAttributes)();
}

static  void method_8335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0]));
    else     (((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]));
    else     (((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_8336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IDatabase*)o)->existsFolderSet)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->existsFolderSet)(*(const ::std::string*)arg[0]);
}

static  void method_8337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->getFolderSet)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->getFolderSet)(*(const ::std::string*)arg[0]);
}

static  void method_8338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_8339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3],
      *(bool*)arg[4]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3],
      *(bool*)arg[4]);
  }
}

static  void method_8340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IDatabase*)o)->existsFolder)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->existsFolder)(*(const ::std::string*)arg[0]);
}

static  void method_8341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->getFolder)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->getFolder)(*(const ::std::string*)arg[0]);
}

static  void method_8342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IDatabase*)o)->listAllNodes)());
    else     (((::cool::IDatabase*)o)->listAllNodes)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IDatabase*)o)->listAllNodes)(*(bool*)arg[0]));
    else     (((::cool::IDatabase*)o)->listAllNodes)(*(bool*)arg[0]);
  }
}

static  void method_8343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IDatabase*)o)->dropNode)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->dropNode)(*(const ::std::string*)arg[0]);
}

static  void method_8344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IDatabase*)o)->existsTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IDatabase*)o)->existsTag)(*(const ::std::string*)arg[0]);
}

static  void method_8345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::IDatabase*)o)->tagNameScope)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IDatabase*)o)->tagNameScope)(*(const ::std::string*)arg[0]);
}

static  void method_8346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::cool::IDatabase*)o)->taggedNodes)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IDatabase*)o)->taggedNodes)(*(const ::std::string*)arg[0]);
}

static  void method_8347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IDatabase*)o)->isOpen)());
  else   (((const ::cool::IDatabase*)o)->isOpen)();
}

static  void method_8348( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IDatabase*)o)->openDatabase)();
}

static  void method_8349( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IDatabase*)o)->closeDatabase)();
}

static  void method_8350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IDatabase*)o)->databaseName)();
  else   (((const ::cool::IDatabase*)o)->databaseName)();
}

//------Dictionary for class IDatabase -------------------------------
void __cool__IDatabase_db_datamem(Reflex::Class*);
void __cool__IDatabase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IDatabase_datamem_bld(&__cool__IDatabase_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IDatabase_funcmem_bld(&__cool__IDatabase_db_funcmem);
void __cool__IDatabase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IDatabase"), typeid(::cool::IDatabase), sizeof(::cool::IDatabase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDatabase"), destructor_8332, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IDatabase_funcmem_bld);
}

//------Delayed data member builder for class IDatabase -------------------
void __cool__IDatabase_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDatabase -------------------
void __cool__IDatabase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10158), Reflex::Literal("databaseId"), method_8333, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8419), Reflex::Literal("databaseAttributes"), method_8334, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2188, type_4025, type_4025, type_1770), Reflex::Literal("createFolderSet"), method_8335, 0, "fullPath;description=\"\";createParents=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("existsFolderSet"), method_8336, 0, "folderSetName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2188, type_4025), Reflex::Literal("getFolderSet"), method_8337, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2215, type_4025, type_10172, type_4025, type_1770), Reflex::Literal("createFolder"), method_8338, 0, "fullPath;folderSpec;description=\"\";createParents=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2215, type_4025, type_10023, type_4025, type_8580, type_1770), Reflex::Literal("createFolder"), method_8339, 0, "fullPath;payloadSpec;description=\"\";mode=SINGLE_VERSION;createParents=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("existsFolder"), method_8340, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2215, type_4025), Reflex::Literal("getFolder"), method_8341, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1287c, type_1770), Reflex::Literal("listAllNodes"), method_8342, 0, "ascending=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("dropNode"), method_8343, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("existsTag"), method_8344, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8226, type_4025), Reflex::Literal("tagNameScope"), method_8345, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1287c, type_4025), Reflex::Literal("taggedNodes"), method_8346, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isOpen"), method_8347, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("openDatabase"), method_8348, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("closeDatabase"), method_8349, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("databaseName"), method_8350, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<cool::IDatabase> -------------------------------
static void destructor_8209(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IDatabase>*)o)->::boost::shared_ptr<cool::IDatabase>::~shared_ptr();
}
static void constructor_8210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IDatabase>(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IDatabase>(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static void constructor_8211( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IDatabase>();
  else ::new(mem) ::boost::shared_ptr<cool::IDatabase>();
}

static  void operator_8212( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IDatabase>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IDatabase>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static  void method_8213( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IDatabase>*)o)->reset)();
}

static  void operator_8214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator*)();
}

static  void operator_8215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator->)();
}

static  void method_8217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->get)();
}

static  void converter_8218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*)();
}

static  void operator_8219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator!)();
}

static  void method_8220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->unique)();
}

static  void method_8221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->use_count)();
}

static  void method_8222( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IDatabase>*)o)->swap)(*(::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static  void method_8223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static void method_newdel_2226( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IDatabase> -------------------------------
void __boost__shared_ptr_cool__IDatabase__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IDatabase__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IDatabase__datamem_bld(&__boost__shared_ptr_cool__IDatabase__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IDatabase__funcmem_bld(&__boost__shared_ptr_cool__IDatabase__db_funcmem);
void __boost__shared_ptr_cool__IDatabase__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IDatabase>"), typeid(::boost::shared_ptr<cool::IDatabase>), sizeof(::boost::shared_ptr<cool::IDatabase>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2250, Reflex::Literal("boost::shared_ptr<cool::IDatabase>::element_type"))
  .AddTypedef(type_10137, Reflex::Literal("boost::shared_ptr<cool::IDatabase>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10138), Reflex::Literal("shared_ptr"), constructor_8210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8211, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2226, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IDatabase__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IDatabase__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IDatabase> -------------------
void __boost__shared_ptr_cool__IDatabase__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10136, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IDatabase_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_8922, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IDatabase_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IDatabase> -------------------
void __boost__shared_ptr_cool__IDatabase__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10139, type_10138), Reflex::Literal("operator="), operator_8212, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("reset"), method_8213, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10140), Reflex::Literal("operator*"), operator_8214, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10136), Reflex::Literal("operator->"), operator_8215, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10136), Reflex::Literal("get"), method_8217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10137), Reflex::Literal("operator cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*"), converter_8218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("operator!"), operator_8219, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_8220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_8221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10139), Reflex::Literal("swap"), method_8222, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("_internal_get_deleter"), method_8223, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("_internal_get_untyped_deleter"), method_8224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10138), Reflex::Literal("_internal_equiv"), method_8225, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IHvsNode -------------------------------
static void destructor_8229(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IHvsNode*)o)->::cool::IHvsNode::~IHvsNode();
}
static  void method_8230( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IHvsNode*)o)->setDescription)(*(const ::std::string*)arg[0]);
}

static  void method_8231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::cool::IHvsNode*)o)->listTags)());
  else   (((const ::cool::IHvsNode*)o)->listTags)();
}

static  void method_8232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::Time)((((const ::cool::IHvsNode*)o)->tagInsertionTime)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->tagInsertionTime)(*(const ::std::string*)arg[0]);
}

static  void method_8233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IHvsNode*)o)->tagDescription)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->tagDescription)(*(const ::std::string*)arg[0]);
}

static  void method_8234( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IHvsNode*)o)->setTagLockStatus)(*(const ::std::string*)arg[0],
    *(::cool::HvsTagLock::Status*)arg[1]);
}

static  void method_8235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::IHvsNode*)o)->tagLockStatus)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->tagLockStatus)(*(const ::std::string*)arg[0]);
}

static  void method_8236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IHvsNode*)o)->isHeadTag)(*(const ::std::string*)arg[0]));
  else   (((::cool::IHvsNode*)o)->isHeadTag)(*(const ::std::string*)arg[0]);
}

static  void method_8237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::IHvsNode*)o)->headTag)());
  else   (((::cool::IHvsNode*)o)->headTag)();
}

static  void method_8238( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::cool::IHvsNode*)o)->createTagRelation)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8239( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::cool::IHvsNode*)o)->deleteTagRelation)(*(const ::std::string*)arg[0]);
}

static  void method_8240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IHvsNode*)o)->findTagRelation)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->findTagRelation)(*(const ::std::string*)arg[0]);
}

static  void method_8241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IHvsNode*)o)->resolveTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->resolveTag)(*(const ::std::string*)arg[0]);
}

static  void method_8242( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IHvsNode*)o)->setTagDescription)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void method_x150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord")), ::Reflex::BaseOffset< ::cool::IHvsNode,::cool::IHvsNodeRecord >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IHvsNode -------------------------------
void __cool__IHvsNode_db_datamem(Reflex::Class*);
void __cool__IHvsNode_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IHvsNode_datamem_bld(&__cool__IHvsNode_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IHvsNode_funcmem_bld(&__cool__IHvsNode_db_funcmem);
void __cool__IHvsNode_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IHvsNode"), typeid(::cool::IHvsNode), sizeof(::cool::IHvsNode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2235, ::Reflex::BaseOffset< ::cool::IHvsNode, ::cool::IHvsNodeRecord >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("cool::IHvsNode::Type"), Reflex::Literal("INNER_NODE=0;LEAF_NODE=1"), &typeid(cool::IHvsNode::Type), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IHvsNode"), destructor_8229, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__IHvsNode_funcmem_bld);
}

//------Delayed data member builder for class IHvsNode -------------------
void __cool__IHvsNode_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IHvsNode -------------------
void __cool__IHvsNode_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025), Reflex::Literal("setDescription"), method_8230, 0, "description", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1287c), Reflex::Literal("listTags"), method_8231, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2220c, type_4025), Reflex::Literal("tagInsertionTime"), method_8232, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_4025), Reflex::Literal("tagDescription"), method_8233, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_7885), Reflex::Literal("setTagLockStatus"), method_8234, 0, "tagName;tagLockStatus", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7885, type_4025), Reflex::Literal("tagLockStatus"), method_8235, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("isHeadTag"), method_8236, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c), Reflex::Literal("headTag"), method_8237, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025), Reflex::Literal("createTagRelation"), method_8238, 0, "parentTagName;tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025), Reflex::Literal("deleteTagRelation"), method_8239, 0, "parentTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_4025), Reflex::Literal("findTagRelation"), method_8240, 0, "parentTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c, type_4025), Reflex::Literal("resolveTag"), method_8241, 0, "ancestorTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025), Reflex::Literal("setTagDescription"), method_8242, 0, "tagName;description", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class RecordSpecificationCannotExtend -------------------------------
static  void operator_8244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecificationCannotExtend*)o)->operator=)(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
  else   (((::cool::RecordSpecificationCannotExtend*)o)->operator=)(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
}

static void constructor_8245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
  else ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
}

static void constructor_8246( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8247(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecificationCannotExtend*)o)->::cool::RecordSpecificationCannotExtend::~RecordSpecificationCannotExtend();
}
static void method_x151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecificationCannotExtend -------------------------------
void __cool__RecordSpecificationCannotExtend_db_datamem(Reflex::Class*);
void __cool__RecordSpecificationCannotExtend_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationCannotExtend_datamem_bld(&__cool__RecordSpecificationCannotExtend_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationCannotExtend_funcmem_bld(&__cool__RecordSpecificationCannotExtend_db_funcmem);
void __cool__RecordSpecificationCannotExtend_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecificationCannotExtend"), typeid(::cool::RecordSpecificationCannotExtend), sizeof(::cool::RecordSpecificationCannotExtend), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10145, type_10146), Reflex::Literal("operator="), operator_8244, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10146), Reflex::Literal("RecordSpecificationCannotExtend"), constructor_8245, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("RecordSpecificationCannotExtend"), constructor_8246, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecificationCannotExtend"), destructor_8247, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordSpecificationCannotExtend -------------------
void __cool__RecordSpecificationCannotExtend_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordSpecificationCannotExtend -------------------
void __cool__RecordSpecificationCannotExtend_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Blob -------------------------------
static void constructor_8250( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::Blob();
  else ::new(mem) ::coral::Blob();
}

static void constructor_8251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::Blob(*(long*)arg[0]);
  else ::new(mem) ::coral::Blob(*(long*)arg[0]);
}

static void destructor_8252(void*, void * o, const std::vector<void*>&, void *) {
((::coral::Blob*)o)->::coral::Blob::~Blob();
}
static void constructor_8253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::Blob(*(const ::coral::Blob*)arg[0]);
  else ::new(mem) ::coral::Blob(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Blob*)o)->operator=)(*(const ::coral::Blob*)arg[0]);
  else   (((::coral::Blob*)o)->operator=)(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Blob*)o)->operator+=)(*(const ::coral::Blob*)arg[0]);
  else   (((::coral::Blob*)o)->operator+=)(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Blob*)o)->operator==)(*(const ::coral::Blob*)arg[0]));
  else   (((const ::coral::Blob*)o)->operator==)(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Blob*)o)->operator!=)(*(const ::coral::Blob*)arg[0]));
  else   (((const ::coral::Blob*)o)->operator!=)(*(const ::coral::Blob*)arg[0]);
}

static  void method_8258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::Blob*)o)->startingAddress)());
  else   (((const ::coral::Blob*)o)->startingAddress)();
}

static  void method_8259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::Blob*)o)->startingAddress)());
  else   (((::coral::Blob*)o)->startingAddress)();
}

static  void method_8260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::coral::Blob*)o)->size)());
  else   (((const ::coral::Blob*)o)->size)();
}

static  void method_8261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Blob*)o)->extend)(*(long*)arg[0]);
}

static  void method_8262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Blob*)o)->resize)(*(long*)arg[0]);
}

static void method_newdel_2231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::Blob >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::Blob >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::Blob >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::Blob >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::Blob >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Blob -------------------------------
void __coral__Blob_db_datamem(Reflex::Class*);
void __coral__Blob_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__Blob_datamem_bld(&__coral__Blob_db_datamem);
Reflex::GenreflexMemberBuilder __coral__Blob_funcmem_bld(&__coral__Blob_db_funcmem);
void __coral__Blob_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::Blob"), typeid(::coral::Blob), sizeof(::coral::Blob), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Blob"), constructor_8250, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_116), Reflex::Literal("Blob"), constructor_8251, 0, "initialSizeInBytes", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Blob"), destructor_8252, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10015), Reflex::Literal("Blob"), constructor_8253, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__coral__Blob_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__Blob_funcmem_bld);
}

//------Delayed data member builder for class Blob -------------------
void __coral__Blob_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_116, Reflex::Literal("m_size"), OffsetOf(__shadow__::__coral__Blob, m_size), ::Reflex::PRIVATE)
  .AddDataMember(type_172, Reflex::Literal("m_data"), OffsetOf(__shadow__::__coral__Blob, m_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Blob -------------------
void __coral__Blob_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10147, type_10015), Reflex::Literal("operator="), operator_8254, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10147, type_10015), Reflex::Literal("operator+="), operator_8255, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10015), Reflex::Literal("operator=="), operator_8256, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10015), Reflex::Literal("operator!="), operator_8257, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914), Reflex::Literal("startingAddress"), method_8258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("startingAddress"), method_8259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("size"), method_8260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_116), Reflex::Literal("extend"), method_8261, 0, "additionalSizeInBytes", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_116), Reflex::Literal("resize"), method_8262, 0, "sizeInBytes", ::Reflex::PUBLIC);
}
//------Stub functions for class IApplication -------------------------------
static void destructor_8265(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IApplication*)o)->::cool::IApplication::~IApplication();
}
static  void method_8266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::IApplication*)o)->databaseService)();
  else   (((::cool::IApplication*)o)->databaseService)();
}

static  void method_8267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::cool::IApplication*)o)->outputLevel)());
  else   (((::cool::IApplication*)o)->outputLevel)();
}

static  void method_8268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IApplication*)o)->setOutputLevel)(*(::cool::MSG::Level*)arg[0]);
}

static  void method_8269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IApplication*)o)->context)());
  else   (((const ::cool::IApplication*)o)->context)();
}

static  void method_8270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IApplication*)o)->connectionSvc)();
  else   (((const ::cool::IApplication*)o)->connectionSvc)();
}

//------Dictionary for class IApplication -------------------------------
void __cool__IApplication_db_datamem(Reflex::Class*);
void __cool__IApplication_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IApplication_datamem_bld(&__cool__IApplication_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IApplication_funcmem_bld(&__cool__IApplication_db_funcmem);
void __cool__IApplication_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IApplication"), typeid(::cool::IApplication), sizeof(::cool::IApplication), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IApplication"), destructor_8265, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IApplication_funcmem_bld);
}

//------Delayed data member builder for class IApplication -------------------
void __cool__IApplication_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IApplication -------------------
void __cool__IApplication_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10149), Reflex::Literal("databaseService"), method_8266, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7891), Reflex::Literal("outputLevel"), method_8267, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7891), Reflex::Literal("setOutputLevel"), method_8268, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10150), Reflex::Literal("context"), method_8269, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10151), Reflex::Literal("connectionSvc"), method_8270, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IHvsNodeRecord -------------------------------
static void destructor_8274(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IHvsNodeRecord*)o)->::cool::IHvsNodeRecord::~IHvsNodeRecord();
}
static  void method_8275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IHvsNodeRecord*)o)->fullPath)();
  else   (((const ::cool::IHvsNodeRecord*)o)->fullPath)();
}

static  void method_8276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IHvsNodeRecord*)o)->description)();
  else   (((const ::cool::IHvsNodeRecord*)o)->description)();
}

static  void method_8277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IHvsNodeRecord*)o)->isLeaf)());
  else   (((const ::cool::IHvsNodeRecord*)o)->isLeaf)();
}

static  void method_8278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IHvsNodeRecord*)o)->isStored)());
  else   (((const ::cool::IHvsNodeRecord*)o)->isStored)();
}

static  void method_8279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IHvsNodeRecord*)o)->insertionTime)();
  else   (((const ::cool::IHvsNodeRecord*)o)->insertionTime)();
}

static  void method_8280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IHvsNodeRecord*)o)->id)());
  else   (((const ::cool::IHvsNodeRecord*)o)->id)();
}

static  void method_8281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IHvsNodeRecord*)o)->parentId)());
  else   (((const ::cool::IHvsNodeRecord*)o)->parentId)();
}

//------Dictionary for class IHvsNodeRecord -------------------------------
void __cool__IHvsNodeRecord_db_datamem(Reflex::Class*);
void __cool__IHvsNodeRecord_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IHvsNodeRecord_datamem_bld(&__cool__IHvsNodeRecord_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IHvsNodeRecord_funcmem_bld(&__cool__IHvsNodeRecord_db_funcmem);
void __cool__IHvsNodeRecord_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IHvsNodeRecord"), typeid(::cool::IHvsNodeRecord), sizeof(::cool::IHvsNodeRecord), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IHvsNodeRecord"), destructor_8274, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IHvsNodeRecord_funcmem_bld);
}

//------Delayed data member builder for class IHvsNodeRecord -------------------
void __cool__IHvsNodeRecord_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IHvsNodeRecord -------------------
void __cool__IHvsNodeRecord_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("fullPath"), method_8275, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("description"), method_8276, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isLeaf"), method_8277, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isStored"), method_8278, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8416), Reflex::Literal("insertionTime"), method_8279, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("id"), method_8280, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2256), Reflex::Literal("parentId"), method_8281, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class TagExists -------------------------------
static  void operator_8285( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagExists*)o)->operator=)(*(const ::cool::TagExists*)arg[0]);
  else   (((::cool::TagExists*)o)->operator=)(*(const ::cool::TagExists*)arg[0]);
}

static void constructor_8286( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagExists(*(const ::cool::TagExists*)arg[0]);
  else ::new(mem) ::cool::TagExists(*(const ::cool::TagExists*)arg[0]);
}

static void constructor_8287( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::TagExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8288(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagExists*)o)->::cool::TagExists::~TagExists();
}
static void method_x153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagExists -------------------------------
void __cool__TagExists_db_datamem(Reflex::Class*);
void __cool__TagExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagExists_datamem_bld(&__cool__TagExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagExists_funcmem_bld(&__cool__TagExists_db_funcmem);
void __cool__TagExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagExists"), typeid(::cool::TagExists), sizeof(::cool::TagExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::TagExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10155, type_10156), Reflex::Literal("operator="), operator_8285, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10156), Reflex::Literal("TagExists"), constructor_8286, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("TagExists"), constructor_8287, 0, "tagName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagExists"), destructor_8288, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagExists -------------------
void __cool__TagExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagExists -------------------
void __cool__TagExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IDatabaseSvc -------------------------------
static void destructor_8291(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IDatabaseSvc*)o)->::cool::IDatabaseSvc::~IDatabaseSvc();
}
static  void method_8292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IDatabasePtr)((((const ::cool::IDatabaseSvc*)o)->createDatabase)(*(const ::cool::DatabaseId*)arg[0]));
  else   (((const ::cool::IDatabaseSvc*)o)->createDatabase)(*(const ::cool::DatabaseId*)arg[0]);
}

static  void method_8293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (cool::IDatabasePtr)((((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0]));
    else     (((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (cool::IDatabasePtr)((((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IDatabaseSvc*)o)->dropDatabase)(*(const ::cool::DatabaseId*)arg[0]));
  else   (((const ::cool::IDatabaseSvc*)o)->dropDatabase)(*(const ::cool::DatabaseId*)arg[0]);
}

static  void method_8295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IDatabaseSvc*)o)->serviceVersion)());
  else   (((const ::cool::IDatabaseSvc*)o)->serviceVersion)();
}

//------Dictionary for class IDatabaseSvc -------------------------------
void __cool__IDatabaseSvc_db_datamem(Reflex::Class*);
void __cool__IDatabaseSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IDatabaseSvc_datamem_bld(&__cool__IDatabaseSvc_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IDatabaseSvc_funcmem_bld(&__cool__IDatabaseSvc_db_funcmem);
void __cool__IDatabaseSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IDatabaseSvc"), typeid(::cool::IDatabaseSvc), sizeof(::cool::IDatabaseSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDatabaseSvc"), destructor_8291, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IDatabaseSvc_funcmem_bld);
}

//------Delayed data member builder for class IDatabaseSvc -------------------
void __cool__IDatabaseSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDatabaseSvc -------------------
void __cool__IDatabaseSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2227, type_10158), Reflex::Literal("createDatabase"), method_8292, 0, "dbId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2227, type_10158, type_1770), Reflex::Literal("openDatabase"), method_8293, 0, "dbId;readOnly=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10158), Reflex::Literal("dropDatabase"), method_8294, 0, "dbId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340c), Reflex::Literal("serviceVersion"), method_8295, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class FieldSpecification -------------------------------
static void destructor_8299(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecification*)o)->::cool::FieldSpecification::~FieldSpecification();
}
static void constructor_8300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecification(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1]);
  else ::new(mem) ::cool::FieldSpecification(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1]);
}

static void constructor_8301( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecification(*(const ::cool::FieldSpecification*)arg[0]);
  else ::new(mem) ::cool::FieldSpecification(*(const ::cool::FieldSpecification*)arg[0]);
}

static  void method_8302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FieldSpecification*)o)->name)();
  else   (((const ::cool::FieldSpecification*)o)->name)();
}

static  void method_8303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FieldSpecification*)o)->storageType)();
  else   (((const ::cool::FieldSpecification*)o)->storageType)();
}

static  void operator_8304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::FieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void operator_8305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::FieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void method_8306( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8307( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0],
      *(bool*)arg[1]);
  }
}

static void method_x154( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IFieldSpecification")), ::Reflex::BaseOffset< ::cool::FieldSpecification,::cool::IFieldSpecification >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecification -------------------------------
void __cool__FieldSpecification_db_datamem(Reflex::Class*);
void __cool__FieldSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecification_datamem_bld(&__cool__FieldSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecification_funcmem_bld(&__cool__FieldSpecification_db_funcmem);
void __cool__FieldSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecification"), typeid(::cool::FieldSpecification), sizeof(::cool::FieldSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2205, ::Reflex::BaseOffset< ::cool::FieldSpecification, ::cool::IFieldSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecification"), destructor_8299, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_7597c), Reflex::Literal("FieldSpecification"), constructor_8300, 0, "name;typeId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10159), Reflex::Literal("FieldSpecification"), constructor_8301, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x154, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FieldSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FieldSpecification_funcmem_bld);
}

//------Delayed data member builder for class FieldSpecification -------------------
void __cool__FieldSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1340c, Reflex::Literal("m_name"), OffsetOf(__shadow__::__cool__FieldSpecification, m_name), ::Reflex::PRIVATE | ::Reflex::CONST);
}
//------Delayed function member builder for class FieldSpecification -------------------
void __cool__FieldSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("name"), method_8302, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10028), Reflex::Literal("storageType"), method_8303, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10036), Reflex::Literal("operator=="), operator_8304, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10036), Reflex::Literal("operator!="), operator_8305, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8420, type_1770), Reflex::Literal("validate"), method_8306, 0, "field;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8804, type_1770), Reflex::Literal("validate"), method_8307, 0, "attribute;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class RecordException -------------------------------
static  void operator_8310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordException*)o)->operator=)(*(const ::cool::RecordException*)arg[0]);
  else   (((::cool::RecordException*)o)->operator=)(*(const ::cool::RecordException*)arg[0]);
}

static void constructor_8311( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordException(*(const ::cool::RecordException*)arg[0]);
  else ::new(mem) ::cool::RecordException(*(const ::cool::RecordException*)arg[0]);
}

static void constructor_8312( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::RecordException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8313(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordException*)o)->::cool::RecordException::~RecordException();
}
static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordException,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordException -------------------------------
void __cool__RecordException_db_datamem(Reflex::Class*);
void __cool__RecordException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordException_datamem_bld(&__cool__RecordException_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordException_funcmem_bld(&__cool__RecordException_db_funcmem);
void __cool__RecordException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordException"), typeid(::cool::RecordException), sizeof(::cool::RecordException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::RecordException, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10161, type_10162), Reflex::Literal("operator="), operator_8310, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10162), Reflex::Literal("RecordException"), constructor_8311, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("RecordException"), constructor_8312, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordException"), destructor_8313, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordException -------------------
void __cool__RecordException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordException -------------------
void __cool__RecordException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ReservedHeadTag -------------------------------
static  void operator_8314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ReservedHeadTag*)o)->operator=)(*(const ::cool::ReservedHeadTag*)arg[0]);
  else   (((::cool::ReservedHeadTag*)o)->operator=)(*(const ::cool::ReservedHeadTag*)arg[0]);
}

static void constructor_8315( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ReservedHeadTag(*(const ::cool::ReservedHeadTag*)arg[0]);
  else ::new(mem) ::cool::ReservedHeadTag(*(const ::cool::ReservedHeadTag*)arg[0]);
}

static void constructor_8316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ReservedHeadTag(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ReservedHeadTag(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8317(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ReservedHeadTag*)o)->::cool::ReservedHeadTag::~ReservedHeadTag();
}
static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ReservedHeadTag,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ReservedHeadTag,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ReservedHeadTag -------------------------------
void __cool__ReservedHeadTag_db_datamem(Reflex::Class*);
void __cool__ReservedHeadTag_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ReservedHeadTag_datamem_bld(&__cool__ReservedHeadTag_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ReservedHeadTag_funcmem_bld(&__cool__ReservedHeadTag_db_funcmem);
void __cool__ReservedHeadTag_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ReservedHeadTag"), typeid(::cool::ReservedHeadTag), sizeof(::cool::ReservedHeadTag), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::ReservedHeadTag, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10163, type_10164), Reflex::Literal("operator="), operator_8314, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10164), Reflex::Literal("ReservedHeadTag"), constructor_8315, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("ReservedHeadTag"), constructor_8316, 0, "tagName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ReservedHeadTag"), destructor_8317, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ReservedHeadTag -------------------
void __cool__ReservedHeadTag_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ReservedHeadTag -------------------
void __cool__ReservedHeadTag_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ValidityKeyOutOfBoundaries -------------------------------
static  void operator_8318( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ValidityKeyOutOfBoundaries*)o)->operator=)(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
  else   (((::cool::ValidityKeyOutOfBoundaries*)o)->operator=)(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
}

static void constructor_8319( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
  else ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
}

static void constructor_8320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKey*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKey*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8321(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ValidityKeyOutOfBoundaries*)o)->::cool::ValidityKeyOutOfBoundaries::~ValidityKeyOutOfBoundaries();
}
static void method_x157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyException")), ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries,::cool::ValidityKeyException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ValidityKeyOutOfBoundaries -------------------------------
void __cool__ValidityKeyOutOfBoundaries_db_datamem(Reflex::Class*);
void __cool__ValidityKeyOutOfBoundaries_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyOutOfBoundaries_datamem_bld(&__cool__ValidityKeyOutOfBoundaries_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyOutOfBoundaries_funcmem_bld(&__cool__ValidityKeyOutOfBoundaries_db_funcmem);
void __cool__ValidityKeyOutOfBoundaries_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ValidityKeyOutOfBoundaries"), typeid(::cool::ValidityKeyOutOfBoundaries), sizeof(::cool::ValidityKeyOutOfBoundaries), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2201, ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries, ::cool::ValidityKeyException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10165, type_10166), Reflex::Literal("operator="), operator_8318, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10166), Reflex::Literal("ValidityKeyOutOfBoundaries"), constructor_8319, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10113, type_4025), Reflex::Literal("ValidityKeyOutOfBoundaries"), constructor_8320, 0, "key;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValidityKeyOutOfBoundaries"), destructor_8321, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ValidityKeyOutOfBoundaries -------------------
void __cool__ValidityKeyOutOfBoundaries_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ValidityKeyOutOfBoundaries -------------------
void __cool__ValidityKeyOutOfBoundaries_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FieldSpecificationInvalidName -------------------------------
static  void operator_8322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldSpecificationInvalidName*)o)->operator=)(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
  else   (((::cool::FieldSpecificationInvalidName*)o)->operator=)(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
}

static void constructor_8323( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
  else ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
}

static void constructor_8324( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8325(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecificationInvalidName*)o)->::cool::FieldSpecificationInvalidName::~FieldSpecificationInvalidName();
}
static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecificationInvalidName -------------------------------
void __cool__FieldSpecificationInvalidName_db_datamem(Reflex::Class*);
void __cool__FieldSpecificationInvalidName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationInvalidName_datamem_bld(&__cool__FieldSpecificationInvalidName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationInvalidName_funcmem_bld(&__cool__FieldSpecificationInvalidName_db_funcmem);
void __cool__FieldSpecificationInvalidName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecificationInvalidName"), typeid(::cool::FieldSpecificationInvalidName), sizeof(::cool::FieldSpecificationInvalidName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10167, type_10168), Reflex::Literal("operator="), operator_8322, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10168), Reflex::Literal("FieldSpecificationInvalidName"), constructor_8323, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("FieldSpecificationInvalidName"), constructor_8324, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecificationInvalidName"), destructor_8325, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldSpecificationInvalidName -------------------
void __cool__FieldSpecificationInvalidName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldSpecificationInvalidName -------------------
void __cool__FieldSpecificationInvalidName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeDoubleIsNaN -------------------------------
static  void operator_8326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeDoubleIsNaN*)o)->operator=)(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
  else   (((::cool::StorageTypeDoubleIsNaN*)o)->operator=)(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
}

static void constructor_8327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
  else ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
}

static void constructor_8328( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8329(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeDoubleIsNaN*)o)->::cool::StorageTypeDoubleIsNaN::~StorageTypeDoubleIsNaN();
}
static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeDoubleIsNaN -------------------------------
void __cool__StorageTypeDoubleIsNaN_db_datamem(Reflex::Class*);
void __cool__StorageTypeDoubleIsNaN_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeDoubleIsNaN_datamem_bld(&__cool__StorageTypeDoubleIsNaN_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeDoubleIsNaN_funcmem_bld(&__cool__StorageTypeDoubleIsNaN_db_funcmem);
void __cool__StorageTypeDoubleIsNaN_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeDoubleIsNaN"), typeid(::cool::StorageTypeDoubleIsNaN), sizeof(::cool::StorageTypeDoubleIsNaN), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2277, ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10169, type_10170), Reflex::Literal("operator="), operator_8326, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10170), Reflex::Literal("StorageTypeDoubleIsNaN"), constructor_8327, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("StorageTypeDoubleIsNaN"), constructor_8328, 0, "expectedName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeDoubleIsNaN"), destructor_8329, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeDoubleIsNaN -------------------
void __cool__StorageTypeDoubleIsNaN_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeDoubleIsNaN -------------------
void __cool__StorageTypeDoubleIsNaN_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagRelationExists -------------------------------
static  void operator_8352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagRelationExists*)o)->operator=)(*(const ::cool::TagRelationExists*)arg[0]);
  else   (((::cool::TagRelationExists*)o)->operator=)(*(const ::cool::TagRelationExists*)arg[0]);
}

static void constructor_8353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationExists(*(const ::cool::TagRelationExists*)arg[0]);
  else ::new(mem) ::cool::TagRelationExists(*(const ::cool::TagRelationExists*)arg[0]);
}

static void constructor_8354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationExists(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::TagRelationExists(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8355(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagRelationExists*)o)->::cool::TagRelationExists::~TagRelationExists();
}
static void method_x160( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagRelationExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagRelationExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagRelationExists -------------------------------
void __cool__TagRelationExists_db_datamem(Reflex::Class*);
void __cool__TagRelationExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagRelationExists_datamem_bld(&__cool__TagRelationExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagRelationExists_funcmem_bld(&__cool__TagRelationExists_db_funcmem);
void __cool__TagRelationExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagRelationExists"), typeid(::cool::TagRelationExists), sizeof(::cool::TagRelationExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::TagRelationExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10173, type_10174), Reflex::Literal("operator="), operator_8352, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10174), Reflex::Literal("TagRelationExists"), constructor_8353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_2256, type_2256, type_4025), Reflex::Literal("TagRelationExists"), constructor_8354, 0, "parentNodeId;parentTagId;childNodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagRelationExists"), destructor_8355, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x160, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagRelationExists -------------------
void __cool__TagRelationExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagRelationExists -------------------
void __cool__TagRelationExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class InvalidFolderSpecification -------------------------------
static  void operator_8356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidFolderSpecification*)o)->operator=)(*(const ::cool::InvalidFolderSpecification*)arg[0]);
  else   (((::cool::InvalidFolderSpecification*)o)->operator=)(*(const ::cool::InvalidFolderSpecification*)arg[0]);
}

static void constructor_8357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidFolderSpecification(*(const ::cool::InvalidFolderSpecification*)arg[0]);
  else ::new(mem) ::cool::InvalidFolderSpecification(*(const ::cool::InvalidFolderSpecification*)arg[0]);
}

static void constructor_8358( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidFolderSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::InvalidFolderSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8359(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidFolderSpecification*)o)->::cool::InvalidFolderSpecification::~InvalidFolderSpecification();
}
static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidFolderSpecification,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidFolderSpecification,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidFolderSpecification -------------------------------
void __cool__InvalidFolderSpecification_db_datamem(Reflex::Class*);
void __cool__InvalidFolderSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidFolderSpecification_datamem_bld(&__cool__InvalidFolderSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidFolderSpecification_funcmem_bld(&__cool__InvalidFolderSpecification_db_funcmem);
void __cool__InvalidFolderSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidFolderSpecification"), typeid(::cool::InvalidFolderSpecification), sizeof(::cool::InvalidFolderSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::InvalidFolderSpecification, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10175, type_10176), Reflex::Literal("operator="), operator_8356, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10176), Reflex::Literal("InvalidFolderSpecification"), constructor_8357, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("InvalidFolderSpecification"), constructor_8358, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidFolderSpecification"), destructor_8359, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidFolderSpecification -------------------
void __cool__InvalidFolderSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidFolderSpecification -------------------
void __cool__InvalidFolderSpecification_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeStringContainsNullChar -------------------------------
static  void operator_8360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeStringContainsNullChar*)o)->operator=)(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
  else   (((::cool::StorageTypeStringContainsNullChar*)o)->operator=)(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
}

static void constructor_8361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
  else ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
}

static void constructor_8362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8363(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeStringContainsNullChar*)o)->::cool::StorageTypeStringContainsNullChar::~StorageTypeStringContainsNullChar();
}
static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeStringContainsNullChar -------------------------------
void __cool__StorageTypeStringContainsNullChar_db_datamem(Reflex::Class*);
void __cool__StorageTypeStringContainsNullChar_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringContainsNullChar_datamem_bld(&__cool__StorageTypeStringContainsNullChar_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringContainsNullChar_funcmem_bld(&__cool__StorageTypeStringContainsNullChar_db_funcmem);
void __cool__StorageTypeStringContainsNullChar_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeStringContainsNullChar"), typeid(::cool::StorageTypeStringContainsNullChar), sizeof(::cool::StorageTypeStringContainsNullChar), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2277, ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10177, type_10178), Reflex::Literal("operator="), operator_8360, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10178), Reflex::Literal("StorageTypeStringContainsNullChar"), constructor_8361, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10028, type_4025), Reflex::Literal("StorageTypeStringContainsNullChar"), constructor_8362, 0, "expectedName;expectedStorageType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeStringContainsNullChar"), destructor_8363, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeStringContainsNullChar -------------------
void __cool__StorageTypeStringContainsNullChar_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeStringContainsNullChar -------------------
void __cool__StorageTypeStringContainsNullChar_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeInvalidUInt63 -------------------------------
static  void operator_8364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeInvalidUInt63*)o)->operator=)(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
  else   (((::cool::StorageTypeInvalidUInt63*)o)->operator=)(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
}

static void constructor_8365( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
  else ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
}

static void constructor_8366( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::std::string*)arg[0],
      *(const ::cool::UInt63*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::std::string*)arg[0],
      *(const ::cool::UInt63*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8367(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeInvalidUInt63*)o)->::cool::StorageTypeInvalidUInt63::~StorageTypeInvalidUInt63();
}
static void method_x163( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeInvalidUInt63 -------------------------------
void __cool__StorageTypeInvalidUInt63_db_datamem(Reflex::Class*);
void __cool__StorageTypeInvalidUInt63_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidUInt63_datamem_bld(&__cool__StorageTypeInvalidUInt63_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidUInt63_funcmem_bld(&__cool__StorageTypeInvalidUInt63_db_funcmem);
void __cool__StorageTypeInvalidUInt63_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeInvalidUInt63"), typeid(::cool::StorageTypeInvalidUInt63), sizeof(::cool::StorageTypeInvalidUInt63), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2277, ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10179, type_10180), Reflex::Literal("operator="), operator_8364, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10180), Reflex::Literal("StorageTypeInvalidUInt63"), constructor_8365, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10037, type_4025), Reflex::Literal("StorageTypeInvalidUInt63"), constructor_8366, 0, "expectedName;value;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeInvalidUInt63"), destructor_8367, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x163, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeInvalidUInt63 -------------------
void __cool__StorageTypeInvalidUInt63_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeInvalidUInt63 -------------------
void __cool__StorageTypeInvalidUInt63_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseSvcFactory -------------------------------
static void destructor_8368(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseSvcFactory*)o)->::cool::DatabaseSvcFactory::~DatabaseSvcFactory();
}
static  void operator_8369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseSvcFactory*)o)->operator=)(*(const ::cool::DatabaseSvcFactory*)arg[0]);
  else   (((::cool::DatabaseSvcFactory*)o)->operator=)(*(const ::cool::DatabaseSvcFactory*)arg[0]);
}

static void constructor_8370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseSvcFactory(*(const ::cool::DatabaseSvcFactory*)arg[0]);
  else ::new(mem) ::cool::DatabaseSvcFactory(*(const ::cool::DatabaseSvcFactory*)arg[0]);
}

static void constructor_8371( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseSvcFactory();
  else ::new(mem) ::cool::DatabaseSvcFactory();
}

static  void method_8372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseSvcFactory*)o)->databaseService)();
  else   (((::cool::DatabaseSvcFactory*)o)->databaseService)();
}

static void method_newdel_2255( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DatabaseSvcFactory -------------------------------
void __cool__DatabaseSvcFactory_db_datamem(Reflex::Class*);
void __cool__DatabaseSvcFactory_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseSvcFactory_datamem_bld(&__cool__DatabaseSvcFactory_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseSvcFactory_funcmem_bld(&__cool__DatabaseSvcFactory_db_funcmem);
void __cool__DatabaseSvcFactory_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseSvcFactory"), typeid(::cool::DatabaseSvcFactory), sizeof(::cool::DatabaseSvcFactory), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseSvcFactory"), destructor_8368, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10181, type_10182), Reflex::Literal("operator="), operator_8369, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10182), Reflex::Literal("DatabaseSvcFactory"), constructor_8370, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DatabaseSvcFactory"), constructor_8371, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2255, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__DatabaseSvcFactory_funcmem_bld);
}

//------Delayed data member builder for class DatabaseSvcFactory -------------------
void __cool__DatabaseSvcFactory_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseSvcFactory -------------------
void __cool__DatabaseSvcFactory_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10149), Reflex::Literal("databaseService"), method_8372, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class InvalidChannelName -------------------------------
static  void operator_8374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidChannelName*)o)->operator=)(*(const ::cool::InvalidChannelName*)arg[0]);
  else   (((::cool::InvalidChannelName*)o)->operator=)(*(const ::cool::InvalidChannelName*)arg[0]);
}

static void constructor_8375( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelName(*(const ::cool::InvalidChannelName*)arg[0]);
  else ::new(mem) ::cool::InvalidChannelName(*(const ::cool::InvalidChannelName*)arg[0]);
}

static void constructor_8376( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelName(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::InvalidChannelName(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelName(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::InvalidChannelName(*(const ::std::string*)arg[0]);
}

static void destructor_8378(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidChannelName*)o)->::cool::InvalidChannelName::~InvalidChannelName();
}
static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelName,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelName,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidChannelName -------------------------------
void __cool__InvalidChannelName_db_datamem(Reflex::Class*);
void __cool__InvalidChannelName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelName_datamem_bld(&__cool__InvalidChannelName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelName_funcmem_bld(&__cool__InvalidChannelName_db_funcmem);
void __cool__InvalidChannelName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidChannelName"), typeid(::cool::InvalidChannelName), sizeof(::cool::InvalidChannelName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::InvalidChannelName, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10183, type_10184), Reflex::Literal("operator="), operator_8374, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10184), Reflex::Literal("InvalidChannelName"), constructor_8375, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_792, type_4025), Reflex::Literal("InvalidChannelName"), constructor_8376, 0, "size;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025), Reflex::Literal("InvalidChannelName"), constructor_8377, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidChannelName"), destructor_8378, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidChannelName -------------------
void __cool__InvalidChannelName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidChannelName -------------------
void __cool__InvalidChannelName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeBlobTooLong -------------------------------
static  void operator_8379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeBlobTooLong*)o)->operator=)(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
  else   (((::cool::StorageTypeBlobTooLong*)o)->operator=)(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
}

static void constructor_8380( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
  else ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
}

static void constructor_8381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(long*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(long*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8382(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeBlobTooLong*)o)->::cool::StorageTypeBlobTooLong::~StorageTypeBlobTooLong();
}
static void method_x166( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeBlobTooLong -------------------------------
void __cool__StorageTypeBlobTooLong_db_datamem(Reflex::Class*);
void __cool__StorageTypeBlobTooLong_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeBlobTooLong_datamem_bld(&__cool__StorageTypeBlobTooLong_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeBlobTooLong_funcmem_bld(&__cool__StorageTypeBlobTooLong_db_funcmem);
void __cool__StorageTypeBlobTooLong_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeBlobTooLong"), typeid(::cool::StorageTypeBlobTooLong), sizeof(::cool::StorageTypeBlobTooLong), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2277, ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10185, type_10186), Reflex::Literal("operator="), operator_8379, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10186), Reflex::Literal("StorageTypeBlobTooLong"), constructor_8380, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_10028, type_116, type_4025), Reflex::Literal("StorageTypeBlobTooLong"), constructor_8381, 0, "expectedName;expectedStorageType;actualSize;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeBlobTooLong"), destructor_8382, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x166, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeBlobTooLong -------------------
void __cool__StorageTypeBlobTooLong_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeBlobTooLong -------------------
void __cool__StorageTypeBlobTooLong_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PayloadSpecificationInvalidFieldName -------------------------------
static  void operator_8383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationInvalidFieldName*)o)->operator=)(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
  else   (((::cool::PayloadSpecificationInvalidFieldName*)o)->operator=)(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
}

static void constructor_8384( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
}

static void constructor_8385( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8386(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationInvalidFieldName*)o)->::cool::PayloadSpecificationInvalidFieldName::~PayloadSpecificationInvalidFieldName();
}
static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationInvalidFieldName -------------------------------
void __cool__PayloadSpecificationInvalidFieldName_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationInvalidFieldName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationInvalidFieldName_datamem_bld(&__cool__PayloadSpecificationInvalidFieldName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationInvalidFieldName_funcmem_bld(&__cool__PayloadSpecificationInvalidFieldName_db_funcmem);
void __cool__PayloadSpecificationInvalidFieldName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationInvalidFieldName"), typeid(::cool::PayloadSpecificationInvalidFieldName), sizeof(::cool::PayloadSpecificationInvalidFieldName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2204, ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10187, type_10188), Reflex::Literal("operator="), operator_8383, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10188), Reflex::Literal("PayloadSpecificationInvalidFieldName"), constructor_8384, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("PayloadSpecificationInvalidFieldName"), constructor_8385, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationInvalidFieldName"), destructor_8386, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationInvalidFieldName -------------------
void __cool__PayloadSpecificationInvalidFieldName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationInvalidFieldName -------------------
void __cool__PayloadSpecificationInvalidFieldName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseOpenInReadOnlyMode -------------------------------
static  void operator_8388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseOpenInReadOnlyMode*)o)->operator=)(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
  else   (((::cool::DatabaseOpenInReadOnlyMode*)o)->operator=)(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
}

static void constructor_8389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
  else ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
}

static void constructor_8390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::std::string*)arg[0]);
}

static void destructor_8391(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseOpenInReadOnlyMode*)o)->::cool::DatabaseOpenInReadOnlyMode::~DatabaseOpenInReadOnlyMode();
}
static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::DatabaseOpenInReadOnlyMode,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::DatabaseOpenInReadOnlyMode,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DatabaseOpenInReadOnlyMode -------------------------------
void __cool__DatabaseOpenInReadOnlyMode_db_datamem(Reflex::Class*);
void __cool__DatabaseOpenInReadOnlyMode_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseOpenInReadOnlyMode_datamem_bld(&__cool__DatabaseOpenInReadOnlyMode_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseOpenInReadOnlyMode_funcmem_bld(&__cool__DatabaseOpenInReadOnlyMode_db_funcmem);
void __cool__DatabaseOpenInReadOnlyMode_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseOpenInReadOnlyMode"), typeid(::cool::DatabaseOpenInReadOnlyMode), sizeof(::cool::DatabaseOpenInReadOnlyMode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::DatabaseOpenInReadOnlyMode, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10189, type_10190), Reflex::Literal("operator="), operator_8388, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10190), Reflex::Literal("DatabaseOpenInReadOnlyMode"), constructor_8389, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025), Reflex::Literal("DatabaseOpenInReadOnlyMode"), constructor_8390, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseOpenInReadOnlyMode"), destructor_8391, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DatabaseOpenInReadOnlyMode -------------------
void __cool__DatabaseOpenInReadOnlyMode_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseOpenInReadOnlyMode -------------------
void __cool__DatabaseOpenInReadOnlyMode_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeFloatIsNaN -------------------------------
static  void operator_8392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeFloatIsNaN*)o)->operator=)(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
  else   (((::cool::StorageTypeFloatIsNaN*)o)->operator=)(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
}

static void constructor_8393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
  else ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
}

static void constructor_8394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8395(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeFloatIsNaN*)o)->::cool::StorageTypeFloatIsNaN::~StorageTypeFloatIsNaN();
}
static void method_x169( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeFloatIsNaN -------------------------------
void __cool__StorageTypeFloatIsNaN_db_datamem(Reflex::Class*);
void __cool__StorageTypeFloatIsNaN_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeFloatIsNaN_datamem_bld(&__cool__StorageTypeFloatIsNaN_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeFloatIsNaN_funcmem_bld(&__cool__StorageTypeFloatIsNaN_db_funcmem);
void __cool__StorageTypeFloatIsNaN_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeFloatIsNaN"), typeid(::cool::StorageTypeFloatIsNaN), sizeof(::cool::StorageTypeFloatIsNaN), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2277, ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10191, type_10192), Reflex::Literal("operator="), operator_8392, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10192), Reflex::Literal("StorageTypeFloatIsNaN"), constructor_8393, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("StorageTypeFloatIsNaN"), constructor_8394, 0, "expectedName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeFloatIsNaN"), destructor_8395, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x169, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeFloatIsNaN -------------------
void __cool__StorageTypeFloatIsNaN_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeFloatIsNaN -------------------
void __cool__StorageTypeFloatIsNaN_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class NodeNotFound -------------------------------
static  void operator_8396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeNotFound*)o)->operator=)(*(const ::cool::NodeNotFound*)arg[0]);
  else   (((::cool::NodeNotFound*)o)->operator=)(*(const ::cool::NodeNotFound*)arg[0]);
}

static void constructor_8397( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeNotFound(*(const ::cool::NodeNotFound*)arg[0]);
  else ::new(mem) ::cool::NodeNotFound(*(const ::cool::NodeNotFound*)arg[0]);
}

static void constructor_8398( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8399( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeNotFound(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeNotFound(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8400(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeNotFound*)o)->::cool::NodeNotFound::~NodeNotFound();
}
static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeNotFound -------------------------------
void __cool__NodeNotFound_db_datamem(Reflex::Class*);
void __cool__NodeNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeNotFound_datamem_bld(&__cool__NodeNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeNotFound_funcmem_bld(&__cool__NodeNotFound_db_funcmem);
void __cool__NodeNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeNotFound"), typeid(::cool::NodeNotFound), sizeof(::cool::NodeNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::NodeNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10193, type_10194), Reflex::Literal("operator="), operator_8396, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10194), Reflex::Literal("NodeNotFound"), constructor_8397, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("NodeNotFound"), constructor_8398, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_4025), Reflex::Literal("NodeNotFound"), constructor_8399, 0, "nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeNotFound"), destructor_8400, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class NodeNotFound -------------------
void __cool__NodeNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class NodeNotFound -------------------
void __cool__NodeNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Application -------------------------------
static void constructor_8402( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Application();
  else ::new(mem) ::cool::Application();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Application((::coral::IConnectionService*)arg[0]);
  else ::new(mem) ::cool::Application((::coral::IConnectionService*)arg[0]);
  }
}

static void destructor_8403(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Application*)o)->::cool::Application::~Application();
}
static  void method_8404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Application*)o)->databaseService)();
  else   (((::cool::Application*)o)->databaseService)();
}

static  void method_8405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::cool::Application*)o)->outputLevel)());
  else   (((::cool::Application*)o)->outputLevel)();
}

static  void method_8406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::Application*)o)->setOutputLevel)(*(::cool::MSG::Level*)arg[0]);
}

static  void method_8407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::Application*)o)->context)());
  else   (((const ::cool::Application*)o)->context)();
}

static  void method_8408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Application*)o)->connectionSvc)();
  else   (((const ::cool::Application*)o)->connectionSvc)();
}

static void constructor_x171( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Application();
  else ::new(mem) ::cool::Application();
}

static void method_newdel_2269( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::Application >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::Application >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::Application >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::Application >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::Application >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IApplication")), ::Reflex::BaseOffset< ::cool::Application,::cool::IApplication >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Application -------------------------------
void __cool__Application_db_datamem(Reflex::Class*);
void __cool__Application_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Application_datamem_bld(&__cool__Application_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Application_funcmem_bld(&__cool__Application_db_funcmem);
void __cool__Application_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Application"), typeid(::cool::Application), sizeof(::cool::Application), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2233, ::Reflex::BaseOffset< ::cool::Application, ::cool::IApplication >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10196), Reflex::Literal("Application"), constructor_8402, 0, "connSvc=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Application"), destructor_8403, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Application"), constructor_x171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2269, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Application_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Application_funcmem_bld);
}

//------Delayed data member builder for class Application -------------------
void __cool__Application_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10195, Reflex::Literal("m_application"), OffsetOf(__shadow__::__cool__Application, m_application), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Application -------------------
void __cool__Application_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10149), Reflex::Literal("databaseService"), method_8404, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7891), Reflex::Literal("outputLevel"), method_8405, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_7891), Reflex::Literal("setOutputLevel"), method_8406, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10150), Reflex::Literal("context"), method_8407, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10151), Reflex::Literal("connectionSvc"), method_8408, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class NodeIsSingleVersion -------------------------------
static  void operator_8411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeIsSingleVersion*)o)->operator=)(*(const ::cool::NodeIsSingleVersion*)arg[0]);
  else   (((::cool::NodeIsSingleVersion*)o)->operator=)(*(const ::cool::NodeIsSingleVersion*)arg[0]);
}

static void constructor_8412( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeIsSingleVersion(*(const ::cool::NodeIsSingleVersion*)arg[0]);
  else ::new(mem) ::cool::NodeIsSingleVersion(*(const ::cool::NodeIsSingleVersion*)arg[0]);
}

static void constructor_8413( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8414(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeIsSingleVersion*)o)->::cool::NodeIsSingleVersion::~NodeIsSingleVersion();
}
static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeIsSingleVersion,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeIsSingleVersion,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeIsSingleVersion -------------------------------
void __cool__NodeIsSingleVersion_db_datamem(Reflex::Class*);
void __cool__NodeIsSingleVersion_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeIsSingleVersion_datamem_bld(&__cool__NodeIsSingleVersion_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeIsSingleVersion_funcmem_bld(&__cool__NodeIsSingleVersion_db_funcmem);
void __cool__NodeIsSingleVersion_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeIsSingleVersion"), typeid(::cool::NodeIsSingleVersion), sizeof(::cool::NodeIsSingleVersion), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::NodeIsSingleVersion, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10199, type_10200), Reflex::Literal("operator="), operator_8411, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10200), Reflex::Literal("NodeIsSingleVersion"), constructor_8412, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("NodeIsSingleVersion"), constructor_8413, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeIsSingleVersion"), destructor_8414, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class NodeIsSingleVersion -------------------
void __cool__NodeIsSingleVersion_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class NodeIsSingleVersion -------------------
void __cool__NodeIsSingleVersion_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class NodeExists -------------------------------
static  void operator_8421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeExists*)o)->operator=)(*(const ::cool::NodeExists*)arg[0]);
  else   (((::cool::NodeExists*)o)->operator=)(*(const ::cool::NodeExists*)arg[0]);
}

static void constructor_8422( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeExists(*(const ::cool::NodeExists*)arg[0]);
  else ::new(mem) ::cool::NodeExists(*(const ::cool::NodeExists*)arg[0]);
}

static void constructor_8423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8424(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeExists*)o)->::cool::NodeExists::~NodeExists();
}
static void method_x175( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeExists -------------------------------
void __cool__NodeExists_db_datamem(Reflex::Class*);
void __cool__NodeExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeExists_datamem_bld(&__cool__NodeExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeExists_funcmem_bld(&__cool__NodeExists_db_funcmem);
void __cool__NodeExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeExists"), typeid(::cool::NodeExists), sizeof(::cool::NodeExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::NodeExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10206, type_10207), Reflex::Literal("operator="), operator_8421, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10207), Reflex::Literal("NodeExists"), constructor_8422, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("NodeExists"), constructor_8423, 0, "fullPath;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeExists"), destructor_8424, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x175, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class NodeExists -------------------
void __cool__NodeExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class NodeExists -------------------
void __cool__NodeExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeInvalidValue -------------------------------
static  void operator_8425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeInvalidValue*)o)->operator=)(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
  else   (((::cool::StorageTypeInvalidValue*)o)->operator=)(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
}

static void constructor_8426( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeInvalidValue(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
  else ::new(mem) ::cool::StorageTypeInvalidValue(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
}

static void method_x176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::cool::RecordException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeInvalidValue -------------------------------
void __cool__StorageTypeInvalidValue_db_datamem(Reflex::Class*);
void __cool__StorageTypeInvalidValue_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidValue_datamem_bld(&__cool__StorageTypeInvalidValue_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidValue_funcmem_bld(&__cool__StorageTypeInvalidValue_db_funcmem);
void __cool__StorageTypeInvalidValue_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeInvalidValue"), typeid(::cool::StorageTypeInvalidValue), sizeof(::cool::StorageTypeInvalidValue), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2197, ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue, ::cool::StorageTypeException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10208, type_10209), Reflex::Literal("operator="), operator_8425, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10209), Reflex::Literal("StorageTypeInvalidValue"), constructor_8426, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeInvalidValue -------------------
void __cool__StorageTypeInvalidValue_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeInvalidValue -------------------
void __cool__StorageTypeInvalidValue_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagIsLocked -------------------------------
static  void operator_8458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagIsLocked*)o)->operator=)(*(const ::cool::TagIsLocked*)arg[0]);
  else   (((::cool::TagIsLocked*)o)->operator=)(*(const ::cool::TagIsLocked*)arg[0]);
}

static void constructor_8459( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagIsLocked(*(const ::cool::TagIsLocked*)arg[0]);
  else ::new(mem) ::cool::TagIsLocked(*(const ::cool::TagIsLocked*)arg[0]);
}

static void constructor_8460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagIsLocked(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::TagIsLocked(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8461(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagIsLocked*)o)->::cool::TagIsLocked::~TagIsLocked();
}
static void method_x177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagIsLocked,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagIsLocked,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagIsLocked -------------------------------
void __cool__TagIsLocked_db_datamem(Reflex::Class*);
void __cool__TagIsLocked_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagIsLocked_datamem_bld(&__cool__TagIsLocked_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagIsLocked_funcmem_bld(&__cool__TagIsLocked_db_funcmem);
void __cool__TagIsLocked_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagIsLocked"), typeid(::cool::TagIsLocked), sizeof(::cool::TagIsLocked), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::TagIsLocked, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10214, type_10215), Reflex::Literal("operator="), operator_8458, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10215), Reflex::Literal("TagIsLocked"), constructor_8459, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("TagIsLocked"), constructor_8460, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagIsLocked"), destructor_8461, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagIsLocked -------------------
void __cool__TagIsLocked_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagIsLocked -------------------
void __cool__TagIsLocked_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IRecordIterator -------------------------------
static void destructor_8464(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecordIterator*)o)->::cool::IRecordIterator::~IRecordIterator();
}
static  void method_8465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IRecordIterator*)o)->isEmpty)());
  else   (((::cool::IRecordIterator*)o)->isEmpty)();
}

static  void method_8466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IRecordIterator*)o)->goToNext)());
  else   (((::cool::IRecordIterator*)o)->goToNext)();
}

static  void method_8467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::IRecordIterator*)o)->currentRef)();
  else   (((::cool::IRecordIterator*)o)->currentRef)();
}

static  void method_8468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IRecordVectorPtr)((((::cool::IRecordIterator*)o)->fetchAllAsVector)());
  else   (((::cool::IRecordIterator*)o)->fetchAllAsVector)();
}

static  void method_8469( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IRecordIterator*)o)->close)();
}

//------Dictionary for class IRecordIterator -------------------------------
void __cool__IRecordIterator_db_datamem(Reflex::Class*);
void __cool__IRecordIterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecordIterator_datamem_bld(&__cool__IRecordIterator_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecordIterator_funcmem_bld(&__cool__IRecordIterator_db_funcmem);
void __cool__IRecordIterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecordIterator"), typeid(::cool::IRecordIterator), sizeof(::cool::IRecordIterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecordIterator"), destructor_8464, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecordIterator_funcmem_bld);
}

//------Delayed data member builder for class IRecordIterator -------------------
void __cool__IRecordIterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecordIterator -------------------
void __cool__IRecordIterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isEmpty"), method_8465, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("goToNext"), method_8466, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8419), Reflex::Literal("currentRef"), method_8467, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2162c), Reflex::Literal("fetchAllAsVector"), method_8468, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("close"), method_8469, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class NodeRelationNotFound -------------------------------
static  void operator_8472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeRelationNotFound*)o)->operator=)(*(const ::cool::NodeRelationNotFound*)arg[0]);
  else   (((::cool::NodeRelationNotFound*)o)->operator=)(*(const ::cool::NodeRelationNotFound*)arg[0]);
}

static void constructor_8473( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeRelationNotFound(*(const ::cool::NodeRelationNotFound*)arg[0]);
  else ::new(mem) ::cool::NodeRelationNotFound(*(const ::cool::NodeRelationNotFound*)arg[0]);
}

static void constructor_8474( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  else ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  }
}

static void destructor_8475(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeRelationNotFound*)o)->::cool::NodeRelationNotFound::~NodeRelationNotFound();
}
static  void method_8476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::NodeRelationNotFound*)o)->parentOnly)());
  else   (((const ::cool::NodeRelationNotFound*)o)->parentOnly)();
}

static void method_x178( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeRelationNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeRelationNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeRelationNotFound -------------------------------
void __cool__NodeRelationNotFound_db_datamem(Reflex::Class*);
void __cool__NodeRelationNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeRelationNotFound_datamem_bld(&__cool__NodeRelationNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeRelationNotFound_funcmem_bld(&__cool__NodeRelationNotFound_db_funcmem);
void __cool__NodeRelationNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeRelationNotFound"), typeid(::cool::NodeRelationNotFound), sizeof(::cool::NodeRelationNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2291, ::Reflex::BaseOffset< ::cool::NodeRelationNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10218, type_10219), Reflex::Literal("operator="), operator_8472, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10219), Reflex::Literal("NodeRelationNotFound"), constructor_8473, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_2256, type_4025, type_1770), Reflex::Literal("NodeRelationNotFound"), constructor_8474, 0, "ancestorNodeId;descendantNodeId;domain;parentOnly=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeRelationNotFound"), destructor_8475, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x178, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__NodeRelationNotFound_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__NodeRelationNotFound_funcmem_bld);
}

//------Delayed data member builder for class NodeRelationNotFound -------------------
void __cool__NodeRelationNotFound_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1770, Reflex::Literal("m_parentOnly"), OffsetOf(__shadow__::__cool__NodeRelationNotFound, m_parentOnly), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class NodeRelationNotFound -------------------
void __cool__NodeRelationNotFound_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("parentOnly"), method_8476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FolderNotFound -------------------------------
static  void operator_8478( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderNotFound*)o)->operator=)(*(const ::cool::FolderNotFound*)arg[0]);
  else   (((::cool::FolderNotFound*)o)->operator=)(*(const ::cool::FolderNotFound*)arg[0]);
}

static void constructor_8479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderNotFound(*(const ::cool::FolderNotFound*)arg[0]);
  else ::new(mem) ::cool::FolderNotFound(*(const ::cool::FolderNotFound*)arg[0]);
}

static void constructor_8480( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static void destructor_8481(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderNotFound*)o)->::cool::FolderNotFound::~FolderNotFound();
}
static  void method_8482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FolderNotFound*)o)->isFolderSet)());
  else   (((const ::cool::FolderNotFound*)o)->isFolderSet)();
}

static void method_x179( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeNotFound")), ::Reflex::BaseOffset< ::cool::FolderNotFound,::cool::NodeNotFound >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FolderNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FolderNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderNotFound -------------------------------
void __cool__FolderNotFound_db_datamem(Reflex::Class*);
void __cool__FolderNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderNotFound_datamem_bld(&__cool__FolderNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderNotFound_funcmem_bld(&__cool__FolderNotFound_db_funcmem);
void __cool__FolderNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderNotFound"), typeid(::cool::FolderNotFound), sizeof(::cool::FolderNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2268, ::Reflex::BaseOffset< ::cool::FolderNotFound, ::cool::NodeNotFound >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10220, type_10221), Reflex::Literal("operator="), operator_8478, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10221), Reflex::Literal("FolderNotFound"), constructor_8479, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025, type_1770), Reflex::Literal("FolderNotFound"), constructor_8480, 0, "fullPath;domain;isFolderSet=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderNotFound"), destructor_8481, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FolderNotFound_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FolderNotFound_funcmem_bld);
}

//------Delayed data member builder for class FolderNotFound -------------------
void __cool__FolderNotFound_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1770, Reflex::Literal("m_isFolderSet"), OffsetOf(__shadow__::__cool__FolderNotFound, m_isFolderSet), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FolderNotFound -------------------
void __cool__FolderNotFound_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isFolderSet"), method_8482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RecordSpecificationWrongSize -------------------------------
static  void operator_8483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecificationWrongSize*)o)->operator=)(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
  else   (((::cool::RecordSpecificationWrongSize*)o)->operator=)(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
}

static void constructor_8484( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationWrongSize(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
  else ::new(mem) ::cool::RecordSpecificationWrongSize(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
}

static void constructor_8485( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationWrongSize(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::RecordSpecificationWrongSize(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8486(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecificationWrongSize*)o)->::cool::RecordSpecificationWrongSize::~RecordSpecificationWrongSize();
}
static void method_x180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecificationWrongSize -------------------------------
void __cool__RecordSpecificationWrongSize_db_datamem(Reflex::Class*);
void __cool__RecordSpecificationWrongSize_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationWrongSize_datamem_bld(&__cool__RecordSpecificationWrongSize_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationWrongSize_funcmem_bld(&__cool__RecordSpecificationWrongSize_db_funcmem);
void __cool__RecordSpecificationWrongSize_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecificationWrongSize"), typeid(::cool::RecordSpecificationWrongSize), sizeof(::cool::RecordSpecificationWrongSize), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2245, ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10222, type_10223), Reflex::Literal("operator="), operator_8483, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10223), Reflex::Literal("RecordSpecificationWrongSize"), constructor_8484, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_2256, type_4025), Reflex::Literal("RecordSpecificationWrongSize"), constructor_8485, 0, "expectedSize;actualSize;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecificationWrongSize"), destructor_8486, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordSpecificationWrongSize -------------------
void __cool__RecordSpecificationWrongSize_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordSpecificationWrongSize -------------------
void __cool__RecordSpecificationWrongSize_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFolderSpecification -------------------------------
static void destructor_8489(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFolderSpecification*)o)->::cool::IFolderSpecification::~IFolderSpecification();
}
static  void method_8490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSpecification*)o)->versioningMode)();
  else   (((const ::cool::IFolderSpecification*)o)->versioningMode)();
}

static  void method_8491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSpecification*)o)->payloadSpecification)();
  else   (((const ::cool::IFolderSpecification*)o)->payloadSpecification)();
}

static  void method_8492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSpecification*)o)->payloadMode)();
  else   (((const ::cool::IFolderSpecification*)o)->payloadMode)();
}

static  void operator_8493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolderSpecification*)o)->operator==)(*(const ::cool::IFolderSpecification*)arg[0]));
  else   (((const ::cool::IFolderSpecification*)o)->operator==)(*(const ::cool::IFolderSpecification*)arg[0]);
}

static  void operator_8494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolderSpecification*)o)->operator!=)(*(const ::cool::IFolderSpecification*)arg[0]));
  else   (((const ::cool::IFolderSpecification*)o)->operator!=)(*(const ::cool::IFolderSpecification*)arg[0]);
}

//------Dictionary for class IFolderSpecification -------------------------------
void __cool__IFolderSpecification_db_datamem(Reflex::Class*);
void __cool__IFolderSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFolderSpecification_datamem_bld(&__cool__IFolderSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFolderSpecification_funcmem_bld(&__cool__IFolderSpecification_db_funcmem);
void __cool__IFolderSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFolderSpecification"), typeid(::cool::IFolderSpecification), sizeof(::cool::IFolderSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFolderSpecification"), destructor_8489, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IFolderSpecification_funcmem_bld);
}

//------Delayed data member builder for class IFolderSpecification -------------------
void __cool__IFolderSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFolderSpecification -------------------
void __cool__IFolderSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10224), Reflex::Literal("versioningMode"), method_8490, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10023), Reflex::Literal("payloadSpecification"), method_8491, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10225), Reflex::Literal("payloadMode"), method_8492, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10172), Reflex::Literal("operator=="), operator_8493, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10172), Reflex::Literal("operator!="), operator_8494, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class Exception -------------------------------
static  void operator_8519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Exception*)o)->operator=)(*(const ::cool::Exception*)arg[0]);
  else   (((::cool::Exception*)o)->operator=)(*(const ::cool::Exception*)arg[0]);
}

static void constructor_8520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Exception(*(const ::cool::Exception*)arg[0]);
  else ::new(mem) ::cool::Exception(*(const ::cool::Exception*)arg[0]);
}

static void constructor_8521( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Exception(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::Exception(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8522(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Exception*)o)->::cool::Exception::~Exception();
}
static  void method_8523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::Exception*)o)->what)());
  else   (((const ::cool::Exception*)o)->what)();
}

static  void method_8524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Exception*)o)->domain)();
  else   (((const ::cool::Exception*)o)->domain)();
}

static void method_x181( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::Exception,::std::exception >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Exception -------------------------------
void __cool__Exception_db_datamem(Reflex::Class*);
void __cool__Exception_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Exception_datamem_bld(&__cool__Exception_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Exception_funcmem_bld(&__cool__Exception_db_funcmem);
void __cool__Exception_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Exception"), typeid(::cool::Exception), sizeof(::cool::Exception), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_1594, ::Reflex::BaseOffset< ::cool::Exception, ::std::exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10229, type_10230), Reflex::Literal("operator="), operator_8519, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10230), Reflex::Literal("Exception"), constructor_8520, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4025, type_4025), Reflex::Literal("Exception"), constructor_8521, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Exception"), destructor_8522, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Exception_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Exception_funcmem_bld);
}

//------Delayed data member builder for class Exception -------------------
void __cool__Exception_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1340, Reflex::Literal("m_message"), OffsetOf(__shadow__::__cool__Exception, m_message), ::Reflex::PRIVATE)
  .AddDataMember(type_1340, Reflex::Literal("m_domain"), OffsetOf(__shadow__::__cool__Exception, m_domain), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Exception -------------------
void __cool__Exception_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1731), Reflex::Literal("what"), method_8523, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4025), Reflex::Literal("domain"), method_8524, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PayloadSpecificationTooManyBlobFields -------------------------------
static  void operator_8526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationTooManyBlobFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
  else   (((::cool::PayloadSpecificationTooManyBlobFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
}

static void constructor_8527( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
}

static void constructor_8528( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8529(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationTooManyBlobFields*)o)->::cool::PayloadSpecificationTooManyBlobFields::~PayloadSpecificationTooManyBlobFields();
}
static void method_x182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationTooManyBlobFields -------------------------------
void __cool__PayloadSpecificationTooManyBlobFields_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationTooManyBlobFields_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyBlobFields_datamem_bld(&__cool__PayloadSpecificationTooManyBlobFields_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyBlobFields_funcmem_bld(&__cool__PayloadSpecificationTooManyBlobFields_db_funcmem);
void __cool__PayloadSpecificationTooManyBlobFields_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyBlobFields"), typeid(::cool::PayloadSpecificationTooManyBlobFields), sizeof(::cool::PayloadSpecificationTooManyBlobFields), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2204, ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10231, type_10232), Reflex::Literal("operator="), operator_8526, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10232), Reflex::Literal("PayloadSpecificationTooManyBlobFields"), constructor_8527, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_4025), Reflex::Literal("PayloadSpecificationTooManyBlobFields"), constructor_8528, 0, "nBlobFields;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationTooManyBlobFields"), destructor_8529, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationTooManyBlobFields -------------------
void __cool__PayloadSpecificationTooManyBlobFields_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationTooManyBlobFields -------------------
void __cool__PayloadSpecificationTooManyBlobFields_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FolderSpecification -------------------------------
static void destructor_8533(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderSpecification*)o)->::cool::FolderSpecification::~FolderSpecification();
}
static void constructor_8534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
  else ::new(mem) ::cool::FolderSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
}

static void constructor_8535( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]);
  else ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(::cool::PayloadMode::Mode*)arg[2]);
  else ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(::cool::PayloadMode::Mode*)arg[2]);
  }
}

static void constructor_8536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(const ::cool::FolderSpecification*)arg[0]);
  else ::new(mem) ::cool::FolderSpecification(*(const ::cool::FolderSpecification*)arg[0]);
}

static  void operator_8537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderSpecification*)o)->operator=)(*(const ::cool::FolderSpecification*)arg[0]);
  else   (((::cool::FolderSpecification*)o)->operator=)(*(const ::cool::FolderSpecification*)arg[0]);
}

static  void method_8538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FolderSpecification*)o)->versioningMode)();
  else   (((const ::cool::FolderSpecification*)o)->versioningMode)();
}

static  void method_8539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FolderSpecification*)o)->payloadSpecification)();
  else   (((const ::cool::FolderSpecification*)o)->payloadSpecification)();
}

static  void method_8540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FolderSpecification*)o)->payloadMode)();
  else   (((const ::cool::FolderSpecification*)o)->payloadMode)();
}

static void method_x183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSpecification")), ::Reflex::BaseOffset< ::cool::FolderSpecification,::cool::IFolderSpecification >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderSpecification -------------------------------
void __cool__FolderSpecification_db_datamem(Reflex::Class*);
void __cool__FolderSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderSpecification_datamem_bld(&__cool__FolderSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderSpecification_funcmem_bld(&__cool__FolderSpecification_db_funcmem);
void __cool__FolderSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderSpecification"), typeid(::cool::FolderSpecification), sizeof(::cool::FolderSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2286, ::Reflex::BaseOffset< ::cool::FolderSpecification, ::cool::IFolderSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderSpecification"), destructor_8533, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10023), Reflex::Literal("FolderSpecification"), constructor_8534, 0, "payloadSpecification", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8580, type_10023, type_7924), Reflex::Literal("FolderSpecification"), constructor_8535, 0, "mode;payloadSpecification;payloadMode=INLINEPAYLOAD", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10233), Reflex::Literal("FolderSpecification"), constructor_8536, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FolderSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FolderSpecification_funcmem_bld);
}

//------Delayed data member builder for class FolderSpecification -------------------
void __cool__FolderSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8580, Reflex::Literal("m_versioningMode"), OffsetOf(__shadow__::__cool__FolderSpecification, m_versioningMode), ::Reflex::PRIVATE)
  .AddDataMember(type_2193, Reflex::Literal("m_payloadSpec"), OffsetOf(__shadow__::__cool__FolderSpecification, m_payloadSpec), ::Reflex::PRIVATE)
  .AddDataMember(type_7924, Reflex::Literal("m_payloadMode"), OffsetOf(__shadow__::__cool__FolderSpecification, m_payloadMode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FolderSpecification -------------------
void __cool__FolderSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234, type_10233), Reflex::Literal("operator="), operator_8537, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10224), Reflex::Literal("versioningMode"), method_8538, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10023), Reflex::Literal("payloadSpecification"), method_8539, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10225), Reflex::Literal("payloadMode"), method_8540, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PayloadSpecificationTooManyString255Fields -------------------------------
static  void operator_8581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationTooManyString255Fields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
  else   (((::cool::PayloadSpecificationTooManyString255Fields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
}

static void constructor_8582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
}

static void constructor_8583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8584(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationTooManyString255Fields*)o)->::cool::PayloadSpecificationTooManyString255Fields::~PayloadSpecificationTooManyString255Fields();
}
static void method_x184( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationTooManyString255Fields -------------------------------
void __cool__PayloadSpecificationTooManyString255Fields_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationTooManyString255Fields_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyString255Fields_datamem_bld(&__cool__PayloadSpecificationTooManyString255Fields_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyString255Fields_funcmem_bld(&__cool__PayloadSpecificationTooManyString255Fields_db_funcmem);
void __cool__PayloadSpecificationTooManyString255Fields_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyString255Fields"), typeid(::cool::PayloadSpecificationTooManyString255Fields), sizeof(::cool::PayloadSpecificationTooManyString255Fields), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2204, ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10238, type_10239), Reflex::Literal("operator="), operator_8581, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10239), Reflex::Literal("PayloadSpecificationTooManyString255Fields"), constructor_8582, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2256, type_4025), Reflex::Literal("PayloadSpecificationTooManyString255Fields"), constructor_8583, 0, "nString255Fields;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationTooManyString255Fields"), destructor_8584, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x184, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationTooManyString255Fields -------------------
void __cool__PayloadSpecificationTooManyString255Fields_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationTooManyString255Fields -------------------
void __cool__PayloadSpecificationTooManyString255Fields_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class AttributeListSpecification -------------------------------
static void constructor_8605( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListSpecification();
  else ::new(mem) ::coral::AttributeListSpecification();
}

static void constructor_8606( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListSpecification(*(const ::coral::AttributeListSpecification*)arg[0]);
  else ::new(mem) ::coral::AttributeListSpecification(*(const ::coral::AttributeListSpecification*)arg[0]);
}

static  void method_8607( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::coral::AttributeListSpecification*)o)->release)();
}

static  void method_8608( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeListSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::type_info*)arg[1]);
}

static  void method_8609( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeListSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::coral::AttributeListSpecification*)o)->size)());
  else   (((const ::coral::AttributeListSpecification*)o)->size)();
}

static  void operator_8611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification*)o)->operator==)(*(const ::coral::AttributeListSpecification*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->operator==)(*(const ::coral::AttributeListSpecification*)arg[0]);
}

static  void operator_8612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification*)o)->operator!=)(*(const ::coral::AttributeListSpecification*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->operator!=)(*(const ::coral::AttributeListSpecification*)arg[0]);
}

static  void method_8613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void method_8614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::AttributeListSpecification*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void operator_8615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeListSpecification*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::coral::AttributeListSpecification*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_8616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeListSpecification*)o)->specificationForAttribute)(*(int*)arg[0]);
  else   (((const ::coral::AttributeListSpecification*)o)->specificationForAttribute)(*(int*)arg[0]);
}

static  void method_8617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeListSpecification::const_iterator)((((const ::coral::AttributeListSpecification*)o)->begin)());
  else   (((const ::coral::AttributeListSpecification*)o)->begin)();
}

static  void method_8618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeListSpecification::const_iterator)((((const ::coral::AttributeListSpecification*)o)->end)());
  else   (((const ::coral::AttributeListSpecification*)o)->end)();
}

//------Dictionary for class AttributeListSpecification -------------------------------
void __coral__AttributeListSpecification_db_datamem(Reflex::Class*);
void __coral__AttributeListSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification_datamem_bld(&__coral__AttributeListSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification_funcmem_bld(&__coral__AttributeListSpecification_db_funcmem);
void __coral__AttributeListSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeListSpecification"), typeid(::coral::AttributeListSpecification), sizeof(::coral::AttributeListSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeListSpecification"), constructor_8605, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10253), Reflex::Literal("AttributeListSpecification"), constructor_8606, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__coral__AttributeListSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeListSpecification_funcmem_bld);
}

//------Delayed data member builder for class AttributeListSpecification -------------------
void __coral__AttributeListSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_30, Reflex::Literal("m_counter"), OffsetOf(__shadow__::__coral__AttributeListSpecification, m_counter), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1296, Reflex::Literal("m_attributeSpecifications"), OffsetOf(__shadow__::__coral__AttributeListSpecification, m_attributeSpecifications), ::Reflex::PRIVATE)
  .AddDataMember(type_1516, Reflex::Literal("m_mapOfNameToIndex"), OffsetOf(__shadow__::__coral__AttributeListSpecification, m_mapOfNameToIndex), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class AttributeListSpecification -------------------
void __coral__AttributeListSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("release"), method_8607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_9682), Reflex::Literal("extend"), method_8608, 0, "name;type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025), Reflex::Literal("extend"), method_8609, 0, "name;typeName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_792), Reflex::Literal("size"), method_8610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10253), Reflex::Literal("operator=="), operator_8611, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10253), Reflex::Literal("operator!="), operator_8612, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("exists"), method_8613, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30, type_4025), Reflex::Literal("index"), method_8614, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10254, type_792), Reflex::Literal("operator[]"), operator_8615, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10254, type_30), Reflex::Literal("specificationForAttribute"), method_8616, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8601), Reflex::Literal("begin"), method_8617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8601), Reflex::Literal("end"), method_8618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class AttributeSpecification -------------------------------
static  void operator_8628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeSpecification*)o)->operator=)(*(const ::coral::AttributeSpecification*)arg[0]);
  else   (((::coral::AttributeSpecification*)o)->operator=)(*(const ::coral::AttributeSpecification*)arg[0]);
}

static  void method_8629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::coral::AttributeSpecification*)o)->name)());
  else   (((const ::coral::AttributeSpecification*)o)->name)();
}

static  void method_8630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeSpecification*)o)->type)();
  else   (((const ::coral::AttributeSpecification*)o)->type)();
}

static  void method_8631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::coral::AttributeSpecification*)o)->typeName)());
  else   (((const ::coral::AttributeSpecification*)o)->typeName)();
}

static  void operator_8632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeSpecification*)o)->operator==)(*(const ::coral::AttributeSpecification*)arg[0]));
  else   (((const ::coral::AttributeSpecification*)o)->operator==)(*(const ::coral::AttributeSpecification*)arg[0]);
}

static  void operator_8633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeSpecification*)o)->operator!=)(*(const ::coral::AttributeSpecification*)arg[0]));
  else   (((const ::coral::AttributeSpecification*)o)->operator!=)(*(const ::coral::AttributeSpecification*)arg[0]);
}

static  void method_8634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::coral::AttributeSpecification*)o)->typeNameForId)(*(const ::std::type_info*)arg[0]));
  else   (((::coral::AttributeSpecification*)o)->typeNameForId)(*(const ::std::type_info*)arg[0]);
}

static  void method_8635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::AttributeSpecification*)o)->typeIdForName)(*(const ::std::string*)arg[0]));
  else   (((::coral::AttributeSpecification*)o)->typeIdForName)(*(const ::std::string*)arg[0]);
}

//------Dictionary for class AttributeSpecification -------------------------------
void __coral__AttributeSpecification_db_datamem(Reflex::Class*);
void __coral__AttributeSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeSpecification_datamem_bld(&__coral__AttributeSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeSpecification_funcmem_bld(&__coral__AttributeSpecification_db_funcmem);
void __coral__AttributeSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeSpecification"), typeid(::coral::AttributeSpecification), sizeof(::coral::AttributeSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddOnDemandDataMemberBuilder(&__coral__AttributeSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeSpecification_funcmem_bld);
}

//------Delayed data member builder for class AttributeSpecification -------------------
void __coral__AttributeSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1340, Reflex::Literal("m_name"), OffsetOf(__shadow__::__coral__AttributeSpecification, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_9683, Reflex::Literal("m_type"), OffsetOf(__shadow__::__coral__AttributeSpecification, m_type), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class AttributeSpecification -------------------
void __coral__AttributeSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10256, type_10254), Reflex::Literal("operator="), operator_8628, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340), Reflex::Literal("name"), method_8629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9682), Reflex::Literal("type"), method_8630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340), Reflex::Literal("typeName"), method_8631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10254), Reflex::Literal("operator=="), operator_8632, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_10254), Reflex::Literal("operator!="), operator_8633, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1340, type_9682), Reflex::Literal("typeNameForId"), method_8634, 0, "type", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9683, type_4025), Reflex::Literal("typeIdForName"), method_8635, 0, "typeName", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IConnectionServiceConfiguration -------------------------------
static  void operator_8637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionServiceConfiguration*)o)->operator=)(*(const ::coral::IConnectionServiceConfiguration*)arg[0]);
  else   (((::coral::IConnectionServiceConfiguration*)o)->operator=)(*(const ::coral::IConnectionServiceConfiguration*)arg[0]);
}

static  void method_8640( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enableReplicaFailOver)();
}

static  void method_8641( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disableReplicaFailOver)();
}

static  void method_8642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isReplicaFailoverEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isReplicaFailoverEnabled)();
}

static  void method_8643( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enableConnectionSharing)();
}

static  void method_8644( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disableConnectionSharing)();
}

static  void method_8645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isConnectionSharingEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isConnectionSharingEnabled)();
}

static  void method_8646( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enableReadOnlySessionOnUpdateConnections)();
}

static  void method_8647( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disableReadOnlySessionOnUpdateConnections)();
}

static  void method_8648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isReadOnlySessionOnUpdateConnectionsEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isReadOnlySessionOnUpdateConnectionsEnabled)();
}

static  void method_8649( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setConnectionRetrialPeriod)(*(int*)arg[0]);
}

static  void method_8650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialPeriod)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialPeriod)();
}

static  void method_8651( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setConnectionRetrialTimeOut)(*(int*)arg[0]);
}

static  void method_8652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialTimeOut)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialTimeOut)();
}

static  void method_8653( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setConnectionTimeOut)(*(int*)arg[0]);
}

static  void method_8654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->connectionTimeOut)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->connectionTimeOut)();
}

static  void method_8655( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enablePoolAutomaticCleanUp)();
}

static  void method_8656( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disablePoolAutomaticCleanUp)();
}

static  void method_8657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isPoolAutomaticCleanUpEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isPoolAutomaticCleanUpEnabled)();
}

static  void method_8658( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMissingConnectionExclusionTime)(*(int*)arg[0]);
}

static  void method_8659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->missingConnectionExclusionTime)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->missingConnectionExclusionTime)();
}

static  void method_8660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMonitoringLevel)(*(::coral::monitor::Level*)arg[0]);
}

static  void method_8661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->monitoringLevel)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->monitoringLevel)();
}

static  void method_8662( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setAuthenticationService)(*(const ::std::string*)arg[0]);
}

static  void method_8663( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setLookupService)(*(const ::std::string*)arg[0]);
}

static  void method_8664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setRelationalService)(*(const ::std::string*)arg[0]);
}

static  void method_8665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMonitoringService)(*(const ::std::string*)arg[0]);
}

static  void method_8666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setAuthenticationService)(*(::coral::IAuthenticationService*)arg[0]);
}

static  void method_8667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setLookupService)(*(::coral::ILookupService*)arg[0]);
}

static  void method_8668( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setRelationalService)(*(::coral::IRelationalService*)arg[0]);
}

static  void method_8669( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMonitoringService)(*(::coral::monitor::IMonitoringService*)arg[0]);
}

static  void method_8670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setReplicaSortingAlgorithm)(*(::coral::IReplicaSortingAlgorithm*)arg[0]);
}

static  void method_8671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->authenticationService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->authenticationService)();
}

static  void method_8672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->lookupService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->lookupService)();
}

static  void method_8673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->relationalService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->relationalService)();
}

static  void method_8674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->monitoringService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->monitoringService)();
}

static  void method_8675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::IConnectionServiceConfiguration*)o)->replicaSortingAlgorithm)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->replicaSortingAlgorithm)();
}

//------Dictionary for class IConnectionServiceConfiguration -------------------------------
void __coral__IConnectionServiceConfiguration_db_datamem(Reflex::Class*);
void __coral__IConnectionServiceConfiguration_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IConnectionServiceConfiguration_datamem_bld(&__coral__IConnectionServiceConfiguration_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IConnectionServiceConfiguration_funcmem_bld(&__coral__IConnectionServiceConfiguration_db_funcmem);
void __coral__IConnectionServiceConfiguration_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IConnectionServiceConfiguration"), typeid(::coral::IConnectionServiceConfiguration), sizeof(::coral::IConnectionServiceConfiguration), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IConnectionServiceConfiguration")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10257, type_10258), Reflex::Literal("operator="), operator_8637, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IConnectionServiceConfiguration_funcmem_bld);
}

//------Delayed data member builder for class IConnectionServiceConfiguration -------------------
void __coral__IConnectionServiceConfiguration_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IConnectionServiceConfiguration -------------------
void __coral__IConnectionServiceConfiguration_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("enableReplicaFailOver"), method_8640, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("disableReplicaFailOver"), method_8641, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isReplicaFailoverEnabled"), method_8642, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("enableConnectionSharing"), method_8643, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("disableConnectionSharing"), method_8644, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isConnectionSharingEnabled"), method_8645, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("enableReadOnlySessionOnUpdateConnections"), method_8646, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("disableReadOnlySessionOnUpdateConnections"), method_8647, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isReadOnlySessionOnUpdateConnectionsEnabled"), method_8648, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_30), Reflex::Literal("setConnectionRetrialPeriod"), method_8649, 0, "timeInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("connectionRetrialPeriod"), method_8650, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_30), Reflex::Literal("setConnectionRetrialTimeOut"), method_8651, 0, "timeOutInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("connectionRetrialTimeOut"), method_8652, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_30), Reflex::Literal("setConnectionTimeOut"), method_8653, 0, "timeOutInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("connectionTimeOut"), method_8654, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("enablePoolAutomaticCleanUp"), method_8655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("disablePoolAutomaticCleanUp"), method_8656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isPoolAutomaticCleanUpEnabled"), method_8657, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_30), Reflex::Literal("setMissingConnectionExclusionTime"), method_8658, 0, "timeInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("missingConnectionExclusionTime"), method_8659, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8751), Reflex::Literal("setMonitoringLevel"), method_8660, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8751), Reflex::Literal("monitoringLevel"), method_8661, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1340c), Reflex::Literal("setAuthenticationService"), method_8662, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025), Reflex::Literal("setLookupService"), method_8663, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025), Reflex::Literal("setRelationalService"), method_8664, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025), Reflex::Literal("setMonitoringService"), method_8665, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10259), Reflex::Literal("setAuthenticationService"), method_8666, 0, "customAuthenticationService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10260), Reflex::Literal("setLookupService"), method_8667, 0, "customLookupService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10261), Reflex::Literal("setRelationalService"), method_8668, 0, "customRelationalService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10262), Reflex::Literal("setMonitoringService"), method_8669, 0, "customMonitoringService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10263), Reflex::Literal("setReplicaSortingAlgorithm"), method_8670, 0, "algorithm", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10259), Reflex::Literal("authenticationService"), method_8671, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10260), Reflex::Literal("lookupService"), method_8672, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10261), Reflex::Literal("relationalService"), method_8673, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10262), Reflex::Literal("monitoringService"), method_8674, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10264), Reflex::Literal("replicaSortingAlgorithm"), method_8675, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class Attribute -------------------------------
static  void operator_8679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->operator=)(*(const ::coral::Attribute*)arg[0]);
  else   (((::coral::Attribute*)o)->operator=)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->fastCopy)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->specification)();
  else   (((const ::coral::Attribute*)o)->specification)();
}

static  void method_8730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValueFromAddress)((const void*)arg[0]);
}

static  void method_8731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::coral::Attribute*)o)->copyValueToAddress)((void*)arg[0]);
}

static  void method_8732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::Attribute*)o)->addressOfData)());
  else   (((::coral::Attribute*)o)->addressOfData)();
}

static  void method_8733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::Attribute*)o)->addressOfData)());
  else   (((const ::coral::Attribute*)o)->addressOfData)();
}

static  void method_8734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->shareData)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->bindUnsafely)((const void*)arg[0]);
}

static  void method_8736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->bindUnsafely)((void*)arg[0]);
}

static  void method_8737( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::coral::Attribute*)o)->setNull)();
  }
  else if ( arg.size() == 1 ) { 
    (((::coral::Attribute*)o)->setNull)(*(bool*)arg[0]);
  }
}

static  void method_8738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->isNull)());
  else   (((const ::coral::Attribute*)o)->isNull)();
}

static  void method_8739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::Attribute*)o)->size)());
  else   (((const ::coral::Attribute*)o)->size)();
}

static  void operator_8740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->operator==)(*(const ::coral::Attribute*)arg[0]));
  else   (((const ::coral::Attribute*)o)->operator==)(*(const ::coral::Attribute*)arg[0]);
}

static  void operator_8741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->operator!=)(*(const ::coral::Attribute*)arg[0]));
  else   (((const ::coral::Attribute*)o)->operator!=)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
    else     (((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0],
      *(bool*)arg[1]);
    else     (((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->isValidData)());
  else   (((const ::coral::Attribute*)o)->isValidData)();
}

static  void method_8682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<coral::Blob>)();
  else   (((::coral::Attribute*)o)->data<coral::Blob>)();
}

static  void method_8683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<std::string>)();
  else   (((::coral::Attribute*)o)->data<std::string>)();
}

static  void method_8684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<long double>)();
  else   (((::coral::Attribute*)o)->data<long double>)();
}

static  void method_8685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<double>)();
  else   (((::coral::Attribute*)o)->data<double>)();
}

static  void method_8686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<float>)();
  else   (((::coral::Attribute*)o)->data<float>)();
}

static  void method_8687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned long long>)();
  else   (((::coral::Attribute*)o)->data<unsigned long long>)();
}

static  void method_8688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<long long>)();
  else   (((::coral::Attribute*)o)->data<long long>)();
}

static  void method_8689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned long>)();
  else   (((::coral::Attribute*)o)->data<unsigned long>)();
}

static  void method_8690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<long>)();
  else   (((::coral::Attribute*)o)->data<long>)();
}

static  void method_8691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned int>)();
  else   (((::coral::Attribute*)o)->data<unsigned int>)();
}

static  void method_8692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<int>)();
  else   (((::coral::Attribute*)o)->data<int>)();
}

static  void method_8693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned short>)();
  else   (((::coral::Attribute*)o)->data<unsigned short>)();
}

static  void method_8694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<short>)();
  else   (((::coral::Attribute*)o)->data<short>)();
}

static  void method_8695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned char>)();
  else   (((::coral::Attribute*)o)->data<unsigned char>)();
}

static  void method_8696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<char>)();
  else   (((::coral::Attribute*)o)->data<char>)();
}

static  void method_8697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<bool>)();
  else   (((::coral::Attribute*)o)->data<bool>)();
}

static  void method_8698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<coral::Blob>)();
  else   (((const ::coral::Attribute*)o)->data<coral::Blob>)();
}

static  void method_8699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<std::string>)();
  else   (((const ::coral::Attribute*)o)->data<std::string>)();
}

static  void method_8700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<long double>)();
  else   (((const ::coral::Attribute*)o)->data<long double>)();
}

static  void method_8701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<double>)();
  else   (((const ::coral::Attribute*)o)->data<double>)();
}

static  void method_8702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<float>)();
  else   (((const ::coral::Attribute*)o)->data<float>)();
}

static  void method_8703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned long long>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned long long>)();
}

static  void method_8704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<long long>)();
  else   (((const ::coral::Attribute*)o)->data<long long>)();
}

static  void method_8705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned long>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned long>)();
}

static  void method_8706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<long>)();
  else   (((const ::coral::Attribute*)o)->data<long>)();
}

static  void method_8707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned int>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned int>)();
}

static  void method_8708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<int>)();
  else   (((const ::coral::Attribute*)o)->data<int>)();
}

static  void method_8709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned short>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned short>)();
}

static  void method_8710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<short>)();
  else   (((const ::coral::Attribute*)o)->data<short>)();
}

static  void method_8711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned char>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned char>)();
}

static  void method_8712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<char>)();
  else   (((const ::coral::Attribute*)o)->data<char>)();
}

static  void method_8713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<bool>)();
  else   (((const ::coral::Attribute*)o)->data<bool>)();
}

static  void method_8714( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<coral::Blob>)(*(const ::coral::Blob*)arg[0]);
}

static  void method_8715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<std::string>)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_8716( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<long double>)(*(const long double*)arg[0]);
}

static  void method_8717( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<double>)(*(const double*)arg[0]);
}

static  void method_8718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<float>)(*(const float*)arg[0]);
}

static  void method_8719( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned long long>)(*(const unsigned long long*)arg[0]);
}

static  void method_8720( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<long long>)(*(const long long*)arg[0]);
}

static  void method_8721( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned long>)(*(const unsigned long*)arg[0]);
}

static  void method_8722( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<long>)(*(const long*)arg[0]);
}

static  void method_8723( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned int>)(*(const unsigned int*)arg[0]);
}

static  void method_8724( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<int>)(*(const int*)arg[0]);
}

static  void method_8725( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned short>)(*(const unsigned short*)arg[0]);
}

static  void method_8726( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<short>)(*(const short*)arg[0]);
}

static  void method_8727( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned char>)(*(const unsigned char*)arg[0]);
}

static  void method_8728( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<char>)(*(const char*)arg[0]);
}

static  void method_8729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<bool>)(*(const bool*)arg[0]);
}

//------Dictionary for class Attribute -------------------------------
void __coral__Attribute_db_datamem(Reflex::Class*);
void __coral__Attribute_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__Attribute_datamem_bld(&__coral__Attribute_db_datamem);
Reflex::GenreflexMemberBuilder __coral__Attribute_funcmem_bld(&__coral__Attribute_db_funcmem);
void __coral__Attribute_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::Attribute"), typeid(::coral::Attribute), sizeof(::coral::Attribute), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddOnDemandDataMemberBuilder(&__coral__Attribute_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__Attribute_funcmem_bld);
}

//------Delayed data member builder for class Attribute -------------------
void __coral__Attribute_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10265, Reflex::Literal("m_specification"), OffsetOf(__shadow__::__coral__Attribute, m_specification), ::Reflex::PRIVATE)
  .AddDataMember(type_10266, Reflex::Literal("m_data"), OffsetOf(__shadow__::__coral__Attribute, m_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Attribute -------------------
void __coral__Attribute_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10267, type_8804), Reflex::Literal("operator="), operator_8679, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8804), Reflex::Literal("fastCopy"), method_8680, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10254), Reflex::Literal("specification"), method_8681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1914), Reflex::Literal("setValueFromAddress"), method_8730, 0, "externalAddress", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_172), Reflex::Literal("copyValueToAddress"), method_8731, 0, "externalAddress", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("addressOfData"), method_8732, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914), Reflex::Literal("addressOfData"), method_8733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8804), Reflex::Literal("shareData"), method_8734, 0, "sourceAttribute", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1914), Reflex::Literal("bindUnsafely"), method_8735, 0, "externalAddress", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_172), Reflex::Literal("bindUnsafely"), method_8736, 0, "externalAddress", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_1770), Reflex::Literal("setNull"), method_8737, 0, "isVariableNull=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isNull"), method_8738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("size"), method_8739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8804), Reflex::Literal("operator=="), operator_8740, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8804), Reflex::Literal("operator!="), operator_8741, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415, type_1770), Reflex::Literal("toOutputStream"), method_8742, 0, "os;valueOnly=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isValidData"), method_8743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10147), Reflex::Literal("data<coral::Blob>"), method_8682, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2946), Reflex::Literal("data<std::string>"), method_8683, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4514), Reflex::Literal("data<long double>"), method_8684, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4515), Reflex::Literal("data<double>"), method_8685, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4516), Reflex::Literal("data<float>"), method_8686, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9129), Reflex::Literal("data<unsigned long long>"), method_8687, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9128), Reflex::Literal("data<long long>"), method_8688, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9127), Reflex::Literal("data<unsigned long>"), method_8689, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9126), Reflex::Literal("data<long>"), method_8690, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3168), Reflex::Literal("data<unsigned int>"), method_8691, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9125), Reflex::Literal("data<int>"), method_8692, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9124), Reflex::Literal("data<unsigned short>"), method_8693, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9123), Reflex::Literal("data<short>"), method_8694, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5666), Reflex::Literal("data<unsigned char>"), method_8695, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3032), Reflex::Literal("data<char>"), method_8696, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4385), Reflex::Literal("data<bool>"), method_8697, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10015), Reflex::Literal("data<coral::Blob>"), method_8698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103), Reflex::Literal("data<std::string>"), method_8699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10268), Reflex::Literal("data<long double>"), method_8700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10016), Reflex::Literal("data<double>"), method_8701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10017), Reflex::Literal("data<float>"), method_8702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10018), Reflex::Literal("data<unsigned long long>"), method_8703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10019), Reflex::Literal("data<long long>"), method_8704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10269), Reflex::Literal("data<unsigned long>"), method_8705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10270), Reflex::Literal("data<long>"), method_8706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3170), Reflex::Literal("data<unsigned int>"), method_8707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5911), Reflex::Literal("data<int>"), method_8708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10020), Reflex::Literal("data<unsigned short>"), method_8709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10021), Reflex::Literal("data<short>"), method_8710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10022), Reflex::Literal("data<unsigned char>"), method_8711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3883), Reflex::Literal("data<char>"), method_8712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5910), Reflex::Literal("data<bool>"), method_8713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10015), Reflex::Literal("setValue<coral::Blob>"), method_8714, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3103), Reflex::Literal("setValue<std::string>"), method_8715, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10268), Reflex::Literal("setValue<long double>"), method_8716, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10016), Reflex::Literal("setValue<double>"), method_8717, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10017), Reflex::Literal("setValue<float>"), method_8718, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10018), Reflex::Literal("setValue<unsigned long long>"), method_8719, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10019), Reflex::Literal("setValue<long long>"), method_8720, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10269), Reflex::Literal("setValue<unsigned long>"), method_8721, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10270), Reflex::Literal("setValue<long>"), method_8722, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3170), Reflex::Literal("setValue<unsigned int>"), method_8723, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_5911), Reflex::Literal("setValue<int>"), method_8724, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10020), Reflex::Literal("setValue<unsigned short>"), method_8725, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10021), Reflex::Literal("setValue<short>"), method_8726, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_10022), Reflex::Literal("setValue<unsigned char>"), method_8727, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_3883), Reflex::Literal("setValue<char>"), method_8728, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_5910), Reflex::Literal("setValue<bool>"), method_8729, 0, "value", ::Reflex::PUBLIC);
}
//------Stub functions for class AttributeList -------------------------------
static void constructor_8759( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList();
  else ::new(mem) ::coral::AttributeList();
}

static void constructor_8760( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0]);
  else ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0],
      *(bool*)arg[1]);
  }
}

static void constructor_8761( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeList*)arg[0]);
  else ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeList*)arg[0]);
}

static void destructor_8762(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeList*)o)->::coral::AttributeList::~AttributeList();
}
static  void operator_8763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->operator=)(*(const ::coral::AttributeList*)arg[0]);
  else   (((::coral::AttributeList*)o)->operator=)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8764( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->copyData)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8765( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->fastCopyData)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->specification)();
  else   (((const ::coral::AttributeList*)o)->specification)();
}

static  void method_8767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::type_info*)arg[1]);
}

static  void method_8769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::coral::AttributeList*)o)->size)());
  else   (((const ::coral::AttributeList*)o)->size)();
}

static  void operator_8770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList*)o)->operator==)(*(const ::coral::AttributeList*)arg[0]));
  else   (((const ::coral::AttributeList*)o)->operator==)(*(const ::coral::AttributeList*)arg[0]);
}

static  void operator_8771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList*)o)->operator!=)(*(const ::coral::AttributeList*)arg[0]));
  else   (((const ::coral::AttributeList*)o)->operator!=)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::AttributeList*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void operator_8773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_8776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_8777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->merge)(*(const ::coral::AttributeList*)arg[0]);
  else   (((::coral::AttributeList*)o)->merge)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
  else   (((const ::coral::AttributeList*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
}

static  void method_8779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::iterator)((((::coral::AttributeList*)o)->begin)());
  else   (((::coral::AttributeList*)o)->begin)();
}

static  void method_8780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::iterator)((((::coral::AttributeList*)o)->end)());
  else   (((::coral::AttributeList*)o)->end)();
}

static  void method_8781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::const_iterator)((((const ::coral::AttributeList*)o)->begin)());
  else   (((const ::coral::AttributeList*)o)->begin)();
}

static  void method_8782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::const_iterator)((((const ::coral::AttributeList*)o)->end)());
  else   (((const ::coral::AttributeList*)o)->end)();
}

static void method_newdel_2342( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AttributeList -------------------------------
void __coral__AttributeList_db_datamem(Reflex::Class*);
void __coral__AttributeList_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList_datamem_bld(&__coral__AttributeList_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList_funcmem_bld(&__coral__AttributeList_db_funcmem);
void __coral__AttributeList_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList"), typeid(::coral::AttributeList), sizeof(::coral::AttributeList), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeList"), constructor_8759, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10253, type_1770), Reflex::Literal("AttributeList"), constructor_8760, 0, "spec;sharedSpecification=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8803), Reflex::Literal("AttributeList"), constructor_8761, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AttributeList"), destructor_8762, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2342, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__coral__AttributeList_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList_funcmem_bld);
}

//------Delayed data member builder for class AttributeList -------------------
void __coral__AttributeList_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10271, Reflex::Literal("m_specification"), OffsetOf(__shadow__::__coral__AttributeList, m_specification), ::Reflex::PRIVATE)
  .AddDataMember(type_1770, Reflex::Literal("m_ownSpecification"), OffsetOf(__shadow__::__coral__AttributeList, m_ownSpecification), ::Reflex::PRIVATE)
  .AddDataMember(type_1297, Reflex::Literal("m_data"), OffsetOf(__shadow__::__coral__AttributeList, m_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class AttributeList -------------------
void __coral__AttributeList_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10296, type_8803), Reflex::Literal("operator="), operator_8763, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8803), Reflex::Literal("copyData"), method_8764, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_8803), Reflex::Literal("fastCopyData"), method_8765, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10253), Reflex::Literal("specification"), method_8766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025), Reflex::Literal("extend"), method_8767, 0, "name;typeName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_9682), Reflex::Literal("extend"), method_8768, 0, "name;type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_792), Reflex::Literal("size"), method_8769, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8803), Reflex::Literal("operator=="), operator_8770, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_8803), Reflex::Literal("operator!="), operator_8771, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("exists"), method_8772, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10267, type_1340c), Reflex::Literal("operator[]"), operator_8773, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8804, type_1340c), Reflex::Literal("operator[]"), operator_8774, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10267, type_75), Reflex::Literal("operator[]"), operator_8775, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8804, type_75), Reflex::Literal("operator[]"), operator_8776, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10296, type_8803), Reflex::Literal("merge"), method_8777, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8415, type_8415), Reflex::Literal("toOutputStream"), method_8778, 0, "os", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8754), Reflex::Literal("begin"), method_8779, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8754), Reflex::Literal("end"), method_8780, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8753), Reflex::Literal("begin"), method_8781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8753), Reflex::Literal("end"), method_8782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IWebCacheInfo -------------------------------
static  void operator_8783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IWebCacheInfo*)o)->operator=)(*(const ::coral::IWebCacheInfo*)arg[0]);
  else   (((::coral::IWebCacheInfo*)o)->operator=)(*(const ::coral::IWebCacheInfo*)arg[0]);
}

static  void method_8786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IWebCacheInfo*)o)->isSchemaInfoCached)());
  else   (((const ::coral::IWebCacheInfo*)o)->isSchemaInfoCached)();
}

static  void method_8787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IWebCacheInfo*)o)->isTableCached)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::IWebCacheInfo*)o)->isTableCached)(*(const ::std::string*)arg[0]);
}

//------Dictionary for class IWebCacheInfo -------------------------------
void __coral__IWebCacheInfo_db_datamem(Reflex::Class*);
void __coral__IWebCacheInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IWebCacheInfo_datamem_bld(&__coral__IWebCacheInfo_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IWebCacheInfo_funcmem_bld(&__coral__IWebCacheInfo_db_funcmem);
void __coral__IWebCacheInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IWebCacheInfo"), typeid(::coral::IWebCacheInfo), sizeof(::coral::IWebCacheInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IWebCacheInfo")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10297, type_10298), Reflex::Literal("operator="), operator_8783, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IWebCacheInfo_funcmem_bld);
}

//------Delayed data member builder for class IWebCacheInfo -------------------
void __coral__IWebCacheInfo_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IWebCacheInfo -------------------
void __coral__IWebCacheInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("isSchemaInfoCached"), method_8786, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_4025), Reflex::Literal("isTableCached"), method_8787, 0, "tableName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IWebCacheControl -------------------------------
static  void operator_8789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IWebCacheControl*)o)->operator=)(*(const ::coral::IWebCacheControl*)arg[0]);
  else   (((::coral::IWebCacheControl*)o)->operator=)(*(const ::coral::IWebCacheControl*)arg[0]);
}

static  void method_8792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->refreshSchemaInfo)(*(const ::std::string*)arg[0]);
}

static  void method_8793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->refreshTable)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IWebCacheControl*)o)->webCacheInfo)(*(const ::std::string*)arg[0]);
  else   (((const ::coral::IWebCacheControl*)o)->webCacheInfo)(*(const ::std::string*)arg[0]);
}

static  void method_8795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::coral::IWebCacheControl*)o)->compressionLevel)());
  else   (((::coral::IWebCacheControl*)o)->compressionLevel)();
}

static  void method_8796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->setCompressionLevel)(*(int*)arg[0]);
}

static  void method_8797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->setProxyList)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

//------Dictionary for class IWebCacheControl -------------------------------
void __coral__IWebCacheControl_db_datamem(Reflex::Class*);
void __coral__IWebCacheControl_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IWebCacheControl_datamem_bld(&__coral__IWebCacheControl_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IWebCacheControl_funcmem_bld(&__coral__IWebCacheControl_db_funcmem);
void __coral__IWebCacheControl_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IWebCacheControl"), typeid(::coral::IWebCacheControl), sizeof(::coral::IWebCacheControl), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IWebCacheControl")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299, type_10300), Reflex::Literal("operator="), operator_8789, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IWebCacheControl_funcmem_bld);
}

//------Delayed data member builder for class IWebCacheControl -------------------
void __coral__IWebCacheControl_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IWebCacheControl -------------------
void __coral__IWebCacheControl_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025), Reflex::Literal("refreshSchemaInfo"), method_8792, 0, "connection", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_4025, type_4025), Reflex::Literal("refreshTable"), method_8793, 0, "connection;tableName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10298, type_4025), Reflex::Literal("webCacheInfo"), method_8794, 0, "connection", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("compressionLevel"), method_8795, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_30), Reflex::Literal("setCompressionLevel"), method_8796, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_9192), Reflex::Literal("setProxyList"), method_8797, 0, "proxyList", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class AttributeListException -------------------------------
static  void operator_8799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeListException*)o)->operator=)(*(const ::coral::AttributeListException*)arg[0]);
  else   (((::coral::AttributeListException*)o)->operator=)(*(const ::coral::AttributeListException*)arg[0]);
}

static void constructor_8800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException(*(const ::coral::AttributeListException*)arg[0]);
  else ::new(mem) ::coral::AttributeListException(*(const ::coral::AttributeListException*)arg[0]);
}

static void constructor_8801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException();
  else ::new(mem) ::coral::AttributeListException();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException(*(::std::string*)arg[0]);
  else ::new(mem) ::coral::AttributeListException(*(::std::string*)arg[0]);
  }
}

static void destructor_8802(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeListException*)o)->::coral::AttributeListException::~AttributeListException();
}
static void constructor_x186( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException();
  else ::new(mem) ::coral::AttributeListException();
}

static void method_newdel_2347( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::Exception")), ::Reflex::BaseOffset< ::coral::AttributeListException,::coral::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::coral::AttributeListException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class AttributeListException -------------------------------
void __coral__AttributeListException_db_datamem(Reflex::Class*);
void __coral__AttributeListException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeListException_datamem_bld(&__coral__AttributeListException_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeListException_funcmem_bld(&__coral__AttributeListException_db_funcmem);
void __coral__AttributeListException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeListException"), typeid(::coral::AttributeListException), sizeof(::coral::AttributeListException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_2354, ::Reflex::BaseOffset< ::coral::AttributeListException, ::coral::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10301, type_10302), Reflex::Literal("operator="), operator_8799, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10302), Reflex::Literal("AttributeListException"), constructor_8800, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1340), Reflex::Literal("AttributeListException"), constructor_8801, 0, "errorMessage=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AttributeListException"), destructor_8802, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeListException"), constructor_x186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2347, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class AttributeListException -------------------
void __coral__AttributeListException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class AttributeListException -------------------
void __coral__AttributeListException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class AttributeException -------------------------------
static  void operator_8805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeException*)o)->operator=)(*(const ::coral::AttributeException*)arg[0]);
  else   (((::coral::AttributeException*)o)->operator=)(*(const ::coral::AttributeException*)arg[0]);
}

static void constructor_8806( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException(*(const ::coral::AttributeException*)arg[0]);
  else ::new(mem) ::coral::AttributeException(*(const ::coral::AttributeException*)arg[0]);
}

static void constructor_8807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException();
  else ::new(mem) ::coral::AttributeException();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException(*(::std::string*)arg[0]);
  else ::new(mem) ::coral::AttributeException(*(::std::string*)arg[0]);
  }
}

static void destructor_8808(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeException*)o)->::coral::AttributeException::~AttributeException();
}
static void constructor_x189( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException();
  else ::new(mem) ::coral::AttributeException();
}

static void method_newdel_2351( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::Exception")), ::Reflex::BaseOffset< ::coral::AttributeException,::coral::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::coral::AttributeException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class AttributeException -------------------------------
void __coral__AttributeException_db_datamem(Reflex::Class*);
void __coral__AttributeException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeException_datamem_bld(&__coral__AttributeException_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeException_funcmem_bld(&__coral__AttributeException_db_funcmem);
void __coral__AttributeException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeException"), typeid(::coral::AttributeException), sizeof(::coral::AttributeException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_2354, ::Reflex::BaseOffset< ::coral::AttributeException, ::coral::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10305, type_10306), Reflex::Literal("operator="), operator_8805, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10306), Reflex::Literal("AttributeException"), constructor_8806, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1340), Reflex::Literal("AttributeException"), constructor_8807, 0, "errorMessage=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AttributeException"), destructor_8808, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeException"), constructor_x189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2351, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class AttributeException -------------------
void __coral__AttributeException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class AttributeException -------------------
void __coral__AttributeException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IConnectionService -------------------------------
static  void operator_8818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionService*)o)->operator=)(*(const ::coral::IConnectionService*)arg[0]);
  else   (((::coral::IConnectionService*)o)->operator=)(*(const ::coral::IConnectionService*)arg[0]);
}

static  void method_8821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(::coral::AccessMode*)arg[1]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(::coral::AccessMode*)arg[1]);
  }
}

static  void method_8822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::coral::AccessMode*)arg[2]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::coral::AccessMode*)arg[2]);
  }
}

static  void method_8823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionService*)o)->configuration)();
  else   (((::coral::IConnectionService*)o)->configuration)();
}

static  void method_8824( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionService*)o)->purgeConnectionPool)();
}

static  void method_8825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionService*)o)->monitoringReporter)();
  else   (((const ::coral::IConnectionService*)o)->monitoringReporter)();
}

static  void method_8826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionService*)o)->webCacheControl)();
  else   (((::coral::IConnectionService*)o)->webCacheControl)();
}

//------Dictionary for class IConnectionService -------------------------------
void __coral__IConnectionService_db_datamem(Reflex::Class*);
void __coral__IConnectionService_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IConnectionService_datamem_bld(&__coral__IConnectionService_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IConnectionService_funcmem_bld(&__coral__IConnectionService_db_funcmem);
void __coral__IConnectionService_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IConnectionService"), typeid(::coral::IConnectionService), sizeof(::coral::IConnectionService), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IConnectionService")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10151, type_10309), Reflex::Literal("operator="), operator_8818, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IConnectionService_funcmem_bld);
}

//------Delayed data member builder for class IConnectionService -------------------
void __coral__IConnectionService_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IConnectionService -------------------
void __coral__IConnectionService_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10310, type_4025, type_2333), Reflex::Literal("connect"), method_8821, 0, "connectionName;accessMode=Update", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10310, type_4025, type_4025, type_2333), Reflex::Literal("connect"), method_8822, 0, "connectionName;asRole;accessMode=Update", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10257), Reflex::Literal("configuration"), method_8823, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("purgeConnectionPool"), method_8824, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10311), Reflex::Literal("monitoringReporter"), method_8825, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299), Reflex::Literal("webCacheControl"), method_8826, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class const_iterator -------------------------------
static void destructor_10244(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeListSpecification::const_iterator*)o)->::coral::AttributeListSpecification::const_iterator::~const_iterator();
}
static void constructor_10245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListSpecification::const_iterator(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
  else ::new(mem) ::coral::AttributeListSpecification::const_iterator(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

static  void operator_10246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeListSpecification::const_iterator*)o)->operator=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
  else   (((::coral::AttributeListSpecification::const_iterator*)o)->operator=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

static  void operator_10248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::AttributeListSpecification::const_iterator*)o)->operator->)());
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator->)();
}

static  void operator_10249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeListSpecification::const_iterator*)o)->operator*)();
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator*)();
}

static  void operator_10250( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::AttributeListSpecification::const_iterator*)o)->operator++)();
}

static  void operator_10251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification::const_iterator*)o)->operator==)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]));
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator==)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

static  void operator_10252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification::const_iterator*)o)->operator!=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]));
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator!=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

//------Dictionary for class const_iterator -------------------------------
void __coral__AttributeListSpecification__const_iterator_db_datamem(Reflex::Class*);
void __coral__AttributeListSpecification__const_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification__const_iterator_datamem_bld(&__coral__AttributeListSpecification__const_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification__const_iterator_funcmem_bld(&__coral__AttributeListSpecification__const_iterator_db_funcmem);
void __coral__AttributeListSpecification__const_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeListSpecification::const_iterator"), typeid(::coral::AttributeListSpecification::const_iterator), sizeof(::coral::AttributeListSpecification::const_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~const_iterator"), destructor_10244, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11329), Reflex::Literal("const_iterator"), constructor_10245, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__coral__AttributeListSpecification__const_iterator_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeListSpecification__const_iterator_funcmem_bld);
}

//------Delayed data member builder for class const_iterator -------------------
void __coral__AttributeListSpecification__const_iterator_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2034, Reflex::Literal("m_iterator"), OffsetOf(__shadow__::__coral__AttributeListSpecification__const_iterator, m_iterator), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class const_iterator -------------------
void __coral__AttributeListSpecification__const_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11330, type_11329), Reflex::Literal("operator="), operator_10246, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10265), Reflex::Literal("operator->"), operator_10248, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10254), Reflex::Literal("operator*"), operator_10249, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("operator++"), operator_10250, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_11329), Reflex::Literal("operator=="), operator_10251, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_11329), Reflex::Literal("operator!="), operator_10252, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class iterator_base -------------------------------
static  void operator_10277( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList::iterator_base*)o)->operator==)(*(const ::coral::AttributeList::iterator_base*)arg[0]));
  else   (((const ::coral::AttributeList::iterator_base*)o)->operator==)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList::iterator_base*)o)->operator!=)(*(const ::coral::AttributeList::iterator_base*)arg[0]));
  else   (((const ::coral::AttributeList::iterator_base*)o)->operator!=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10279( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::AttributeList::iterator_base*)o)->operator++)();
}

//------Dictionary for class iterator_base -------------------------------
void __coral__AttributeList__iterator_base_db_datamem(Reflex::Class*);
void __coral__AttributeList__iterator_base_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_base_datamem_bld(&__coral__AttributeList__iterator_base_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_base_funcmem_bld(&__coral__AttributeList__iterator_base_db_funcmem);
void __coral__AttributeList__iterator_base_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList::iterator_base"), typeid(::coral::AttributeList::iterator_base), sizeof(::coral::AttributeList::iterator_base), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddOnDemandDataMemberBuilder(&__coral__AttributeList__iterator_base_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList__iterator_base_funcmem_bld);
}

//------Delayed data member builder for class iterator_base -------------------
void __coral__AttributeList__iterator_base_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2037, Reflex::Literal("m_iterator"), OffsetOf(__shadow__::__coral__AttributeList__iterator_base, m_iterator), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class iterator_base -------------------
void __coral__AttributeList__iterator_base_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_11336), Reflex::Literal("operator=="), operator_10277, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_11336), Reflex::Literal("operator!="), operator_10278, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("operator++"), operator_10279, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class iterator -------------------------------
static  void operator_10280( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator*)arg[0]);
  else   (((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator*)arg[0]);
}

static void constructor_10281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator*)arg[0]);
  else ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator*)arg[0]);
}

static void destructor_10282(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeList::iterator*)o)->::coral::AttributeList::iterator::~iterator();
}
static void constructor_10283( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else   (((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::AttributeList::iterator*)o)->operator->)());
  else   (((::coral::AttributeList::iterator*)o)->operator->)();
}

static  void operator_10287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::iterator*)o)->operator*)();
  else   (((::coral::AttributeList::iterator*)o)->operator*)();
}

static void method_x192( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator_base")), ::Reflex::BaseOffset< ::coral::AttributeList::iterator,::coral::AttributeList::iterator_base >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class iterator -------------------------------
void __coral__AttributeList__iterator_db_datamem(Reflex::Class*);
void __coral__AttributeList__iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_datamem_bld(&__coral__AttributeList__iterator_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_funcmem_bld(&__coral__AttributeList__iterator_db_funcmem);
void __coral__AttributeList__iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList::iterator"), typeid(::coral::AttributeList::iterator), sizeof(::coral::AttributeList::iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_8758, ::Reflex::BaseOffset< ::coral::AttributeList::iterator, ::coral::AttributeList::iterator_base >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11338, type_11339), Reflex::Literal("operator="), operator_10280, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11339), Reflex::Literal("iterator"), constructor_10281, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10282, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11336), Reflex::Literal("iterator"), constructor_10283, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x192, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList__iterator_funcmem_bld);
}

//------Delayed data member builder for class iterator -------------------
void __coral__AttributeList__iterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator -------------------
void __coral__AttributeList__iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11338, type_11336), Reflex::Literal("operator="), operator_10284, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3051), Reflex::Literal("operator->"), operator_10286, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10267), Reflex::Literal("operator*"), operator_10287, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class const_iterator -------------------------------
static  void operator_10288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::const_iterator*)arg[0]);
  else   (((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::const_iterator*)arg[0]);
}

static void constructor_10289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::const_iterator*)arg[0]);
  else ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::const_iterator*)arg[0]);
}

static void destructor_10290(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeList::const_iterator*)o)->::coral::AttributeList::const_iterator::~const_iterator();
}
static void constructor_10291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else   (((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::AttributeList::const_iterator*)o)->operator->)());
  else   (((const ::coral::AttributeList::const_iterator*)o)->operator->)();
}

static  void operator_10295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList::const_iterator*)o)->operator*)();
  else   (((const ::coral::AttributeList::const_iterator*)o)->operator*)();
}

static void method_x193( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator_base")), ::Reflex::BaseOffset< ::coral::AttributeList::const_iterator,::coral::AttributeList::iterator_base >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class const_iterator -------------------------------
void __coral__AttributeList__const_iterator_db_datamem(Reflex::Class*);
void __coral__AttributeList__const_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList__const_iterator_datamem_bld(&__coral__AttributeList__const_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList__const_iterator_funcmem_bld(&__coral__AttributeList__const_iterator_db_funcmem);
void __coral__AttributeList__const_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList::const_iterator"), typeid(::coral::AttributeList::const_iterator), sizeof(::coral::AttributeList::const_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_8758, ::Reflex::BaseOffset< ::coral::AttributeList::const_iterator, ::coral::AttributeList::iterator_base >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11340, type_11341), Reflex::Literal("operator="), operator_10288, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11341), Reflex::Literal("const_iterator"), constructor_10289, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~const_iterator"), destructor_10290, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11336), Reflex::Literal("const_iterator"), constructor_10291, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x193, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList__const_iterator_funcmem_bld);
}

//------Delayed data member builder for class const_iterator -------------------
void __coral__AttributeList__const_iterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class const_iterator -------------------
void __coral__AttributeList__const_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11340, type_11336), Reflex::Literal("operator="), operator_10292, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11342), Reflex::Literal("operator->"), operator_10294, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8804), Reflex::Literal("operator*"), operator_10295, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class shared_count -------------------------------
static void constructor_10534( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count();
  else ::new(mem) ::boost::detail::shared_count();
}

static void destructor_10535(void*, void * o, const std::vector<void*>&, void *) {
((::boost::detail::shared_count*)o)->::boost::detail::shared_count::~shared_count();
}
static void constructor_10536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::shared_count*)arg[0]);
  else ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::shared_count*)arg[0]);
}

static void constructor_10537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0]);
  else ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0]);
}

static void constructor_10538( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0],
      *(::boost::detail::sp_nothrow_tag*)arg[1]);
  else ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0],
      *(::boost::detail::sp_nothrow_tag*)arg[1]);
}

static  void operator_10539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::detail::shared_count*)o)->operator=)(*(const ::boost::detail::shared_count*)arg[0]);
  else   (((::boost::detail::shared_count*)o)->operator=)(*(const ::boost::detail::shared_count*)arg[0]);
}

static  void method_10540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::detail::shared_count*)o)->swap)(*(::boost::detail::shared_count*)arg[0]);
}

static  void method_10541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::detail::shared_count*)o)->use_count)());
  else   (((const ::boost::detail::shared_count*)o)->use_count)();
}

static  void method_10542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::detail::shared_count*)o)->unique)());
  else   (((const ::boost::detail::shared_count*)o)->unique)();
}

static  void method_10543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::detail::shared_count*)o)->empty)());
  else   (((const ::boost::detail::shared_count*)o)->empty)();
}

static  void method_10544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::detail::shared_count*)o)->get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::detail::shared_count*)o)->get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_10545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::detail::shared_count*)o)->get_untyped_deleter)());
  else   (((const ::boost::detail::shared_count*)o)->get_untyped_deleter)();
}

static void method_newdel_8922( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_count -------------------------------
void __boost__detail__shared_count_db_datamem(Reflex::Class*);
void __boost__detail__shared_count_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__detail__shared_count_datamem_bld(&__boost__detail__shared_count_db_datamem);
Reflex::GenreflexMemberBuilder __boost__detail__shared_count_funcmem_bld(&__boost__detail__shared_count_db_funcmem);
void __boost__detail__shared_count_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::detail::shared_count"), typeid(::boost::detail::shared_count), sizeof(::boost::detail::shared_count), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_count"), constructor_10534, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_count"), destructor_10535, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10547), Reflex::Literal("shared_count"), constructor_10536, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10546), Reflex::Literal("shared_count"), constructor_10537, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10546, type_8916), Reflex::Literal("shared_count"), constructor_10538, 0, "r;", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8922, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__detail__shared_count_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__detail__shared_count_funcmem_bld);
}

//------Delayed data member builder for class shared_count -------------------
void __boost__detail__shared_count_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5149, Reflex::Literal("pi_"), OffsetOf(__shadow__::__boost__detail__shared_count, pi_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_count -------------------
void __boost__detail__shared_count_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11441, type_10547), Reflex::Literal("operator="), operator_10539, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862, type_11441), Reflex::Literal("swap"), method_10540, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_116), Reflex::Literal("use_count"), method_10541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("unique"), method_10542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("empty"), method_10543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172, type_10043), Reflex::Literal("get_deleter"), method_10544, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_172), Reflex::Literal("get_untyped_deleter"), method_10545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Typedefs -------------------------------
static void destructor_11219(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PyCool::Helpers::Typedefs*)o)->::cool::PyCool::Helpers::Typedefs::~Typedefs();
}
static  void operator_11220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PyCool::Helpers::Typedefs*)o)->operator=)(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
  else   (((::cool::PyCool::Helpers::Typedefs*)o)->operator=)(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
}

static void constructor_11221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PyCool::Helpers::Typedefs(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
  else ::new(mem) ::cool::PyCool::Helpers::Typedefs(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
}

static void constructor_11222( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PyCool::Helpers::Typedefs();
  else ::new(mem) ::cool::PyCool::Helpers::Typedefs();
}

static  void method_11223( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_a__Bool)();
}

static  void method_11225( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_b__UChar)();
}

static  void method_11227( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_d__Int16)();
}

static  void method_11229( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_e__UInt16)();
}

static  void method_11231( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_f__Int32)();
}

static  void method_11233( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_g__UInt32)();
}

static  void method_11235( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_h__UInt63)();
}

static  void method_11237( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_i__Int64)();
}

static  void method_11239( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_j__UInt64)();
}

static  void method_11241( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_k__Float)();
}

static  void method_11243( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_l__Double)();
}

static  void method_11245( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_m__String255)();
}

static  void method_11247( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_n__String4k)();
}

static  void method_11249( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_o__String64k)();
}

static  void method_11251( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_p__String16M)();
}

static  void method_11253( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_q__Blob64k)();
}

static  void method_11255( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_r__Blob16M)();
}

static  void method_11257( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_s__ValidityKey)();
}

static  void method_11259( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_t__ChannelId)();
}

static  void method_11224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiona<bool>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiona<bool>)();
}

static  void method_11226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned char)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionb<unsigned char>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionb<unsigned char>)();
}

static  void method_11228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiond<short>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiond<short>)();
}

static  void method_11230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functione<unsigned short>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functione<unsigned short>)();
}

static  void method_11232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionf<int>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionf<int>)();
}

static  void method_11234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiong<unsigned int>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiong<unsigned int>)();
}

static  void method_11236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionh<unsigned long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionh<unsigned long long>)();
}

static  void method_11238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functioni<long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functioni<long long>)();
}

static  void method_11240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionj<unsigned long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionj<unsigned long long>)();
}

static  void method_11242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionk<float>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionk<float>)();
}

static  void method_11244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionl<double>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionl<double>)();
}

static  void method_11246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionm<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionm<std::string>)();
}

static  void method_11248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionn<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionn<std::string>)();
}

static  void method_11250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiono<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiono<std::string>)();
}

static  void method_11252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionp<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionp<std::string>)();
}

static  void method_11254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::Blob)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionq<coral::Blob>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionq<coral::Blob>)();
}

static  void method_11256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::Blob)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionr<coral::Blob>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionr<coral::Blob>)();
}

static  void method_11258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functions<unsigned long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functions<unsigned long long>)();
}

static  void method_11260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiont<unsigned int>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiont<unsigned int>)();
}

static void method_newdel_10064( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Typedefs -------------------------------
void __cool__PyCool__Helpers__Typedefs_db_datamem(Reflex::Class*);
void __cool__PyCool__Helpers__Typedefs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PyCool__Helpers__Typedefs_datamem_bld(&__cool__PyCool__Helpers__Typedefs_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PyCool__Helpers__Typedefs_funcmem_bld(&__cool__PyCool__Helpers__Typedefs_db_funcmem);
void __cool__PyCool__Helpers__Typedefs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs"), typeid(::cool::PyCool::Helpers::Typedefs), sizeof(::cool::PyCool::Helpers::Typedefs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2287, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Bool"))
  .AddTypedef(type_2169, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UChar"))
  .AddTypedef(type_2219, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Int16"))
  .AddTypedef(type_2221, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt16"))
  .AddTypedef(type_2239, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Int32"))
  .AddTypedef(type_2256, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt32"))
  .AddTypedef(type_2296, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt63"))
  .AddTypedef(type_2166, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Int64"))
  .AddTypedef(type_2261, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt64"))
  .AddTypedef(type_2266, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Float"))
  .AddTypedef(type_2234, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Double"))
  .AddTypedef(type_2297, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String255"))
  .AddTypedef(type_2240, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String4k"))
  .AddTypedef(type_2200, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String64k"))
  .AddTypedef(type_2258, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String16M"))
  .AddTypedef(type_2290, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob64k"))
  .AddTypedef(type_2232, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob16M"))
  .AddTypedef(type_2237, Reflex::Literal("cool::PyCool::Helpers::Typedefs::ValidityKey"))
  .AddTypedef(type_2203, Reflex::Literal("cool::PyCool::Helpers::Typedefs::ChannelId"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Typedefs"), destructor_11219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11579, type_11580), Reflex::Literal("operator="), operator_11220, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11580), Reflex::Literal("Typedefs"), constructor_11221, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Typedefs"), constructor_11222, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_10064, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__PyCool__Helpers__Typedefs_funcmem_bld);
}

//------Delayed data member builder for class Typedefs -------------------
void __cool__PyCool__Helpers__Typedefs_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Typedefs -------------------
void __cool__PyCool__Helpers__Typedefs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_a__Bool"), method_11223, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_b__UChar"), method_11225, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_d__Int16"), method_11227, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_e__UInt16"), method_11229, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_f__Int32"), method_11231, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_g__UInt32"), method_11233, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_h__UInt63"), method_11235, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_i__Int64"), method_11237, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_j__UInt64"), method_11239, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_k__Float"), method_11241, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_l__Double"), method_11243, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_m__String255"), method_11245, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_n__String4k"), method_11247, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_o__String64k"), method_11249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_p__String16M"), method_11251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_q__Blob64k"), method_11253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_r__Blob16M"), method_11255, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_s__ValidityKey"), method_11257, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1862), Reflex::Literal("type_id_t__ChannelId"), method_11259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770), Reflex::Literal("functiona<bool>"), method_11224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_130), Reflex::Literal("functionb<unsigned char>"), method_11226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_614), Reflex::Literal("functiond<short>"), method_11228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_242), Reflex::Literal("functione<unsigned short>"), method_11230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30), Reflex::Literal("functionf<int>"), method_11232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75), Reflex::Literal("functiong<unsigned int>"), method_11234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("functionh<unsigned long long>"), method_11236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_91), Reflex::Literal("functioni<long long>"), method_11238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("functionj<unsigned long long>"), method_11240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1736), Reflex::Literal("functionk<float>"), method_11242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1730), Reflex::Literal("functionl<double>"), method_11244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1333), Reflex::Literal("functionm<std::string>"), method_11246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1333), Reflex::Literal("functionn<std::string>"), method_11248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1333), Reflex::Literal("functiono<std::string>"), method_11250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1333), Reflex::Literal("functionp<std::string>"), method_11252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2231), Reflex::Literal("functionq<coral::Blob>"), method_11254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2231), Reflex::Literal("functionr<coral::Blob>"), method_11256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("functions<unsigned long long>"), method_11258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75), Reflex::Literal("functiont<unsigned int>"), method_11260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void destructor_4278(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::~_Rb_tree_iterator();
}
static  void operator_4279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_4280( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_4281( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
  else ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
}

static void constructor_4282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >((::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >((::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void operator_4283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
}

static  void operator_4284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)());
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)();
}

static  void operator_4285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
}

static  void operator_4286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_4287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
}

static  void operator_4288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_4289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void operator_4290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void method_newdel_1367( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem);
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >"), typeid(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >), sizeof(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddTypedef(type_1318, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_4269, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::reference"))
  .AddTypedef(type_4271, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_1657, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::iterator_category"))
  .AddTypedef(type_1471, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_3872, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Base_ptr"))
  .AddTypedef(type_4276, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Link_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Rb_tree_iterator"), destructor_4278, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9409, type_9410), Reflex::Literal("operator="), operator_4279, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9410), Reflex::Literal("_Rb_tree_iterator"), constructor_4280, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Rb_tree_iterator"), constructor_4281, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4276), Reflex::Literal("_Rb_tree_iterator"), constructor_4282, 0, "__x", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1367, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3872, Reflex::Literal("_M_node"), OffsetOf(__shadow__::__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_, _M_node), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4269), Reflex::Literal("operator*"), operator_4283, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4271), Reflex::Literal("operator->"), operator_4284, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9409), Reflex::Literal("operator++"), operator_4285, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367, type_30), Reflex::Literal("operator++"), operator_4286, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9409), Reflex::Literal("operator--"), operator_4287, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367, type_30), Reflex::Literal("operator--"), operator_4288, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9410), Reflex::Literal("operator=="), operator_4289, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9410), Reflex::Literal("operator!="), operator_4290, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void destructor_5468(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::~_Rb_tree_const_iterator();
}
static  void operator_5469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_5470( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_5471( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
}

static void constructor_5472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >((const ::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >((const ::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_5473( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void method_5474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->_M_const_cast)());
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->_M_const_cast)();
}

static  void operator_5475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
}

static  void operator_5476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)());
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)();
}

static  void operator_5477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
}

static  void operator_5478( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_5479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
}

static  void operator_5480( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_5481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void operator_5482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void method_newdel_1586( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem);
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >"), typeid(::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >), sizeof(::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddTypedef(type_1318, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_4583, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::reference"))
  .AddTypedef(type_4580, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_1367, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_1657, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::iterator_category"))
  .AddTypedef(type_1471, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_4550, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Base_ptr"))
  .AddTypedef(type_4593, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Link_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Rb_tree_const_iterator"), destructor_5468, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9673, type_9674), Reflex::Literal("operator="), operator_5469, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9674), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5470, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5471, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4593), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5472, 0, "__x", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9410), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5473, 0, "__it", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1586, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4550, Reflex::Literal("_M_node"), OffsetOf(__shadow__::__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_, _M_node), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1367), Reflex::Literal("_M_const_cast"), method_5474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4583), Reflex::Literal("operator*"), operator_5475, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4580), Reflex::Literal("operator->"), operator_5476, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9673), Reflex::Literal("operator++"), operator_5477, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1586, type_30), Reflex::Literal("operator++"), operator_5478, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9673), Reflex::Literal("operator--"), operator_5479, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1586, type_30), Reflex::Literal("operator--"), operator_5480, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9674), Reflex::Literal("operator=="), operator_5481, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1770, type_9674), Reflex::Literal("operator!="), operator_5482, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
static void function_10063( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned char)(cool::PyCool::Helpers::getBlobByte(*(::coral::Blob*)arg[0],
    *(long*)arg[1]));
  else cool::PyCool::Helpers::getBlobByte(*(::coral::Blob*)arg[0],
    *(long*)arg[1]);
}
static void function_10065( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IObjectPtr)(cool::PyCool::Helpers::IObjectPtr((::cool::IObject*)arg[0]));
  else cool::PyCool::Helpers::IObjectPtr((::cool::IObject*)arg[0]);
}
static void function_10066( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    cool::PyCool::Helpers::refreshDatabaseFromDbSvc((::cool::IDatabaseSvc*)arg[0],
      *(const ::cool::DatabaseId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    cool::PyCool::Helpers::refreshDatabaseFromDbSvc((::cool::IDatabaseSvc*)arg[0],
      *(const ::cool::DatabaseId*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_10067( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&cool::PyCool::Helpers::coolMinMax();
  else cool::PyCool::Helpers::coolMinMax();
}
static void function_10068( void*, void*, const std::vector<void*>& arg, void*)
{
  cool::PyCool::Helpers::setBlobByte(*(::coral::Blob*)arg[0],
    *(long*)arg[1],
    *(unsigned char*)arg[2]);
}
static void function_10069( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IRecordPtr)(cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecord*)arg[0]));
  else cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecord*)arg[0]);
}
static void function_10070( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IRecordPtr)(cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecordSpecification*)arg[0]));
  else cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecordSpecification*)arg[0]);
}
static void function_10071( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    cool::PyCool::Helpers::refreshDatabaseFromDb((::cool::IDatabase*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    cool::PyCool::Helpers::refreshDatabaseFromDb((::cool::IDatabase*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_10072( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)(cool::PyCool::Helpers::toString(*(::cool::IRecord*)arg[0]));
  else cool::PyCool::Helpers::toString(*(::cool::IRecord*)arg[0]);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __cool__IRecord_dict(); 
      __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__dict(); 
      __cool__IObject_dict(); 
      __std__iterator_traits_boost__shared_ptr_cool__IObject_p__dict(); 
      __std__iterator_traits_coral__AttributeSpecificationpsconstp__dict(); 
      __std__iterator_traits_coral__Attributepp__dict(); 
      __std__iterator_traits_coral__Attributepsconstp__dict(); 
      __std__basic_string_char__dict(); 
      __std__vector_std__basic_string_char_s__dict(); 
      __std__vector_unsignedsint__dict(); 
      __boost__shared_ptr_cool__IRecord__dict(); 
      __std__vector_boost__shared_ptr_cool__IRecord_s__dict(); 
      __boost__shared_ptr_cool__IObject__dict(); 
      __std__vector_boost__shared_ptr_cool__IObject_s__dict(); 
      __std__vector_cool__IFieldp__dict(); 
      __std__vector_cool__IRecordSelectionp__dict(); 
      __std__vector_cool__IFieldSpecificationp__dict(); 
      __cool__ChannelSelection_dict(); 
      __cool__ChannelSelection__ChannelRange_dict(); 
      __std__vector_cool__ChannelSelection__ChannelRange__dict(); 
      __std__vector_coral__AttributeSpecificationp__dict(); 
      __std__vector_coral__Attributep__dict(); 
      __std__allocator_boost__shared_ptr_cool__IRecord_s__dict(); 
      __std__allocator_boost__shared_ptr_cool__IObject_s__dict(); 
      __std__allocator_cool__IFieldp__dict(); 
      __std__allocator_cool__IRecordSelectionp__dict(); 
      __std__allocator_cool__IFieldSpecificationp__dict(); 
      __std__allocator_cool__ChannelSelection__ChannelRange__dict(); 
      __std__allocator_coral__AttributeSpecificationp__dict(); 
      __std__allocator_coral__Attributep__dict(); 
      __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__dict(); 
      __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__dict(); 
      __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__dict(); 
      __std__allocator_cool__IFieldp___rebind_cool__IFieldp__dict(); 
      __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__dict(); 
      __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__dict(); 
      __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__dict(); 
      __std__allocator_coral__Attributep___rebind_coral__Attributep__dict(); 
      __std__map_unsignedsint_std__basic_string_char_s__dict(); 
      __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__dict(); 
      __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__dict(); 
      __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__dict(); 
      __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__dict(); 
      __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__dict(); 
      __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__dict(); 
      __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__dict(); 
      __std__type_info_dict(); 
      __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__dict(); 
      __std____are_same_coral__Attributepsconstp_coral__Attributepp__dict(); 
      __std____are_same_coral__Attributepp_coral__Attributepp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__dict(); 
      ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__dict(); 
      ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__dict(); 
      ____gnu_cxx__new_allocator_cool__IRecordSelectionp__dict(); 
      ____gnu_cxx__new_allocator_cool__IFieldp__dict(); 
      ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__dict(); 
      ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__dict(); 
      ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__dict(); 
      ____gnu_cxx__new_allocator_coral__Attributep__dict(); 
      ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__dict(); 
      ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__dict(); 
      ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__dict(); 
      ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__dict(); 
      ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__dict(); 
      ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__dict(); 
      ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__dict(); 
      __cool__IObjectIterator_dict(); 
      __cool__FieldSelection_dict(); 
      __cool__FieldSpecificationWrongStorageType_dict(); 
      __cool__TagNotFound_dict(); 
      __cool__PayloadSpecificationTooManyFields_dict(); 
      __cool__ChannelExists_dict(); 
      __cool__IField_dict(); 
      __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      __cool__InvalidChannelRange_dict(); 
      __cool__StorageTypeStringTooLong_dict(); 
      __cool__IFolderSet_dict(); 
      __cool__CompositeSelection_dict(); 
      __cool__StorageType_dict(); 
      __cool__IRecordSpecification_dict(); 
      __boost__shared_ptr_cool__IObjectIterator__dict(); 
      __cool__RecordSpecificationUnknownField_dict(); 
      __cool__TagRelationNotFound_dict(); 
      __cool__FolderSetNotFound_dict(); 
      __cool__FieldWrongCppType_dict(); 
      __boost__shared_ptr_cool__IFolderSet__dict(); 
      __cool__FieldSpecificationWrongName_dict(); 
      __cool__RecordSpecification_dict(); 
      __cool__ObjectNotFound_dict(); 
      __cool__ChannelNotFound_dict(); 
      __cool__StorageTypeException_dict(); 
      __cool__StorageTypeWrongCppType_dict(); 
      __cool__Record_dict(); 
      __cool__ValidityKeyException_dict(); 
      __cool__FieldIsNull_dict(); 
      __cool__InvalidPayloadSpecification_dict(); 
      __cool__IFieldSpecification_dict(); 
      __cool__FolderIsSingleVersion_dict(); 
      __cool__ITime_dict(); 
      __cool__ConstRecordAdapter_dict(); 
      __cool__InvalidTagRelation_dict(); 
      __cool__DatabaseNotOpen_dict(); 
      __cool__DatabaseDoesNotExist_dict(); 
      __cool__IFolder_dict(); 
      __boost__shared_ptr_cool__IFolder__dict(); 
      __cool__ValidityIntervalBackwards_dict(); 
      __cool__Time_dict(); 
      __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__dict(); 
      __cool__IRecordSelection_dict(); 
      __cool__IDatabase_dict(); 
      __boost__shared_ptr_cool__IDatabase__dict(); 
      __cool__IHvsNode_dict(); 
      __cool__RecordSpecificationCannotExtend_dict(); 
      __coral__Blob_dict(); 
      __cool__IApplication_dict(); 
      __cool__IHvsNodeRecord_dict(); 
      __cool__TagExists_dict(); 
      __cool__IDatabaseSvc_dict(); 
      __cool__FieldSpecification_dict(); 
      __cool__RecordException_dict(); 
      __cool__ReservedHeadTag_dict(); 
      __cool__ValidityKeyOutOfBoundaries_dict(); 
      __cool__FieldSpecificationInvalidName_dict(); 
      __cool__StorageTypeDoubleIsNaN_dict(); 
      __cool__TagRelationExists_dict(); 
      __cool__InvalidFolderSpecification_dict(); 
      __cool__StorageTypeStringContainsNullChar_dict(); 
      __cool__StorageTypeInvalidUInt63_dict(); 
      __cool__DatabaseSvcFactory_dict(); 
      __cool__InvalidChannelName_dict(); 
      __cool__StorageTypeBlobTooLong_dict(); 
      __cool__PayloadSpecificationInvalidFieldName_dict(); 
      __cool__DatabaseOpenInReadOnlyMode_dict(); 
      __cool__StorageTypeFloatIsNaN_dict(); 
      __cool__NodeNotFound_dict(); 
      __cool__Application_dict(); 
      __cool__NodeIsSingleVersion_dict(); 
      __cool__NodeExists_dict(); 
      __cool__StorageTypeInvalidValue_dict(); 
      __cool__TagIsLocked_dict(); 
      __cool__IRecordIterator_dict(); 
      __cool__NodeRelationNotFound_dict(); 
      __cool__FolderNotFound_dict(); 
      __cool__RecordSpecificationWrongSize_dict(); 
      __cool__IFolderSpecification_dict(); 
      __cool__Exception_dict(); 
      __cool__PayloadSpecificationTooManyBlobFields_dict(); 
      __cool__FolderSpecification_dict(); 
      __cool__PayloadSpecificationTooManyString255Fields_dict(); 
      __coral__AttributeListSpecification_dict(); 
      __coral__AttributeSpecification_dict(); 
      __coral__IConnectionServiceConfiguration_dict(); 
      __coral__Attribute_dict(); 
      __coral__AttributeList_dict(); 
      __coral__IWebCacheInfo_dict(); 
      __coral__IWebCacheControl_dict(); 
      __coral__AttributeListException_dict(); 
      __coral__AttributeException_dict(); 
      __coral__IConnectionService_dict(); 
      __coral__AttributeListSpecification__const_iterator_dict(); 
      __coral__AttributeList__iterator_base_dict(); 
      __coral__AttributeList__iterator_dict(); 
      __coral__AttributeList__const_iterator_dict(); 
      __boost__detail__shared_count_dict(); 
      __cool__PyCool__Helpers__Typedefs_dict(); 
      __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict(); 
      __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict(); 
      ::Reflex::Type t0 = ::Reflex::FunctionTypeBuilder(type_130, type_10147, type_116);      ::Reflex::FunctionBuilder(t0, Reflex::Literal("cool::PyCool::Helpers::getBlobByte"), function_10063, 0, Reflex::Literal("b;pos"), ::Reflex::PUBLIC);
      ::Reflex::Type t1 = ::Reflex::FunctionTypeBuilder(type_2181, type_10075);      ::Reflex::FunctionBuilder(t1, Reflex::Literal("cool::PyCool::Helpers::IObjectPtr"), function_10065, 0, Reflex::Literal("obj"), ::Reflex::PUBLIC);
      ::Reflex::Type t2 = ::Reflex::FunctionTypeBuilder(type_1862, type_11261, type_10158, type_1770);      ::Reflex::FunctionBuilder(t2, Reflex::Literal("cool::PyCool::Helpers::refreshDatabaseFromDbSvc"), function_10066, 0, Reflex::Literal("dbSvc;dbId;keepNodes=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t3 = ::Reflex::FunctionTypeBuilder(type_10099);      ::Reflex::FunctionBuilder(t3, Reflex::Literal("cool::PyCool::Helpers::coolMinMax"), function_10067, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t4 = ::Reflex::FunctionTypeBuilder(type_1862, type_10147, type_116, type_130);      ::Reflex::FunctionBuilder(t4, Reflex::Literal("cool::PyCool::Helpers::setBlobByte"), function_10068, 0, Reflex::Literal("b;pos;val"), ::Reflex::PUBLIC);
      ::Reflex::Type t5 = ::Reflex::FunctionTypeBuilder(type_2289, type_8419);      ::Reflex::FunctionBuilder(t5, Reflex::Literal("cool::PyCool::Helpers::IRecordPtr"), function_10069, 0, Reflex::Literal("rec"), ::Reflex::PUBLIC);
      ::Reflex::Type t6 = ::Reflex::FunctionTypeBuilder(type_2289, type_10023);      ::Reflex::FunctionBuilder(t6, Reflex::Literal("cool::PyCool::Helpers::IRecordPtr"), function_10070, 0, Reflex::Literal("spec"), ::Reflex::PUBLIC);
      ::Reflex::Type t7 = ::Reflex::FunctionTypeBuilder(type_1862, type_10136, type_1770);      ::Reflex::FunctionBuilder(t7, Reflex::Literal("cool::PyCool::Helpers::refreshDatabaseFromDb"), function_10071, 0, Reflex::Literal("db;keepNodes=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t8 = ::Reflex::FunctionTypeBuilder(type_1340, type_10086);      ::Reflex::FunctionBuilder(t8, Reflex::Literal("cool::PyCool::Helpers::toString"), function_10072, 0, Reflex::Literal("r"), ::Reflex::PUBLIC);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::StorageType::TypeId"),typeid(::cool::StorageType::TypeId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("Bool"),0)
        .AddItem(Reflex::Literal("UChar"),1)
        .AddItem(Reflex::Literal("Int16"),2)
        .AddItem(Reflex::Literal("UInt16"),3)
        .AddItem(Reflex::Literal("Int32"),4)
        .AddItem(Reflex::Literal("UInt32"),5)
        .AddItem(Reflex::Literal("UInt63"),6)
        .AddItem(Reflex::Literal("Int64"),7)
        .AddItem(Reflex::Literal("Float"),8)
        .AddItem(Reflex::Literal("Double"),9)
        .AddItem(Reflex::Literal("String255"),10)
        .AddItem(Reflex::Literal("String4k"),11)
        .AddItem(Reflex::Literal("String64k"),12)
        .AddItem(Reflex::Literal("String16M"),13)
        .AddItem(Reflex::Literal("Blob64k"),14)
        .AddItem(Reflex::Literal("Blob16M"),15);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::HvsTagLock::Status"),typeid(::cool::HvsTagLock::Status), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("UNLOCKED"),0)
        .AddItem(Reflex::Literal("LOCKED"),1)
        .AddItem(Reflex::Literal("PARTIALLYLOCKED"),2);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::MSG::Level"),typeid(::cool::MSG::Level), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("NIL"),0)
        .AddItem(Reflex::Literal("VERBOSE"),1)
        .AddItem(Reflex::Literal("DEBUG"),2)
        .AddItem(Reflex::Literal("INFO"),3)
        .AddItem(Reflex::Literal("WARNING"),4)
        .AddItem(Reflex::Literal("ERROR"),5)
        .AddItem(Reflex::Literal("FATAL"),6)
        .AddItem(Reflex::Literal("ALWAYS"),7)
        .AddItem(Reflex::Literal("NUM_LEVELS"),8);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::PayloadMode::Mode"),typeid(::cool::PayloadMode::Mode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("INLINEPAYLOAD"),0)
        .AddItem(Reflex::Literal("SEPARATEPAYLOAD"),1)
        .AddItem(Reflex::Literal("VECTORPAYLOAD"),2);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::IHvsNode::Type"),typeid(::cool::IHvsNode::Type), ::Reflex::PUBLIC)
        .AddItem(Reflex::Literal("INNER_NODE"),0)
        .AddItem(Reflex::Literal("LEAF_NODE"),1);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::ChannelSelection::Order"),typeid(::cool::ChannelSelection::Order), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("channelBeforeSince"),0)
        .AddItem(Reflex::Literal("sinceBeforeChannel"),1)
        .AddItem(Reflex::Literal("channelBeforeSinceDesc"),2)
        .AddItem(Reflex::Literal("sinceDescBeforeChannel"),3);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::FolderVersioning::Mode"),typeid(::cool::FolderVersioning::Mode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("NONE"),-1)
        .AddItem(Reflex::Literal("SINGLE_VERSION"),0)
        .AddItem(Reflex::Literal("MULTI_VERSION"),1);
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt16Min"), type_2221c, (size_t)&cool::UInt16Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int32Min"), type_2239c, (size_t)&cool::Int32Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UCharMax"), type_2169c, (size_t)&cool::UCharMax, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UCharMin"), type_2169c, (size_t)&cool::UCharMin, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt32Max"), type_2256c, (size_t)&cool::UInt32Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::ValidityKeyMax"), type_2237c, (size_t)&cool::ValidityKeyMax, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt32Min"), type_2256c, (size_t)&cool::UInt32Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int32Max"), type_2239c, (size_t)&cool::Int32Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt63Max"), type_2296c, (size_t)&cool::UInt63Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::ValidityKeyMin"), type_2237c, (size_t)&cool::ValidityKeyMin, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt63Min"), type_2296c, (size_t)&cool::UInt63Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt64Max"), type_2261c, (size_t)&cool::UInt64Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int64Max"), type_2166c, (size_t)&cool::Int64Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int16Max"), type_2219c, (size_t)&cool::Int16Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int16Min"), type_2219c, (size_t)&cool::Int16Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt64Min"), type_2261c, (size_t)&cool::UInt64Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int64Min"), type_2166c, (size_t)&cool::Int64Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt16Max"), type_2221c, (size_t)&cool::UInt16Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
    }
    ~Dictionaries() {
      type_2191.Unload(); // class cool::IRecord 
      type_1279.Unload(); // class std::iterator_traits<boost::shared_ptr<cool::IRecord>*> 
      type_2210.Unload(); // class cool::IObject 
      type_1280.Unload(); // class std::iterator_traits<boost::shared_ptr<cool::IObject>*> 
      type_1282.Unload(); // class std::iterator_traits<coral::AttributeSpecification* const*> 
      type_1283.Unload(); // class std::iterator_traits<coral::Attribute**> 
      type_1284.Unload(); // class std::iterator_traits<coral::Attribute* const*> 
      type_1333.Unload(); // class std::basic_string<char> 
      type_1287.Unload(); // class std::vector<std::basic_string<char> > 
      type_1288.Unload(); // class std::vector<unsigned int> 
      type_2288.Unload(); // class boost::shared_ptr<cool::IRecord> 
      type_1289.Unload(); // class std::vector<boost::shared_ptr<cool::IRecord> > 
      type_2180.Unload(); // class boost::shared_ptr<cool::IObject> 
      type_1290.Unload(); // class std::vector<boost::shared_ptr<cool::IObject> > 
      type_1291.Unload(); // class std::vector<cool::IField*> 
      type_1292.Unload(); // class std::vector<cool::IRecordSelection*> 
      type_1294.Unload(); // class std::vector<cool::IFieldSpecification*> 
      type_2278.Unload(); // class cool::ChannelSelection 
      type_3566.Unload(); // class cool::ChannelSelection::ChannelRange 
      type_1295.Unload(); // class std::vector<cool::ChannelSelection::ChannelRange> 
      type_1296.Unload(); // class std::vector<coral::AttributeSpecification*> 
      type_1297.Unload(); // class std::vector<coral::Attribute*> 
      type_1430.Unload(); // class std::allocator<boost::shared_ptr<cool::IRecord> > 
      type_1431.Unload(); // class std::allocator<boost::shared_ptr<cool::IObject> > 
      type_1432.Unload(); // class std::allocator<cool::IField*> 
      type_1433.Unload(); // class std::allocator<cool::IRecordSelection*> 
      type_1435.Unload(); // class std::allocator<cool::IFieldSpecification*> 
      type_1436.Unload(); // class std::allocator<cool::ChannelSelection::ChannelRange> 
      type_1437.Unload(); // class std::allocator<coral::AttributeSpecification*> 
      type_1440.Unload(); // class std::allocator<coral::Attribute*> 
      type_1447.Unload(); // class std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > 
      type_1448.Unload(); // class std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > 
      type_1449.Unload(); // class std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> 
      type_1450.Unload(); // class std::allocator<cool::IField*>::rebind<cool::IField*> 
      type_1451.Unload(); // class std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> 
      type_1452.Unload(); // class std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> 
      type_1455.Unload(); // class std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> 
      type_1456.Unload(); // class std::allocator<coral::Attribute*>::rebind<coral::Attribute*> 
      type_1515.Unload(); // class std::map<unsigned int,std::basic_string<char> > 
      type_1568.Unload(); // class std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > 
      type_1569.Unload(); // class std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > 
      type_1570.Unload(); // class std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > 
      type_1571.Unload(); // class std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > 
      type_1572.Unload(); // class std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > 
      type_1573.Unload(); // class std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > 
      type_1574.Unload(); // class std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > 
      type_1575.Unload(); // class std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > 
      type_1592.Unload(); // class std::type_info 
      type_1711.Unload(); // class std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> 
      type_1712.Unload(); // class std::__are_same<coral::Attribute* const*,coral::Attribute**> 
      type_1713.Unload(); // class std::__are_same<coral::Attribute**,coral::Attribute**> 
      type_1933.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > 
      type_1934.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > 
      type_1935.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > 
      type_1936.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > 
      type_1937.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > 
      type_1938.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > 
      type_1941.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > 
      type_1942.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > 
      type_1947.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > 
      type_1948.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > 
      type_1949.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> 
      type_1950.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> 
      type_1951.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> 
      type_1952.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> 
      type_1955.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> 
      type_1956.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> 
      type_1961.Unload(); // class __gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > 
      type_1962.Unload(); // class __gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > 
      type_1963.Unload(); // class __gnu_cxx::new_allocator<cool::IRecordSelection*> 
      type_1964.Unload(); // class __gnu_cxx::new_allocator<cool::IField*> 
      type_1965.Unload(); // class __gnu_cxx::new_allocator<cool::IFieldSpecification*> 
      type_1966.Unload(); // class __gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> 
      type_1969.Unload(); // class __gnu_cxx::new_allocator<coral::AttributeSpecification*> 
      type_1970.Unload(); // class __gnu_cxx::new_allocator<coral::Attribute*> 
      type_2005.Unload(); // class __gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > 
      type_2006.Unload(); // class __gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > 
      type_2007.Unload(); // class __gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > 
      type_2021.Unload(); // class __gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > 
      type_2023.Unload(); // class __gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > 
      type_2034.Unload(); // class __gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > 
      type_2036.Unload(); // class __gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > 
      type_2037.Unload(); // class __gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > 
      type_2153.Unload(); // class cool::IObjectIterator 
      type_2154.Unload(); // class cool::FieldSelection 
      type_2155.Unload(); // class cool::FieldSpecificationWrongStorageType 
      type_2157.Unload(); // class cool::TagNotFound 
      type_2158.Unload(); // class cool::PayloadSpecificationTooManyFields 
      type_2159.Unload(); // class cool::ChannelExists 
      type_2160.Unload(); // class cool::IField 
      type_2161.Unload(); // class boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > 
      type_2164.Unload(); // class cool::InvalidChannelRange 
      type_2165.Unload(); // class cool::StorageTypeStringTooLong 
      type_2167.Unload(); // class cool::IFolderSet 
      type_2168.Unload(); // class cool::CompositeSelection 
      type_2170.Unload(); // class cool::StorageType 
      type_2171.Unload(); // class cool::IRecordSpecification 
      type_2172.Unload(); // class boost::shared_ptr<cool::IObjectIterator> 
      type_2176.Unload(); // class cool::RecordSpecificationUnknownField 
      type_2179.Unload(); // class cool::TagRelationNotFound 
      type_2182.Unload(); // class cool::FolderSetNotFound 
      type_2186.Unload(); // class cool::FieldWrongCppType 
      type_2187.Unload(); // class boost::shared_ptr<cool::IFolderSet> 
      type_2192.Unload(); // class cool::FieldSpecificationWrongName 
      type_2193.Unload(); // class cool::RecordSpecification 
      type_2194.Unload(); // class cool::ObjectNotFound 
      type_2196.Unload(); // class cool::ChannelNotFound 
      type_2197.Unload(); // class cool::StorageTypeException 
      type_2198.Unload(); // class cool::StorageTypeWrongCppType 
      type_2199.Unload(); // class cool::Record 
      type_2201.Unload(); // class cool::ValidityKeyException 
      type_2202.Unload(); // class cool::FieldIsNull 
      type_2204.Unload(); // class cool::InvalidPayloadSpecification 
      type_2205.Unload(); // class cool::IFieldSpecification 
      type_2207.Unload(); // class cool::FolderIsSingleVersion 
      type_2208.Unload(); // class cool::ITime 
      type_2209.Unload(); // class cool::ConstRecordAdapter 
      type_2211.Unload(); // class cool::InvalidTagRelation 
      type_2212.Unload(); // class cool::DatabaseNotOpen 
      type_2213.Unload(); // class cool::DatabaseDoesNotExist 
      type_2300.Unload(); // class cool::IFolder 
      type_2214.Unload(); // class boost::shared_ptr<cool::IFolder> 
      type_2218.Unload(); // class cool::ValidityIntervalBackwards 
      type_2220.Unload(); // class cool::Time 
      type_2223.Unload(); // class boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > 
      type_2225.Unload(); // class cool::IRecordSelection 
      type_2250.Unload(); // class cool::IDatabase 
      type_2226.Unload(); // class boost::shared_ptr<cool::IDatabase> 
      type_2228.Unload(); // class cool::IHvsNode 
      type_2230.Unload(); // class cool::RecordSpecificationCannotExtend 
      type_2231.Unload(); // class coral::Blob 
      type_2233.Unload(); // class cool::IApplication 
      type_2235.Unload(); // class cool::IHvsNodeRecord 
      type_2242.Unload(); // class cool::TagExists 
      type_2243.Unload(); // class cool::IDatabaseSvc 
      type_2244.Unload(); // class cool::FieldSpecification 
      type_2245.Unload(); // class cool::RecordException 
      type_2246.Unload(); // class cool::ReservedHeadTag 
      type_2247.Unload(); // class cool::ValidityKeyOutOfBoundaries 
      type_2248.Unload(); // class cool::FieldSpecificationInvalidName 
      type_2249.Unload(); // class cool::StorageTypeDoubleIsNaN 
      type_2251.Unload(); // class cool::TagRelationExists 
      type_2252.Unload(); // class cool::InvalidFolderSpecification 
      type_2253.Unload(); // class cool::StorageTypeStringContainsNullChar 
      type_2254.Unload(); // class cool::StorageTypeInvalidUInt63 
      type_2255.Unload(); // class cool::DatabaseSvcFactory 
      type_2259.Unload(); // class cool::InvalidChannelName 
      type_2262.Unload(); // class cool::StorageTypeBlobTooLong 
      type_2263.Unload(); // class cool::PayloadSpecificationInvalidFieldName 
      type_2265.Unload(); // class cool::DatabaseOpenInReadOnlyMode 
      type_2267.Unload(); // class cool::StorageTypeFloatIsNaN 
      type_2268.Unload(); // class cool::NodeNotFound 
      type_2269.Unload(); // class cool::Application 
      type_2270.Unload(); // class cool::NodeIsSingleVersion 
      type_2276.Unload(); // class cool::NodeExists 
      type_2277.Unload(); // class cool::StorageTypeInvalidValue 
      type_2280.Unload(); // class cool::TagIsLocked 
      type_2281.Unload(); // class cool::IRecordIterator 
      type_2282.Unload(); // class cool::NodeRelationNotFound 
      type_2283.Unload(); // class cool::FolderNotFound 
      type_2284.Unload(); // class cool::RecordSpecificationWrongSize 
      type_2286.Unload(); // class cool::IFolderSpecification 
      type_2291.Unload(); // class cool::Exception 
      type_2294.Unload(); // class cool::PayloadSpecificationTooManyBlobFields 
      type_2299.Unload(); // class cool::FolderSpecification 
      type_2302.Unload(); // class cool::PayloadSpecificationTooManyString255Fields 
      type_2332.Unload(); // class coral::AttributeListSpecification 
      type_2335.Unload(); // class coral::AttributeSpecification 
      type_2336.Unload(); // class coral::IConnectionServiceConfiguration 
      type_2339.Unload(); // class coral::Attribute 
      type_2342.Unload(); // class coral::AttributeList 
      type_2345.Unload(); // class coral::IWebCacheInfo 
      type_2346.Unload(); // class coral::IWebCacheControl 
      type_2347.Unload(); // class coral::AttributeListException 
      type_2351.Unload(); // class coral::AttributeException 
      type_2353.Unload(); // class coral::IConnectionService 
      type_8601.Unload(); // class coral::AttributeListSpecification::const_iterator 
      type_8758.Unload(); // class coral::AttributeList::iterator_base 
      type_8754.Unload(); // class coral::AttributeList::iterator 
      type_8753.Unload(); // class coral::AttributeList::const_iterator 
      type_8922.Unload(); // class boost::detail::shared_count 
      type_10064.Unload(); // class cool::PyCool::Helpers::Typedefs 
      type_1367.Unload(); // class std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > 
      type_1586.Unload(); // class std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
