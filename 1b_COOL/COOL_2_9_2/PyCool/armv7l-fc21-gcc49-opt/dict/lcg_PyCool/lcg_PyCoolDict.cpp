// Generated at Tue Mar 31 09:54:44 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="g++"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard "
  GCCXML_EXECUTABLE="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__SSP_STRONG__='3' -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__UINT_LEAST16_MAX__='65535' -D__ARM_SIZEOF_WCHAR_T='4' -D__ATOMIC_ACQUIRE='2' -D__SFRACT_IBIT__='0' -D__FLT_MIN__='1.1754943508222875e-38F' -D__GCC_IEC_559_COMPLEX='2' -D__UFRACT_MAX__='0XFFFFP-16UR' -D__UINT_LEAST8_TYPE__='unsigned char' -D__DQ_FBIT__='63' -D__INTMAX_C(c)='c ## LL' -D__ARM_FEATURE_SAT='1' -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK' -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__UINT8_MAX__='255' -D__ACCUM_FBIT__='15' -D__WINT_MAX__='4294967295U' -D__USFRACT_FBIT__='8' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='4294967295U' -D__ARM_ARCH_ISA_ARM='1' -D__WCHAR_MAX__='4294967295U' -D__LACCUM_IBIT__='32' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.9406564584124654e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__GCC_IEC_559='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__cpp_binary_literals='201304' -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__FRACT_FBIT__='15' -D__UINT_FAST64_MAX__='18446744073709551615ULL' -D__SIG_ATOMIC_TYPE__='int' -D__UACCUM_FBIT__='16' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__ARMEL__='1' -D__ARM_FEATURE_UNALIGNED='1' -D__LFRACT_IBIT__='0' -D__GNUC_PATCHLEVEL__='2' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR' -D__UINT_FAST8_MAX__='255' -D__has_include(STR)='__has_include__(STR)' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615ULL' -D__SA_FBIT__='15' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L' -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16' -D__ARM_FP='12' -D__UFRACT_MIN__='0.0UR' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__CHAR_UNSIGNED__='1' -D__UINT32_MAX__='4294967295U' -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64' -D__LDBL_MAX_EXP__='1024' -D__WINT_MIN__='0U' -D__linux__='1' -D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='0U' -D__INT64_C(c)='c ## LL' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D_FORTIFY_SOURCE='2' -D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='4' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USACCUM_IBIT__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)' -D__HA_IBIT__='8' -D__ARM_NEON_FP='4' -D__TQ_IBIT__='0' -D__FLT_EPSILON__='1.1920928955078125e-7F' -D__APCS_32__='1' -D__GXX_WEAK__='1' -D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L' -D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF' -D__DA_IBIT__='32' -D__ARM_SIZEOF_MINIMAL_ENUM='4' -D__INT32_MAX__='2147483647' -D__UQQ_FBIT__='8' -D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK' -D__STDC_IEC_559__='1' -D__STDC_ISO_10646__='201103L' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR' -D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1' -D__has_include_next(STR)='__has_include_next__(STR)' -D__ARM_PCS_VFP='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32' -D__UACCUM_EPSILON__='0x1P-16UK' -D__GNUC__='4' -D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__GXX_RTTI='1' -D__HQ_IBIT__='0' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D__BIGGEST_ALIGNMENT__='8' -D__DQ_IBIT__='0' -D__DBL_MAX__='double(1.7976931348623157e+308L)' -D__ULFRACT_IBIT__='0' -D__INT_FAST32_MAX__='2147483647' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807LL' -D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-94)' -D__THUMB_INTERWORK__='1' -D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__INT_FAST16_TYPE__='int' -D__LDBL_HAS_DENORM__='1' -D__ARM_FEATURE_LDREX='15' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK' -D__DEC128_EPSILON__='1E-33DL' -D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0' -D__PTRDIFF_MAX__='2147483647' -D__UACCUM_MIN__='0.0UK' -D__STDC_NO_THREADS__='1' -D__UACCUM_IBIT__='16' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4' -D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4' -D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64' -D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR' -D__UFRACT_IBIT__='0' -D__ARM_FEATURE_QBIT='1' -D__INT_FAST64_TYPE__='long long int' -D__DBL_MIN__='double(2.2250738585072014e-308L)' -D__FLT_MIN_10_EXP__='(-37)' -D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32' -D__GXX_TYPEINFO_EQUALITY_INLINE='0' -D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0' -D__UINT8_TYPE__='unsigned char' -D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.9.2 20150212 (Red Hat 4.9.2-6)"' -D__UINT64_C(c)='c ## ULL' -D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R' -D__ULACCUM_MIN__='0.0ULK' -D_STDC_PREDEF_H='1' -D__UDA_FBIT__='32' -D__LLACCUM_EPSILON__='0x1P-31LLK' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__USFRACT_MIN__='0.0UHR' -D__ULLACCUM_IBIT__='32' -D__UQQ_IBIT__='0' -D__STDC_IEC_559_COMPLEX__='1' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -D__INT_FAST32_TYPE__='int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='unsigned int' -D__UINT64_MAX__='18446744073709551615ULL' -D__UDQ_FBIT__='64' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__ARM_ARCH_PROFILE='65' -D__LDBL_EPSILON__='2.2204460492503131e-16L' -D__UINTMAX_C(c)='c ## ULL' -D__GNUC_RH_RELEASE__='6' -D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__VFP_FP__='1' -D__SIZEOF_PTRDIFF_T__='4' -D__LACCUM_EPSILON__='0x1P-31LK' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='2147483647' -D__UINT_FAST32_MAX__='4294967295U' -D__UINT_LEAST64_TYPE__='long long unsigned int' -D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='2147483647L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__unix='1' -D__USA_FBIT__='16' -D__UINT_FAST16_TYPE__='unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__ARM_32BIT_STATE='1' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__SACCUM_FBIT__='7' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long long int' -D__ARM_FEATURE_CLZ='1' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__SQ_FBIT__='31' -D__DEC32_MAX_EXP__='97' -D__ARM_ARCH_ISA_THUMB='2' -D__INT_FAST8_MAX__='127' -D__ARM_ARCH='7' -D__INTPTR_MAX__='2147483647' -D__QQ_FBIT__='7' -Dlinux='1' -D__UTA_IBIT__='64' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='53' -D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__INTPTR_TYPE__='int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='unsigned int' -D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32' -D__UINTPTR_MAX__='4294967295U' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807LL' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long long unsigned int' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31' -D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__INT64_TYPE__='long long int' -D__FLT_MAX_EXP__='128' -D__UTQ_IBIT__='0' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807LL' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0' -D__LDBL_MIN_EXP__='(-1021)' -D__arm__='1' -D__UDA_IBIT__='32' -D__INT_LEAST8_MAX__='127' -D__LFRACT_FBIT__='31' -D__WCHAR_UNSIGNED__='1' -D__ARM_ARCH_7A__='1' -D__LDBL_MAX_10_EXP__='308' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.2204460492503131e-16L)' -D__ARM_FEATURE_SIMD32='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long long unsigned int' -D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127' -D__INT_FAST8_TYPE__='signed char' -D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0' -D__LLACCUM_IBIT__='32' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63' -D__UDQ_IBIT__='0' -D__ORDER_BIG_ENDIAN__='4321' -D__ACCUM_EPSILON__='0x1P-15K' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807LL' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.4012984643248171e-45F' -D__LLFRACT_IBIT__='0' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.4028234663852886e+38F' -D__USACCUM_FBIT__='8' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__UFRACT_EPSILON__='0x1P-16UR' -D__INTMAX_TYPE__='long long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='9' -D__UINTMAX_MAX__='18446744073709551615ULL' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)' -D__ATOMIC_SEQ_CST='5' -D__DA_FBIT__='31' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='unsigned int' -D__USA_IBIT__='16' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__ARM_EABI__='1' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8' -D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='15' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='4294967295U' -D__GNUC_GNU_INLINE__='1' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32' -D__ARM_FEATURE_DSP='1' -D__QQ_IBIT__='0' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/GCC/4.9" -isystem"/home/jwsmith/HDD/lcgcmake-install-gcc49/Python/2.7.6/armv7l-fc21-gcc49-opt/include/python2.7" -isystem"/home/jwsmith/HDD/CORAL/armv7l-fc21-gcc49-opt/include" -isystem"." -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/armv7hl-redhat-linux-gnueabi" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/backward" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/include" -isystem"/usr/local/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9"

Compiler info:
g++ (GCC) 4.9.2 20150212 (Red Hat 4.9.2-6)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/home/jwsmith/HDD/COOL/COOL_2_9_2/PyCool/armv7l-fc21-gcc49-opt/dict/PyCool_headers_and_helpers.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("__gnu_cxx") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("cool") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("coral") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("boost") );
  ::Reflex::NamespaceBuilder nsb5( Reflex::Literal("cool::HvsTagLock") );
  ::Reflex::NamespaceBuilder nsb6( Reflex::Literal("cool::MSG") );
  ::Reflex::NamespaceBuilder nsb7( Reflex::Literal("cool::PayloadMode") );
  ::Reflex::NamespaceBuilder nsb8( Reflex::Literal("cool::FolderVersioning") );
  ::Reflex::NamespaceBuilder nsb9( Reflex::Literal("boost::detail") );
  ::Reflex::NamespaceBuilder nsb10( Reflex::Literal("cool::PyCool::Helpers") );
  ::Reflex::Type type_31 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_124 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1881 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_2490 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_1969 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_679 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_1847 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1840 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_96 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_80 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_2331 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Time"));
  ::Reflex::Type type_2342 = ::Reflex::TypeBuilder(Reflex::Literal("coral::Blob"));
  ::Reflex::Type type_2319 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ITime"));
  ::Reflex::Type type_48 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1848 = ::Reflex::TypeBuilder(Reflex::Literal("long double"));
  ::Reflex::Type type_2270 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IField"));
  ::Reflex::Type type_2310 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Record"));
  ::Reflex::Type type_140 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_2302 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord"));
  ::Reflex::Type type_2321 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObject"));
  ::Reflex::Type type_269 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_2410 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolder"));
  ::Reflex::Type type_2244 = ::Reflex::TypeBuilder(Reflex::Literal("seal::Context"));
  ::Reflex::Type type_1701 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_2339 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNode"));
  ::Reflex::Type type_1703 = ::Reflex::TypeBuilder(Reflex::Literal("std::exception"));
  ::Reflex::Type type_2402 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception"));
  ::Reflex::Type type_2361 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IDatabase"));
  ::Reflex::Type type_2353 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagExists"));
  ::Reflex::Type type_2449 = ::Reflex::TypeBuilder(Reflex::Literal("coral::Attribute"));
  ::Reflex::Type type_1809 = ::Reflex::TypeBuilder(Reflex::Literal("std::__true_type"));
  ::Reflex::Type type_2277 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSet"));
  ::Reflex::Type type_2387 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeExists"));
  ::Reflex::Type type_2464 = ::Reflex::TypeBuilder(Reflex::Literal("coral::Exception"));
  ::Reflex::Type type_114 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long long"));
  ::Reflex::Type type_1367 = ::Reflex::TypeBuilder(Reflex::Literal("std::__false_type"));
  ::Reflex::Type type_2280 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageType"));
  ::Reflex::Type type_2267 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagNotFound"));
  ::Reflex::Type type_2313 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldIsNull"));
  ::Reflex::Type type_2391 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagIsLocked"));
  ::Reflex::Type type_2380 = ::Reflex::TypeBuilder(Reflex::Literal("cool::Application"));
  ::Reflex::Type type_2379 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeNotFound"));
  ::Reflex::Type type_2354 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IDatabaseSvc"));
  ::Reflex::Type type_2344 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IApplication"));
  ::Reflex::Type type_2269 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelExists"));
  ::Reflex::Type type_2452 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList"));
  ::Reflex::Type type_1535 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_2305 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ObjectNotFound"));
  ::Reflex::Type type_2346 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord"));
  ::Reflex::Type type_8002 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::MSG::Level"));
  ::Reflex::Type type_2394 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderNotFound"));
  ::Reflex::Type type_2458 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeData"));
  ::Reflex::Type type_2455 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IWebCacheInfo"));
  ::Reflex::Type type_2447 = ::Reflex::TypeBuilder(Reflex::Literal("coral::ISessionProxy"));
  ::Reflex::Type type_2264 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSelection"));
  ::Reflex::Type type_2392 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordIterator"));
  ::Reflex::Type type_2356 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException"));
  ::Reflex::Type type_2263 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObjectIterator"));
  ::Reflex::Type type_2307 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelNotFound"));
  ::Reflex::Type type_2323 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseNotOpen"));
  ::Reflex::Type type_2357 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ReservedHeadTag"));
  ::Reflex::Type type_2451 = ::Reflex::TypeBuilder(Reflex::Literal("coral::ILookupService"));
  ::Reflex::Type type_2443 = ::Reflex::EnumTypeBuilder(Reflex::Literal("coral::AccessMode"));
  ::Reflex::Type type_1597 = ::Reflex::TypeBuilder(Reflex::Literal("std::char_traits<char>"));
  ::Reflex::Type type_2336 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSelection"));
  ::Reflex::Type type_2389 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelSelection"));
  ::Reflex::Type type_1443 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_1810 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2292 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderSetNotFound"));
  ::Reflex::Type type_2297 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldWrongCppType"));
  ::Reflex::Type type_2362 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagRelationExists"));
  ::Reflex::Type type_2456 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IWebCacheControl"));
  ::Reflex::Type type_1713 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_node_base"));
  ::Reflex::Type type_2322 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidTagRelation"));
  ::Reflex::Type type_8336 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::IHvsNode::Type"));
  ::Reflex::Type type_2355 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecification"));
  ::Reflex::Type type_2366 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseSvcFactory"));
  ::Reflex::Type type_2370 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidChannelName"));
  ::Reflex::Type type_2278 = ::Reflex::TypeBuilder(Reflex::Literal("cool::CompositeSelection"));
  ::Reflex::Type type_2320 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ConstRecordAdapter"));
  ::Reflex::Type type_1398 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_2316 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFieldSpecification"));
  ::Reflex::Type type_2274 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidChannelRange"));
  ::Reflex::Type type_2289 = ::Reflex::TypeBuilder(Reflex::Literal("cool::TagRelationNotFound"));
  ::Reflex::Type type_2304 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecification"));
  ::Reflex::Type type_2381 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeIsSingleVersion"));
  ::Reflex::Type type_2463 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IConnectionService"));
  ::Reflex::Type type_2409 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderSpecification"));
  ::Reflex::Type type_8861 = ::Reflex::EnumTypeBuilder(Reflex::Literal("coral::monitor::Level"));
  ::Reflex::Type type_2453 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IRelationalService"));
  ::Reflex::Type type_2461 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeException"));
  ::Reflex::Type type_9077 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::weak_count"));
  ::Reflex::Type type_2281 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSpecification"));
  ::Reflex::Type type_1401 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::IField*>"));
  ::Reflex::Type type_2308 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException"));
  ::Reflex::Type type_2312 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyException"));
  ::Reflex::Type type_2324 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseDoesNotExist"));
  ::Reflex::Type type_2397 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSpecification"));
  ::Reflex::Type type_2393 = ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeRelationNotFound"));
  ::Reflex::Type type_2454 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IMonitoringReporter"));
  ::Reflex::Type type_9031 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::shared_count"));
  ::Reflex::Type type_2318 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FolderIsSingleVersion"));
  ::Reflex::Type type_2378 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeFloatIsNaN"));
  ::Reflex::Type type_8034 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::PayloadMode::Mode"));
  ::Reflex::Type type_1539 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned int>"));
  ::Reflex::Type type_7996 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::HvsTagLock::Status"));
  ::Reflex::Type type_2360 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeDoubleIsNaN"));
  ::Reflex::Type type_2373 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeBlobTooLong"));
  ::Reflex::Type type_2445 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeSpecification"));
  ::Reflex::Type type_1542 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IField*>"));
  ::Reflex::Type type_2252 = ::Reflex::TypeBuilder(Reflex::Literal("__cxxabiv1::__class_type_info"));
  ::Reflex::Type type_7704 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::StorageType::TypeId"));
  ::Reflex::Type type_2388 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue"));
  ::Reflex::Type type_2309 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeWrongCppType"));
  ::Reflex::Type type_2448 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IAuthenticationService"));
  ::Reflex::Type type_2457 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeListException"));
  ::Reflex::Type type_9025 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::sp_nothrow_tag"));
  ::Reflex::Type type_1407 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<coral::Attribute*>"));
  ::Reflex::Type type_2275 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeStringTooLong"));
  ::Reflex::Type type_2365 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidUInt63"));
  ::Reflex::Type type_8864 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator"));
  ::Reflex::Type type_9078 = ::Reflex::TypeBuilder(Reflex::Literal("boost::detail::sp_counted_base"));
  ::Reflex::Type type_1533 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_2329 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityIntervalBackwards"));
  ::Reflex::Type type_2444 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IReplicaSortingAlgorithm"));
  ::Reflex::Type type_1767 = ::Reflex::TypeBuilder(Reflex::Literal("std::bidirectional_iterator_tag"));
  ::Reflex::Type type_2290 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IObject>"));
  ::Reflex::Type type_2325 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolder>"));
  ::Reflex::Type type_2399 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IRecord>"));
  ::Reflex::Type type_2363 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification"));
  ::Reflex::Type type_8690 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::FolderVersioning::Mode"));
  ::Reflex::Type type_2358 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyOutOfBoundaries"));
  ::Reflex::Type type_2376 = ::Reflex::TypeBuilder(Reflex::Literal("cool::DatabaseOpenInReadOnlyMode"));
  ::Reflex::Type type_10172 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs"));
  ::Reflex::Type type_8544 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::ChannelSelection::Order"));
  ::Reflex::Type type_1550 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::Attribute*>"));
  ::Reflex::Type type_2315 = ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification"));
  ::Reflex::Type type_2303 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecificationWrongName"));
  ::Reflex::Type type_2442 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeListSpecification"));
  ::Reflex::Type type_2337 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IDatabase>"));
  ::Reflex::Type type_7706 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::FieldSelection::Relation"));
  ::Reflex::Type type_7801 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::FieldSelection::Nullness"));
  ::Reflex::Type type_2395 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecificationWrongSize"));
  ::Reflex::Type type_8860 = ::Reflex::TypeBuilder(Reflex::Literal("coral::monitor::IMonitoringService"));
  ::Reflex::Type type_2298 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolderSet>"));
  ::Reflex::Type type_2359 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecificationInvalidName"));
  ::Reflex::Type type_8868 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator_base"));
  ::Reflex::Type type_1402 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::IRecordSelection*>"));
  ::Reflex::Type type_3676 = ::Reflex::TypeBuilder(Reflex::Literal("cool::ChannelSelection::ChannelRange"));
  ::Reflex::Type type_8863 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::const_iterator"));
  ::Reflex::Type type_4003 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>::_Alloc_hider"));
  ::Reflex::Type type_1397 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_2287 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecificationUnknownField"));
  ::Reflex::Type type_2341 = ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordSpecificationCannotExtend"));
  ::Reflex::Type type_1625 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"));
  ::Reflex::Type type_2446 = ::Reflex::TypeBuilder(Reflex::Literal("coral::IConnectionServiceConfiguration"));
  ::Reflex::Type type_1543 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>"));
  ::Reflex::Type type_1404 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::IFieldSpecification*>"));
  ::Reflex::Type type_2070 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>"));
  ::Reflex::Type type_2268 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyFields"));
  ::Reflex::Type type_2364 = ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeStringContainsNullChar"));
  ::Reflex::Type type_2282 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>"));
  ::Reflex::Type type_1393 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute**>"));
  ::Reflex::Type type_1536 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::basic_string<char> >"));
  ::Reflex::Type type_2265 = ::Reflex::TypeBuilder(Reflex::Literal("cool::FieldSpecificationWrongStorageType"));
  ::Reflex::Type type_7929 = ::Reflex::EnumTypeBuilder(Reflex::Literal("cool::CompositeSelection::Connective"));
  ::Reflex::Type type_1545 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1403 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const cool::IRecordSelection*>"));
  ::Reflex::Type type_2374 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationInvalidFieldName"));
  ::Reflex::Type type_1406 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<coral::AttributeSpecification*>"));
  ::Reflex::Type type_2076 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>"));
  ::Reflex::Type type_2405 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyBlobFields"));
  ::Reflex::Type type_1399 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1400 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_1394 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute* const*>"));
  ::Reflex::Type type_1547 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1624 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_1700 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_2412 = ::Reflex::TypeBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyString255Fields"));
  ::Reflex::Type type_1540 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1541 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_1405 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_2069 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>"));
  ::Reflex::Type type_8711 = ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeListSpecification::const_iterator"));
  ::Reflex::Type type_10338 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord* boost::shared_ptr<cool::IRecord>::*"));
  ::Reflex::Type type_10186 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObject* boost::shared_ptr<cool::IObject>::*"));
  ::Reflex::Type type_10232 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolder* boost::shared_ptr<cool::IFolder>::*"));
  ::Reflex::Type type_1546 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_2071 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1560 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IField*>::rebind<cool::IField*>"));
  ::Reflex::Type type_1428 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_1823 = ::Reflex::TypeBuilder(Reflex::Literal("std::__are_same<coral::Attribute**,coral::Attribute**>"));
  ::Reflex::Type type_1389 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>"));
  ::Reflex::Type type_1390 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>"));
  ::Reflex::Type type_10247 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*"));
  ::Reflex::Type type_2038 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned int> >"));
  ::Reflex::Type type_2075 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>"));
  ::Reflex::Type type_2042 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >"));
  ::Reflex::Type type_10193 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*"));
  ::Reflex::Type type_1392 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>"));
  ::Reflex::Type type_2067 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_2068 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_2132 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >"));
  ::Reflex::Type type_1566 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::Attribute*>::rebind<coral::Attribute*>"));
  ::Reflex::Type type_1822 = ::Reflex::TypeBuilder(Reflex::Literal("std::__are_same<coral::Attribute* const*,coral::Attribute**>"));
  ::Reflex::Type type_2114 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_1676 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >"));
  ::Reflex::Type type_2048 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >"));
  ::Reflex::Type type_2113 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_2072 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_1680 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >"));
  ::Reflex::Type type_2271 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_2334 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_2147 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >"));
  ::Reflex::Type type_2041 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >"));
  ::Reflex::Type type_10168 = ::Reflex::TypeBuilder(Reflex::Literal("cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*"));
  ::Reflex::Type type_2035 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_2126 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_2043 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1684 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >"));
  ::Reflex::Type type_1537 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_2135 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >"));
  ::Reflex::Type type_1559 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>"));
  ::Reflex::Type type_2047 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_2112 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_1643 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_2127 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_2039 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_2040 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_5433 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::_Vector_impl"));
  ::Reflex::Type type_2136 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> >"));
  ::Reflex::Type type_1561 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1477 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_2044 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_2143 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_2056 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>"));
  ::Reflex::Type type_1679 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >"));
  ::Reflex::Type type_1672 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::basic_string<char> > >"));
  ::Reflex::Type type_1675 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_1695 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_5505 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::_Vector_impl"));
  ::Reflex::Type type_2144 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >"));
  ::Reflex::Type type_1565 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1821 = ::Reflex::TypeBuilder(Reflex::Literal("std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>"));
  ::Reflex::Type type_2062 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>"));
  ::Reflex::Type type_1681 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1671 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> > >"));
  ::Reflex::Type type_2133 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >"));
  ::Reflex::Type type_1557 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_1558 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_2124 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_1650 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_1431 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,bool>"));
  ::Reflex::Type type_1658 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> > >"));
  ::Reflex::Type type_1683 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_5415 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::_Vector_impl"));
  ::Reflex::Type type_2134 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> >"));
  ::Reflex::Type type_2137 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1562 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_2125 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_2036 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1649 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_2055 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>"));
  ::Reflex::Type type_1677 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_1678 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_1657 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> > >"));
  ::Reflex::Type type_1648 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_5451 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::_Vector_impl"));
  ::Reflex::Type type_2138 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> >"));
  ::Reflex::Type type_1668 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >"));
  ::Reflex::Type type_2142 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_2057 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>"));
  ::Reflex::Type type_1682 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_1647 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1667 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >"));
  ::Reflex::Type type_2128 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_2130 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_5487 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::_Vector_impl"));
  ::Reflex::Type type_2141 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >"));
  ::Reflex::Type type_2061 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>"));
  ::Reflex::Type type_1656 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> > >"));
  ::Reflex::Type type_5379 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::_Vector_impl"));
  ::Reflex::Type type_5397 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::_Vector_impl"));
  ::Reflex::Type type_1646 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_2129 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >"));
  ::Reflex::Type type_2131 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >"));
  ::Reflex::Type type_2139 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_10150 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*"));
  ::Reflex::Type type_10241 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*"));
  ::Reflex::Type type_2053 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >"));
  ::Reflex::Type type_2054 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >"));
  ::Reflex::Type type_1655 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> > >"));
  ::Reflex::Type type_1660 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> > >"));
  ::Reflex::Type type_1645 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_5469 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::_Vector_impl"));
  ::Reflex::Type type_2140 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >"));
  ::Reflex::Type type_2058 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>"));
  ::Reflex::Type type_1659 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> > >"));
  ::Reflex::Type type_1666 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> > >"));
  ::Reflex::Type type_1652 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >"));
  ::Reflex::Type type_1654 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >"));
  ::Reflex::Type type_1665 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >"));
  ::Reflex::Type type_1651 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >"));
  ::Reflex::Type type_1653 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >"));
  ::Reflex::Type type_1662 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> > >"));
  ::Reflex::Type type_1661 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> > >"));
  ::Reflex::Type type_1430 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1429 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1761 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned int,std::basic_string<char> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_2272 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IRecordVectorPtr"), type_2271);
  ::Reflex::Type type_2283 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectIteratorPtr"), type_2282);
  ::Reflex::Type type_2286 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IRecordVector"), type_1399);
  ::Reflex::Type type_2291 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectPtr"), type_2290);
  ::Reflex::Type type_2293 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectVector"), type_1400);
  ::Reflex::Type type_2299 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IFolderSetPtr"), type_2298);
  ::Reflex::Type type_1450 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1443);
  ::Reflex::Type type_2311 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String64k"), type_1450);
  ::Reflex::Type type_2326 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IFolderPtr"), type_2325);
  ::Reflex::Type type_2335 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IObjectVectorPtr"), type_2334);
  ::Reflex::Type type_2338 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IDatabasePtr"), type_2337);
  ::Reflex::Type type_2343 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Blob16M"), type_2342);
  ::Reflex::Type type_2351 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String4k"), type_1450);
  ::Reflex::Type type_2369 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String16M"), type_1450);
  ::Reflex::Type type_2400 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::IRecordPtr"), type_2399);
  ::Reflex::Type type_2401 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Blob64k"), type_2342);
  ::Reflex::Type type_2403 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::DatabaseId"), type_1450);
  ::Reflex::Type type_2407 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::String255"), type_1450);
  ::Reflex::Type type_5141 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::iterator"), type_1477);
  ::Reflex::Type type_5142 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_iterator"), type_1695);
  ::Reflex::Type type_11320 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String255"), type_2407);
  ::Reflex::Type type_11321 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String4k"), type_2351);
  ::Reflex::Type type_11322 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String64k"), type_2311);
  ::Reflex::Type type_11323 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::String16M"), type_2369);
  ::Reflex::Type type_11324 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob64k"), type_2401);
  ::Reflex::Type type_11325 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob16M"), type_2343);
  ::Reflex::Type type_2281c = ::Reflex::ConstBuilder(type_2281);
  ::Reflex::Type type_10133 = ::Reflex::ReferenceBuilder(type_2281c);
  ::Reflex::Type type_2367 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt32"), type_80);
  ::Reflex::Type type_1450c = ::Reflex::ConstBuilder(type_1450);
  ::Reflex::Type type_4135 = ::Reflex::ReferenceBuilder(type_1450c);
  ::Reflex::Type type_2270c = ::Reflex::ConstBuilder(type_2270);
  ::Reflex::Type type_8530 = ::Reflex::ReferenceBuilder(type_2270c);
  ::Reflex::Type type_2302c = ::Reflex::ConstBuilder(type_2302);
  ::Reflex::Type type_8529 = ::Reflex::ReferenceBuilder(type_2302c);
  ::Reflex::Type type_1827 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_1700);
  ::Reflex::Type type_8525 = ::Reflex::ReferenceBuilder(type_1827);
  ::Reflex::Type type_2452c = ::Reflex::ConstBuilder(type_2452);
  ::Reflex::Type type_8913 = ::Reflex::ReferenceBuilder(type_2452c);
  ::Reflex::Type type_1581 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_31);
  ::Reflex::Type type_3119 = ::Reflex::PointerBuilder(type_2399);
  ::Reflex::Type type_3121 = ::Reflex::ReferenceBuilder(type_2399);
  ::Reflex::Type type_9282 = ::Reflex::ReferenceBuilder(type_1389);
  ::Reflex::Type type_1389c = ::Reflex::ConstBuilder(type_1389);
  ::Reflex::Type type_9283 = ::Reflex::ReferenceBuilder(type_1389c);
  ::Reflex::Type type_10185 = ::Reflex::PointerBuilder(type_2321);
  ::Reflex::Type type_2314 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::ChannelId"), type_2367);
  ::Reflex::Type type_2314c = ::Reflex::ConstBuilder(type_2314);
  ::Reflex::Type type_10145 = ::Reflex::ReferenceBuilder(type_2314c);
  ::Reflex::Type type_2372 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt64"), type_114);
  ::Reflex::Type type_2294 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt63"), type_2372);
  ::Reflex::Type type_2348 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::ValidityKey"), type_2294);
  ::Reflex::Type type_2348c = ::Reflex::ConstBuilder(type_2348);
  ::Reflex::Type type_10223 = ::Reflex::ReferenceBuilder(type_2348c);
  ::Reflex::Type type_10224 = ::Reflex::ReferenceBuilder(type_2392);
  ::Reflex::Type type_2319c = ::Reflex::ConstBuilder(type_2319);
  ::Reflex::Type type_8526 = ::Reflex::ReferenceBuilder(type_2319c);
  ::Reflex::Type type_3130 = ::Reflex::PointerBuilder(type_2290);
  ::Reflex::Type type_3132 = ::Reflex::ReferenceBuilder(type_2290);
  ::Reflex::Type type_9284 = ::Reflex::ReferenceBuilder(type_1390);
  ::Reflex::Type type_1390c = ::Reflex::ConstBuilder(type_1390);
  ::Reflex::Type type_9285 = ::Reflex::ReferenceBuilder(type_1390c);
  ::Reflex::Type type_3149 = ::Reflex::PointerBuilder(type_2445);
  ::Reflex::Type type_3149c = ::Reflex::ConstBuilder(type_3149);
  ::Reflex::Type type_3152 = ::Reflex::PointerBuilder(type_3149c);
  ::Reflex::Type type_3154 = ::Reflex::ReferenceBuilder(type_3149c);
  ::Reflex::Type type_9289 = ::Reflex::ReferenceBuilder(type_1392);
  ::Reflex::Type type_1392c = ::Reflex::ConstBuilder(type_1392);
  ::Reflex::Type type_9290 = ::Reflex::ReferenceBuilder(type_1392c);
  ::Reflex::Type type_3161 = ::Reflex::PointerBuilder(type_2449);
  ::Reflex::Type type_3164 = ::Reflex::PointerBuilder(type_3161);
  ::Reflex::Type type_3166 = ::Reflex::ReferenceBuilder(type_3161);
  ::Reflex::Type type_9291 = ::Reflex::ReferenceBuilder(type_1393);
  ::Reflex::Type type_1393c = ::Reflex::ConstBuilder(type_1393);
  ::Reflex::Type type_9292 = ::Reflex::ReferenceBuilder(type_1393c);
  ::Reflex::Type type_3161c = ::Reflex::ConstBuilder(type_3161);
  ::Reflex::Type type_3175 = ::Reflex::PointerBuilder(type_3161c);
  ::Reflex::Type type_3177 = ::Reflex::ReferenceBuilder(type_3161c);
  ::Reflex::Type type_9294 = ::Reflex::ReferenceBuilder(type_1394);
  ::Reflex::Type type_1394c = ::Reflex::ConstBuilder(type_1394);
  ::Reflex::Type type_9295 = ::Reflex::ReferenceBuilder(type_1394c);
  ::Reflex::Type type_1636 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_80);
  ::Reflex::Type type_1636c = ::Reflex::ConstBuilder(type_1636);
  ::Reflex::Type type_3142 = ::Reflex::ReferenceBuilder(type_2490);
  ::Reflex::Type type_2490c = ::Reflex::ConstBuilder(type_2490);
  ::Reflex::Type type_3993 = ::Reflex::ReferenceBuilder(type_2490c);
  ::Reflex::Type type_820 = ::Reflex::PointerBuilder(type_2490);
  ::Reflex::Type type_1841 = ::Reflex::PointerBuilder(type_2490c);
  ::Reflex::Type type_1535c = ::Reflex::ConstBuilder(type_1535);
  ::Reflex::Type type_9409 = ::Reflex::ReferenceBuilder(type_1535c);
  ::Reflex::Type type_1443c = ::Reflex::ConstBuilder(type_1443);
  ::Reflex::Type type_3213 = ::Reflex::ReferenceBuilder(type_1443c);
  ::Reflex::Type type_3056 = ::Reflex::ReferenceBuilder(type_1443);
  ::Reflex::Type type_3208 = ::Reflex::PointerBuilder(type_1443);
  ::Reflex::Type type_3210 = ::Reflex::PointerBuilder(type_1443c);
  ::Reflex::Type type_1536c = ::Reflex::ConstBuilder(type_1536);
  ::Reflex::Type type_9301 = ::Reflex::ReferenceBuilder(type_1536c);
  ::Reflex::Type type_1397c = ::Reflex::ConstBuilder(type_1397);
  ::Reflex::Type type_9302 = ::Reflex::ReferenceBuilder(type_1397c);
  ::Reflex::Type type_9303 = ::Reflex::ReferenceBuilder(type_1397);
  ::Reflex::Type type_2488 = ::Reflex::PointerBuilder(type_80);
  ::Reflex::Type type_80c = ::Reflex::ConstBuilder(type_80);
  ::Reflex::Type type_3276 = ::Reflex::PointerBuilder(type_80c);
  ::Reflex::Type type_3278 = ::Reflex::ReferenceBuilder(type_80);
  ::Reflex::Type type_3280 = ::Reflex::ReferenceBuilder(type_80c);
  ::Reflex::Type type_1539c = ::Reflex::ConstBuilder(type_1539);
  ::Reflex::Type type_9305 = ::Reflex::ReferenceBuilder(type_1539c);
  ::Reflex::Type type_1398c = ::Reflex::ConstBuilder(type_1398);
  ::Reflex::Type type_9306 = ::Reflex::ReferenceBuilder(type_1398c);
  ::Reflex::Type type_9307 = ::Reflex::ReferenceBuilder(type_1398);
  ::Reflex::Type type_10337 = ::Reflex::PointerBuilder(type_2302);
  ::Reflex::Type type_2399c = ::Reflex::ConstBuilder(type_2399);
  ::Reflex::Type type_3346 = ::Reflex::ReferenceBuilder(type_2399c);
  ::Reflex::Type type_10196 = ::Reflex::ReferenceBuilder(type_2302);
  ::Reflex::Type type_185 = ::Reflex::PointerBuilder(type_1969);
  ::Reflex::Type type_9034 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("boost::detail::sp_typeinfo"), type_1701);
  ::Reflex::Type type_9034c = ::Reflex::ConstBuilder(type_9034);
  ::Reflex::Type type_10153 = ::Reflex::ReferenceBuilder(type_9034c);
  ::Reflex::Type type_3343 = ::Reflex::PointerBuilder(type_2399c);
  ::Reflex::Type type_1540c = ::Reflex::ConstBuilder(type_1540);
  ::Reflex::Type type_9309 = ::Reflex::ReferenceBuilder(type_1540c);
  ::Reflex::Type type_1399c = ::Reflex::ConstBuilder(type_1399);
  ::Reflex::Type type_9310 = ::Reflex::ReferenceBuilder(type_1399c);
  ::Reflex::Type type_9311 = ::Reflex::ReferenceBuilder(type_1399);
  ::Reflex::Type type_2290c = ::Reflex::ConstBuilder(type_2290);
  ::Reflex::Type type_3412 = ::Reflex::ReferenceBuilder(type_2290c);
  ::Reflex::Type type_10187 = ::Reflex::ReferenceBuilder(type_2321);
  ::Reflex::Type type_3409 = ::Reflex::PointerBuilder(type_2290c);
  ::Reflex::Type type_1541c = ::Reflex::ConstBuilder(type_1541);
  ::Reflex::Type type_9313 = ::Reflex::ReferenceBuilder(type_1541c);
  ::Reflex::Type type_1400c = ::Reflex::ConstBuilder(type_1400);
  ::Reflex::Type type_9314 = ::Reflex::ReferenceBuilder(type_1400c);
  ::Reflex::Type type_9315 = ::Reflex::ReferenceBuilder(type_1400);
  ::Reflex::Type type_3469 = ::Reflex::PointerBuilder(type_2270);
  ::Reflex::Type type_3475 = ::Reflex::PointerBuilder(type_3469);
  ::Reflex::Type type_3469c = ::Reflex::ConstBuilder(type_3469);
  ::Reflex::Type type_3477 = ::Reflex::PointerBuilder(type_3469c);
  ::Reflex::Type type_3479 = ::Reflex::ReferenceBuilder(type_3469);
  ::Reflex::Type type_3481 = ::Reflex::ReferenceBuilder(type_3469c);
  ::Reflex::Type type_1542c = ::Reflex::ConstBuilder(type_1542);
  ::Reflex::Type type_9317 = ::Reflex::ReferenceBuilder(type_1542c);
  ::Reflex::Type type_1401c = ::Reflex::ConstBuilder(type_1401);
  ::Reflex::Type type_9318 = ::Reflex::ReferenceBuilder(type_1401c);
  ::Reflex::Type type_9319 = ::Reflex::ReferenceBuilder(type_1401);
  ::Reflex::Type type_3538 = ::Reflex::PointerBuilder(type_2336);
  ::Reflex::Type type_3544 = ::Reflex::PointerBuilder(type_3538);
  ::Reflex::Type type_3538c = ::Reflex::ConstBuilder(type_3538);
  ::Reflex::Type type_3546 = ::Reflex::PointerBuilder(type_3538c);
  ::Reflex::Type type_3548 = ::Reflex::ReferenceBuilder(type_3538);
  ::Reflex::Type type_3550 = ::Reflex::ReferenceBuilder(type_3538c);
  ::Reflex::Type type_1543c = ::Reflex::ConstBuilder(type_1543);
  ::Reflex::Type type_9321 = ::Reflex::ReferenceBuilder(type_1543c);
  ::Reflex::Type type_1402c = ::Reflex::ConstBuilder(type_1402);
  ::Reflex::Type type_9322 = ::Reflex::ReferenceBuilder(type_1402c);
  ::Reflex::Type type_9323 = ::Reflex::ReferenceBuilder(type_1402);
  ::Reflex::Type type_3607 = ::Reflex::PointerBuilder(type_2316);
  ::Reflex::Type type_3613 = ::Reflex::PointerBuilder(type_3607);
  ::Reflex::Type type_3607c = ::Reflex::ConstBuilder(type_3607);
  ::Reflex::Type type_3615 = ::Reflex::PointerBuilder(type_3607c);
  ::Reflex::Type type_3617 = ::Reflex::ReferenceBuilder(type_3607);
  ::Reflex::Type type_3619 = ::Reflex::ReferenceBuilder(type_3607c);
  ::Reflex::Type type_1545c = ::Reflex::ConstBuilder(type_1545);
  ::Reflex::Type type_9325 = ::Reflex::ReferenceBuilder(type_1545c);
  ::Reflex::Type type_1404c = ::Reflex::ConstBuilder(type_1404);
  ::Reflex::Type type_9326 = ::Reflex::ReferenceBuilder(type_1404c);
  ::Reflex::Type type_9327 = ::Reflex::ReferenceBuilder(type_1404);
  ::Reflex::Type type_10320 = ::Reflex::ReferenceBuilder(type_2389);
  ::Reflex::Type type_2389c = ::Reflex::ConstBuilder(type_2389);
  ::Reflex::Type type_10321 = ::Reflex::ReferenceBuilder(type_2389c);
  ::Reflex::Type type_8544c = ::Reflex::ConstBuilder(type_8544);
  ::Reflex::Type type_10322 = ::Reflex::ReferenceBuilder(type_8544c);
  ::Reflex::Type type_3686 = ::Reflex::ReferenceBuilder(type_3676);
  ::Reflex::Type type_3676c = ::Reflex::ConstBuilder(type_3676);
  ::Reflex::Type type_3688 = ::Reflex::ReferenceBuilder(type_3676c);
  ::Reflex::Type type_3682 = ::Reflex::PointerBuilder(type_3676);
  ::Reflex::Type type_3684 = ::Reflex::PointerBuilder(type_3676c);
  ::Reflex::Type type_1546c = ::Reflex::ConstBuilder(type_1546);
  ::Reflex::Type type_9339 = ::Reflex::ReferenceBuilder(type_1546c);
  ::Reflex::Type type_1405c = ::Reflex::ConstBuilder(type_1405);
  ::Reflex::Type type_9340 = ::Reflex::ReferenceBuilder(type_1405c);
  ::Reflex::Type type_9341 = ::Reflex::ReferenceBuilder(type_1405);
  ::Reflex::Type type_3750 = ::Reflex::PointerBuilder(type_3149);
  ::Reflex::Type type_3753 = ::Reflex::ReferenceBuilder(type_3149);
  ::Reflex::Type type_1547c = ::Reflex::ConstBuilder(type_1547);
  ::Reflex::Type type_9342 = ::Reflex::ReferenceBuilder(type_1547c);
  ::Reflex::Type type_1406c = ::Reflex::ConstBuilder(type_1406);
  ::Reflex::Type type_9343 = ::Reflex::ReferenceBuilder(type_1406c);
  ::Reflex::Type type_9344 = ::Reflex::ReferenceBuilder(type_1406);
  ::Reflex::Type type_1550c = ::Reflex::ConstBuilder(type_1550);
  ::Reflex::Type type_9345 = ::Reflex::ReferenceBuilder(type_1550c);
  ::Reflex::Type type_1407c = ::Reflex::ConstBuilder(type_1407);
  ::Reflex::Type type_9346 = ::Reflex::ReferenceBuilder(type_1407c);
  ::Reflex::Type type_9347 = ::Reflex::ReferenceBuilder(type_1407);
  ::Reflex::Type type_9567 = ::Reflex::ReferenceBuilder(type_1540);
  ::Reflex::Type type_9568 = ::Reflex::ReferenceBuilder(type_1541);
  ::Reflex::Type type_9569 = ::Reflex::ReferenceBuilder(type_1542);
  ::Reflex::Type type_9570 = ::Reflex::ReferenceBuilder(type_1543);
  ::Reflex::Type type_9571 = ::Reflex::ReferenceBuilder(type_1545);
  ::Reflex::Type type_9572 = ::Reflex::ReferenceBuilder(type_1546);
  ::Reflex::Type type_9573 = ::Reflex::ReferenceBuilder(type_1547);
  ::Reflex::Type type_9580 = ::Reflex::ReferenceBuilder(type_1550);
  ::Reflex::Type type_9592 = ::Reflex::ReferenceBuilder(type_1557);
  ::Reflex::Type type_1557c = ::Reflex::ConstBuilder(type_1557);
  ::Reflex::Type type_9593 = ::Reflex::ReferenceBuilder(type_1557c);
  ::Reflex::Type type_9594 = ::Reflex::ReferenceBuilder(type_1558);
  ::Reflex::Type type_1558c = ::Reflex::ConstBuilder(type_1558);
  ::Reflex::Type type_9595 = ::Reflex::ReferenceBuilder(type_1558c);
  ::Reflex::Type type_9596 = ::Reflex::ReferenceBuilder(type_1559);
  ::Reflex::Type type_1559c = ::Reflex::ConstBuilder(type_1559);
  ::Reflex::Type type_9597 = ::Reflex::ReferenceBuilder(type_1559c);
  ::Reflex::Type type_9598 = ::Reflex::ReferenceBuilder(type_1560);
  ::Reflex::Type type_1560c = ::Reflex::ConstBuilder(type_1560);
  ::Reflex::Type type_9599 = ::Reflex::ReferenceBuilder(type_1560c);
  ::Reflex::Type type_9600 = ::Reflex::ReferenceBuilder(type_1561);
  ::Reflex::Type type_1561c = ::Reflex::ConstBuilder(type_1561);
  ::Reflex::Type type_9601 = ::Reflex::ReferenceBuilder(type_1561c);
  ::Reflex::Type type_9602 = ::Reflex::ReferenceBuilder(type_1562);
  ::Reflex::Type type_1562c = ::Reflex::ConstBuilder(type_1562);
  ::Reflex::Type type_9603 = ::Reflex::ReferenceBuilder(type_1562c);
  ::Reflex::Type type_9608 = ::Reflex::ReferenceBuilder(type_1565);
  ::Reflex::Type type_1565c = ::Reflex::ConstBuilder(type_1565);
  ::Reflex::Type type_9609 = ::Reflex::ReferenceBuilder(type_1565c);
  ::Reflex::Type type_9610 = ::Reflex::ReferenceBuilder(type_1566);
  ::Reflex::Type type_1566c = ::Reflex::ConstBuilder(type_1566);
  ::Reflex::Type type_9611 = ::Reflex::ReferenceBuilder(type_1566c);
  ::Reflex::Type type_4381 = ::Reflex::PointerBuilder(type_1428);
  ::Reflex::Type type_1428c = ::Reflex::ConstBuilder(type_1428);
  ::Reflex::Type type_4690 = ::Reflex::PointerBuilder(type_1428c);
  ::Reflex::Type type_4379 = ::Reflex::ReferenceBuilder(type_1428);
  ::Reflex::Type type_4693 = ::Reflex::ReferenceBuilder(type_1428c);
  ::Reflex::Type type_1810c = ::Reflex::ConstBuilder(type_1810);
  ::Reflex::Type type_9646 = ::Reflex::ReferenceBuilder(type_1810c);
  ::Reflex::Type type_1537c = ::Reflex::ConstBuilder(type_1537);
  ::Reflex::Type type_9562 = ::Reflex::ReferenceBuilder(type_1537c);
  ::Reflex::Type type_1624c = ::Reflex::ConstBuilder(type_1624);
  ::Reflex::Type type_9647 = ::Reflex::ReferenceBuilder(type_1624c);
  ::Reflex::Type type_9648 = ::Reflex::ReferenceBuilder(type_1624);
  ::Reflex::Type type_9697 = ::Reflex::ReferenceBuilder(type_1677);
  ::Reflex::Type type_1677c = ::Reflex::ConstBuilder(type_1677);
  ::Reflex::Type type_9698 = ::Reflex::ReferenceBuilder(type_1677c);
  ::Reflex::Type type_9708 = ::Reflex::ReferenceBuilder(type_1678);
  ::Reflex::Type type_1678c = ::Reflex::ConstBuilder(type_1678);
  ::Reflex::Type type_9709 = ::Reflex::ReferenceBuilder(type_1678c);
  ::Reflex::Type type_9719 = ::Reflex::ReferenceBuilder(type_1679);
  ::Reflex::Type type_1679c = ::Reflex::ConstBuilder(type_1679);
  ::Reflex::Type type_9720 = ::Reflex::ReferenceBuilder(type_1679c);
  ::Reflex::Type type_9730 = ::Reflex::ReferenceBuilder(type_1680);
  ::Reflex::Type type_1680c = ::Reflex::ConstBuilder(type_1680);
  ::Reflex::Type type_9731 = ::Reflex::ReferenceBuilder(type_1680c);
  ::Reflex::Type type_9741 = ::Reflex::ReferenceBuilder(type_1681);
  ::Reflex::Type type_1681c = ::Reflex::ConstBuilder(type_1681);
  ::Reflex::Type type_9742 = ::Reflex::ReferenceBuilder(type_1681c);
  ::Reflex::Type type_9752 = ::Reflex::ReferenceBuilder(type_1682);
  ::Reflex::Type type_1682c = ::Reflex::ConstBuilder(type_1682);
  ::Reflex::Type type_9753 = ::Reflex::ReferenceBuilder(type_1682c);
  ::Reflex::Type type_9763 = ::Reflex::ReferenceBuilder(type_1683);
  ::Reflex::Type type_1683c = ::Reflex::ConstBuilder(type_1683);
  ::Reflex::Type type_9764 = ::Reflex::ReferenceBuilder(type_1683c);
  ::Reflex::Type type_9774 = ::Reflex::ReferenceBuilder(type_1684);
  ::Reflex::Type type_1684c = ::Reflex::ConstBuilder(type_1684);
  ::Reflex::Type type_9775 = ::Reflex::ReferenceBuilder(type_1684c);
  ::Reflex::Type type_1701c = ::Reflex::ConstBuilder(type_1701);
  ::Reflex::Type type_9791 = ::Reflex::ReferenceBuilder(type_1701c);
  ::Reflex::Type type_9792 = ::Reflex::PointerBuilder(type_1701c);
  ::Reflex::Type type_2000 = ::Reflex::PointerBuilder(type_185);
  ::Reflex::Type type_2252c = ::Reflex::ConstBuilder(type_2252);
  ::Reflex::Type type_9793 = ::Reflex::PointerBuilder(type_2252c);
  ::Reflex::Type type_9892 = ::Reflex::ReferenceBuilder(type_1821);
  ::Reflex::Type type_1821c = ::Reflex::ConstBuilder(type_1821);
  ::Reflex::Type type_9893 = ::Reflex::ReferenceBuilder(type_1821c);
  ::Reflex::Type type_9894 = ::Reflex::ReferenceBuilder(type_1822);
  ::Reflex::Type type_1822c = ::Reflex::ConstBuilder(type_1822);
  ::Reflex::Type type_9895 = ::Reflex::ReferenceBuilder(type_1822c);
  ::Reflex::Type type_9896 = ::Reflex::ReferenceBuilder(type_1823);
  ::Reflex::Type type_1823c = ::Reflex::ConstBuilder(type_1823);
  ::Reflex::Type type_9897 = ::Reflex::ReferenceBuilder(type_1823c);
  ::Reflex::Type type_9938 = ::Reflex::ReferenceBuilder(type_2039);
  ::Reflex::Type type_2039c = ::Reflex::ConstBuilder(type_2039);
  ::Reflex::Type type_9939 = ::Reflex::ReferenceBuilder(type_2039c);
  ::Reflex::Type type_9940 = ::Reflex::ReferenceBuilder(type_2040);
  ::Reflex::Type type_2040c = ::Reflex::ConstBuilder(type_2040);
  ::Reflex::Type type_9941 = ::Reflex::ReferenceBuilder(type_2040c);
  ::Reflex::Type type_9942 = ::Reflex::ReferenceBuilder(type_2041);
  ::Reflex::Type type_2041c = ::Reflex::ConstBuilder(type_2041);
  ::Reflex::Type type_9943 = ::Reflex::ReferenceBuilder(type_2041c);
  ::Reflex::Type type_9944 = ::Reflex::ReferenceBuilder(type_2042);
  ::Reflex::Type type_2042c = ::Reflex::ConstBuilder(type_2042);
  ::Reflex::Type type_9945 = ::Reflex::ReferenceBuilder(type_2042c);
  ::Reflex::Type type_9946 = ::Reflex::ReferenceBuilder(type_2043);
  ::Reflex::Type type_2043c = ::Reflex::ConstBuilder(type_2043);
  ::Reflex::Type type_9947 = ::Reflex::ReferenceBuilder(type_2043c);
  ::Reflex::Type type_9948 = ::Reflex::ReferenceBuilder(type_2044);
  ::Reflex::Type type_2044c = ::Reflex::ConstBuilder(type_2044);
  ::Reflex::Type type_9949 = ::Reflex::ReferenceBuilder(type_2044c);
  ::Reflex::Type type_9952 = ::Reflex::ReferenceBuilder(type_2047);
  ::Reflex::Type type_2047c = ::Reflex::ConstBuilder(type_2047);
  ::Reflex::Type type_9953 = ::Reflex::ReferenceBuilder(type_2047c);
  ::Reflex::Type type_9954 = ::Reflex::ReferenceBuilder(type_2048);
  ::Reflex::Type type_2048c = ::Reflex::ConstBuilder(type_2048);
  ::Reflex::Type type_9955 = ::Reflex::ReferenceBuilder(type_2048c);
  ::Reflex::Type type_9964 = ::Reflex::ReferenceBuilder(type_2053);
  ::Reflex::Type type_2053c = ::Reflex::ConstBuilder(type_2053);
  ::Reflex::Type type_9965 = ::Reflex::ReferenceBuilder(type_2053c);
  ::Reflex::Type type_9966 = ::Reflex::ReferenceBuilder(type_2054);
  ::Reflex::Type type_2054c = ::Reflex::ConstBuilder(type_2054);
  ::Reflex::Type type_9967 = ::Reflex::ReferenceBuilder(type_2054c);
  ::Reflex::Type type_9968 = ::Reflex::ReferenceBuilder(type_2055);
  ::Reflex::Type type_2055c = ::Reflex::ConstBuilder(type_2055);
  ::Reflex::Type type_9969 = ::Reflex::ReferenceBuilder(type_2055c);
  ::Reflex::Type type_9970 = ::Reflex::ReferenceBuilder(type_2056);
  ::Reflex::Type type_2056c = ::Reflex::ConstBuilder(type_2056);
  ::Reflex::Type type_9971 = ::Reflex::ReferenceBuilder(type_2056c);
  ::Reflex::Type type_9972 = ::Reflex::ReferenceBuilder(type_2057);
  ::Reflex::Type type_2057c = ::Reflex::ConstBuilder(type_2057);
  ::Reflex::Type type_9973 = ::Reflex::ReferenceBuilder(type_2057c);
  ::Reflex::Type type_9974 = ::Reflex::ReferenceBuilder(type_2058);
  ::Reflex::Type type_2058c = ::Reflex::ConstBuilder(type_2058);
  ::Reflex::Type type_9975 = ::Reflex::ReferenceBuilder(type_2058c);
  ::Reflex::Type type_9980 = ::Reflex::ReferenceBuilder(type_2061);
  ::Reflex::Type type_2061c = ::Reflex::ConstBuilder(type_2061);
  ::Reflex::Type type_9981 = ::Reflex::ReferenceBuilder(type_2061c);
  ::Reflex::Type type_9982 = ::Reflex::ReferenceBuilder(type_2062);
  ::Reflex::Type type_2062c = ::Reflex::ConstBuilder(type_2062);
  ::Reflex::Type type_9983 = ::Reflex::ReferenceBuilder(type_2062c);
  ::Reflex::Type type_9992 = ::Reflex::ReferenceBuilder(type_2067);
  ::Reflex::Type type_2067c = ::Reflex::ConstBuilder(type_2067);
  ::Reflex::Type type_9993 = ::Reflex::ReferenceBuilder(type_2067c);
  ::Reflex::Type type_1969c = ::Reflex::ConstBuilder(type_1969);
  ::Reflex::Type type_2021 = ::Reflex::PointerBuilder(type_1969c);
  ::Reflex::Type type_9994 = ::Reflex::ReferenceBuilder(type_2068);
  ::Reflex::Type type_2068c = ::Reflex::ConstBuilder(type_2068);
  ::Reflex::Type type_9995 = ::Reflex::ReferenceBuilder(type_2068c);
  ::Reflex::Type type_9996 = ::Reflex::ReferenceBuilder(type_2069);
  ::Reflex::Type type_2069c = ::Reflex::ConstBuilder(type_2069);
  ::Reflex::Type type_9997 = ::Reflex::ReferenceBuilder(type_2069c);
  ::Reflex::Type type_9998 = ::Reflex::ReferenceBuilder(type_2070);
  ::Reflex::Type type_2070c = ::Reflex::ConstBuilder(type_2070);
  ::Reflex::Type type_9999 = ::Reflex::ReferenceBuilder(type_2070c);
  ::Reflex::Type type_10000 = ::Reflex::ReferenceBuilder(type_2071);
  ::Reflex::Type type_2071c = ::Reflex::ConstBuilder(type_2071);
  ::Reflex::Type type_10001 = ::Reflex::ReferenceBuilder(type_2071c);
  ::Reflex::Type type_10002 = ::Reflex::ReferenceBuilder(type_2072);
  ::Reflex::Type type_2072c = ::Reflex::ConstBuilder(type_2072);
  ::Reflex::Type type_10003 = ::Reflex::ReferenceBuilder(type_2072c);
  ::Reflex::Type type_10008 = ::Reflex::ReferenceBuilder(type_2075);
  ::Reflex::Type type_2075c = ::Reflex::ConstBuilder(type_2075);
  ::Reflex::Type type_10009 = ::Reflex::ReferenceBuilder(type_2075c);
  ::Reflex::Type type_10010 = ::Reflex::ReferenceBuilder(type_2076);
  ::Reflex::Type type_2076c = ::Reflex::ConstBuilder(type_2076);
  ::Reflex::Type type_10011 = ::Reflex::ReferenceBuilder(type_2076c);
  ::Reflex::Type type_10064 = ::Reflex::ReferenceBuilder(type_2112);
  ::Reflex::Type type_2112c = ::Reflex::ConstBuilder(type_2112);
  ::Reflex::Type type_10065 = ::Reflex::ReferenceBuilder(type_2112c);
  ::Reflex::Type type_10066 = ::Reflex::ReferenceBuilder(type_2113);
  ::Reflex::Type type_2113c = ::Reflex::ConstBuilder(type_2113);
  ::Reflex::Type type_10067 = ::Reflex::ReferenceBuilder(type_2113c);
  ::Reflex::Type type_10068 = ::Reflex::ReferenceBuilder(type_2114);
  ::Reflex::Type type_2114c = ::Reflex::ConstBuilder(type_2114);
  ::Reflex::Type type_10069 = ::Reflex::ReferenceBuilder(type_2114c);
  ::Reflex::Type type_10084 = ::Reflex::ReferenceBuilder(type_2128);
  ::Reflex::Type type_2128c = ::Reflex::ConstBuilder(type_2128);
  ::Reflex::Type type_10085 = ::Reflex::ReferenceBuilder(type_2128c);
  ::Reflex::Type type_3119c = ::Reflex::ConstBuilder(type_3119);
  ::Reflex::Type type_10086 = ::Reflex::ReferenceBuilder(type_3119c);
  ::Reflex::Type type_10087 = ::Reflex::ReferenceBuilder(type_2130);
  ::Reflex::Type type_2130c = ::Reflex::ConstBuilder(type_2130);
  ::Reflex::Type type_10088 = ::Reflex::ReferenceBuilder(type_2130c);
  ::Reflex::Type type_3130c = ::Reflex::ConstBuilder(type_3130);
  ::Reflex::Type type_10089 = ::Reflex::ReferenceBuilder(type_3130c);
  ::Reflex::Type type_10093 = ::Reflex::ReferenceBuilder(type_2141);
  ::Reflex::Type type_2141c = ::Reflex::ConstBuilder(type_2141);
  ::Reflex::Type type_7476 = ::Reflex::ReferenceBuilder(type_2141c);
  ::Reflex::Type type_3152c = ::Reflex::ConstBuilder(type_3152);
  ::Reflex::Type type_10094 = ::Reflex::ReferenceBuilder(type_3152c);
  ::Reflex::Type type_10095 = ::Reflex::ReferenceBuilder(type_2143);
  ::Reflex::Type type_2143c = ::Reflex::ConstBuilder(type_2143);
  ::Reflex::Type type_10096 = ::Reflex::ReferenceBuilder(type_2143c);
  ::Reflex::Type type_3164c = ::Reflex::ConstBuilder(type_3164);
  ::Reflex::Type type_10097 = ::Reflex::ReferenceBuilder(type_3164c);
  ::Reflex::Type type_10098 = ::Reflex::ReferenceBuilder(type_2144);
  ::Reflex::Type type_2144c = ::Reflex::ConstBuilder(type_2144);
  ::Reflex::Type type_7477 = ::Reflex::ReferenceBuilder(type_2144c);
  ::Reflex::Type type_3175c = ::Reflex::ConstBuilder(type_3175);
  ::Reflex::Type type_10099 = ::Reflex::ReferenceBuilder(type_3175c);
  ::Reflex::Type type_2321c = ::Reflex::ConstBuilder(type_2321);
  ::Reflex::Type type_8527 = ::Reflex::ReferenceBuilder(type_2321c);
  ::Reflex::Type type_2335c = ::Reflex::ConstBuilder(type_2335);
  ::Reflex::Type type_7704c = ::Reflex::ConstBuilder(type_7704);
  ::Reflex::Type type_2342c = ::Reflex::ConstBuilder(type_2342);
  ::Reflex::Type type_10125 = ::Reflex::ReferenceBuilder(type_2342c);
  ::Reflex::Type type_1840c = ::Reflex::ConstBuilder(type_1840);
  ::Reflex::Type type_10126 = ::Reflex::ReferenceBuilder(type_1840c);
  ::Reflex::Type type_1847c = ::Reflex::ConstBuilder(type_1847);
  ::Reflex::Type type_10127 = ::Reflex::ReferenceBuilder(type_1847c);
  ::Reflex::Type type_114c = ::Reflex::ConstBuilder(type_114);
  ::Reflex::Type type_10128 = ::Reflex::ReferenceBuilder(type_114c);
  ::Reflex::Type type_96c = ::Reflex::ConstBuilder(type_96);
  ::Reflex::Type type_10129 = ::Reflex::ReferenceBuilder(type_96c);
  ::Reflex::Type type_31c = ::Reflex::ConstBuilder(type_31);
  ::Reflex::Type type_6021 = ::Reflex::ReferenceBuilder(type_31c);
  ::Reflex::Type type_269c = ::Reflex::ConstBuilder(type_269);
  ::Reflex::Type type_10130 = ::Reflex::ReferenceBuilder(type_269c);
  ::Reflex::Type type_679c = ::Reflex::ConstBuilder(type_679);
  ::Reflex::Type type_10131 = ::Reflex::ReferenceBuilder(type_679c);
  ::Reflex::Type type_140c = ::Reflex::ConstBuilder(type_140);
  ::Reflex::Type type_10132 = ::Reflex::ReferenceBuilder(type_140c);
  ::Reflex::Type type_1881c = ::Reflex::ConstBuilder(type_1881);
  ::Reflex::Type type_6020 = ::Reflex::ReferenceBuilder(type_1881c);
  ::Reflex::Type type_10136 = ::Reflex::ReferenceBuilder(type_2265);
  ::Reflex::Type type_2265c = ::Reflex::ConstBuilder(type_2265);
  ::Reflex::Type type_10137 = ::Reflex::ReferenceBuilder(type_2265c);
  ::Reflex::Type type_2280c = ::Reflex::ConstBuilder(type_2280);
  ::Reflex::Type type_10138 = ::Reflex::ReferenceBuilder(type_2280c);
  ::Reflex::Type type_10139 = ::Reflex::ReferenceBuilder(type_2267);
  ::Reflex::Type type_2267c = ::Reflex::ConstBuilder(type_2267);
  ::Reflex::Type type_10140 = ::Reflex::ReferenceBuilder(type_2267c);
  ::Reflex::Type type_10141 = ::Reflex::ReferenceBuilder(type_2268);
  ::Reflex::Type type_2268c = ::Reflex::ConstBuilder(type_2268);
  ::Reflex::Type type_10142 = ::Reflex::ReferenceBuilder(type_2268c);
  ::Reflex::Type type_10143 = ::Reflex::ReferenceBuilder(type_2269);
  ::Reflex::Type type_2269c = ::Reflex::ConstBuilder(type_2269);
  ::Reflex::Type type_10144 = ::Reflex::ReferenceBuilder(type_2269c);
  ::Reflex::Type type_2316c = ::Reflex::ConstBuilder(type_2316);
  ::Reflex::Type type_10146 = ::Reflex::ReferenceBuilder(type_2316c);
  ::Reflex::Type type_2449c = ::Reflex::ConstBuilder(type_2449);
  ::Reflex::Type type_8914 = ::Reflex::ReferenceBuilder(type_2449c);
  ::Reflex::Type type_2294c = ::Reflex::ConstBuilder(type_2294);
  ::Reflex::Type type_10147 = ::Reflex::ReferenceBuilder(type_2294c);
  ::Reflex::Type type_2276 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Int64"), type_96);
  ::Reflex::Type type_2276c = ::Reflex::ConstBuilder(type_2276);
  ::Reflex::Type type_7714 = ::Reflex::ReferenceBuilder(type_2276c);
  ::Reflex::Type type_2367c = ::Reflex::ConstBuilder(type_2367);
  ::Reflex::Type type_7711 = ::Reflex::ReferenceBuilder(type_2367c);
  ::Reflex::Type type_2350 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Int32"), type_31);
  ::Reflex::Type type_2350c = ::Reflex::ConstBuilder(type_2350);
  ::Reflex::Type type_7709 = ::Reflex::ReferenceBuilder(type_2350c);
  ::Reflex::Type type_2332 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UInt16"), type_269);
  ::Reflex::Type type_2332c = ::Reflex::ConstBuilder(type_2332);
  ::Reflex::Type type_7744 = ::Reflex::ReferenceBuilder(type_2332c);
  ::Reflex::Type type_2330 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Int16"), type_679);
  ::Reflex::Type type_2330c = ::Reflex::ConstBuilder(type_2330);
  ::Reflex::Type type_7715 = ::Reflex::ReferenceBuilder(type_2330c);
  ::Reflex::Type type_2279 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::UChar"), type_140);
  ::Reflex::Type type_2279c = ::Reflex::ConstBuilder(type_2279);
  ::Reflex::Type type_7712 = ::Reflex::ReferenceBuilder(type_2279c);
  ::Reflex::Type type_10149 = ::Reflex::PointerBuilder(type_1399);
  ::Reflex::Type type_2271c = ::Reflex::ConstBuilder(type_2271);
  ::Reflex::Type type_10151 = ::Reflex::ReferenceBuilder(type_2271c);
  ::Reflex::Type type_10152 = ::Reflex::ReferenceBuilder(type_2271);
  ::Reflex::Type type_10154 = ::Reflex::ReferenceBuilder(type_2274);
  ::Reflex::Type type_2274c = ::Reflex::ConstBuilder(type_2274);
  ::Reflex::Type type_10155 = ::Reflex::ReferenceBuilder(type_2274c);
  ::Reflex::Type type_10156 = ::Reflex::ReferenceBuilder(type_2275);
  ::Reflex::Type type_2275c = ::Reflex::ConstBuilder(type_2275);
  ::Reflex::Type type_10157 = ::Reflex::ReferenceBuilder(type_2275c);
  ::Reflex::Type type_869 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_80);
  ::Reflex::Type type_2336c = ::Reflex::ConstBuilder(type_2336);
  ::Reflex::Type type_10160 = ::Reflex::PointerBuilder(type_2336c);
  ::Reflex::Type type_1403c = ::Reflex::ConstBuilder(type_1403);
  ::Reflex::Type type_10161 = ::Reflex::ReferenceBuilder(type_1403c);
  ::Reflex::Type type_10164 = ::Reflex::ReferenceBuilder(type_7704c);
  ::Reflex::Type type_10167 = ::Reflex::PointerBuilder(type_2263);
  ::Reflex::Type type_2282c = ::Reflex::ConstBuilder(type_2282);
  ::Reflex::Type type_10169 = ::Reflex::ReferenceBuilder(type_2282c);
  ::Reflex::Type type_10170 = ::Reflex::ReferenceBuilder(type_2282);
  ::Reflex::Type type_10124 = ::Reflex::ReferenceBuilder(type_2263);
  ::Reflex::Type type_10181 = ::Reflex::ReferenceBuilder(type_2287);
  ::Reflex::Type type_2287c = ::Reflex::ConstBuilder(type_2287);
  ::Reflex::Type type_10182 = ::Reflex::ReferenceBuilder(type_2287c);
  ::Reflex::Type type_48c = ::Reflex::ConstBuilder(type_48);
  ::Reflex::Type type_10183 = ::Reflex::ReferenceBuilder(type_2289);
  ::Reflex::Type type_2289c = ::Reflex::ConstBuilder(type_2289);
  ::Reflex::Type type_10184 = ::Reflex::ReferenceBuilder(type_2289c);
  ::Reflex::Type type_10188 = ::Reflex::ReferenceBuilder(type_2292);
  ::Reflex::Type type_2292c = ::Reflex::ConstBuilder(type_2292);
  ::Reflex::Type type_10189 = ::Reflex::ReferenceBuilder(type_2292c);
  ::Reflex::Type type_10190 = ::Reflex::ReferenceBuilder(type_2297);
  ::Reflex::Type type_2297c = ::Reflex::ConstBuilder(type_2297);
  ::Reflex::Type type_10191 = ::Reflex::ReferenceBuilder(type_2297c);
  ::Reflex::Type type_10192 = ::Reflex::PointerBuilder(type_2277);
  ::Reflex::Type type_2298c = ::Reflex::ConstBuilder(type_2298);
  ::Reflex::Type type_10194 = ::Reflex::ReferenceBuilder(type_2298c);
  ::Reflex::Type type_10195 = ::Reflex::ReferenceBuilder(type_2298);
  ::Reflex::Type type_10159 = ::Reflex::ReferenceBuilder(type_2277);
  ::Reflex::Type type_10197 = ::Reflex::ReferenceBuilder(type_2303);
  ::Reflex::Type type_2303c = ::Reflex::ConstBuilder(type_2303);
  ::Reflex::Type type_10198 = ::Reflex::ReferenceBuilder(type_2303c);
  ::Reflex::Type type_2304c = ::Reflex::ConstBuilder(type_2304);
  ::Reflex::Type type_10199 = ::Reflex::ReferenceBuilder(type_2304c);
  ::Reflex::Type type_10200 = ::Reflex::ReferenceBuilder(type_2304);
  ::Reflex::Type type_10201 = ::Reflex::ReferenceBuilder(type_2305);
  ::Reflex::Type type_2305c = ::Reflex::ConstBuilder(type_2305);
  ::Reflex::Type type_10202 = ::Reflex::ReferenceBuilder(type_2305c);
  ::Reflex::Type type_10203 = ::Reflex::ReferenceBuilder(type_2307);
  ::Reflex::Type type_2307c = ::Reflex::ConstBuilder(type_2307);
  ::Reflex::Type type_10204 = ::Reflex::ReferenceBuilder(type_2307c);
  ::Reflex::Type type_10205 = ::Reflex::ReferenceBuilder(type_2308);
  ::Reflex::Type type_2308c = ::Reflex::ConstBuilder(type_2308);
  ::Reflex::Type type_10206 = ::Reflex::ReferenceBuilder(type_2308c);
  ::Reflex::Type type_10207 = ::Reflex::ReferenceBuilder(type_2309);
  ::Reflex::Type type_2309c = ::Reflex::ConstBuilder(type_2309);
  ::Reflex::Type type_10208 = ::Reflex::ReferenceBuilder(type_2309c);
  ::Reflex::Type type_2310c = ::Reflex::ConstBuilder(type_2310);
  ::Reflex::Type type_10209 = ::Reflex::ReferenceBuilder(type_2310c);
  ::Reflex::Type type_10210 = ::Reflex::ReferenceBuilder(type_2310);
  ::Reflex::Type type_10148 = ::Reflex::ReferenceBuilder(type_2270);
  ::Reflex::Type type_10211 = ::Reflex::ReferenceBuilder(type_2312);
  ::Reflex::Type type_2312c = ::Reflex::ConstBuilder(type_2312);
  ::Reflex::Type type_10212 = ::Reflex::ReferenceBuilder(type_2312c);
  ::Reflex::Type type_10213 = ::Reflex::ReferenceBuilder(type_2313);
  ::Reflex::Type type_2313c = ::Reflex::ConstBuilder(type_2313);
  ::Reflex::Type type_10214 = ::Reflex::ReferenceBuilder(type_2313c);
  ::Reflex::Type type_10215 = ::Reflex::ReferenceBuilder(type_2315);
  ::Reflex::Type type_2315c = ::Reflex::ConstBuilder(type_2315);
  ::Reflex::Type type_10216 = ::Reflex::ReferenceBuilder(type_2315c);
  ::Reflex::Type type_10218 = ::Reflex::ReferenceBuilder(type_2318);
  ::Reflex::Type type_2318c = ::Reflex::ConstBuilder(type_2318);
  ::Reflex::Type type_10219 = ::Reflex::ReferenceBuilder(type_2318c);
  ::Reflex::Type type_10225 = ::Reflex::ReferenceBuilder(type_2322);
  ::Reflex::Type type_2322c = ::Reflex::ConstBuilder(type_2322);
  ::Reflex::Type type_10226 = ::Reflex::ReferenceBuilder(type_2322c);
  ::Reflex::Type type_10227 = ::Reflex::ReferenceBuilder(type_2323);
  ::Reflex::Type type_2323c = ::Reflex::ConstBuilder(type_2323);
  ::Reflex::Type type_10228 = ::Reflex::ReferenceBuilder(type_2323c);
  ::Reflex::Type type_10229 = ::Reflex::ReferenceBuilder(type_2324);
  ::Reflex::Type type_2324c = ::Reflex::ConstBuilder(type_2324);
  ::Reflex::Type type_10230 = ::Reflex::ReferenceBuilder(type_2324c);
  ::Reflex::Type type_2397c = ::Reflex::ConstBuilder(type_2397);
  ::Reflex::Type type_10282 = ::Reflex::ReferenceBuilder(type_2397c);
  ::Reflex::Type type_2331c = ::Reflex::ConstBuilder(type_2331);
  ::Reflex::Type type_10231 = ::Reflex::PointerBuilder(type_2410);
  ::Reflex::Type type_2325c = ::Reflex::ConstBuilder(type_2325);
  ::Reflex::Type type_10233 = ::Reflex::ReferenceBuilder(type_2325c);
  ::Reflex::Type type_10234 = ::Reflex::ReferenceBuilder(type_2325);
  ::Reflex::Type type_10235 = ::Reflex::ReferenceBuilder(type_2410);
  ::Reflex::Type type_10236 = ::Reflex::ReferenceBuilder(type_2329);
  ::Reflex::Type type_2329c = ::Reflex::ConstBuilder(type_2329);
  ::Reflex::Type type_10237 = ::Reflex::ReferenceBuilder(type_2329c);
  ::Reflex::Type type_10238 = ::Reflex::ReferenceBuilder(type_2331c);
  ::Reflex::Type type_10239 = ::Reflex::ReferenceBuilder(type_2331);
  ::Reflex::Type type_10240 = ::Reflex::PointerBuilder(type_1400);
  ::Reflex::Type type_2334c = ::Reflex::ConstBuilder(type_2334);
  ::Reflex::Type type_10242 = ::Reflex::ReferenceBuilder(type_2334c);
  ::Reflex::Type type_10243 = ::Reflex::ReferenceBuilder(type_2334);
  ::Reflex::Type type_2403c = ::Reflex::ConstBuilder(type_2403);
  ::Reflex::Type type_10268 = ::Reflex::ReferenceBuilder(type_2403c);
  ::Reflex::Type type_10246 = ::Reflex::PointerBuilder(type_2361);
  ::Reflex::Type type_2337c = ::Reflex::ConstBuilder(type_2337);
  ::Reflex::Type type_10248 = ::Reflex::ReferenceBuilder(type_2337c);
  ::Reflex::Type type_10249 = ::Reflex::ReferenceBuilder(type_2337);
  ::Reflex::Type type_10250 = ::Reflex::ReferenceBuilder(type_2361);
  ::Reflex::Type type_10255 = ::Reflex::ReferenceBuilder(type_2341);
  ::Reflex::Type type_2341c = ::Reflex::ConstBuilder(type_2341);
  ::Reflex::Type type_10256 = ::Reflex::ReferenceBuilder(type_2341c);
  ::Reflex::Type type_10257 = ::Reflex::ReferenceBuilder(type_2342);
  ::Reflex::Type type_10259 = ::Reflex::ReferenceBuilder(type_2354);
  ::Reflex::Type type_10260 = ::Reflex::PointerBuilder(type_2244);
  ::Reflex::Type type_10261 = ::Reflex::ReferenceBuilder(type_2463);
  ::Reflex::Type type_10265 = ::Reflex::ReferenceBuilder(type_2353);
  ::Reflex::Type type_2353c = ::Reflex::ConstBuilder(type_2353);
  ::Reflex::Type type_10266 = ::Reflex::ReferenceBuilder(type_2353c);
  ::Reflex::Type type_2355c = ::Reflex::ConstBuilder(type_2355);
  ::Reflex::Type type_10269 = ::Reflex::ReferenceBuilder(type_2355c);
  ::Reflex::Type type_10271 = ::Reflex::ReferenceBuilder(type_2356);
  ::Reflex::Type type_2356c = ::Reflex::ConstBuilder(type_2356);
  ::Reflex::Type type_10272 = ::Reflex::ReferenceBuilder(type_2356c);
  ::Reflex::Type type_10273 = ::Reflex::ReferenceBuilder(type_2357);
  ::Reflex::Type type_2357c = ::Reflex::ConstBuilder(type_2357);
  ::Reflex::Type type_10274 = ::Reflex::ReferenceBuilder(type_2357c);
  ::Reflex::Type type_10275 = ::Reflex::ReferenceBuilder(type_2358);
  ::Reflex::Type type_2358c = ::Reflex::ConstBuilder(type_2358);
  ::Reflex::Type type_10276 = ::Reflex::ReferenceBuilder(type_2358c);
  ::Reflex::Type type_10277 = ::Reflex::ReferenceBuilder(type_2359);
  ::Reflex::Type type_2359c = ::Reflex::ConstBuilder(type_2359);
  ::Reflex::Type type_10278 = ::Reflex::ReferenceBuilder(type_2359c);
  ::Reflex::Type type_10279 = ::Reflex::ReferenceBuilder(type_2360);
  ::Reflex::Type type_2360c = ::Reflex::ConstBuilder(type_2360);
  ::Reflex::Type type_10280 = ::Reflex::ReferenceBuilder(type_2360c);
  ::Reflex::Type type_10283 = ::Reflex::ReferenceBuilder(type_2362);
  ::Reflex::Type type_2362c = ::Reflex::ConstBuilder(type_2362);
  ::Reflex::Type type_10284 = ::Reflex::ReferenceBuilder(type_2362c);
  ::Reflex::Type type_10285 = ::Reflex::ReferenceBuilder(type_2363);
  ::Reflex::Type type_2363c = ::Reflex::ConstBuilder(type_2363);
  ::Reflex::Type type_10286 = ::Reflex::ReferenceBuilder(type_2363c);
  ::Reflex::Type type_10287 = ::Reflex::ReferenceBuilder(type_2364);
  ::Reflex::Type type_2364c = ::Reflex::ConstBuilder(type_2364);
  ::Reflex::Type type_10288 = ::Reflex::ReferenceBuilder(type_2364c);
  ::Reflex::Type type_10289 = ::Reflex::ReferenceBuilder(type_2365);
  ::Reflex::Type type_2365c = ::Reflex::ConstBuilder(type_2365);
  ::Reflex::Type type_10290 = ::Reflex::ReferenceBuilder(type_2365c);
  ::Reflex::Type type_10291 = ::Reflex::ReferenceBuilder(type_2366);
  ::Reflex::Type type_2366c = ::Reflex::ConstBuilder(type_2366);
  ::Reflex::Type type_10292 = ::Reflex::ReferenceBuilder(type_2366c);
  ::Reflex::Type type_10293 = ::Reflex::ReferenceBuilder(type_2370);
  ::Reflex::Type type_2370c = ::Reflex::ConstBuilder(type_2370);
  ::Reflex::Type type_10294 = ::Reflex::ReferenceBuilder(type_2370c);
  ::Reflex::Type type_10295 = ::Reflex::ReferenceBuilder(type_2373);
  ::Reflex::Type type_2373c = ::Reflex::ConstBuilder(type_2373);
  ::Reflex::Type type_10296 = ::Reflex::ReferenceBuilder(type_2373c);
  ::Reflex::Type type_10297 = ::Reflex::ReferenceBuilder(type_2374);
  ::Reflex::Type type_2374c = ::Reflex::ConstBuilder(type_2374);
  ::Reflex::Type type_10298 = ::Reflex::ReferenceBuilder(type_2374c);
  ::Reflex::Type type_10299 = ::Reflex::ReferenceBuilder(type_2376);
  ::Reflex::Type type_2376c = ::Reflex::ConstBuilder(type_2376);
  ::Reflex::Type type_10300 = ::Reflex::ReferenceBuilder(type_2376c);
  ::Reflex::Type type_10301 = ::Reflex::ReferenceBuilder(type_2378);
  ::Reflex::Type type_2378c = ::Reflex::ConstBuilder(type_2378);
  ::Reflex::Type type_10302 = ::Reflex::ReferenceBuilder(type_2378c);
  ::Reflex::Type type_10303 = ::Reflex::ReferenceBuilder(type_2379);
  ::Reflex::Type type_2379c = ::Reflex::ConstBuilder(type_2379);
  ::Reflex::Type type_10304 = ::Reflex::ReferenceBuilder(type_2379c);
  ::Reflex::Type type_10305 = ::Reflex::PointerBuilder(type_2344);
  ::Reflex::Type type_10306 = ::Reflex::PointerBuilder(type_2463);
  ::Reflex::Type type_10309 = ::Reflex::ReferenceBuilder(type_2381);
  ::Reflex::Type type_2381c = ::Reflex::ConstBuilder(type_2381);
  ::Reflex::Type type_10310 = ::Reflex::ReferenceBuilder(type_2381c);
  ::Reflex::Type type_10316 = ::Reflex::ReferenceBuilder(type_2387);
  ::Reflex::Type type_2387c = ::Reflex::ConstBuilder(type_2387);
  ::Reflex::Type type_10317 = ::Reflex::ReferenceBuilder(type_2387c);
  ::Reflex::Type type_10318 = ::Reflex::ReferenceBuilder(type_2388);
  ::Reflex::Type type_2388c = ::Reflex::ConstBuilder(type_2388);
  ::Reflex::Type type_10319 = ::Reflex::ReferenceBuilder(type_2388c);
  ::Reflex::Type type_10324 = ::Reflex::ReferenceBuilder(type_2391);
  ::Reflex::Type type_2391c = ::Reflex::ConstBuilder(type_2391);
  ::Reflex::Type type_10325 = ::Reflex::ReferenceBuilder(type_2391c);
  ::Reflex::Type type_2272c = ::Reflex::ConstBuilder(type_2272);
  ::Reflex::Type type_10328 = ::Reflex::ReferenceBuilder(type_2393);
  ::Reflex::Type type_2393c = ::Reflex::ConstBuilder(type_2393);
  ::Reflex::Type type_10329 = ::Reflex::ReferenceBuilder(type_2393c);
  ::Reflex::Type type_10330 = ::Reflex::ReferenceBuilder(type_2394);
  ::Reflex::Type type_2394c = ::Reflex::ConstBuilder(type_2394);
  ::Reflex::Type type_10331 = ::Reflex::ReferenceBuilder(type_2394c);
  ::Reflex::Type type_10332 = ::Reflex::ReferenceBuilder(type_2395);
  ::Reflex::Type type_2395c = ::Reflex::ConstBuilder(type_2395);
  ::Reflex::Type type_10333 = ::Reflex::ReferenceBuilder(type_2395c);
  ::Reflex::Type type_8690c = ::Reflex::ConstBuilder(type_8690);
  ::Reflex::Type type_10334 = ::Reflex::ReferenceBuilder(type_8690c);
  ::Reflex::Type type_8034c = ::Reflex::ConstBuilder(type_8034);
  ::Reflex::Type type_10335 = ::Reflex::ReferenceBuilder(type_8034c);
  ::Reflex::Type type_10339 = ::Reflex::ReferenceBuilder(type_2402);
  ::Reflex::Type type_2402c = ::Reflex::ConstBuilder(type_2402);
  ::Reflex::Type type_10340 = ::Reflex::ReferenceBuilder(type_2402c);
  ::Reflex::Type type_10341 = ::Reflex::ReferenceBuilder(type_2405);
  ::Reflex::Type type_2405c = ::Reflex::ConstBuilder(type_2405);
  ::Reflex::Type type_10342 = ::Reflex::ReferenceBuilder(type_2405c);
  ::Reflex::Type type_2409c = ::Reflex::ConstBuilder(type_2409);
  ::Reflex::Type type_10343 = ::Reflex::ReferenceBuilder(type_2409c);
  ::Reflex::Type type_10344 = ::Reflex::ReferenceBuilder(type_2409);
  ::Reflex::Type type_10348 = ::Reflex::ReferenceBuilder(type_2412);
  ::Reflex::Type type_2412c = ::Reflex::ConstBuilder(type_2412);
  ::Reflex::Type type_10349 = ::Reflex::ReferenceBuilder(type_2412c);
  ::Reflex::Type type_2442c = ::Reflex::ConstBuilder(type_2442);
  ::Reflex::Type type_10363 = ::Reflex::ReferenceBuilder(type_2442c);
  ::Reflex::Type type_2445c = ::Reflex::ConstBuilder(type_2445);
  ::Reflex::Type type_10364 = ::Reflex::ReferenceBuilder(type_2445c);
  ::Reflex::Type type_10366 = ::Reflex::ReferenceBuilder(type_2445);
  ::Reflex::Type type_10367 = ::Reflex::ReferenceBuilder(type_2446);
  ::Reflex::Type type_2446c = ::Reflex::ConstBuilder(type_2446);
  ::Reflex::Type type_10368 = ::Reflex::ReferenceBuilder(type_2446c);
  ::Reflex::Type type_10369 = ::Reflex::ReferenceBuilder(type_2448);
  ::Reflex::Type type_10370 = ::Reflex::ReferenceBuilder(type_2451);
  ::Reflex::Type type_10371 = ::Reflex::ReferenceBuilder(type_2453);
  ::Reflex::Type type_10372 = ::Reflex::ReferenceBuilder(type_8860);
  ::Reflex::Type type_10373 = ::Reflex::ReferenceBuilder(type_2444);
  ::Reflex::Type type_10374 = ::Reflex::PointerBuilder(type_2444);
  ::Reflex::Type type_10375 = ::Reflex::PointerBuilder(type_2445c);
  ::Reflex::Type type_10376 = ::Reflex::PointerBuilder(type_2458);
  ::Reflex::Type type_10377 = ::Reflex::ReferenceBuilder(type_2449);
  ::Reflex::Type type_4624 = ::Reflex::ReferenceBuilder(type_1848);
  ::Reflex::Type type_4625 = ::Reflex::ReferenceBuilder(type_1840);
  ::Reflex::Type type_4626 = ::Reflex::ReferenceBuilder(type_1847);
  ::Reflex::Type type_9239 = ::Reflex::ReferenceBuilder(type_114);
  ::Reflex::Type type_9238 = ::Reflex::ReferenceBuilder(type_96);
  ::Reflex::Type type_9237 = ::Reflex::ReferenceBuilder(type_48);
  ::Reflex::Type type_9236 = ::Reflex::ReferenceBuilder(type_124);
  ::Reflex::Type type_9235 = ::Reflex::ReferenceBuilder(type_31);
  ::Reflex::Type type_9234 = ::Reflex::ReferenceBuilder(type_269);
  ::Reflex::Type type_9233 = ::Reflex::ReferenceBuilder(type_679);
  ::Reflex::Type type_5776 = ::Reflex::ReferenceBuilder(type_140);
  ::Reflex::Type type_4495 = ::Reflex::ReferenceBuilder(type_1881);
  ::Reflex::Type type_1848c = ::Reflex::ConstBuilder(type_1848);
  ::Reflex::Type type_10378 = ::Reflex::ReferenceBuilder(type_1848c);
  ::Reflex::Type type_10379 = ::Reflex::ReferenceBuilder(type_48c);
  ::Reflex::Type type_124c = ::Reflex::ConstBuilder(type_124);
  ::Reflex::Type type_10380 = ::Reflex::ReferenceBuilder(type_124c);
  ::Reflex::Type type_10381 = ::Reflex::PointerBuilder(type_2442);
  ::Reflex::Type type_10406 = ::Reflex::ReferenceBuilder(type_2452);
  ::Reflex::Type type_10407 = ::Reflex::ReferenceBuilder(type_2455);
  ::Reflex::Type type_2455c = ::Reflex::ConstBuilder(type_2455);
  ::Reflex::Type type_10408 = ::Reflex::ReferenceBuilder(type_2455c);
  ::Reflex::Type type_10409 = ::Reflex::ReferenceBuilder(type_2456);
  ::Reflex::Type type_2456c = ::Reflex::ConstBuilder(type_2456);
  ::Reflex::Type type_10410 = ::Reflex::ReferenceBuilder(type_2456c);
  ::Reflex::Type type_10411 = ::Reflex::ReferenceBuilder(type_2457);
  ::Reflex::Type type_2457c = ::Reflex::ConstBuilder(type_2457);
  ::Reflex::Type type_10412 = ::Reflex::ReferenceBuilder(type_2457c);
  ::Reflex::Type type_10415 = ::Reflex::ReferenceBuilder(type_2461);
  ::Reflex::Type type_2461c = ::Reflex::ConstBuilder(type_2461);
  ::Reflex::Type type_10416 = ::Reflex::ReferenceBuilder(type_2461c);
  ::Reflex::Type type_2463c = ::Reflex::ConstBuilder(type_2463);
  ::Reflex::Type type_10419 = ::Reflex::ReferenceBuilder(type_2463c);
  ::Reflex::Type type_10420 = ::Reflex::PointerBuilder(type_2447);
  ::Reflex::Type type_2454c = ::Reflex::ConstBuilder(type_2454);
  ::Reflex::Type type_10421 = ::Reflex::ReferenceBuilder(type_2454c);
  ::Reflex::Type type_8711c = ::Reflex::ConstBuilder(type_8711);
  ::Reflex::Type type_11439 = ::Reflex::ReferenceBuilder(type_8711c);
  ::Reflex::Type type_11440 = ::Reflex::ReferenceBuilder(type_8711);
  ::Reflex::Type type_8868c = ::Reflex::ConstBuilder(type_8868);
  ::Reflex::Type type_11446 = ::Reflex::ReferenceBuilder(type_8868c);
  ::Reflex::Type type_11448 = ::Reflex::ReferenceBuilder(type_8864);
  ::Reflex::Type type_8864c = ::Reflex::ConstBuilder(type_8864);
  ::Reflex::Type type_11449 = ::Reflex::ReferenceBuilder(type_8864c);
  ::Reflex::Type type_11450 = ::Reflex::ReferenceBuilder(type_8863);
  ::Reflex::Type type_8863c = ::Reflex::ConstBuilder(type_8863);
  ::Reflex::Type type_11451 = ::Reflex::ReferenceBuilder(type_8863c);
  ::Reflex::Type type_11452 = ::Reflex::PointerBuilder(type_2449c);
  ::Reflex::Type type_5255 = ::Reflex::PointerBuilder(type_9078);
  ::Reflex::Type type_9031c = ::Reflex::ConstBuilder(type_9031);
  ::Reflex::Type type_10641 = ::Reflex::ReferenceBuilder(type_9031c);
  ::Reflex::Type type_9077c = ::Reflex::ConstBuilder(type_9077);
  ::Reflex::Type type_10640 = ::Reflex::ReferenceBuilder(type_9077c);
  ::Reflex::Type type_11549 = ::Reflex::ReferenceBuilder(type_9031);
  ::Reflex::Type type_2398 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Bool"), type_1881);
  ::Reflex::Type type_2377 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Float"), type_1847);
  ::Reflex::Type type_2345 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("cool::Double"), type_1840);
  ::Reflex::Type type_11689 = ::Reflex::ReferenceBuilder(type_10172);
  ::Reflex::Type type_10172c = ::Reflex::ConstBuilder(type_10172);
  ::Reflex::Type type_11690 = ::Reflex::ReferenceBuilder(type_10172c);
  ::Reflex::Type type_3982 = ::Reflex::PointerBuilder(type_1713);
  ::Reflex::Type type_4386 = ::Reflex::PointerBuilder(type_1643);
  ::Reflex::Type type_9519 = ::Reflex::ReferenceBuilder(type_1477);
  ::Reflex::Type type_1477c = ::Reflex::ConstBuilder(type_1477);
  ::Reflex::Type type_9520 = ::Reflex::ReferenceBuilder(type_1477c);
  ::Reflex::Type type_1713c = ::Reflex::ConstBuilder(type_1713);
  ::Reflex::Type type_4660 = ::Reflex::PointerBuilder(type_1713c);
  ::Reflex::Type type_1643c = ::Reflex::ConstBuilder(type_1643);
  ::Reflex::Type type_4703 = ::Reflex::PointerBuilder(type_1643c);
  ::Reflex::Type type_9782 = ::Reflex::ReferenceBuilder(type_1695);
  ::Reflex::Type type_1695c = ::Reflex::ConstBuilder(type_1695);
  ::Reflex::Type type_9783 = ::Reflex::ReferenceBuilder(type_1695c);
  ::Reflex::Type type_11370 = ::Reflex::PointerBuilder(type_2354);
  ::Reflex::Type type_2372c = ::Reflex::ConstBuilder(type_2372);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __cool__IRecord
#undef __cool__IRecord
#endif
class __cool__IRecord {
  public:
  __cool__IRecord();
  virtual ~__cool__IRecord() throw();
};
#ifdef __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_
#undef __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_
#endif
struct __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_ {
  public:
  __std__iterator_traits_boost__shared_ptr_cool__IRecord_p_();
};
#ifdef __cool__IObject
#undef __cool__IObject
#endif
class __cool__IObject {
  public:
  __cool__IObject();
  virtual ~__cool__IObject() throw();
};
#ifdef __std__iterator_traits_boost__shared_ptr_cool__IObject_p_
#undef __std__iterator_traits_boost__shared_ptr_cool__IObject_p_
#endif
struct __std__iterator_traits_boost__shared_ptr_cool__IObject_p_ {
  public:
  __std__iterator_traits_boost__shared_ptr_cool__IObject_p_();
};
#ifdef __std__iterator_traits_coral__AttributeSpecificationpsconstp_
#undef __std__iterator_traits_coral__AttributeSpecificationpsconstp_
#endif
struct __std__iterator_traits_coral__AttributeSpecificationpsconstp_ {
  public:
  __std__iterator_traits_coral__AttributeSpecificationpsconstp_();
};
#ifdef __std__iterator_traits_coral__Attributepp_
#undef __std__iterator_traits_coral__Attributepp_
#endif
struct __std__iterator_traits_coral__Attributepp_ {
  public:
  __std__iterator_traits_coral__Attributepp_();
};
#ifdef __std__iterator_traits_coral__Attributepsconstp_
#undef __std__iterator_traits_coral__Attributepsconstp_
#endif
struct __std__iterator_traits_coral__Attributepsconstp_ {
  public:
  __std__iterator_traits_coral__Attributepsconstp_();
};
#ifdef __std__basic_string_char_
#undef __std__basic_string_char_
#endif
struct __std__basic_string_char_ {
  public:
  __std__basic_string_char_();
#ifdef __std__basic_string_char____Rep_base
#undef __std__basic_string_char____Rep_base
#endif
  struct __std__basic_string_char____Rep_base {
    public:
    __std__basic_string_char____Rep_base();
    ::std::size_t _M_length;
    ::std::size_t _M_capacity;
    ::_Atomic_word _M_refcount;
  };
#ifdef __std__basic_string_char____Rep
#undef __std__basic_string_char____Rep
#endif
  struct __std__basic_string_char____Rep :   public __std__basic_string_char____Rep_base   {
    public:
    __std__basic_string_char____Rep();
  };
#ifdef __std__basic_string_char____Alloc_hider
#undef __std__basic_string_char____Alloc_hider
#endif
  struct __std__basic_string_char____Alloc_hider :   public ::std::allocator<char>   {
    public:
    __std__basic_string_char____Alloc_hider();
    void* _M_p;
  };
  __std__basic_string_char____Alloc_hider _M_dataplus;
};
#ifdef __std__vector_std__basic_string_char_s_
#undef __std__vector_std__basic_string_char_s_
#endif
class __std__vector_std__basic_string_char_s_ : protected ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > {
  public:
  __std__vector_std__basic_string_char_s_();
};
#ifdef __std__vector_unsignedsint_
#undef __std__vector_unsignedsint_
#endif
class __std__vector_unsignedsint_ : protected ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > {
  public:
  __std__vector_unsignedsint_();
};
#ifdef __boost__shared_ptr_cool__IRecord_
#undef __boost__shared_ptr_cool__IRecord_
#endif
class __boost__shared_ptr_cool__IRecord_ {
  public:
  __boost__shared_ptr_cool__IRecord_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __std__vector_boost__shared_ptr_cool__IRecord_s_
#undef __std__vector_boost__shared_ptr_cool__IRecord_s_
#endif
class __std__vector_boost__shared_ptr_cool__IRecord_s_ : protected ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > {
  public:
  __std__vector_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef __boost__shared_ptr_cool__IObject_
#undef __boost__shared_ptr_cool__IObject_
#endif
class __boost__shared_ptr_cool__IObject_ {
  public:
  __boost__shared_ptr_cool__IObject_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __std__vector_boost__shared_ptr_cool__IObject_s_
#undef __std__vector_boost__shared_ptr_cool__IObject_s_
#endif
class __std__vector_boost__shared_ptr_cool__IObject_s_ : protected ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > {
  public:
  __std__vector_boost__shared_ptr_cool__IObject_s_();
};
#ifdef __std__vector_cool__IFieldp_
#undef __std__vector_cool__IFieldp_
#endif
class __std__vector_cool__IFieldp_ : protected ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > {
  public:
  __std__vector_cool__IFieldp_();
};
#ifdef __std__vector_cool__IRecordSelectionp_
#undef __std__vector_cool__IRecordSelectionp_
#endif
class __std__vector_cool__IRecordSelectionp_ : protected ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > {
  public:
  __std__vector_cool__IRecordSelectionp_();
};
#ifdef __std__vector_cool__IFieldSpecificationp_
#undef __std__vector_cool__IFieldSpecificationp_
#endif
class __std__vector_cool__IFieldSpecificationp_ : protected ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > {
  public:
  __std__vector_cool__IFieldSpecificationp_();
};
#ifdef __cool__ChannelSelection
#undef __cool__ChannelSelection
#endif
class __cool__ChannelSelection {
  public:
  __cool__ChannelSelection();
  bool m_isNumeric;
  bool m_allChannels;
  ::std::vector<cool::ChannelSelection::ChannelRange> m_ranges;
  ::std::string m_channelName;
  ::cool::ChannelSelection::Order m_order;
};
#ifdef __cool__ChannelSelection__ChannelRange
#undef __cool__ChannelSelection__ChannelRange
#endif
class __cool__ChannelSelection__ChannelRange {
  public:
  __cool__ChannelSelection__ChannelRange();
  ::cool::ChannelId m_firstChannel;
  ::cool::ChannelId m_lastChannel;
};
#ifdef __std__vector_cool__ChannelSelection__ChannelRange_
#undef __std__vector_cool__ChannelSelection__ChannelRange_
#endif
class __std__vector_cool__ChannelSelection__ChannelRange_ : protected ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > {
  public:
  __std__vector_cool__ChannelSelection__ChannelRange_();
};
#ifdef __std__vector_coral__AttributeSpecificationp_
#undef __std__vector_coral__AttributeSpecificationp_
#endif
class __std__vector_coral__AttributeSpecificationp_ : protected ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > {
  public:
  __std__vector_coral__AttributeSpecificationp_();
};
#ifdef __std__vector_coral__Attributep_
#undef __std__vector_coral__Attributep_
#endif
class __std__vector_coral__Attributep_ : protected ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > {
  public:
  __std__vector_coral__Attributep_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IRecord_s_
#undef __std__allocator_boost__shared_ptr_cool__IRecord_s_
#endif
class __std__allocator_boost__shared_ptr_cool__IRecord_s_ : public ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > {
  public:
  __std__allocator_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IObject_s_
#undef __std__allocator_boost__shared_ptr_cool__IObject_s_
#endif
class __std__allocator_boost__shared_ptr_cool__IObject_s_ : public ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > {
  public:
  __std__allocator_boost__shared_ptr_cool__IObject_s_();
};
#ifdef __std__allocator_cool__IFieldp_
#undef __std__allocator_cool__IFieldp_
#endif
class __std__allocator_cool__IFieldp_ : public ::__gnu_cxx::new_allocator<cool::IField*> {
  public:
  __std__allocator_cool__IFieldp_();
};
#ifdef __std__allocator_cool__IRecordSelectionp_
#undef __std__allocator_cool__IRecordSelectionp_
#endif
class __std__allocator_cool__IRecordSelectionp_ : public ::__gnu_cxx::new_allocator<cool::IRecordSelection*> {
  public:
  __std__allocator_cool__IRecordSelectionp_();
};
#ifdef __std__allocator_cool__IFieldSpecificationp_
#undef __std__allocator_cool__IFieldSpecificationp_
#endif
class __std__allocator_cool__IFieldSpecificationp_ : public ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> {
  public:
  __std__allocator_cool__IFieldSpecificationp_();
};
#ifdef __std__allocator_cool__ChannelSelection__ChannelRange_
#undef __std__allocator_cool__ChannelSelection__ChannelRange_
#endif
class __std__allocator_cool__ChannelSelection__ChannelRange_ : public ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> {
  public:
  __std__allocator_cool__ChannelSelection__ChannelRange_();
};
#ifdef __std__allocator_coral__AttributeSpecificationp_
#undef __std__allocator_coral__AttributeSpecificationp_
#endif
class __std__allocator_coral__AttributeSpecificationp_ : public ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> {
  public:
  __std__allocator_coral__AttributeSpecificationp_();
};
#ifdef __std__allocator_coral__Attributep_
#undef __std__allocator_coral__Attributep_
#endif
class __std__allocator_coral__Attributep_ : public ::__gnu_cxx::new_allocator<coral::Attribute*> {
  public:
  __std__allocator_coral__Attributep_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_
#undef __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_
#endif
struct __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_ {
  public:
  __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_
#undef __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_
#endif
struct __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_ {
  public:
  __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s_();
};
#ifdef __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_
#undef __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_
#endif
struct __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_ {
  public:
  __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp_();
};
#ifdef __std__allocator_cool__IFieldp___rebind_cool__IFieldp_
#undef __std__allocator_cool__IFieldp___rebind_cool__IFieldp_
#endif
struct __std__allocator_cool__IFieldp___rebind_cool__IFieldp_ {
  public:
  __std__allocator_cool__IFieldp___rebind_cool__IFieldp_();
};
#ifdef __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_
#undef __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_
#endif
struct __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_ {
  public:
  __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp_();
};
#ifdef __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_
#undef __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_
#endif
struct __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_ {
  public:
  __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange_();
};
#ifdef __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_
#undef __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_
#endif
struct __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_ {
  public:
  __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp_();
};
#ifdef __std__allocator_coral__Attributep___rebind_coral__Attributep_
#undef __std__allocator_coral__Attributep___rebind_coral__Attributep_
#endif
struct __std__allocator_coral__Attributep___rebind_coral__Attributep_ {
  public:
  __std__allocator_coral__Attributep___rebind_coral__Attributep_();
};
#ifdef __std__map_unsignedsint_std__basic_string_char_s_
#undef __std__map_unsignedsint_std__basic_string_char_s_
#endif
class __std__map_unsignedsint_std__basic_string_char_s_ {
  public:
  __std__map_unsignedsint_std__basic_string_char_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned int,std::basic_string<char> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::basic_string<char> > > > _M_t;
};
#ifdef __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#undef __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#endif
struct __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_();
  ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_
#undef __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_
#endif
struct __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_();
  ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_
#undef __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_
#endif
struct __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_ {
  public:
  __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_();
  ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_
#undef __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_
#endif
struct __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_ {
  public:
  __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_();
  ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_
#undef __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_
#endif
struct __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_ {
  public:
  __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_();
  ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_
#undef __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_
#endif
struct __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_ {
  public:
  __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_();
  ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_
#undef __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_
#endif
struct __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_ {
  public:
  __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_();
  ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::_Vector_impl _M_impl;
};
#ifdef __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_
#undef __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_
#endif
struct __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_ {
  public:
  __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_();
  ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::_Vector_impl _M_impl;
};
#ifdef __std__type_info
#undef __std__type_info
#endif
class __std__type_info {
  public:
  __std__type_info();
  virtual ~__std__type_info() throw();
  void* __name;
};
#ifdef __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_
#undef __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_
#endif
struct __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_ {
  public:
  __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp_();
};
#ifdef __std____are_same_coral__Attributepsconstp_coral__Attributepp_
#undef __std____are_same_coral__Attributepsconstp_coral__Attributepp_
#endif
struct __std____are_same_coral__Attributepsconstp_coral__Attributepp_ {
  public:
  __std____are_same_coral__Attributepsconstp_coral__Attributepp_();
};
#ifdef __std____are_same_coral__Attributepp_coral__Attributepp_
#undef __std____are_same_coral__Attributepp_coral__Attributepp_
#endif
struct __std____are_same_coral__Attributepp_coral__Attributepp_ {
  public:
  __std____are_same_coral__Attributepp_coral__Attributepp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_
#undef ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_
#undef ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp_();
};
#ifdef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_
#undef ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_
#endif
struct ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_ {
  public:
  ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep_();
};
#ifdef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_
#undef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_
#endif
class ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_ {
  public:
  ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s_();
};
#ifdef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_
#undef ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_
#endif
class ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_ {
  public:
  ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s_();
};
#ifdef ____gnu_cxx__new_allocator_cool__IRecordSelectionp_
#undef ____gnu_cxx__new_allocator_cool__IRecordSelectionp_
#endif
class ____gnu_cxx__new_allocator_cool__IRecordSelectionp_ {
  public:
  ____gnu_cxx__new_allocator_cool__IRecordSelectionp_();
};
#ifdef ____gnu_cxx__new_allocator_cool__IFieldp_
#undef ____gnu_cxx__new_allocator_cool__IFieldp_
#endif
class ____gnu_cxx__new_allocator_cool__IFieldp_ {
  public:
  ____gnu_cxx__new_allocator_cool__IFieldp_();
};
#ifdef ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_
#undef ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_
#endif
class ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_ {
  public:
  ____gnu_cxx__new_allocator_cool__IFieldSpecificationp_();
};
#ifdef ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_
#undef ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_
#endif
class ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_ {
  public:
  ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange_();
};
#ifdef ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_
#undef ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_
#endif
class ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_ {
  public:
  ____gnu_cxx__new_allocator_coral__AttributeSpecificationp_();
};
#ifdef ____gnu_cxx__new_allocator_coral__Attributep_
#undef ____gnu_cxx__new_allocator_coral__Attributep_
#endif
class ____gnu_cxx__new_allocator_coral__Attributep_ {
  public:
  ____gnu_cxx__new_allocator_coral__Attributep_();
};
#ifdef ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_
#undef ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_
#endif
struct ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_ {
  public:
  ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s_();
};
#ifdef ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_
#endif
struct ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s_();
};
#ifdef ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_
#endif
struct ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s_();
};
#ifdef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#undef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#endif
class ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_
#undef ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_
#endif
class ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_
#undef ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_
#endif
class ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_ {
  public:
  ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_
#endif
class ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_
#undef ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_
#endif
class ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_ {
  public:
  ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_();
  void* _M_current;
};
#ifdef __cool__IObjectIterator
#undef __cool__IObjectIterator
#endif
class __cool__IObjectIterator {
  public:
  __cool__IObjectIterator();
  virtual ~__cool__IObjectIterator() throw();
};
#ifdef __cool__FieldSelection
#undef __cool__FieldSelection
#endif
class __cool__FieldSelection : virtual public ::cool::IRecordSelection {
  public:
  __cool__FieldSelection();
  virtual ~__cool__FieldSelection() throw();
  ::cool::Record m_refValue;
  ::cool::FieldSelection::Relation m_relation;
};
#ifdef __cool__FieldSpecificationWrongStorageType
#undef __cool__FieldSpecificationWrongStorageType
#endif
class __cool__FieldSpecificationWrongStorageType : public ::cool::RecordException {
  public:
  __cool__FieldSpecificationWrongStorageType();
  virtual ~__cool__FieldSpecificationWrongStorageType() throw();
};
#ifdef __cool__TagNotFound
#undef __cool__TagNotFound
#endif
class __cool__TagNotFound : public ::cool::Exception {
  public:
  __cool__TagNotFound();
  virtual ~__cool__TagNotFound() throw();
};
#ifdef __cool__PayloadSpecificationTooManyFields
#undef __cool__PayloadSpecificationTooManyFields
#endif
class __cool__PayloadSpecificationTooManyFields : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationTooManyFields();
  virtual ~__cool__PayloadSpecificationTooManyFields() throw();
};
#ifdef __cool__ChannelExists
#undef __cool__ChannelExists
#endif
class __cool__ChannelExists : public ::cool::Exception {
  public:
  __cool__ChannelExists();
  virtual ~__cool__ChannelExists() throw();
};
#ifdef __cool__IField
#undef __cool__IField
#endif
class __cool__IField {
  public:
  __cool__IField();
  virtual ~__cool__IField() throw();
};
#ifdef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#undef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_
#endif
class __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_ {
  public:
  __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__InvalidChannelRange
#undef __cool__InvalidChannelRange
#endif
class __cool__InvalidChannelRange : public ::cool::Exception {
  public:
  __cool__InvalidChannelRange();
  virtual ~__cool__InvalidChannelRange() throw();
};
#ifdef __cool__StorageTypeStringTooLong
#undef __cool__StorageTypeStringTooLong
#endif
class __cool__StorageTypeStringTooLong : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeStringTooLong();
  virtual ~__cool__StorageTypeStringTooLong() throw();
};
#ifdef __cool__IFolderSet
#undef __cool__IFolderSet
#endif
class __cool__IFolderSet : virtual public ::cool::IHvsNode {
  public:
  __cool__IFolderSet();
  virtual ~__cool__IFolderSet() throw();
  virtual ::std::vector<std::basic_string<char> > listFolders(bool) throw();
  virtual const ::cool::IRecord& folderSetAttributes() const throw();
  virtual ::std::vector<std::basic_string<char> > listFolderSets(bool) throw();
};
#ifdef __cool__CompositeSelection
#undef __cool__CompositeSelection
#endif
class __cool__CompositeSelection : virtual public ::cool::IRecordSelection {
  public:
  __cool__CompositeSelection();
  virtual ~__cool__CompositeSelection() throw();
  ::cool::CompositeSelection::Connective m_conn;
  ::std::vector<cool::IRecordSelection*> m_selVec;
};
#ifdef __cool__StorageType
#undef __cool__StorageType
#endif
class __cool__StorageType {
  public:
  __cool__StorageType();
  virtual ~__cool__StorageType() throw();
  ::cool::StorageType::TypeId m_id;
};
#ifdef __cool__IRecordSpecification
#undef __cool__IRecordSpecification
#endif
class __cool__IRecordSpecification {
  public:
  __cool__IRecordSpecification();
  virtual ~__cool__IRecordSpecification() throw();
};
#ifdef __boost__shared_ptr_cool__IObjectIterator_
#undef __boost__shared_ptr_cool__IObjectIterator_
#endif
class __boost__shared_ptr_cool__IObjectIterator_ {
  public:
  __boost__shared_ptr_cool__IObjectIterator_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__RecordSpecificationUnknownField
#undef __cool__RecordSpecificationUnknownField
#endif
class __cool__RecordSpecificationUnknownField : public ::cool::RecordException {
  public:
  __cool__RecordSpecificationUnknownField();
  virtual ~__cool__RecordSpecificationUnknownField() throw();
};
#ifdef __cool__TagRelationNotFound
#undef __cool__TagRelationNotFound
#endif
class __cool__TagRelationNotFound : public ::cool::Exception {
  public:
  __cool__TagRelationNotFound();
  virtual ~__cool__TagRelationNotFound() throw();
};
#ifdef __cool__FolderSetNotFound
#undef __cool__FolderSetNotFound
#endif
class __cool__FolderSetNotFound : public ::cool::NodeNotFound {
  public:
  __cool__FolderSetNotFound();
  virtual ~__cool__FolderSetNotFound() throw();
  bool m_isFolder;
};
#ifdef __cool__FieldWrongCppType
#undef __cool__FieldWrongCppType
#endif
class __cool__FieldWrongCppType : public ::cool::RecordException {
  public:
  __cool__FieldWrongCppType();
  virtual ~__cool__FieldWrongCppType() throw();
};
#ifdef __boost__shared_ptr_cool__IFolderSet_
#undef __boost__shared_ptr_cool__IFolderSet_
#endif
class __boost__shared_ptr_cool__IFolderSet_ {
  public:
  __boost__shared_ptr_cool__IFolderSet_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__FieldSpecificationWrongName
#undef __cool__FieldSpecificationWrongName
#endif
class __cool__FieldSpecificationWrongName : public ::cool::RecordException {
  public:
  __cool__FieldSpecificationWrongName();
  virtual ~__cool__FieldSpecificationWrongName() throw();
};
#ifdef __cool__RecordSpecification
#undef __cool__RecordSpecification
#endif
class __cool__RecordSpecification : public ::cool::IRecordSpecification {
  public:
  __cool__RecordSpecification();
  virtual ~__cool__RecordSpecification() throw();
  ::std::vector<cool::IFieldSpecification*> m_fSpecs;
};
#ifdef __cool__ObjectNotFound
#undef __cool__ObjectNotFound
#endif
class __cool__ObjectNotFound : public ::cool::Exception {
  public:
  __cool__ObjectNotFound();
  virtual ~__cool__ObjectNotFound() throw();
};
#ifdef __cool__ChannelNotFound
#undef __cool__ChannelNotFound
#endif
class __cool__ChannelNotFound : public ::cool::Exception {
  public:
  __cool__ChannelNotFound();
  virtual ~__cool__ChannelNotFound() throw();
};
#ifdef __cool__StorageTypeException
#undef __cool__StorageTypeException
#endif
class __cool__StorageTypeException : public ::cool::RecordException {
  public:
  __cool__StorageTypeException();
  virtual ~__cool__StorageTypeException() throw();
};
#ifdef __cool__StorageTypeWrongCppType
#undef __cool__StorageTypeWrongCppType
#endif
class __cool__StorageTypeWrongCppType : public ::cool::StorageTypeException {
  public:
  __cool__StorageTypeWrongCppType();
  virtual ~__cool__StorageTypeWrongCppType() throw();
};
#ifdef __cool__Record
#undef __cool__Record
#endif
class __cool__Record : public ::cool::IRecord {
  public:
  __cool__Record();
  virtual ~__cool__Record() throw();
  ::cool::RecordSpecification m_spec;
  ::coral::AttributeList m_attrList;
  ::std::vector<cool::IField*> m_fields;
};
#ifdef __cool__ValidityKeyException
#undef __cool__ValidityKeyException
#endif
class __cool__ValidityKeyException : public ::cool::Exception {
  public:
  __cool__ValidityKeyException();
  virtual ~__cool__ValidityKeyException() throw();
};
#ifdef __cool__FieldIsNull
#undef __cool__FieldIsNull
#endif
class __cool__FieldIsNull : public ::cool::RecordException {
  public:
  __cool__FieldIsNull();
  virtual ~__cool__FieldIsNull() throw();
};
#ifdef __cool__InvalidPayloadSpecification
#undef __cool__InvalidPayloadSpecification
#endif
class __cool__InvalidPayloadSpecification : public ::cool::InvalidFolderSpecification {
  public:
  __cool__InvalidPayloadSpecification();
  virtual ~__cool__InvalidPayloadSpecification() throw();
};
#ifdef __cool__IFieldSpecification
#undef __cool__IFieldSpecification
#endif
class __cool__IFieldSpecification {
  public:
  __cool__IFieldSpecification();
  virtual ~__cool__IFieldSpecification() throw();
};
#ifdef __cool__FolderIsSingleVersion
#undef __cool__FolderIsSingleVersion
#endif
class __cool__FolderIsSingleVersion : public ::cool::NodeIsSingleVersion {
  public:
  __cool__FolderIsSingleVersion();
  virtual ~__cool__FolderIsSingleVersion() throw();
};
#ifdef __cool__ITime
#undef __cool__ITime
#endif
class __cool__ITime {
  public:
  __cool__ITime();
  virtual ~__cool__ITime() throw();
};
#ifdef __cool__ConstRecordAdapter
#undef __cool__ConstRecordAdapter
#endif
class __cool__ConstRecordAdapter : public ::cool::IRecord {
  public:
  __cool__ConstRecordAdapter();
  virtual ~__cool__ConstRecordAdapter() throw();
  ::cool::RecordSpecification m_spec;
  int& m_attrList;
  ::std::vector<cool::IField*> m_fields;
  ::coral::AttributeList m_publicAttrList;
};
#ifdef __cool__InvalidTagRelation
#undef __cool__InvalidTagRelation
#endif
class __cool__InvalidTagRelation : public ::cool::Exception {
  public:
  __cool__InvalidTagRelation();
  virtual ~__cool__InvalidTagRelation() throw();
};
#ifdef __cool__DatabaseNotOpen
#undef __cool__DatabaseNotOpen
#endif
class __cool__DatabaseNotOpen : public ::cool::Exception {
  public:
  __cool__DatabaseNotOpen();
  virtual ~__cool__DatabaseNotOpen() throw();
};
#ifdef __cool__DatabaseDoesNotExist
#undef __cool__DatabaseDoesNotExist
#endif
class __cool__DatabaseDoesNotExist : public ::cool::Exception {
  public:
  __cool__DatabaseDoesNotExist();
  virtual ~__cool__DatabaseDoesNotExist() throw();
};
#ifdef __cool__IFolder
#undef __cool__IFolder
#endif
class __cool__IFolder : virtual public ::cool::IHvsNode {
  public:
  __cool__IFolder();
  virtual ~__cool__IFolder() throw();
  virtual const ::cool::Time insertionTimeOfLastObjectInTag(std::string const&) const throw();
  virtual void storeObject(unsigned long long const&, unsigned long long const&, cool::IRecord const&, unsigned int const&, std::string const&, bool) throw();
  virtual ::cool::IObjectIteratorPtr findObjects(unsigned long long const&, cool::ChannelSelection const&, std::string const&) const throw();
  virtual void setupStorageBuffer(bool) throw();
  virtual bool existsUserTag(std::string const&) const throw();
  virtual const ::cool::IRecordSpecification& payloadSpecification() const throw();
  virtual ::cool::ChannelId channelId(std::string const&) const throw();
  virtual void storeObject(unsigned long long const&, unsigned long long const&, coral::AttributeList const&, unsigned int const&, std::string const&, bool) throw();
  virtual void tagHeadAsOfDate(cool::ITime const&, std::string const&, std::string const&) const throw();
  virtual void createChannel(unsigned int const&, std::string const&, std::string const&) throw();
  virtual const ::std::map<unsigned int,std::basic_string<char> > listChannelsWithNames() const throw();
  virtual void deleteTag(std::string const&) throw();
  virtual const ::std::string channelName(unsigned int const&) const throw();
  virtual void renamePayload(std::string const&, std::string const&) throw();
  virtual void flushStorageBuffer() throw();
  virtual const ::cool::IRecord& folderAttributes() const throw();
  virtual void setChannelDescription(unsigned int const&, std::string const&) throw();
  virtual void cloneTagAsUserTag(std::string const&, std::string const&, std::string const&, bool) throw();
  virtual ::cool::IObjectPtr findObject(unsigned long long const&, unsigned int const&, std::string const&) const throw();
  virtual bool existsChannel(std::string const&) const throw();
  virtual void setPrefetchAll(bool) throw();
  virtual const ::cool::IFolderSpecification& folderSpecification() const throw();
  virtual const ::std::string channelDescription(unsigned int const&) const throw();
  virtual bool dropChannel(unsigned int const&) throw();
  virtual const ::std::vector<unsigned int> listChannels() const throw();
  virtual void tagCurrentHead(std::string const&, std::string const&) const throw();
  virtual ::cool::IObjectIteratorPtr browseObjects(unsigned long long const&, unsigned long long const&, cool::ChannelSelection const&, std::string const&, cool::IRecordSelection const*) const throw();
  virtual ::cool::FolderVersioning::Mode versioningMode() const throw();
  virtual void setChannelName(unsigned int const&, std::string const&) throw();
  virtual void storeObject(unsigned long long const&, unsigned long long const&, std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > const&, unsigned int const&, std::string const&, bool) throw();
  virtual void extendPayloadSpecification(cool::IRecord const&) throw();
  virtual bool existsChannel(unsigned int const&) const throw();
  virtual int truncateObjectValidity(unsigned long long const&, cool::ChannelSelection const&) throw();
  virtual unsigned int countObjects(unsigned long long const&, unsigned long long const&, cool::ChannelSelection const&, std::string const&, cool::IRecordSelection const*) const throw();
};
#ifdef __boost__shared_ptr_cool__IFolder_
#undef __boost__shared_ptr_cool__IFolder_
#endif
class __boost__shared_ptr_cool__IFolder_ {
  public:
  __boost__shared_ptr_cool__IFolder_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__ValidityIntervalBackwards
#undef __cool__ValidityIntervalBackwards
#endif
class __cool__ValidityIntervalBackwards : public ::cool::ValidityKeyException {
  public:
  __cool__ValidityIntervalBackwards();
  virtual ~__cool__ValidityIntervalBackwards() throw();
};
#ifdef __cool__Time
#undef __cool__Time
#endif
class __cool__Time : public ::cool::ITime {
  public:
  __cool__Time();
  virtual ~__cool__Time() throw();
  int m_year;
  int m_month;
  int m_day;
  int m_hour;
  int m_minute;
  int m_second;
  long m_nanosecond;
};
#ifdef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_
#undef __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_
#endif
class __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_ {
  public:
  __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__IRecordSelection
#undef __cool__IRecordSelection
#endif
class __cool__IRecordSelection {
  public:
  __cool__IRecordSelection();
  virtual ~__cool__IRecordSelection() throw();
};
#ifdef __cool__IDatabase
#undef __cool__IDatabase
#endif
class __cool__IDatabase {
  public:
  __cool__IDatabase();
  virtual ~__cool__IDatabase() throw();
};
#ifdef __boost__shared_ptr_cool__IDatabase_
#undef __boost__shared_ptr_cool__IDatabase_
#endif
class __boost__shared_ptr_cool__IDatabase_ {
  public:
  __boost__shared_ptr_cool__IDatabase_();
  void* px;
  ::boost::detail::shared_count pn;
};
#ifdef __cool__IHvsNode
#undef __cool__IHvsNode
#endif
class __cool__IHvsNode : virtual public ::cool::IHvsNodeRecord {
  public:
  __cool__IHvsNode();
  virtual ~__cool__IHvsNode() throw();
};
#ifdef __cool__RecordSpecificationCannotExtend
#undef __cool__RecordSpecificationCannotExtend
#endif
class __cool__RecordSpecificationCannotExtend : public ::cool::RecordException {
  public:
  __cool__RecordSpecificationCannotExtend();
  virtual ~__cool__RecordSpecificationCannotExtend() throw();
};
#ifdef __coral__Blob
#undef __coral__Blob
#endif
class __coral__Blob {
  public:
  __coral__Blob();
  long m_size;
  void* m_data;
};
#ifdef __cool__IApplication
#undef __cool__IApplication
#endif
class __cool__IApplication {
  public:
  __cool__IApplication();
  virtual ~__cool__IApplication() throw();
};
#ifdef __cool__IHvsNodeRecord
#undef __cool__IHvsNodeRecord
#endif
class __cool__IHvsNodeRecord {
  public:
  __cool__IHvsNodeRecord();
  virtual ~__cool__IHvsNodeRecord() throw();
};
#ifdef __cool__TagExists
#undef __cool__TagExists
#endif
class __cool__TagExists : public ::cool::Exception {
  public:
  __cool__TagExists();
  virtual ~__cool__TagExists() throw();
};
#ifdef __cool__IDatabaseSvc
#undef __cool__IDatabaseSvc
#endif
class __cool__IDatabaseSvc {
  public:
  __cool__IDatabaseSvc();
  virtual ~__cool__IDatabaseSvc() throw();
};
#ifdef __cool__FieldSpecification
#undef __cool__FieldSpecification
#endif
class __cool__FieldSpecification : public ::cool::IFieldSpecification {
  public:
  __cool__FieldSpecification();
  virtual ~__cool__FieldSpecification() throw();
  ::std::string m_name;
  int& m_type;
};
#ifdef __cool__RecordException
#undef __cool__RecordException
#endif
class __cool__RecordException : public ::cool::Exception {
  public:
  __cool__RecordException();
  virtual ~__cool__RecordException() throw();
};
#ifdef __cool__ReservedHeadTag
#undef __cool__ReservedHeadTag
#endif
class __cool__ReservedHeadTag : public ::cool::Exception {
  public:
  __cool__ReservedHeadTag();
  virtual ~__cool__ReservedHeadTag() throw();
};
#ifdef __cool__ValidityKeyOutOfBoundaries
#undef __cool__ValidityKeyOutOfBoundaries
#endif
class __cool__ValidityKeyOutOfBoundaries : public ::cool::ValidityKeyException {
  public:
  __cool__ValidityKeyOutOfBoundaries();
  virtual ~__cool__ValidityKeyOutOfBoundaries() throw();
};
#ifdef __cool__FieldSpecificationInvalidName
#undef __cool__FieldSpecificationInvalidName
#endif
class __cool__FieldSpecificationInvalidName : public ::cool::RecordException {
  public:
  __cool__FieldSpecificationInvalidName();
  virtual ~__cool__FieldSpecificationInvalidName() throw();
};
#ifdef __cool__StorageTypeDoubleIsNaN
#undef __cool__StorageTypeDoubleIsNaN
#endif
class __cool__StorageTypeDoubleIsNaN : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeDoubleIsNaN();
  virtual ~__cool__StorageTypeDoubleIsNaN() throw();
};
#ifdef __cool__TagRelationExists
#undef __cool__TagRelationExists
#endif
class __cool__TagRelationExists : public ::cool::Exception {
  public:
  __cool__TagRelationExists();
  virtual ~__cool__TagRelationExists() throw();
};
#ifdef __cool__InvalidFolderSpecification
#undef __cool__InvalidFolderSpecification
#endif
class __cool__InvalidFolderSpecification : public ::cool::Exception {
  public:
  __cool__InvalidFolderSpecification();
  virtual ~__cool__InvalidFolderSpecification() throw();
};
#ifdef __cool__StorageTypeStringContainsNullChar
#undef __cool__StorageTypeStringContainsNullChar
#endif
class __cool__StorageTypeStringContainsNullChar : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeStringContainsNullChar();
  virtual ~__cool__StorageTypeStringContainsNullChar() throw();
};
#ifdef __cool__StorageTypeInvalidUInt63
#undef __cool__StorageTypeInvalidUInt63
#endif
class __cool__StorageTypeInvalidUInt63 : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeInvalidUInt63();
  virtual ~__cool__StorageTypeInvalidUInt63() throw();
};
#ifdef __cool__DatabaseSvcFactory
#undef __cool__DatabaseSvcFactory
#endif
class __cool__DatabaseSvcFactory {
  public:
  __cool__DatabaseSvcFactory();
};
#ifdef __cool__InvalidChannelName
#undef __cool__InvalidChannelName
#endif
class __cool__InvalidChannelName : public ::cool::Exception {
  public:
  __cool__InvalidChannelName();
  virtual ~__cool__InvalidChannelName() throw();
};
#ifdef __cool__StorageTypeBlobTooLong
#undef __cool__StorageTypeBlobTooLong
#endif
class __cool__StorageTypeBlobTooLong : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeBlobTooLong();
  virtual ~__cool__StorageTypeBlobTooLong() throw();
};
#ifdef __cool__PayloadSpecificationInvalidFieldName
#undef __cool__PayloadSpecificationInvalidFieldName
#endif
class __cool__PayloadSpecificationInvalidFieldName : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationInvalidFieldName();
  virtual ~__cool__PayloadSpecificationInvalidFieldName() throw();
};
#ifdef __cool__DatabaseOpenInReadOnlyMode
#undef __cool__DatabaseOpenInReadOnlyMode
#endif
class __cool__DatabaseOpenInReadOnlyMode : public ::cool::Exception {
  public:
  __cool__DatabaseOpenInReadOnlyMode();
  virtual ~__cool__DatabaseOpenInReadOnlyMode() throw();
};
#ifdef __cool__StorageTypeFloatIsNaN
#undef __cool__StorageTypeFloatIsNaN
#endif
class __cool__StorageTypeFloatIsNaN : public ::cool::StorageTypeInvalidValue {
  public:
  __cool__StorageTypeFloatIsNaN();
  virtual ~__cool__StorageTypeFloatIsNaN() throw();
};
#ifdef __cool__NodeNotFound
#undef __cool__NodeNotFound
#endif
class __cool__NodeNotFound : public ::cool::Exception {
  public:
  __cool__NodeNotFound();
  virtual ~__cool__NodeNotFound() throw();
};
#ifdef __cool__Application
#undef __cool__Application
#endif
class __cool__Application : public ::cool::IApplication {
  public:
  __cool__Application();
  virtual ~__cool__Application() throw();
  void* m_application;
};
#ifdef __cool__NodeIsSingleVersion
#undef __cool__NodeIsSingleVersion
#endif
class __cool__NodeIsSingleVersion : public ::cool::Exception {
  public:
  __cool__NodeIsSingleVersion();
  virtual ~__cool__NodeIsSingleVersion() throw();
};
#ifdef __cool__NodeExists
#undef __cool__NodeExists
#endif
class __cool__NodeExists : public ::cool::Exception {
  public:
  __cool__NodeExists();
  virtual ~__cool__NodeExists() throw();
};
#ifdef __cool__StorageTypeInvalidValue
#undef __cool__StorageTypeInvalidValue
#endif
class __cool__StorageTypeInvalidValue : public ::cool::StorageTypeException {
  public:
  __cool__StorageTypeInvalidValue();
  virtual ~__cool__StorageTypeInvalidValue() throw();
};
#ifdef __cool__TagIsLocked
#undef __cool__TagIsLocked
#endif
class __cool__TagIsLocked : public ::cool::Exception {
  public:
  __cool__TagIsLocked();
  virtual ~__cool__TagIsLocked() throw();
};
#ifdef __cool__IRecordIterator
#undef __cool__IRecordIterator
#endif
class __cool__IRecordIterator {
  public:
  __cool__IRecordIterator();
  virtual ~__cool__IRecordIterator() throw();
};
#ifdef __cool__NodeRelationNotFound
#undef __cool__NodeRelationNotFound
#endif
class __cool__NodeRelationNotFound : public ::cool::Exception {
  public:
  __cool__NodeRelationNotFound();
  virtual ~__cool__NodeRelationNotFound() throw();
  bool m_parentOnly;
};
#ifdef __cool__FolderNotFound
#undef __cool__FolderNotFound
#endif
class __cool__FolderNotFound : public ::cool::NodeNotFound {
  public:
  __cool__FolderNotFound();
  virtual ~__cool__FolderNotFound() throw();
  bool m_isFolderSet;
};
#ifdef __cool__RecordSpecificationWrongSize
#undef __cool__RecordSpecificationWrongSize
#endif
class __cool__RecordSpecificationWrongSize : public ::cool::RecordException {
  public:
  __cool__RecordSpecificationWrongSize();
  virtual ~__cool__RecordSpecificationWrongSize() throw();
};
#ifdef __cool__IFolderSpecification
#undef __cool__IFolderSpecification
#endif
class __cool__IFolderSpecification {
  public:
  __cool__IFolderSpecification();
  virtual ~__cool__IFolderSpecification() throw();
};
#ifdef __cool__Exception
#undef __cool__Exception
#endif
class __cool__Exception : public ::std::exception {
  public:
  __cool__Exception();
  virtual ~__cool__Exception() throw();
  ::std::string m_message;
  ::std::string m_domain;
};
#ifdef __cool__PayloadSpecificationTooManyBlobFields
#undef __cool__PayloadSpecificationTooManyBlobFields
#endif
class __cool__PayloadSpecificationTooManyBlobFields : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationTooManyBlobFields();
  virtual ~__cool__PayloadSpecificationTooManyBlobFields() throw();
};
#ifdef __cool__FolderSpecification
#undef __cool__FolderSpecification
#endif
class __cool__FolderSpecification : public ::cool::IFolderSpecification {
  public:
  __cool__FolderSpecification();
  virtual ~__cool__FolderSpecification() throw();
  ::cool::FolderVersioning::Mode m_versioningMode;
  ::cool::RecordSpecification m_payloadSpec;
  ::cool::PayloadMode::Mode m_payloadMode;
};
#ifdef __cool__PayloadSpecificationTooManyString255Fields
#undef __cool__PayloadSpecificationTooManyString255Fields
#endif
class __cool__PayloadSpecificationTooManyString255Fields : public ::cool::InvalidPayloadSpecification {
  public:
  __cool__PayloadSpecificationTooManyString255Fields();
  virtual ~__cool__PayloadSpecificationTooManyString255Fields() throw();
};
#ifdef __coral__AttributeListSpecification
#undef __coral__AttributeListSpecification
#endif
class __coral__AttributeListSpecification {
  public:
  __coral__AttributeListSpecification();
  int m_counter;
  ::std::vector<coral::AttributeSpecification*> m_attributeSpecifications;
  ::std::map<std::basic_string<char>,int> m_mapOfNameToIndex;
};
#ifdef __coral__AttributeSpecification
#undef __coral__AttributeSpecification
#endif
class __coral__AttributeSpecification {
  public:
  __coral__AttributeSpecification();
  ::std::string m_name;
  void* m_type;
};
#ifdef __coral__IConnectionServiceConfiguration
#undef __coral__IConnectionServiceConfiguration
#endif
class __coral__IConnectionServiceConfiguration {
  public:
  __coral__IConnectionServiceConfiguration();
  virtual ~__coral__IConnectionServiceConfiguration() throw();
};
#ifdef __coral__Attribute
#undef __coral__Attribute
#endif
class __coral__Attribute {
  public:
  __coral__Attribute();
  void* m_specification;
  void* m_data;
};
#ifdef __coral__AttributeList
#undef __coral__AttributeList
#endif
class __coral__AttributeList {
  public:
  __coral__AttributeList();
  void* m_specification;
  bool m_ownSpecification;
  ::std::vector<coral::Attribute*> m_data;
};
#ifdef __coral__IWebCacheInfo
#undef __coral__IWebCacheInfo
#endif
class __coral__IWebCacheInfo {
  public:
  __coral__IWebCacheInfo();
  virtual ~__coral__IWebCacheInfo() throw();
};
#ifdef __coral__IWebCacheControl
#undef __coral__IWebCacheControl
#endif
class __coral__IWebCacheControl {
  public:
  __coral__IWebCacheControl();
  virtual ~__coral__IWebCacheControl() throw();
};
#ifdef __coral__AttributeListException
#undef __coral__AttributeListException
#endif
class __coral__AttributeListException : public ::coral::Exception {
  public:
  __coral__AttributeListException();
  virtual ~__coral__AttributeListException() throw();
};
#ifdef __coral__AttributeException
#undef __coral__AttributeException
#endif
class __coral__AttributeException : public ::coral::Exception {
  public:
  __coral__AttributeException();
  virtual ~__coral__AttributeException() throw();
};
#ifdef __coral__IConnectionService
#undef __coral__IConnectionService
#endif
class __coral__IConnectionService {
  public:
  __coral__IConnectionService();
  virtual ~__coral__IConnectionService() throw();
};
#ifdef __coral__AttributeListSpecification__const_iterator
#undef __coral__AttributeListSpecification__const_iterator
#endif
class __coral__AttributeListSpecification__const_iterator {
  public:
  __coral__AttributeListSpecification__const_iterator();
  ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > m_iterator;
};
#ifdef __coral__AttributeList__iterator_base
#undef __coral__AttributeList__iterator_base
#endif
class __coral__AttributeList__iterator_base {
  public:
  __coral__AttributeList__iterator_base();
  virtual ~__coral__AttributeList__iterator_base() throw();
  ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > m_iterator;
};
#ifdef __coral__AttributeList__iterator
#undef __coral__AttributeList__iterator
#endif
class __coral__AttributeList__iterator : public ::coral::AttributeList::iterator_base {
  public:
  __coral__AttributeList__iterator();
  virtual ~__coral__AttributeList__iterator() throw();
};
#ifdef __coral__AttributeList__const_iterator
#undef __coral__AttributeList__const_iterator
#endif
class __coral__AttributeList__const_iterator : public ::coral::AttributeList::iterator_base {
  public:
  __coral__AttributeList__const_iterator();
  virtual ~__coral__AttributeList__const_iterator() throw();
};
#ifdef __boost__detail__shared_count
#undef __boost__detail__shared_count
#endif
class __boost__detail__shared_count {
  public:
  __boost__detail__shared_count();
  void* pi_;
};
#ifdef __cool__PyCool__Helpers__Typedefs
#undef __cool__PyCool__Helpers__Typedefs
#endif
struct __cool__PyCool__Helpers__Typedefs {
  public:
  __cool__PyCool__Helpers__Typedefs();
};
#ifdef __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#undef __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#endif
struct __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_ {
  public:
  __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_();
  void* _M_node;
};
#ifdef __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#undef __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_
#endif
struct __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_ {
  public:
  __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_();
  void* _M_node;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class IRecord -------------------------------
static void destructor_8064(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecord*)o)->::cool::IRecord::~IRecord();
}
static  void method_8065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->specification)();
  else   (((const ::cool::IRecord*)o)->specification)();
}

static  void method_8066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecord*)o)->size)());
  else   (((const ::cool::IRecord*)o)->size)();
}

static  void method_8067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecord*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IRecord*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void operator_8068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::IRecord*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::IRecord*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_8070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecord*)o)->operator==)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::IRecord*)o)->operator==)(*(const ::cool::IRecord*)arg[0]);
}

static  void operator_8071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecord*)o)->operator!=)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::IRecord*)o)->operator!=)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IRecord*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void method_8073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecord*)o)->attributeList)();
  else   (((const ::cool::IRecord*)o)->attributeList)();
}

//------Dictionary for class IRecord -------------------------------
void __cool__IRecord_db_datamem(Reflex::Class*);
void __cool__IRecord_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecord_datamem_bld(&__cool__IRecord_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecord_funcmem_bld(&__cool__IRecord_db_funcmem);
void __cool__IRecord_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecord"), typeid(::cool::IRecord), sizeof(::cool::IRecord), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecord"), destructor_8064, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecord_funcmem_bld);
}

//------Delayed data member builder for class IRecord -------------------
void __cool__IRecord_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecord -------------------
void __cool__IRecord_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10133), Reflex::Literal("specification"), method_8065, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("size"), method_8066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367, type_4135), Reflex::Literal("index"), method_8067, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_4135), Reflex::Literal("operator[]"), operator_8068, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_2367), Reflex::Literal("operator[]"), operator_8069, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8529), Reflex::Literal("operator=="), operator_8070, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8529), Reflex::Literal("operator!="), operator_8071, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525), Reflex::Literal("print"), method_8072, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913), Reflex::Literal("attributeList"), method_8073, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------------------
static void destructor_3123(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)o)->::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::~iterator_traits();
}
static  void operator_3124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
  else   (((::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
}

static void constructor_3125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>*)arg[0]);
}

static void constructor_3126( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>();
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>();
}

static void method_newdel_1389( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IRecord>*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------------------
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_datamem(Reflex::Class*);
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__datamem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__funcmem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_funcmem);
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>"), typeid(::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>), sizeof(::std::iterator_traits<boost::shared_ptr<cool::IRecord>*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1533, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::iterator_category"))
  .AddTypedef(type_2399, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::difference_type"))
  .AddTypedef(type_3119, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::pointer"))
  .AddTypedef(type_3121, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IRecord>*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9282, type_9283), Reflex::Literal("operator="), operator_3124, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9283), Reflex::Literal("iterator_traits"), constructor_3125, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1389, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<boost::shared_ptr<cool::IRecord>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IObject -------------------------------
static void destructor_8208(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IObject*)o)->::cool::IObject::~IObject();
}
static  void method_8209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IObject*)o)->clone)());
  else   (((const ::cool::IObject*)o)->clone)();
}

static  void method_8210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->channelId)();
  else   (((const ::cool::IObject*)o)->channelId)();
}

static  void method_8211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->since)();
  else   (((const ::cool::IObject*)o)->since)();
}

static  void method_8212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->until)();
  else   (((const ::cool::IObject*)o)->until)();
}

static  void method_8213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->payload)();
  else   (((const ::cool::IObject*)o)->payload)();
}

static  void method_8214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->payloadIterator)();
  else   (((const ::cool::IObject*)o)->payloadIterator)();
}

static  void method_8215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IObject*)o)->payloadValue)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IObject*)o)->payloadValue)(*(const ::std::string*)arg[0]);
}

static  void method_8216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IObject*)o)->isStored)());
  else   (((const ::cool::IObject*)o)->isStored)();
}

static  void method_8217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->objectId)());
  else   (((const ::cool::IObject*)o)->objectId)();
}

static  void method_8218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->payloadId)());
  else   (((const ::cool::IObject*)o)->payloadId)();
}

static  void method_8219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->payloadSetId)());
  else   (((const ::cool::IObject*)o)->payloadSetId)();
}

static  void method_8220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IObject*)o)->payloadSize)());
  else   (((const ::cool::IObject*)o)->payloadSize)();
}

static  void method_8221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->insertionTime)();
  else   (((const ::cool::IObject*)o)->insertionTime)();
}

static  void method_8222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IObject*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IObject*)o)->print)(*(::std::ostream*)arg[0]);
}

//------Dictionary for class IObject -------------------------------
void __cool__IObject_db_datamem(Reflex::Class*);
void __cool__IObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IObject_datamem_bld(&__cool__IObject_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IObject_funcmem_bld(&__cool__IObject_db_funcmem);
void __cool__IObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IObject"), typeid(::cool::IObject), sizeof(::cool::IObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IObject"), destructor_8208, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IObject_funcmem_bld);
}

//------Delayed data member builder for class IObject -------------------
void __cool__IObject_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IObject -------------------
void __cool__IObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10185), Reflex::Literal("clone"), method_8209, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10145), Reflex::Literal("channelId"), method_8210, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10223), Reflex::Literal("since"), method_8211, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10223), Reflex::Literal("until"), method_8212, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8529), Reflex::Literal("payload"), method_8213, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10224), Reflex::Literal("payloadIterator"), method_8214, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_4135), Reflex::Literal("payloadValue"), method_8215, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isStored"), method_8216, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("objectId"), method_8217, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("payloadId"), method_8218, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("payloadSetId"), method_8219, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("payloadSize"), method_8220, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8526), Reflex::Literal("insertionTime"), method_8221, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525), Reflex::Literal("print"), method_8222, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------------------
static void destructor_3134(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)o)->::std::iterator_traits<boost::shared_ptr<cool::IObject>*>::~iterator_traits();
}
static  void operator_3135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
  else   (((::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)o)->operator=)(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
}

static void constructor_3136( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>(*(const ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>*)arg[0]);
}

static void constructor_3137( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>();
  else ::new(mem) ::std::iterator_traits<boost::shared_ptr<cool::IObject>*>();
}

static void method_newdel_1390( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<boost::shared_ptr<cool::IObject>*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------------------
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_datamem(Reflex::Class*);
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IObject_p__datamem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_boost__shared_ptr_cool__IObject_p__funcmem_bld(&__std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_funcmem);
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>"), typeid(::std::iterator_traits<boost::shared_ptr<cool::IObject>*>), sizeof(::std::iterator_traits<boost::shared_ptr<cool::IObject>*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1533, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::iterator_category"))
  .AddTypedef(type_2290, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::difference_type"))
  .AddTypedef(type_3130, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::pointer"))
  .AddTypedef(type_3132, Reflex::Literal("std::iterator_traits<boost::shared_ptr<cool::IObject>*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9284, type_9285), Reflex::Literal("operator="), operator_3135, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9285), Reflex::Literal("iterator_traits"), constructor_3136, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1390, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<boost::shared_ptr<cool::IObject>*> -------------------
void __std__iterator_traits_boost__shared_ptr_cool__IObject_p__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class iterator_traits<coral::AttributeSpecification* const*> -------------------------------
static void destructor_3156(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<coral::AttributeSpecification* const*>*)o)->::std::iterator_traits<coral::AttributeSpecification* const*>::~iterator_traits();
}
static  void operator_3157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<coral::AttributeSpecification* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
  else   (((::std::iterator_traits<coral::AttributeSpecification* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
}

static void constructor_3158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>(*(const ::std::iterator_traits<coral::AttributeSpecification* const*>*)arg[0]);
}

static void constructor_3159( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>();
  else ::new(mem) ::std::iterator_traits<coral::AttributeSpecification* const*>();
}

static void method_newdel_1392( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::AttributeSpecification* const*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<coral::AttributeSpecification* const*> -------------------------------
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_datamem(Reflex::Class*);
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__AttributeSpecificationpsconstp__datamem_bld(&__std__iterator_traits_coral__AttributeSpecificationpsconstp__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__AttributeSpecificationpsconstp__funcmem_bld(&__std__iterator_traits_coral__AttributeSpecificationpsconstp__db_funcmem);
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>"), typeid(::std::iterator_traits<coral::AttributeSpecification* const*>), sizeof(::std::iterator_traits<coral::AttributeSpecification* const*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1533, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::iterator_category"))
  .AddTypedef(type_3149, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::difference_type"))
  .AddTypedef(type_3152, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::pointer"))
  .AddTypedef(type_3154, Reflex::Literal("std::iterator_traits<coral::AttributeSpecification* const*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9289, type_9290), Reflex::Literal("operator="), operator_3157, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9290), Reflex::Literal("iterator_traits"), constructor_3158, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1392, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<coral::AttributeSpecification* const*> -------------------
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<coral::AttributeSpecification* const*> -------------------
void __std__iterator_traits_coral__AttributeSpecificationpsconstp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class iterator_traits<coral::Attribute**> -------------------------------
static void destructor_3168(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<coral::Attribute**>*)o)->::std::iterator_traits<coral::Attribute**>::~iterator_traits();
}
static  void operator_3169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<coral::Attribute**>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
  else   (((::std::iterator_traits<coral::Attribute**>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
}

static void constructor_3170( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute**>(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<coral::Attribute**>(*(const ::std::iterator_traits<coral::Attribute**>*)arg[0]);
}

static void constructor_3171( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute**>();
  else ::new(mem) ::std::iterator_traits<coral::Attribute**>();
}

static void method_newdel_1393( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<coral::Attribute**> -------------------------------
void __std__iterator_traits_coral__Attributepp__db_datamem(Reflex::Class*);
void __std__iterator_traits_coral__Attributepp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepp__datamem_bld(&__std__iterator_traits_coral__Attributepp__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepp__funcmem_bld(&__std__iterator_traits_coral__Attributepp__db_funcmem);
void __std__iterator_traits_coral__Attributepp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute**>"), typeid(::std::iterator_traits<coral::Attribute**>), sizeof(::std::iterator_traits<coral::Attribute**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1533, Reflex::Literal("std::iterator_traits<coral::Attribute**>::iterator_category"))
  .AddTypedef(type_3161, Reflex::Literal("std::iterator_traits<coral::Attribute**>::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::iterator_traits<coral::Attribute**>::difference_type"))
  .AddTypedef(type_3164, Reflex::Literal("std::iterator_traits<coral::Attribute**>::pointer"))
  .AddTypedef(type_3166, Reflex::Literal("std::iterator_traits<coral::Attribute**>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9291, type_9292), Reflex::Literal("operator="), operator_3169, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9292), Reflex::Literal("iterator_traits"), constructor_3170, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1393, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<coral::Attribute**> -------------------
void __std__iterator_traits_coral__Attributepp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<coral::Attribute**> -------------------
void __std__iterator_traits_coral__Attributepp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class iterator_traits<coral::Attribute* const*> -------------------------------
static void destructor_3179(void*, void * o, const std::vector<void*>&, void *) {
((::std::iterator_traits<coral::Attribute* const*>*)o)->::std::iterator_traits<coral::Attribute* const*>::~iterator_traits();
}
static  void operator_3180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator_traits<coral::Attribute* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
  else   (((::std::iterator_traits<coral::Attribute* const*>*)o)->operator=)(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
}

static void constructor_3181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute* const*>(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
  else ::new(mem) ::std::iterator_traits<coral::Attribute* const*>(*(const ::std::iterator_traits<coral::Attribute* const*>*)arg[0]);
}

static void constructor_3182( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator_traits<coral::Attribute* const*>();
  else ::new(mem) ::std::iterator_traits<coral::Attribute* const*>();
}

static void method_newdel_1394( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator_traits<coral::Attribute* const*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator_traits<coral::Attribute* const*> -------------------------------
void __std__iterator_traits_coral__Attributepsconstp__db_datamem(Reflex::Class*);
void __std__iterator_traits_coral__Attributepsconstp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepsconstp__datamem_bld(&__std__iterator_traits_coral__Attributepsconstp__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_traits_coral__Attributepsconstp__funcmem_bld(&__std__iterator_traits_coral__Attributepsconstp__db_funcmem);
void __std__iterator_traits_coral__Attributepsconstp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator_traits<coral::Attribute* const*>"), typeid(::std::iterator_traits<coral::Attribute* const*>), sizeof(::std::iterator_traits<coral::Attribute* const*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1533, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::iterator_category"))
  .AddTypedef(type_3161, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::difference_type"))
  .AddTypedef(type_3175, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::pointer"))
  .AddTypedef(type_3177, Reflex::Literal("std::iterator_traits<coral::Attribute* const*>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator_traits"), destructor_3179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9294, type_9295), Reflex::Literal("operator="), operator_3180, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9295), Reflex::Literal("iterator_traits"), constructor_3181, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator_traits"), constructor_3182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1394, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator_traits<coral::Attribute* const*> -------------------
void __std__iterator_traits_coral__Attributepsconstp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator_traits<coral::Attribute* const*> -------------------
void __std__iterator_traits_coral__Attributepsconstp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
static void constructor_4025( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>();
  else ::new(mem) ::std::basic_string<char>();
}

static void constructor_4026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_4027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
}

static void constructor_4028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static void constructor_4029( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
}

static void constructor_4030( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_4031( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  }
}

static void constructor_4032( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void destructor_4033(void*, void * o, const std::vector<void*>&, void *) {
((::std::basic_string<char>*)o)->::std::basic_string<char>::~basic_string();
}
static  void operator_4034( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_4035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
}

static  void operator_4036( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
}

static  void method_4037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->begin)());
  else   (((::std::basic_string<char>*)o)->begin)();
}

static  void method_4038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->begin)());
  else   (((const ::std::basic_string<char>*)o)->begin)();
}

static  void method_4039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->end)());
  else   (((::std::basic_string<char>*)o)->end)();
}

static  void method_4040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->end)());
  else   (((const ::std::basic_string<char>*)o)->end)();
}

static  void method_4045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->size)());
  else   (((const ::std::basic_string<char>*)o)->size)();
}

static  void method_4046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->length)());
  else   (((const ::std::basic_string<char>*)o)->length)();
}

static  void method_4047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->max_size)());
  else   (((const ::std::basic_string<char>*)o)->max_size)();
}

static  void method_4048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_4049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0]);
}

static  void method_4050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->capacity)());
  else   (((const ::std::basic_string<char>*)o)->capacity)();
}

static  void method_4051( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::basic_string<char>*)o)->reserve)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::basic_string<char>*)o)->reserve)(*(::std::size_t*)arg[0]);
  }
}

static  void method_4052( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::basic_string<char>*)o)->clear)();
}

static  void method_4053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::basic_string<char>*)o)->empty)());
  else   (((const ::std::basic_string<char>*)o)->empty)();
}

static  void operator_4054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void operator_4058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_4059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_4060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
}

static  void method_4061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_4062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_4064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
}

static  void method_4065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_4066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->push_back)(*(char*)arg[0]);
}

static  void method_4067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_4068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_4070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
}

static  void method_4071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_4072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_4073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_4074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_4075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_4077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_4078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]));
  else   (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]);
}

static  void method_4079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)();
    else     (((::std::basic_string<char>*)o)->erase)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]);
}

static  void method_4081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]);
}

static  void method_4082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_4083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_4084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_4085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_4086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_4087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_4088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_4089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
}

static  void method_4090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_4091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
}

static  void method_4092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
}

static  void method_4093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
}

static  void method_4094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
}

static  void method_4099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static  void method_4100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->swap)(*(::std::basic_string<char>*)arg[0]);
}

static  void method_4101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->c_str)());
  else   (((const ::std::basic_string<char>*)o)->c_str)();
}

static  void method_4102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->data)());
  else   (((const ::std::basic_string<char>*)o)->data)();
}

static  void method_4103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<char>)((((const ::std::basic_string<char>*)o)->get_allocator)());
  else   (((const ::std::basic_string<char>*)o)->get_allocator)();
}

static  void method_4104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_4126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)());
    else     (((const ::std::basic_string<char>*)o)->substr)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_4129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_4130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_4131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_4132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]);
}

static  void method_4133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_4134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static void method_newdel_1443( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
void __std__basic_string_char__db_datamem(Reflex::Class*);
void __std__basic_string_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__basic_string_char__datamem_bld(&__std__basic_string_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__basic_string_char__funcmem_bld(&__std__basic_string_char__db_funcmem);
void __std__basic_string_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::basic_string<char>"), typeid(::std::basic_string<char>), sizeof(::std::basic_string<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddDataMember(type_1636c, Reflex::Literal("npos"), (size_t)&std::basic_string<char>::npos, ::Reflex::PUBLIC | Reflex::STATIC | Reflex::CONST)
  .AddTypedef(type_1535, Reflex::Literal("std::basic_string<char>::_CharT_alloc_type"))
  .AddTypedef(type_1597, Reflex::Literal("std::basic_string<char>::traits_type"))
  .AddTypedef(type_2490, Reflex::Literal("std::basic_string<char>::value_type"))
  .AddTypedef(type_1535, Reflex::Literal("std::basic_string<char>::allocator_type"))
  .AddTypedef(type_1636, Reflex::Literal("std::basic_string<char>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::basic_string<char>::difference_type"))
  .AddTypedef(type_3142, Reflex::Literal("std::basic_string<char>::reference"))
  .AddTypedef(type_3993, Reflex::Literal("std::basic_string<char>::const_reference"))
  .AddTypedef(type_820, Reflex::Literal("std::basic_string<char>::pointer"))
  .AddTypedef(type_1841, Reflex::Literal("std::basic_string<char>::const_pointer"))
  .AddTypedef(type_2132, Reflex::Literal("std::basic_string<char>::iterator"))
  .AddTypedef(type_2147, Reflex::Literal("std::basic_string<char>::const_iterator"))
  .AddTypedef(type_1671, Reflex::Literal("std::basic_string<char>::const_reverse_iterator"))
  .AddTypedef(type_1672, Reflex::Literal("std::basic_string<char>::reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("basic_string"), constructor_4025, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9409), Reflex::Literal("basic_string"), constructor_4026, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213), Reflex::Literal("basic_string"), constructor_4027, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_1636, type_1636), Reflex::Literal("basic_string"), constructor_4028, 0, "__str;__pos;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_1636, type_1636, type_9409), Reflex::Literal("basic_string"), constructor_4029, 0, "__str;__pos;__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1841, type_1636, type_9409), Reflex::Literal("basic_string"), constructor_4030, 0, "__s;__n;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1841, type_9409), Reflex::Literal("basic_string"), constructor_4031, 0, "__s;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_2490, type_9409), Reflex::Literal("basic_string"), constructor_4032, 0, "__n;__c;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~basic_string"), destructor_4033, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1443, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__basic_string_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__basic_string_char__funcmem_bld);
}

//------Delayed data member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4003, Reflex::Literal("_M_dataplus"), OffsetOf(__shadow__::__std__basic_string_char_, _M_dataplus), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3213), Reflex::Literal("operator="), operator_4034, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1841), Reflex::Literal("operator="), operator_4035, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2490), Reflex::Literal("operator="), operator_4036, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2132), Reflex::Literal("begin"), method_4037, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2147), Reflex::Literal("begin"), method_4038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2132), Reflex::Literal("end"), method_4039, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2147), Reflex::Literal("end"), method_4040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_4045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("length"), method_4046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_4047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_2490), Reflex::Literal("resize"), method_4048, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("resize"), method_4049, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_4050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_4051, 0, "__res=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_4052, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_4053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3993, type_1636), Reflex::Literal("operator[]"), operator_4054, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3142, type_1636), Reflex::Literal("operator[]"), operator_4055, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3993, type_1636), Reflex::Literal("at"), method_4056, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3142, type_1636), Reflex::Literal("at"), method_4057, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3213), Reflex::Literal("operator+="), operator_4058, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1841), Reflex::Literal("operator+="), operator_4059, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2490), Reflex::Literal("operator+="), operator_4060, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3213), Reflex::Literal("append"), method_4061, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3213, type_1636, type_1636), Reflex::Literal("append"), method_4062, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1841, type_1636), Reflex::Literal("append"), method_4063, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1841), Reflex::Literal("append"), method_4064, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_2490), Reflex::Literal("append"), method_4065, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2490), Reflex::Literal("push_back"), method_4066, 0, "__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3213), Reflex::Literal("assign"), method_4067, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3213, type_1636, type_1636), Reflex::Literal("assign"), method_4068, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1841, type_1636), Reflex::Literal("assign"), method_4069, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1841), Reflex::Literal("assign"), method_4070, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_2490), Reflex::Literal("assign"), method_4071, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2132, type_1636, type_2490), Reflex::Literal("insert"), method_4072, 0, "__p;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_3213), Reflex::Literal("insert"), method_4073, 0, "__pos1;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_3213, type_1636, type_1636), Reflex::Literal("insert"), method_4074, 0, "__pos1;__str;__pos2;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1841, type_1636), Reflex::Literal("insert"), method_4075, 0, "__pos;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1841), Reflex::Literal("insert"), method_4076, 0, "__pos;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1636, type_2490), Reflex::Literal("insert"), method_4077, 0, "__pos;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2132, type_2132, type_2490), Reflex::Literal("insert"), method_4078, 0, "__p;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1636), Reflex::Literal("erase"), method_4079, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2132, type_2132), Reflex::Literal("erase"), method_4080, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2132, type_2132, type_2132), Reflex::Literal("erase"), method_4081, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1636, type_3213), Reflex::Literal("replace"), method_4082, 0, "__pos;__n;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1636, type_3213, type_1636, type_1636), Reflex::Literal("replace"), method_4083, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1636, type_1841, type_1636), Reflex::Literal("replace"), method_4084, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1636, type_1841), Reflex::Literal("replace"), method_4085, 0, "__pos;__n1;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636, type_1636, type_1636, type_2490), Reflex::Literal("replace"), method_4086, 0, "__pos;__n1;__n2;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_3213), Reflex::Literal("replace"), method_4087, 0, "__i1;__i2;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_1841, type_1636), Reflex::Literal("replace"), method_4088, 0, "__i1;__i2;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_1841), Reflex::Literal("replace"), method_4089, 0, "__i1;__i2;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_1636, type_2490), Reflex::Literal("replace"), method_4090, 0, "__i1;__i2;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_820, type_820), Reflex::Literal("replace"), method_4091, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_1841, type_1841), Reflex::Literal("replace"), method_4092, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_2132, type_2132), Reflex::Literal("replace"), method_4093, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2132, type_2132, type_2147, type_2147), Reflex::Literal("replace"), method_4094, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_820, type_1636, type_1636), Reflex::Literal("copy"), method_4099, 0, "__s;__n;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3056), Reflex::Literal("swap"), method_4100, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1841), Reflex::Literal("c_str"), method_4101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1841), Reflex::Literal("data"), method_4102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1535), Reflex::Literal("get_allocator"), method_4103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636, type_1636), Reflex::Literal("find"), method_4104, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3213, type_1636), Reflex::Literal("find"), method_4105, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636), Reflex::Literal("find"), method_4106, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_2490, type_1636), Reflex::Literal("find"), method_4107, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3213, type_1636), Reflex::Literal("rfind"), method_4108, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636, type_1636), Reflex::Literal("rfind"), method_4109, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636), Reflex::Literal("rfind"), method_4110, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_2490, type_1636), Reflex::Literal("rfind"), method_4111, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3213, type_1636), Reflex::Literal("find_first_of"), method_4112, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636, type_1636), Reflex::Literal("find_first_of"), method_4113, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636), Reflex::Literal("find_first_of"), method_4114, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_2490, type_1636), Reflex::Literal("find_first_of"), method_4115, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3213, type_1636), Reflex::Literal("find_last_of"), method_4116, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636, type_1636), Reflex::Literal("find_last_of"), method_4117, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636), Reflex::Literal("find_last_of"), method_4118, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_2490, type_1636), Reflex::Literal("find_last_of"), method_4119, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3213, type_1636), Reflex::Literal("find_first_not_of"), method_4120, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636, type_1636), Reflex::Literal("find_first_not_of"), method_4121, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636), Reflex::Literal("find_first_not_of"), method_4122, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_2490, type_1636), Reflex::Literal("find_first_not_of"), method_4123, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3213, type_1636), Reflex::Literal("find_last_not_of"), method_4124, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636, type_1636), Reflex::Literal("find_last_not_of"), method_4125, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_1841, type_1636), Reflex::Literal("find_last_not_of"), method_4126, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_2490, type_1636), Reflex::Literal("find_last_not_of"), method_4127, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1443, type_1636, type_1636), Reflex::Literal("substr"), method_4128, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_3213), Reflex::Literal("compare"), method_4129, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_1636, type_1636, type_3213), Reflex::Literal("compare"), method_4130, 0, "__pos;__n;__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_1636, type_1636, type_3213, type_1636, type_1636), Reflex::Literal("compare"), method_4131, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_1841), Reflex::Literal("compare"), method_4132, 0, "__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_1636, type_1636, type_1841), Reflex::Literal("compare"), method_4133, 0, "__pos;__n1;__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_1636, type_1636, type_1841, type_1636), Reflex::Literal("compare"), method_4134, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void constructor_3222( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >();
  else ::new(mem) ::std::vector<std::basic_string<char> >();
}

static void constructor_3223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
}

static void constructor_3224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  }
}

static void constructor_3225( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static void destructor_3226(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<std::basic_string<char> >*)o)->::std::vector<std::basic_string<char> >::~vector();
}
static  void operator_3227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_3228( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_3229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_3230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_3231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_3232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_3237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->size)();
}

static  void method_3238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->max_size)();
}

static  void method_3239( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::basic_string<char>*)arg[1]);
  }
}

static  void method_3240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->capacity)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->capacity)();
}

static  void method_3241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->empty)();
}

static  void method_3242( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_3249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_3250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_3251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_3252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_3253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_3254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->push_back)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_3255( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->pop_back)();
}

static  void method_3256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_3257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_3258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_3259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]);
}

static  void method_3260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->swap)(*(::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_3261( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->clear)();
}

static void method_newdel_1397( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >")), ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >,::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
}

//------Dictionary for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__datamem_bld(&__std__vector_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__funcmem_bld(&__std__vector_std__basic_string_char_s__db_funcmem);
void __std__vector_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"), typeid(::std::vector<std::basic_string<char> >), sizeof(::std::vector<std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddBase(type_1675, ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >, ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1443, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1675, Reflex::Literal("std::vector<std::basic_string<char> >::_Base"))
  .AddTypedef(type_1536, Reflex::Literal("std::vector<std::basic_string<char> >::_Tp_alloc_type"))
  .AddTypedef(type_2035, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_traits"))
  .AddTypedef(type_1443, Reflex::Literal("std::vector<std::basic_string<char> >::value_type"))
  .AddTypedef(type_3208, Reflex::Literal("std::vector<std::basic_string<char> >::pointer"))
  .AddTypedef(type_3210, Reflex::Literal("std::vector<std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_3056, Reflex::Literal("std::vector<std::basic_string<char> >::reference"))
  .AddTypedef(type_3213, Reflex::Literal("std::vector<std::basic_string<char> >::const_reference"))
  .AddTypedef(type_2124, Reflex::Literal("std::vector<std::basic_string<char> >::iterator"))
  .AddTypedef(type_2125, Reflex::Literal("std::vector<std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1645, Reflex::Literal("std::vector<std::basic_string<char> >::const_reverse_iterator"))
  .AddTypedef(type_1646, Reflex::Literal("std::vector<std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<std::basic_string<char> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1536, Reflex::Literal("std::vector<std::basic_string<char> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3222, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9301), Reflex::Literal("vector"), constructor_3223, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3213, type_9301), Reflex::Literal("vector"), constructor_3224, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9302), Reflex::Literal("vector"), constructor_3225, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3226, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1397, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9303, type_9302), Reflex::Literal("operator="), operator_3227, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3213), Reflex::Literal("assign"), method_3228, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2124), Reflex::Literal("begin"), method_3229, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2125), Reflex::Literal("begin"), method_3230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2124), Reflex::Literal("end"), method_3231, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2125), Reflex::Literal("end"), method_3232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_1443), Reflex::Literal("resize"), method_3239, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3242, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636), Reflex::Literal("operator[]"), operator_3243, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3213, type_1636), Reflex::Literal("operator[]"), operator_3244, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_1636), Reflex::Literal("at"), method_3246, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3213, type_1636), Reflex::Literal("at"), method_3247, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("front"), method_3248, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3213), Reflex::Literal("front"), method_3249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("back"), method_3250, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3213), Reflex::Literal("back"), method_3251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3208), Reflex::Literal("data"), method_3252, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3210), Reflex::Literal("data"), method_3253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3213), Reflex::Literal("push_back"), method_3254, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3255, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2124, type_2124, type_3213), Reflex::Literal("insert"), method_3256, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2124, type_1636, type_3213), Reflex::Literal("insert"), method_3257, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2124, type_2124), Reflex::Literal("erase"), method_3258, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2124, type_2124, type_2124), Reflex::Literal("erase"), method_3259, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9303), Reflex::Literal("swap"), method_3260, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3261, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
static void constructor_3289( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>();
  else ::new(mem) ::std::vector<unsigned int>();
}

static void constructor_3290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
}

static void constructor_3291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  }
}

static void constructor_3292( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
}

static void destructor_3293(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<unsigned int>*)o)->::std::vector<unsigned int>::~vector();
}
static  void operator_3294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
}

static  void method_3295( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->begin)());
  else   (((::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->begin)());
  else   (((const ::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->end)());
  else   (((::std::vector<unsigned int>*)o)->end)();
}

static  void method_3299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->end)());
  else   (((const ::std::vector<unsigned int>*)o)->end)();
}

static  void method_3304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->size)());
  else   (((const ::std::vector<unsigned int>*)o)->size)();
}

static  void method_3305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->max_size)());
  else   (((const ::std::vector<unsigned int>*)o)->max_size)();
}

static  void method_3306( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_3307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->capacity)());
  else   (((const ::std::vector<unsigned int>*)o)->capacity)();
}

static  void method_3308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned int>*)o)->empty)());
  else   (((const ::std::vector<unsigned int>*)o)->empty)();
}

static  void method_3309( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->front)();
  else   (((::std::vector<unsigned int>*)o)->front)();
}

static  void method_3316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->front)();
  else   (((const ::std::vector<unsigned int>*)o)->front)();
}

static  void method_3317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->back)();
  else   (((::std::vector<unsigned int>*)o)->back)();
}

static  void method_3318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->back)();
  else   (((const ::std::vector<unsigned int>*)o)->back)();
}

static  void method_3319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned int>*)o)->data)());
  else   (((::std::vector<unsigned int>*)o)->data)();
}

static  void method_3320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned int>*)o)->data)());
  else   (((const ::std::vector<unsigned int>*)o)->data)();
}

static  void method_3321( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->push_back)(*(const unsigned int*)arg[0]);
}

static  void method_3322( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->pop_back)();
}

static  void method_3323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned int*)arg[2]);
}

static  void method_3325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]);
}

static  void method_3326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void method_3327( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->swap)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_3328( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->clear)();
}

static void method_newdel_1398( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >")), ::Reflex::BaseOffset< ::std::vector<unsigned int>,::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
}

//------Dictionary for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*);
void __std__vector_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__datamem_bld(&__std__vector_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__funcmem_bld(&__std__vector_unsignedsint__db_funcmem);
void __std__vector_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned int>"), typeid(::std::vector<unsigned int>), sizeof(::std::vector<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddBase(type_1676, ::Reflex::BaseOffset< ::std::vector<unsigned int>, ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_80, Reflex::Literal("std::vector<unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1676, Reflex::Literal("std::vector<unsigned int>::_Base"))
  .AddTypedef(type_1539, Reflex::Literal("std::vector<unsigned int>::_Tp_alloc_type"))
  .AddTypedef(type_2038, Reflex::Literal("std::vector<unsigned int>::_Alloc_traits"))
  .AddTypedef(type_80, Reflex::Literal("std::vector<unsigned int>::value_type"))
  .AddTypedef(type_2488, Reflex::Literal("std::vector<unsigned int>::pointer"))
  .AddTypedef(type_3276, Reflex::Literal("std::vector<unsigned int>::const_pointer"))
  .AddTypedef(type_3278, Reflex::Literal("std::vector<unsigned int>::reference"))
  .AddTypedef(type_3280, Reflex::Literal("std::vector<unsigned int>::const_reference"))
  .AddTypedef(type_2126, Reflex::Literal("std::vector<unsigned int>::iterator"))
  .AddTypedef(type_2127, Reflex::Literal("std::vector<unsigned int>::const_iterator"))
  .AddTypedef(type_1649, Reflex::Literal("std::vector<unsigned int>::const_reverse_iterator"))
  .AddTypedef(type_1650, Reflex::Literal("std::vector<unsigned int>::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<unsigned int>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<unsigned int>::difference_type"))
  .AddTypedef(type_1539, Reflex::Literal("std::vector<unsigned int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3289, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9305), Reflex::Literal("vector"), constructor_3290, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3280, type_9305), Reflex::Literal("vector"), constructor_3291, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9306), Reflex::Literal("vector"), constructor_3292, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3293, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1398, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9307, type_9306), Reflex::Literal("operator="), operator_3294, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3280), Reflex::Literal("assign"), method_3295, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2126), Reflex::Literal("begin"), method_3296, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2127), Reflex::Literal("begin"), method_3297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2126), Reflex::Literal("end"), method_3298, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2127), Reflex::Literal("end"), method_3299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_80), Reflex::Literal("resize"), method_3306, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3309, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3278, type_1636), Reflex::Literal("operator[]"), operator_3310, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3280, type_1636), Reflex::Literal("operator[]"), operator_3311, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3278, type_1636), Reflex::Literal("at"), method_3313, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3280, type_1636), Reflex::Literal("at"), method_3314, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3278), Reflex::Literal("front"), method_3315, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3280), Reflex::Literal("front"), method_3316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3278), Reflex::Literal("back"), method_3317, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3280), Reflex::Literal("back"), method_3318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2488), Reflex::Literal("data"), method_3319, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3276), Reflex::Literal("data"), method_3320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3280), Reflex::Literal("push_back"), method_3321, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3322, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2126, type_2126, type_3280), Reflex::Literal("insert"), method_3323, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2126, type_1636, type_3280), Reflex::Literal("insert"), method_3324, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2126, type_2126), Reflex::Literal("erase"), method_3325, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2126, type_2126, type_2126), Reflex::Literal("erase"), method_3326, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9307), Reflex::Literal("swap"), method_3327, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3328, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class shared_ptr<cool::IRecord> -------------------------------
static void destructor_8610(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IRecord>*)o)->::boost::shared_ptr<cool::IRecord>::~shared_ptr();
}
static void constructor_8611( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IRecord>(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IRecord>(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static void constructor_8612( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IRecord>();
  else ::new(mem) ::boost::shared_ptr<cool::IRecord>();
}

static  void operator_8613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IRecord>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IRecord>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_8614( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IRecord>*)o)->reset)();
}

static  void operator_8615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IRecord>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator*)();
}

static  void operator_8616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator->)();
}

static  void method_8618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->get)();
}

static  void converter_8619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IRecord* boost::shared_ptr<cool::IRecord>::*)((((const ::boost::shared_ptr<cool::IRecord>*)o)->operator cool::IRecord* boost::shared_ptr<cool::IRecord>::*)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator cool::IRecord* boost::shared_ptr<cool::IRecord>::*)();
}

static  void operator_8620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IRecord>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->operator!)();
}

static  void method_8621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IRecord>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->unique)();
}

static  void method_8622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IRecord>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->use_count)();
}

static  void method_8623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IRecord>*)o)->swap)(*(::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_8624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IRecord>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static void method_newdel_2399( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IRecord> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IRecord> -------------------------------
void __boost__shared_ptr_cool__IRecord__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IRecord__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IRecord__datamem_bld(&__boost__shared_ptr_cool__IRecord__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IRecord__funcmem_bld(&__boost__shared_ptr_cool__IRecord__db_funcmem);
void __boost__shared_ptr_cool__IRecord__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IRecord>"), typeid(::boost::shared_ptr<cool::IRecord>), sizeof(::boost::shared_ptr<cool::IRecord>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2302, Reflex::Literal("boost::shared_ptr<cool::IRecord>::element_type"))
  .AddTypedef(type_10338, Reflex::Literal("boost::shared_ptr<cool::IRecord>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8610, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3346), Reflex::Literal("shared_ptr"), constructor_8611, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8612, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IRecord__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IRecord__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IRecord> -------------------
void __boost__shared_ptr_cool__IRecord__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10337, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IRecord_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IRecord_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IRecord> -------------------
void __boost__shared_ptr_cool__IRecord__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3121, type_3346), Reflex::Literal("operator="), operator_8613, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_8614, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10196), Reflex::Literal("operator*"), operator_8615, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10337), Reflex::Literal("operator->"), operator_8616, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10337), Reflex::Literal("get"), method_8618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10338), Reflex::Literal("operator cool::IRecord* boost::shared_ptr<cool::IRecord>::*"), converter_8619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_8620, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_8621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_8622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3121), Reflex::Literal("swap"), method_8623, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_8624, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_8625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_3346), Reflex::Literal("_internal_equiv"), method_8626, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
static void constructor_3355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >();
}

static void constructor_3356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_3357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[2]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IRecord>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[2]);
  }
}

static void constructor_3358( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IRecord> >(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void destructor_3359(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->::std::vector<boost::shared_ptr<cool::IRecord> >::~vector();
}
static  void operator_3360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_3361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_3362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)());
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)();
}

static  void method_3363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->begin)();
}

static  void method_3364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)());
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)();
}

static  void method_3365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->end)();
}

static  void method_3370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->size)();
}

static  void method_3371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->max_size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->max_size)();
}

static  void method_3372( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::boost::shared_ptr<cool::IRecord>*)arg[1]);
  }
}

static  void method_3373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->capacity)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->capacity)();
}

static  void method_3374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->empty)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->empty)();
}

static  void method_3375( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
}

static  void method_3382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->front)();
}

static  void method_3383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
}

static  void method_3384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->back)();
}

static  void method_3385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)());
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)();
}

static  void method_3386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->data)();
}

static  void method_3387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->push_back)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_3388( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->pop_back)();
}

static  void method_3389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_3390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[2]);
}

static  void method_3391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]));
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_3392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[1]);
}

static  void method_3393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->swap)(*(::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_3394( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IRecord> >*)o)->clear)();
}

static void method_newdel_1399( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >")), ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IRecord> >,::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IRecord> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IRecord> > >::Generate();
}

//------Dictionary for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IRecord_s__datamem_bld(&__std__vector_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&__std__vector_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void __std__vector_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >"), typeid(::std::vector<boost::shared_ptr<cool::IRecord> >), sizeof(::std::vector<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_1677, ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IRecord> >, ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2399, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Alloc_value_type"))
  .AddTypedef(type_1677, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Base"))
  .AddTypedef(type_1540, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Tp_alloc_type"))
  .AddTypedef(type_2039, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::_Alloc_traits"))
  .AddTypedef(type_2399, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::value_type"))
  .AddTypedef(type_3119, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::pointer"))
  .AddTypedef(type_3343, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_pointer"))
  .AddTypedef(type_3121, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::reference"))
  .AddTypedef(type_3346, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_reference"))
  .AddTypedef(type_2128, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::iterator"))
  .AddTypedef(type_2129, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_iterator"))
  .AddTypedef(type_1651, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::const_reverse_iterator"))
  .AddTypedef(type_1652, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::difference_type"))
  .AddTypedef(type_1540, Reflex::Literal("std::vector<boost::shared_ptr<cool::IRecord> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3355, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9309), Reflex::Literal("vector"), constructor_3356, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3346, type_9309), Reflex::Literal("vector"), constructor_3357, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9310), Reflex::Literal("vector"), constructor_3358, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3359, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_boost__shared_ptr_cool__IRecord_s__funcmem_bld);
}

//------Delayed data member builder for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std__vector_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9311, type_9310), Reflex::Literal("operator="), operator_3360, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3346), Reflex::Literal("assign"), method_3361, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128), Reflex::Literal("begin"), method_3362, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2129), Reflex::Literal("begin"), method_3363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128), Reflex::Literal("end"), method_3364, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2129), Reflex::Literal("end"), method_3365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_2399), Reflex::Literal("resize"), method_3372, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3375, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3121, type_1636), Reflex::Literal("operator[]"), operator_3376, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3346, type_1636), Reflex::Literal("operator[]"), operator_3377, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3121, type_1636), Reflex::Literal("at"), method_3379, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3346, type_1636), Reflex::Literal("at"), method_3380, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3121), Reflex::Literal("front"), method_3381, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3346), Reflex::Literal("front"), method_3382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3121), Reflex::Literal("back"), method_3383, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3346), Reflex::Literal("back"), method_3384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3119), Reflex::Literal("data"), method_3385, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3343), Reflex::Literal("data"), method_3386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3346), Reflex::Literal("push_back"), method_3387, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3388, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_2128, type_3346), Reflex::Literal("insert"), method_3389, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2128, type_1636, type_3346), Reflex::Literal("insert"), method_3390, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_2128), Reflex::Literal("erase"), method_3391, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_2128, type_2128), Reflex::Literal("erase"), method_3392, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9311), Reflex::Literal("swap"), method_3393, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3394, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class shared_ptr<cool::IObject> -------------------------------
static void destructor_8011(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IObject>*)o)->::boost::shared_ptr<cool::IObject>::~shared_ptr();
}
static void constructor_8012( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObject>(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IObject>(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static void constructor_8013( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObject>();
  else ::new(mem) ::boost::shared_ptr<cool::IObject>();
}

static  void operator_8014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IObject>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IObject>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_8015( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IObject>*)o)->reset)();
}

static  void operator_8016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IObject>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator*)();
}

static  void operator_8017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator->)();
}

static  void method_8019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->get)();
}

static  void converter_8020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IObject* boost::shared_ptr<cool::IObject>::*)((((const ::boost::shared_ptr<cool::IObject>*)o)->operator cool::IObject* boost::shared_ptr<cool::IObject>::*)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator cool::IObject* boost::shared_ptr<cool::IObject>::*)();
}

static  void operator_8021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObject>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->operator!)();
}

static  void method_8022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObject>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->unique)();
}

static  void method_8023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IObject>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->use_count)();
}

static  void method_8024( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IObject>*)o)->swap)(*(::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_8025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObject>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static void method_newdel_2290( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IObject> -------------------------------
void __boost__shared_ptr_cool__IObject__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObject__datamem_bld(&__boost__shared_ptr_cool__IObject__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObject__funcmem_bld(&__boost__shared_ptr_cool__IObject__db_funcmem);
void __boost__shared_ptr_cool__IObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IObject>"), typeid(::boost::shared_ptr<cool::IObject>), sizeof(::boost::shared_ptr<cool::IObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2321, Reflex::Literal("boost::shared_ptr<cool::IObject>::element_type"))
  .AddTypedef(type_10186, Reflex::Literal("boost::shared_ptr<cool::IObject>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8011, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3412), Reflex::Literal("shared_ptr"), constructor_8012, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8013, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2290, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IObject__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IObject> -------------------
void __boost__shared_ptr_cool__IObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10185, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObject_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObject_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IObject> -------------------
void __boost__shared_ptr_cool__IObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132, type_3412), Reflex::Literal("operator="), operator_8014, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_8015, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10187), Reflex::Literal("operator*"), operator_8016, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10185), Reflex::Literal("operator->"), operator_8017, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10185), Reflex::Literal("get"), method_8019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10186), Reflex::Literal("operator cool::IObject* boost::shared_ptr<cool::IObject>::*"), converter_8020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_8021, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_8022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_8023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3132), Reflex::Literal("swap"), method_8024, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_8025, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_8026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_3412), Reflex::Literal("_internal_equiv"), method_8027, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
static void constructor_3421( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >();
}

static void constructor_3422( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_3423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[2]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(::std::size_t*)arg[0],
      *(const ::boost::shared_ptr<cool::IObject>*)arg[1],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[2]);
  }
}

static void constructor_3424( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::vector<boost::shared_ptr<cool::IObject> >(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void destructor_3425(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->::std::vector<boost::shared_ptr<cool::IObject> >::~vector();
}
static  void operator_3426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_3427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_3428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)());
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)();
}

static  void method_3429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->begin)();
}

static  void method_3430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)());
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)();
}

static  void method_3431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->end)();
}

static  void method_3436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->size)();
}

static  void method_3437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->max_size)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->max_size)();
}

static  void method_3438( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::boost::shared_ptr<cool::IObject>*)arg[1]);
  }
}

static  void method_3439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->capacity)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->capacity)();
}

static  void method_3440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->empty)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->empty)();
}

static  void method_3441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
}

static  void method_3448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->front)();
}

static  void method_3449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
}

static  void method_3450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->back)();
}

static  void method_3451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)());
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)();
}

static  void method_3452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)());
  else   (((const ::std::vector<boost::shared_ptr<cool::IObject> >*)o)->data)();
}

static  void method_3453( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->push_back)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_3454( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->pop_back)();
}

static  void method_3455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_3456( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[2]);
}

static  void method_3457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]));
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_3458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[1]));
  else   (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[1]);
}

static  void method_3459( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->swap)(*(::std::vector<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_3460( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<boost::shared_ptr<cool::IObject> >*)o)->clear)();
}

static void method_newdel_1400( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >")), ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IObject> >,::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IObject> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<boost::shared_ptr<cool::IObject> > >::Generate();
}

//------Dictionary for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
void __std__vector_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void __std__vector_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IObject_s__datamem_bld(&__std__vector_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_boost__shared_ptr_cool__IObject_s__funcmem_bld(&__std__vector_boost__shared_ptr_cool__IObject_s__db_funcmem);
void __std__vector_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >"), typeid(::std::vector<boost::shared_ptr<cool::IObject> >), sizeof(::std::vector<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_1678, ::Reflex::BaseOffset< ::std::vector<boost::shared_ptr<cool::IObject> >, ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2290, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Alloc_value_type"))
  .AddTypedef(type_1678, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Base"))
  .AddTypedef(type_1541, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Tp_alloc_type"))
  .AddTypedef(type_2040, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::_Alloc_traits"))
  .AddTypedef(type_2290, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::value_type"))
  .AddTypedef(type_3130, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::pointer"))
  .AddTypedef(type_3409, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_pointer"))
  .AddTypedef(type_3132, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::reference"))
  .AddTypedef(type_3412, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_reference"))
  .AddTypedef(type_2130, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::iterator"))
  .AddTypedef(type_2131, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_iterator"))
  .AddTypedef(type_1653, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::const_reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::difference_type"))
  .AddTypedef(type_1541, Reflex::Literal("std::vector<boost::shared_ptr<cool::IObject> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3421, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9313), Reflex::Literal("vector"), constructor_3422, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3412, type_9313), Reflex::Literal("vector"), constructor_3423, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9314), Reflex::Literal("vector"), constructor_3424, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3425, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1400, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_boost__shared_ptr_cool__IObject_s__funcmem_bld);
}

//------Delayed data member builder for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std__vector_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std__vector_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9315, type_9314), Reflex::Literal("operator="), operator_3426, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3412), Reflex::Literal("assign"), method_3427, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130), Reflex::Literal("begin"), method_3428, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2131), Reflex::Literal("begin"), method_3429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130), Reflex::Literal("end"), method_3430, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2131), Reflex::Literal("end"), method_3431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_2290), Reflex::Literal("resize"), method_3438, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3441, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132, type_1636), Reflex::Literal("operator[]"), operator_3442, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3412, type_1636), Reflex::Literal("operator[]"), operator_3443, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132, type_1636), Reflex::Literal("at"), method_3445, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3412, type_1636), Reflex::Literal("at"), method_3446, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132), Reflex::Literal("front"), method_3447, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3412), Reflex::Literal("front"), method_3448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132), Reflex::Literal("back"), method_3449, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3412), Reflex::Literal("back"), method_3450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130), Reflex::Literal("data"), method_3451, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3409), Reflex::Literal("data"), method_3452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3412), Reflex::Literal("push_back"), method_3453, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3454, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130, type_2130, type_3412), Reflex::Literal("insert"), method_3455, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2130, type_1636, type_3412), Reflex::Literal("insert"), method_3456, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130, type_2130), Reflex::Literal("erase"), method_3457, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130, type_2130, type_2130), Reflex::Literal("erase"), method_3458, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9315), Reflex::Literal("swap"), method_3459, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3460, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------------------
static void constructor_3490( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>();
  else ::new(mem) ::std::vector<cool::IField*>();
}

static void constructor_3491( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void constructor_3492( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1]);
  else ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1],
      *(const ::std::allocator<cool::IField*>*)arg[2]);
  else ::new(mem) ::std::vector<cool::IField*>(*(::std::size_t*)arg[0],
      *(::cool::IField* const*)arg[1],
      *(const ::std::allocator<cool::IField*>*)arg[2]);
  }
}

static void constructor_3493( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IField*>(*(const ::std::vector<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IField*>(*(const ::std::vector<cool::IField*>*)arg[0]);
}

static void destructor_3494(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::IField*>*)o)->::std::vector<cool::IField*>::~vector();
}
static  void operator_3495( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->operator=)(*(const ::std::vector<cool::IField*>*)arg[0]);
  else   (((::std::vector<cool::IField*>*)o)->operator=)(*(const ::std::vector<cool::IField*>*)arg[0]);
}

static  void method_3496( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::cool::IField* const*)arg[1]);
}

static  void method_3497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->begin)());
  else   (((::std::vector<cool::IField*>*)o)->begin)();
}

static  void method_3498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> >)((((const ::std::vector<cool::IField*>*)o)->begin)());
  else   (((const ::std::vector<cool::IField*>*)o)->begin)();
}

static  void method_3499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->end)());
  else   (((::std::vector<cool::IField*>*)o)->end)();
}

static  void method_3500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField* const*,std::vector<cool::IField*> >)((((const ::std::vector<cool::IField*>*)o)->end)());
  else   (((const ::std::vector<cool::IField*>*)o)->end)();
}

static  void method_3505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IField*>*)o)->size)());
  else   (((const ::std::vector<cool::IField*>*)o)->size)();
}

static  void method_3506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IField*>*)o)->max_size)());
  else   (((const ::std::vector<cool::IField*>*)o)->max_size)();
}

static  void method_3507( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::IField*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::IField*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::cool::IField*)arg[1]);
  }
}

static  void method_3508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IField*>*)o)->capacity)());
  else   (((const ::std::vector<cool::IField*>*)o)->capacity)();
}

static  void method_3509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::IField*>*)o)->empty)());
  else   (((const ::std::vector<cool::IField*>*)o)->empty)();
}

static  void method_3510( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3511( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IField*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IField*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->front)();
  else   (((::std::vector<cool::IField*>*)o)->front)();
}

static  void method_3517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->front)();
  else   (((const ::std::vector<cool::IField*>*)o)->front)();
}

static  void method_3518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IField*>*)o)->back)();
  else   (((::std::vector<cool::IField*>*)o)->back)();
}

static  void method_3519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IField*>*)o)->back)();
  else   (((const ::std::vector<cool::IField*>*)o)->back)();
}

static  void method_3520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::IField*>*)o)->data)());
  else   (((::std::vector<cool::IField*>*)o)->data)();
}

static  void method_3521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::IField*>*)o)->data)());
  else   (((const ::std::vector<cool::IField*>*)o)->data)();
}

static  void method_3522( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->push_back)(*(::cool::IField* const*)arg[0]);
}

static  void method_3523( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IField*>*)o)->pop_back)();
}

static  void method_3524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::cool::IField* const*)arg[1]));
  else   (((::std::vector<cool::IField*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::cool::IField* const*)arg[1]);
}

static  void method_3525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::cool::IField* const*)arg[2]);
}

static  void method_3526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0]));
  else   (((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0]);
}

static  void method_3527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >)((((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[1]));
  else   (((::std::vector<cool::IField*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IField**,std::vector<cool::IField*> >*)arg[1]);
}

static  void method_3528( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IField*>*)o)->swap)(*(::std::vector<cool::IField*>*)arg[0]);
}

static  void method_3529( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IField*>*)o)->clear)();
}

static void method_newdel_1401( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >")), ::Reflex::BaseOffset< ::std::vector<cool::IField*>,::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::IField*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::IField*> >::Generate();
}

//------Dictionary for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------------------
void __std__vector_cool__IFieldp__db_datamem(Reflex::Class*);
void __std__vector_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldp__datamem_bld(&__std__vector_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldp__funcmem_bld(&__std__vector_cool__IFieldp__db_funcmem);
void __std__vector_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::IField*>"), typeid(::std::vector<cool::IField*>), sizeof(::std::vector<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1680, ::Reflex::BaseOffset< ::std::vector<cool::IField*>, ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3469, Reflex::Literal("std::vector<cool::IField*>::_Alloc_value_type"))
  .AddTypedef(type_1680, Reflex::Literal("std::vector<cool::IField*>::_Base"))
  .AddTypedef(type_1542, Reflex::Literal("std::vector<cool::IField*>::_Tp_alloc_type"))
  .AddTypedef(type_2042, Reflex::Literal("std::vector<cool::IField*>::_Alloc_traits"))
  .AddTypedef(type_3469, Reflex::Literal("std::vector<cool::IField*>::value_type"))
  .AddTypedef(type_3475, Reflex::Literal("std::vector<cool::IField*>::pointer"))
  .AddTypedef(type_3477, Reflex::Literal("std::vector<cool::IField*>::const_pointer"))
  .AddTypedef(type_3479, Reflex::Literal("std::vector<cool::IField*>::reference"))
  .AddTypedef(type_3481, Reflex::Literal("std::vector<cool::IField*>::const_reference"))
  .AddTypedef(type_2135, Reflex::Literal("std::vector<cool::IField*>::iterator"))
  .AddTypedef(type_2136, Reflex::Literal("std::vector<cool::IField*>::const_iterator"))
  .AddTypedef(type_1657, Reflex::Literal("std::vector<cool::IField*>::const_reverse_iterator"))
  .AddTypedef(type_1658, Reflex::Literal("std::vector<cool::IField*>::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<cool::IField*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<cool::IField*>::difference_type"))
  .AddTypedef(type_1542, Reflex::Literal("std::vector<cool::IField*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3490, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9317), Reflex::Literal("vector"), constructor_3491, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3481, type_9317), Reflex::Literal("vector"), constructor_3492, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9318), Reflex::Literal("vector"), constructor_3493, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3494, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1401, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__IFieldp__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std__vector_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std__vector_cool__IFieldp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9319, type_9318), Reflex::Literal("operator="), operator_3495, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3481), Reflex::Literal("assign"), method_3496, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2135), Reflex::Literal("begin"), method_3497, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2136), Reflex::Literal("begin"), method_3498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2135), Reflex::Literal("end"), method_3499, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2136), Reflex::Literal("end"), method_3500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3506, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3469), Reflex::Literal("resize"), method_3507, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3508, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3509, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3510, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3479, type_1636), Reflex::Literal("operator[]"), operator_3511, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3481, type_1636), Reflex::Literal("operator[]"), operator_3512, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3479, type_1636), Reflex::Literal("at"), method_3514, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3481, type_1636), Reflex::Literal("at"), method_3515, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3479), Reflex::Literal("front"), method_3516, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3481), Reflex::Literal("front"), method_3517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3479), Reflex::Literal("back"), method_3518, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3481), Reflex::Literal("back"), method_3519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3475), Reflex::Literal("data"), method_3520, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3477), Reflex::Literal("data"), method_3521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3481), Reflex::Literal("push_back"), method_3522, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3523, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2135, type_2135, type_3481), Reflex::Literal("insert"), method_3524, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2135, type_1636, type_3481), Reflex::Literal("insert"), method_3525, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2135, type_2135), Reflex::Literal("erase"), method_3526, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2135, type_2135, type_2135), Reflex::Literal("erase"), method_3527, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9319), Reflex::Literal("swap"), method_3528, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3529, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
static void constructor_3559( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>();
  else ::new(mem) ::std::vector<cool::IRecordSelection*>();
}

static void constructor_3560( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_3561( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[2]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(::std::size_t*)arg[0],
      *(::cool::IRecordSelection* const*)arg[1],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[2]);
  }
}

static void constructor_3562( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IRecordSelection*>(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
}

static void destructor_3563(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::IRecordSelection*>*)o)->::std::vector<cool::IRecordSelection*>::~vector();
}
static  void operator_3564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
  else   (((::std::vector<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::vector<cool::IRecordSelection*>*)arg[0]);
}

static  void method_3565( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]);
}

static  void method_3566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->begin)());
  else   (((::std::vector<cool::IRecordSelection*>*)o)->begin)();
}

static  void method_3567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> >)((((const ::std::vector<cool::IRecordSelection*>*)o)->begin)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->begin)();
}

static  void method_3568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->end)());
  else   (((::std::vector<cool::IRecordSelection*>*)o)->end)();
}

static  void method_3569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection* const*,std::vector<cool::IRecordSelection*> >)((((const ::std::vector<cool::IRecordSelection*>*)o)->end)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->end)();
}

static  void method_3574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IRecordSelection*>*)o)->size)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->size)();
}

static  void method_3575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IRecordSelection*>*)o)->max_size)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->max_size)();
}

static  void method_3576( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::IRecordSelection*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::IRecordSelection*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::cool::IRecordSelection*)arg[1]);
  }
}

static  void method_3577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IRecordSelection*>*)o)->capacity)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->capacity)();
}

static  void method_3578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::IRecordSelection*>*)o)->empty)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->empty)();
}

static  void method_3579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->front)();
  else   (((::std::vector<cool::IRecordSelection*>*)o)->front)();
}

static  void method_3586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->front)();
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->front)();
}

static  void method_3587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IRecordSelection*>*)o)->back)();
  else   (((::std::vector<cool::IRecordSelection*>*)o)->back)();
}

static  void method_3588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IRecordSelection*>*)o)->back)();
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->back)();
}

static  void method_3589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::IRecordSelection*>*)o)->data)());
  else   (((::std::vector<cool::IRecordSelection*>*)o)->data)();
}

static  void method_3590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::IRecordSelection*>*)o)->data)());
  else   (((const ::std::vector<cool::IRecordSelection*>*)o)->data)();
}

static  void method_3591( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->push_back)(*(::cool::IRecordSelection* const*)arg[0]);
}

static  void method_3592( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->pop_back)();
}

static  void method_3593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]));
  else   (((::std::vector<cool::IRecordSelection*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]);
}

static  void method_3594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::cool::IRecordSelection* const*)arg[2]);
}

static  void method_3595( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0]));
  else   (((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0]);
}

static  void method_3596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >)((((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[1]));
  else   (((::std::vector<cool::IRecordSelection*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IRecordSelection**,std::vector<cool::IRecordSelection*> >*)arg[1]);
}

static  void method_3597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->swap)(*(::std::vector<cool::IRecordSelection*>*)arg[0]);
}

static  void method_3598( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IRecordSelection*>*)o)->clear)();
}

static void method_newdel_1402( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >")), ::Reflex::BaseOffset< ::std::vector<cool::IRecordSelection*>,::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::IRecordSelection*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::IRecordSelection*> >::Generate();
}

//------Dictionary for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
void __std__vector_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void __std__vector_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__IRecordSelectionp__datamem_bld(&__std__vector_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__IRecordSelectionp__funcmem_bld(&__std__vector_cool__IRecordSelectionp__db_funcmem);
void __std__vector_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::IRecordSelection*>"), typeid(::std::vector<cool::IRecordSelection*>), sizeof(::std::vector<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1679, ::Reflex::BaseOffset< ::std::vector<cool::IRecordSelection*>, ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3538, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Alloc_value_type"))
  .AddTypedef(type_1679, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Base"))
  .AddTypedef(type_1543, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Tp_alloc_type"))
  .AddTypedef(type_2041, Reflex::Literal("std::vector<cool::IRecordSelection*>::_Alloc_traits"))
  .AddTypedef(type_3538, Reflex::Literal("std::vector<cool::IRecordSelection*>::value_type"))
  .AddTypedef(type_3544, Reflex::Literal("std::vector<cool::IRecordSelection*>::pointer"))
  .AddTypedef(type_3546, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_pointer"))
  .AddTypedef(type_3548, Reflex::Literal("std::vector<cool::IRecordSelection*>::reference"))
  .AddTypedef(type_3550, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_reference"))
  .AddTypedef(type_2133, Reflex::Literal("std::vector<cool::IRecordSelection*>::iterator"))
  .AddTypedef(type_2134, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_iterator"))
  .AddTypedef(type_1655, Reflex::Literal("std::vector<cool::IRecordSelection*>::const_reverse_iterator"))
  .AddTypedef(type_1656, Reflex::Literal("std::vector<cool::IRecordSelection*>::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<cool::IRecordSelection*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<cool::IRecordSelection*>::difference_type"))
  .AddTypedef(type_1543, Reflex::Literal("std::vector<cool::IRecordSelection*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3559, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9321), Reflex::Literal("vector"), constructor_3560, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3550, type_9321), Reflex::Literal("vector"), constructor_3561, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9322), Reflex::Literal("vector"), constructor_3562, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3563, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1402, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__IRecordSelectionp__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std__vector_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std__vector_cool__IRecordSelectionp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9323, type_9322), Reflex::Literal("operator="), operator_3564, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3550), Reflex::Literal("assign"), method_3565, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2133), Reflex::Literal("begin"), method_3566, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2134), Reflex::Literal("begin"), method_3567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2133), Reflex::Literal("end"), method_3568, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2134), Reflex::Literal("end"), method_3569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3538), Reflex::Literal("resize"), method_3576, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3579, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3548, type_1636), Reflex::Literal("operator[]"), operator_3580, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3550, type_1636), Reflex::Literal("operator[]"), operator_3581, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3548, type_1636), Reflex::Literal("at"), method_3583, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3550, type_1636), Reflex::Literal("at"), method_3584, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3548), Reflex::Literal("front"), method_3585, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3550), Reflex::Literal("front"), method_3586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3548), Reflex::Literal("back"), method_3587, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3550), Reflex::Literal("back"), method_3588, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3544), Reflex::Literal("data"), method_3589, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3546), Reflex::Literal("data"), method_3590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3550), Reflex::Literal("push_back"), method_3591, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2133, type_2133, type_3550), Reflex::Literal("insert"), method_3593, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2133, type_1636, type_3550), Reflex::Literal("insert"), method_3594, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2133, type_2133), Reflex::Literal("erase"), method_3595, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2133, type_2133, type_2133), Reflex::Literal("erase"), method_3596, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9323), Reflex::Literal("swap"), method_3597, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3598, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
static void constructor_3628( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>();
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>();
}

static void constructor_3629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_3630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[2]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(::std::size_t*)arg[0],
      *(::cool::IFieldSpecification* const*)arg[1],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[2]);
  }
}

static void constructor_3631( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<cool::IFieldSpecification*>(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
}

static void destructor_3632(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::IFieldSpecification*>*)o)->::std::vector<cool::IFieldSpecification*>::~vector();
}
static  void operator_3633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::vector<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_3634( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]);
}

static  void method_3635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->begin)());
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->begin)();
}

static  void method_3636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> >)((((const ::std::vector<cool::IFieldSpecification*>*)o)->begin)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->begin)();
}

static  void method_3637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->end)());
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->end)();
}

static  void method_3638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification* const*,std::vector<cool::IFieldSpecification*> >)((((const ::std::vector<cool::IFieldSpecification*>*)o)->end)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->end)();
}

static  void method_3643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IFieldSpecification*>*)o)->size)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->size)();
}

static  void method_3644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IFieldSpecification*>*)o)->max_size)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->max_size)();
}

static  void method_3645( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::IFieldSpecification*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::IFieldSpecification*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::cool::IFieldSpecification*)arg[1]);
  }
}

static  void method_3646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::IFieldSpecification*>*)o)->capacity)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->capacity)();
}

static  void method_3647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::IFieldSpecification*>*)o)->empty)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->empty)();
}

static  void method_3648( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->front)();
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->front)();
}

static  void method_3655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->front)();
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->front)();
}

static  void method_3656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::IFieldSpecification*>*)o)->back)();
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->back)();
}

static  void method_3657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::IFieldSpecification*>*)o)->back)();
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->back)();
}

static  void method_3658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::IFieldSpecification*>*)o)->data)());
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->data)();
}

static  void method_3659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::IFieldSpecification*>*)o)->data)());
  else   (((const ::std::vector<cool::IFieldSpecification*>*)o)->data)();
}

static  void method_3660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->push_back)(*(::cool::IFieldSpecification* const*)arg[0]);
}

static  void method_3661( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->pop_back)();
}

static  void method_3662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]));
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]);
}

static  void method_3663( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::cool::IFieldSpecification* const*)arg[2]);
}

static  void method_3664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0]));
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0]);
}

static  void method_3665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >)((((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[1]));
  else   (((::std::vector<cool::IFieldSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::IFieldSpecification**,std::vector<cool::IFieldSpecification*> >*)arg[1]);
}

static  void method_3666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->swap)(*(::std::vector<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_3667( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::IFieldSpecification*>*)o)->clear)();
}

static void method_newdel_1404( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >")), ::Reflex::BaseOffset< ::std::vector<cool::IFieldSpecification*>,::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::IFieldSpecification*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::IFieldSpecification*> >::Generate();
}

//------Dictionary for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
void __std__vector_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void __std__vector_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldSpecificationp__datamem_bld(&__std__vector_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__IFieldSpecificationp__funcmem_bld(&__std__vector_cool__IFieldSpecificationp__db_funcmem);
void __std__vector_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::IFieldSpecification*>"), typeid(::std::vector<cool::IFieldSpecification*>), sizeof(::std::vector<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1681, ::Reflex::BaseOffset< ::std::vector<cool::IFieldSpecification*>, ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3607, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Alloc_value_type"))
  .AddTypedef(type_1681, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Base"))
  .AddTypedef(type_1545, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Tp_alloc_type"))
  .AddTypedef(type_2043, Reflex::Literal("std::vector<cool::IFieldSpecification*>::_Alloc_traits"))
  .AddTypedef(type_3607, Reflex::Literal("std::vector<cool::IFieldSpecification*>::value_type"))
  .AddTypedef(type_3613, Reflex::Literal("std::vector<cool::IFieldSpecification*>::pointer"))
  .AddTypedef(type_3615, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_pointer"))
  .AddTypedef(type_3617, Reflex::Literal("std::vector<cool::IFieldSpecification*>::reference"))
  .AddTypedef(type_3619, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_reference"))
  .AddTypedef(type_2137, Reflex::Literal("std::vector<cool::IFieldSpecification*>::iterator"))
  .AddTypedef(type_2138, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_iterator"))
  .AddTypedef(type_1659, Reflex::Literal("std::vector<cool::IFieldSpecification*>::const_reverse_iterator"))
  .AddTypedef(type_1660, Reflex::Literal("std::vector<cool::IFieldSpecification*>::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<cool::IFieldSpecification*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<cool::IFieldSpecification*>::difference_type"))
  .AddTypedef(type_1545, Reflex::Literal("std::vector<cool::IFieldSpecification*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3628, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9325), Reflex::Literal("vector"), constructor_3629, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3619, type_9325), Reflex::Literal("vector"), constructor_3630, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9326), Reflex::Literal("vector"), constructor_3631, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3632, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1404, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__IFieldSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std__vector_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std__vector_cool__IFieldSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9327, type_9326), Reflex::Literal("operator="), operator_3633, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3619), Reflex::Literal("assign"), method_3634, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2137), Reflex::Literal("begin"), method_3635, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2138), Reflex::Literal("begin"), method_3636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2137), Reflex::Literal("end"), method_3637, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2138), Reflex::Literal("end"), method_3638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3607), Reflex::Literal("resize"), method_3645, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3648, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3617, type_1636), Reflex::Literal("operator[]"), operator_3649, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3619, type_1636), Reflex::Literal("operator[]"), operator_3650, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3617, type_1636), Reflex::Literal("at"), method_3652, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3619, type_1636), Reflex::Literal("at"), method_3653, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3617), Reflex::Literal("front"), method_3654, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3619), Reflex::Literal("front"), method_3655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3617), Reflex::Literal("back"), method_3656, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3619), Reflex::Literal("back"), method_3657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3613), Reflex::Literal("data"), method_3658, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3615), Reflex::Literal("data"), method_3659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3619), Reflex::Literal("push_back"), method_3660, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3661, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2137, type_2137, type_3619), Reflex::Literal("insert"), method_3662, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2137, type_1636, type_3619), Reflex::Literal("insert"), method_3663, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2137, type_2137), Reflex::Literal("erase"), method_3664, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2137, type_2137, type_2137), Reflex::Literal("erase"), method_3665, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9327), Reflex::Literal("swap"), method_3666, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3667, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class ChannelSelection -------------------------------
static void destructor_8545(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelSelection*)o)->::cool::ChannelSelection::~ChannelSelection();
}
static  void operator_8546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelSelection*)o)->operator=)(*(const ::cool::ChannelSelection*)arg[0]);
  else   (((::cool::ChannelSelection*)o)->operator=)(*(const ::cool::ChannelSelection*)arg[0]);
}

static void constructor_8547( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection*)arg[0]);
}

static void constructor_8548( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection();
  else ::new(mem) ::cool::ChannelSelection();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection::Order*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelSelection::Order*)arg[0]);
  }
}

static void constructor_8549( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0]);
}

static void constructor_8550( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::cool::ChannelSelection::Order*)arg[2]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::cool::ChannelSelection::Order*)arg[2]);
  }
}

static void constructor_8551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelSelection::Order*)arg[1]);
  else ::new(mem) ::cool::ChannelSelection(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelSelection::Order*)arg[1]);
  }
}

static  void method_8552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->allChannels)());
  else   (((const ::cool::ChannelSelection*)o)->allChannels)();
}

static  void method_8553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection*)o)->firstChannel)());
  else   (((const ::cool::ChannelSelection*)o)->firstChannel)();
}

static  void method_8554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection*)o)->lastChannel)());
  else   (((const ::cool::ChannelSelection*)o)->lastChannel)();
}

static  void method_8555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ChannelSelection*)o)->order)());
  else   (((const ::cool::ChannelSelection*)o)->order)();
}

static  void method_8556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (cool::ChannelSelection)((((::cool::ChannelSelection*)o)->all)());
    else     (((::cool::ChannelSelection*)o)->all)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (cool::ChannelSelection)((((::cool::ChannelSelection*)o)->all)(*(const ::cool::ChannelSelection::Order*)arg[0]));
    else     (((::cool::ChannelSelection*)o)->all)(*(const ::cool::ChannelSelection::Order*)arg[0]);
  }
}

static  void method_8557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::ChannelSelection*)o)->inSelection)(*(const ::std::string*)arg[0]);
}

static  void method_8559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->isContiguous)());
  else   (((const ::cool::ChannelSelection*)o)->isContiguous)();
}

static  void method_8560( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::ChannelSelection*)o)->addRange)(*(const ::cool::ChannelId*)arg[0],
    *(const ::cool::ChannelId*)arg[1]);
}

static  void method_8561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::ChannelSelection*)o)->addChannel)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection*)o)->isNumeric)());
  else   (((const ::cool::ChannelSelection*)o)->isNumeric)();
}

static  void method_8563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ChannelSelection*)o)->channelName)();
  else   (((const ::cool::ChannelSelection*)o)->channelName)();
}

static  void method_8564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::cool::ChannelSelection*)o)->begin)());
  else   (((const ::cool::ChannelSelection*)o)->begin)();
}

static  void method_8565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::cool::ChannelSelection*)o)->end)());
  else   (((const ::cool::ChannelSelection*)o)->end)();
}

static  void method_8566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::ChannelSelection*)o)->rangeCount)());
  else   (((const ::cool::ChannelSelection*)o)->rangeCount)();
}

static void constructor_x29( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection();
  else ::new(mem) ::cool::ChannelSelection();
}

static void method_newdel_2389( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ChannelSelection -------------------------------
void __cool__ChannelSelection_db_datamem(Reflex::Class*);
void __cool__ChannelSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection_datamem_bld(&__cool__ChannelSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection_funcmem_bld(&__cool__ChannelSelection_db_funcmem);
void __cool__ChannelSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelSelection"), typeid(::cool::ChannelSelection), sizeof(::cool::ChannelSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddEnum(Reflex::Literal("cool::ChannelSelection::Order"), Reflex::Literal("channelBeforeSince=0;sinceBeforeChannel=1;channelBeforeSinceDesc=2;sinceDescBeforeChannel=3"), &typeid(cool::ChannelSelection::Order), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelSelection"), destructor_8545, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10320, type_10321), Reflex::Literal("operator="), operator_8546, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10321), Reflex::Literal("ChannelSelection"), constructor_8547, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10322), Reflex::Literal("ChannelSelection"), constructor_8548, 0, "order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10145), Reflex::Literal("ChannelSelection"), constructor_8549, 0, "channel", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10145, type_10145, type_10322), Reflex::Literal("ChannelSelection"), constructor_8550, 0, "firstChannel;lastChannel;order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10322), Reflex::Literal("ChannelSelection"), constructor_8551, 0, "channelName;order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ChannelSelection"), constructor_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2389, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__ChannelSelection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__ChannelSelection_funcmem_bld);
}

//------Delayed data member builder for class ChannelSelection -------------------
void __cool__ChannelSelection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1881, Reflex::Literal("m_isNumeric"), OffsetOf(__shadow__::__cool__ChannelSelection, m_isNumeric), ::Reflex::PRIVATE)
  .AddDataMember(type_1881, Reflex::Literal("m_allChannels"), OffsetOf(__shadow__::__cool__ChannelSelection, m_allChannels), ::Reflex::PRIVATE)
  .AddDataMember(type_1405, Reflex::Literal("m_ranges"), OffsetOf(__shadow__::__cool__ChannelSelection, m_ranges), ::Reflex::PRIVATE)
  .AddDataMember(type_1450, Reflex::Literal("m_channelName"), OffsetOf(__shadow__::__cool__ChannelSelection, m_channelName), ::Reflex::PRIVATE)
  .AddDataMember(type_8544, Reflex::Literal("m_order"), OffsetOf(__shadow__::__cool__ChannelSelection, m_order), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ChannelSelection -------------------
void __cool__ChannelSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("allChannels"), method_8552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314), Reflex::Literal("firstChannel"), method_8553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314), Reflex::Literal("lastChannel"), method_8554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8544), Reflex::Literal("order"), method_8555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2389c, type_10322), Reflex::Literal("all"), method_8556, 0, "order=channelBeforeSince", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10145), Reflex::Literal("inSelection"), method_8557, 0, "channel", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("inSelection"), method_8558, 0, "channelName", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isContiguous"), method_8559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10145, type_10145), Reflex::Literal("addRange"), method_8560, 0, "firstChannel;lastChannel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10145), Reflex::Literal("addChannel"), method_8561, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isNumeric"), method_8562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("channelName"), method_8563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2140), Reflex::Literal("begin"), method_8564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2140), Reflex::Literal("end"), method_8565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_80), Reflex::Literal("rangeCount"), method_8566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ChannelRange -------------------------------
static void destructor_9330(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelSelection::ChannelRange*)o)->::cool::ChannelSelection::ChannelRange::~ChannelRange();
}
static  void operator_9331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelSelection::ChannelRange*)o)->operator=)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
  else   (((::cool::ChannelSelection::ChannelRange*)o)->operator=)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static void constructor_9332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
  else ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static void constructor_9333( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection::ChannelRange();
  else ::new(mem) ::cool::ChannelSelection::ChannelRange();
}

static void constructor_9334( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  else ::new(mem) ::cool::ChannelSelection::ChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
}

static  void method_9335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection::ChannelRange*)o)->firstChannel)());
  else   (((const ::cool::ChannelSelection::ChannelRange*)o)->firstChannel)();
}

static  void method_9336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::ChannelSelection::ChannelRange*)o)->lastChannel)());
  else   (((const ::cool::ChannelSelection::ChannelRange*)o)->lastChannel)();
}

static  void method_9337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ChannelSelection::ChannelRange*)o)->inRange)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::ChannelSelection::ChannelRange*)o)->inRange)(*(const ::cool::ChannelId*)arg[0]);
}

static void method_newdel_3676( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::ChannelSelection::ChannelRange >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ChannelRange -------------------------------
void __cool__ChannelSelection__ChannelRange_db_datamem(Reflex::Class*);
void __cool__ChannelSelection__ChannelRange_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection__ChannelRange_datamem_bld(&__cool__ChannelSelection__ChannelRange_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelSelection__ChannelRange_funcmem_bld(&__cool__ChannelSelection__ChannelRange_db_funcmem);
void __cool__ChannelSelection__ChannelRange_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelSelection::ChannelRange"), typeid(::cool::ChannelSelection::ChannelRange), sizeof(::cool::ChannelSelection::ChannelRange), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelRange"), destructor_9330, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3686, type_3688), Reflex::Literal("operator="), operator_9331, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3688), Reflex::Literal("ChannelRange"), constructor_9332, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ChannelRange"), constructor_9333, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10145, type_10145), Reflex::Literal("ChannelRange"), constructor_9334, 0, "firstChannel;lastChannel", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3676, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__ChannelSelection__ChannelRange_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__ChannelSelection__ChannelRange_funcmem_bld);
}

//------Delayed data member builder for class ChannelRange -------------------
void __cool__ChannelSelection__ChannelRange_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2314, Reflex::Literal("m_firstChannel"), OffsetOf(__shadow__::__cool__ChannelSelection__ChannelRange, m_firstChannel), ::Reflex::PRIVATE)
  .AddDataMember(type_2314, Reflex::Literal("m_lastChannel"), OffsetOf(__shadow__::__cool__ChannelSelection__ChannelRange, m_lastChannel), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ChannelRange -------------------
void __cool__ChannelSelection__ChannelRange_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314), Reflex::Literal("firstChannel"), method_9335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314), Reflex::Literal("lastChannel"), method_9336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10145), Reflex::Literal("inRange"), method_9337, 0, "channel", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
static void constructor_3697( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>();
}

static void constructor_3698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_3699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[2]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(::std::size_t*)arg[0],
      *(const ::cool::ChannelSelection::ChannelRange*)arg[1],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[2]);
  }
}

static void constructor_3700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::vector<cool::ChannelSelection::ChannelRange>(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void destructor_3701(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->::std::vector<cool::ChannelSelection::ChannelRange>::~vector();
}
static  void operator_3702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_3703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_3704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)());
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)();
}

static  void method_3705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->begin)();
}

static  void method_3706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)());
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)();
}

static  void method_3707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->end)();
}

static  void method_3712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->size)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->size)();
}

static  void method_3713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->max_size)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->max_size)();
}

static  void method_3714( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::cool::ChannelSelection::ChannelRange*)arg[1]);
  }
}

static  void method_3715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->capacity)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->capacity)();
}

static  void method_3716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->empty)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->empty)();
}

static  void method_3717( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
}

static  void method_3724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->front)();
}

static  void method_3725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
}

static  void method_3726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->back)();
}

static  void method_3727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)());
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)();
}

static  void method_3728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)());
  else   (((const ::std::vector<cool::ChannelSelection::ChannelRange>*)o)->data)();
}

static  void method_3729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->push_back)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static  void method_3730( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->pop_back)();
}

static  void method_3731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]));
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_3732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[2]);
}

static  void method_3733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0]));
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static  void method_3734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >)((((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[1]));
  else   (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cool::ChannelSelection::ChannelRange*,std::vector<cool::ChannelSelection::ChannelRange> >*)arg[1]);
}

static  void method_3735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->swap)(*(::std::vector<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_3736( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cool::ChannelSelection::ChannelRange>*)o)->clear)();
}

static void method_newdel_1405( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >")), ::Reflex::BaseOffset< ::std::vector<cool::ChannelSelection::ChannelRange>,::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cool::ChannelSelection::ChannelRange> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cool::ChannelSelection::ChannelRange> >::Generate();
}

//------Dictionary for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
void __std__vector_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void __std__vector_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cool__ChannelSelection__ChannelRange__datamem_bld(&__std__vector_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cool__ChannelSelection__ChannelRange__funcmem_bld(&__std__vector_cool__ChannelSelection__ChannelRange__db_funcmem);
void __std__vector_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>"), typeid(::std::vector<cool::ChannelSelection::ChannelRange>), sizeof(::std::vector<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_1682, ::Reflex::BaseOffset< ::std::vector<cool::ChannelSelection::ChannelRange>, ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3676, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Alloc_value_type"))
  .AddTypedef(type_1682, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Base"))
  .AddTypedef(type_1546, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Tp_alloc_type"))
  .AddTypedef(type_2044, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::_Alloc_traits"))
  .AddTypedef(type_3676, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::value_type"))
  .AddTypedef(type_3682, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::pointer"))
  .AddTypedef(type_3684, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_pointer"))
  .AddTypedef(type_3686, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::reference"))
  .AddTypedef(type_3688, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_reference"))
  .AddTypedef(type_2139, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::iterator"))
  .AddTypedef(type_2140, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_iterator"))
  .AddTypedef(type_1661, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::const_reverse_iterator"))
  .AddTypedef(type_1662, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::difference_type"))
  .AddTypedef(type_1546, Reflex::Literal("std::vector<cool::ChannelSelection::ChannelRange>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3697, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9339), Reflex::Literal("vector"), constructor_3698, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3688, type_9339), Reflex::Literal("vector"), constructor_3699, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9340), Reflex::Literal("vector"), constructor_3700, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3701, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1405, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cool__ChannelSelection__ChannelRange__funcmem_bld);
}

//------Delayed data member builder for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std__vector_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std__vector_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9341, type_9340), Reflex::Literal("operator="), operator_3702, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3688), Reflex::Literal("assign"), method_3703, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2139), Reflex::Literal("begin"), method_3704, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2140), Reflex::Literal("begin"), method_3705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2139), Reflex::Literal("end"), method_3706, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2140), Reflex::Literal("end"), method_3707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3676), Reflex::Literal("resize"), method_3714, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3717, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3686, type_1636), Reflex::Literal("operator[]"), operator_3718, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3688, type_1636), Reflex::Literal("operator[]"), operator_3719, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3686, type_1636), Reflex::Literal("at"), method_3721, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3688, type_1636), Reflex::Literal("at"), method_3722, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3686), Reflex::Literal("front"), method_3723, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3688), Reflex::Literal("front"), method_3724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3686), Reflex::Literal("back"), method_3725, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3688), Reflex::Literal("back"), method_3726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3682), Reflex::Literal("data"), method_3727, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3684), Reflex::Literal("data"), method_3728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3688), Reflex::Literal("push_back"), method_3729, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3730, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2139, type_2139, type_3688), Reflex::Literal("insert"), method_3731, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2139, type_1636, type_3688), Reflex::Literal("insert"), method_3732, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2139, type_2139), Reflex::Literal("erase"), method_3733, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2139, type_2139, type_2139), Reflex::Literal("erase"), method_3734, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9341), Reflex::Literal("swap"), method_3735, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3736, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
static void constructor_3763( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>();
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>();
}

static void constructor_3764( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_3765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[2]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(::std::size_t*)arg[0],
      *(::coral::AttributeSpecification* const*)arg[1],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[2]);
  }
}

static void constructor_3766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::AttributeSpecification*>(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
}

static void destructor_3767(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<coral::AttributeSpecification*>*)o)->::std::vector<coral::AttributeSpecification*>::~vector();
}
static  void operator_3768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::vector<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_3769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]);
}

static  void method_3770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->begin)());
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->begin)();
}

static  void method_3771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::std::vector<coral::AttributeSpecification*>*)o)->begin)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->begin)();
}

static  void method_3772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->end)());
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->end)();
}

static  void method_3773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::std::vector<coral::AttributeSpecification*>*)o)->end)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->end)();
}

static  void method_3778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::AttributeSpecification*>*)o)->size)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->size)();
}

static  void method_3779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::AttributeSpecification*>*)o)->max_size)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->max_size)();
}

static  void method_3780( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<coral::AttributeSpecification*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<coral::AttributeSpecification*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::coral::AttributeSpecification*)arg[1]);
  }
}

static  void method_3781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::AttributeSpecification*>*)o)->capacity)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->capacity)();
}

static  void method_3782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<coral::AttributeSpecification*>*)o)->empty)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->empty)();
}

static  void method_3783( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->front)();
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->front)();
}

static  void method_3790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->front)();
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->front)();
}

static  void method_3791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::AttributeSpecification*>*)o)->back)();
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->back)();
}

static  void method_3792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::AttributeSpecification*>*)o)->back)();
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->back)();
}

static  void method_3793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<coral::AttributeSpecification*>*)o)->data)());
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->data)();
}

static  void method_3794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<coral::AttributeSpecification*>*)o)->data)());
  else   (((const ::std::vector<coral::AttributeSpecification*>*)o)->data)();
}

static  void method_3795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->push_back)(*(::coral::AttributeSpecification* const*)arg[0]);
}

static  void method_3796( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->pop_back)();
}

static  void method_3797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]));
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]);
}

static  void method_3798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::coral::AttributeSpecification* const*)arg[2]);
}

static  void method_3799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0]));
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static  void method_3800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >)((((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[1]));
  else   (((::std::vector<coral::AttributeSpecification*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification**,std::vector<coral::AttributeSpecification*> >*)arg[1]);
}

static  void method_3801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->swap)(*(::std::vector<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_3802( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::AttributeSpecification*>*)o)->clear)();
}

static void method_newdel_1406( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >")), ::Reflex::BaseOffset< ::std::vector<coral::AttributeSpecification*>,::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<coral::AttributeSpecification*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<coral::AttributeSpecification*> >::Generate();
}

//------Dictionary for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
void __std__vector_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void __std__vector_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_coral__AttributeSpecificationp__datamem_bld(&__std__vector_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_coral__AttributeSpecificationp__funcmem_bld(&__std__vector_coral__AttributeSpecificationp__db_funcmem);
void __std__vector_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<coral::AttributeSpecification*>"), typeid(::std::vector<coral::AttributeSpecification*>), sizeof(::std::vector<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_1683, ::Reflex::BaseOffset< ::std::vector<coral::AttributeSpecification*>, ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3149, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Alloc_value_type"))
  .AddTypedef(type_1683, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Base"))
  .AddTypedef(type_1547, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Tp_alloc_type"))
  .AddTypedef(type_2047, Reflex::Literal("std::vector<coral::AttributeSpecification*>::_Alloc_traits"))
  .AddTypedef(type_3149, Reflex::Literal("std::vector<coral::AttributeSpecification*>::value_type"))
  .AddTypedef(type_3750, Reflex::Literal("std::vector<coral::AttributeSpecification*>::pointer"))
  .AddTypedef(type_3152, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_pointer"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<coral::AttributeSpecification*>::reference"))
  .AddTypedef(type_3154, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_reference"))
  .AddTypedef(type_2142, Reflex::Literal("std::vector<coral::AttributeSpecification*>::iterator"))
  .AddTypedef(type_2141, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_iterator"))
  .AddTypedef(type_1665, Reflex::Literal("std::vector<coral::AttributeSpecification*>::const_reverse_iterator"))
  .AddTypedef(type_1666, Reflex::Literal("std::vector<coral::AttributeSpecification*>::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<coral::AttributeSpecification*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<coral::AttributeSpecification*>::difference_type"))
  .AddTypedef(type_1547, Reflex::Literal("std::vector<coral::AttributeSpecification*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3763, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9342), Reflex::Literal("vector"), constructor_3764, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3154, type_9342), Reflex::Literal("vector"), constructor_3765, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9343), Reflex::Literal("vector"), constructor_3766, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3767, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1406, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_coral__AttributeSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std__vector_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std__vector_coral__AttributeSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9344, type_9343), Reflex::Literal("operator="), operator_3768, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3154), Reflex::Literal("assign"), method_3769, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2142), Reflex::Literal("begin"), method_3770, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141), Reflex::Literal("begin"), method_3771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2142), Reflex::Literal("end"), method_3772, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141), Reflex::Literal("end"), method_3773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3149), Reflex::Literal("resize"), method_3780, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3783, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3753, type_1636), Reflex::Literal("operator[]"), operator_3784, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3154, type_1636), Reflex::Literal("operator[]"), operator_3785, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3753, type_1636), Reflex::Literal("at"), method_3787, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3154, type_1636), Reflex::Literal("at"), method_3788, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3753), Reflex::Literal("front"), method_3789, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3154), Reflex::Literal("front"), method_3790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3753), Reflex::Literal("back"), method_3791, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3154), Reflex::Literal("back"), method_3792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3750), Reflex::Literal("data"), method_3793, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3152), Reflex::Literal("data"), method_3794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3154), Reflex::Literal("push_back"), method_3795, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2142, type_2142, type_3154), Reflex::Literal("insert"), method_3797, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2142, type_1636, type_3154), Reflex::Literal("insert"), method_3798, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2142, type_2142), Reflex::Literal("erase"), method_3799, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2142, type_2142, type_2142), Reflex::Literal("erase"), method_3800, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9344), Reflex::Literal("swap"), method_3801, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3802, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
static void constructor_3827( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>();
  else ::new(mem) ::std::vector<coral::Attribute*>();
}

static void constructor_3828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_3829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1],
      *(const ::std::allocator<coral::Attribute*>*)arg[2]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(::std::size_t*)arg[0],
      *(::coral::Attribute* const*)arg[1],
      *(const ::std::allocator<coral::Attribute*>*)arg[2]);
  }
}

static void constructor_3830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::vector<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::vector<coral::Attribute*>(*(const ::std::vector<coral::Attribute*>*)arg[0]);
}

static void destructor_3831(void*, void * o, const std::vector<void*>&, void *) {
((::std::vector<coral::Attribute*>*)o)->::std::vector<coral::Attribute*>::~vector();
}
static  void operator_3832( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->operator=)(*(const ::std::vector<coral::Attribute*>*)arg[0]);
  else   (((::std::vector<coral::Attribute*>*)o)->operator=)(*(const ::std::vector<coral::Attribute*>*)arg[0]);
}

static  void method_3833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::coral::Attribute* const*)arg[1]);
}

static  void method_3834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->begin)());
  else   (((::std::vector<coral::Attribute*>*)o)->begin)();
}

static  void method_3835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::std::vector<coral::Attribute*>*)o)->begin)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->begin)();
}

static  void method_3836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->end)());
  else   (((::std::vector<coral::Attribute*>*)o)->end)();
}

static  void method_3837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::std::vector<coral::Attribute*>*)o)->end)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->end)();
}

static  void method_3842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::Attribute*>*)o)->size)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->size)();
}

static  void method_3843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::Attribute*>*)o)->max_size)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->max_size)();
}

static  void method_3844( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<coral::Attribute*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<coral::Attribute*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::coral::Attribute*)arg[1]);
  }
}

static  void method_3845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<coral::Attribute*>*)o)->capacity)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->capacity)();
}

static  void method_3846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<coral::Attribute*>*)o)->empty)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->empty)();
}

static  void method_3847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::Attribute*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<coral::Attribute*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->front)();
  else   (((::std::vector<coral::Attribute*>*)o)->front)();
}

static  void method_3854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->front)();
  else   (((const ::std::vector<coral::Attribute*>*)o)->front)();
}

static  void method_3855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<coral::Attribute*>*)o)->back)();
  else   (((::std::vector<coral::Attribute*>*)o)->back)();
}

static  void method_3856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<coral::Attribute*>*)o)->back)();
  else   (((const ::std::vector<coral::Attribute*>*)o)->back)();
}

static  void method_3857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<coral::Attribute*>*)o)->data)());
  else   (((::std::vector<coral::Attribute*>*)o)->data)();
}

static  void method_3858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<coral::Attribute*>*)o)->data)());
  else   (((const ::std::vector<coral::Attribute*>*)o)->data)();
}

static  void method_3859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->push_back)(*(::coral::Attribute* const*)arg[0]);
}

static  void method_3860( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->pop_back)();
}

static  void method_3861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::coral::Attribute* const*)arg[1]));
  else   (((::std::vector<coral::Attribute*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::coral::Attribute* const*)arg[1]);
}

static  void method_3862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::coral::Attribute* const*)arg[2]);
}

static  void method_3863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]));
  else   (((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
}

static  void method_3864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[1]));
  else   (((::std::vector<coral::Attribute*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[1]);
}

static  void method_3865( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->swap)(*(::std::vector<coral::Attribute*>*)arg[0]);
}

static  void method_3866( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<coral::Attribute*>*)o)->clear)();
}

static void method_newdel_1407( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >")), ::Reflex::BaseOffset< ::std::vector<coral::Attribute*>,::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<coral::Attribute*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<coral::Attribute*> >::Generate();
}

//------Dictionary for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
void __std__vector_coral__Attributep__db_datamem(Reflex::Class*);
void __std__vector_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_coral__Attributep__datamem_bld(&__std__vector_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_coral__Attributep__funcmem_bld(&__std__vector_coral__Attributep__db_funcmem);
void __std__vector_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<coral::Attribute*>"), typeid(::std::vector<coral::Attribute*>), sizeof(::std::vector<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_1684, ::Reflex::BaseOffset< ::std::vector<coral::Attribute*>, ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3161, Reflex::Literal("std::vector<coral::Attribute*>::_Alloc_value_type"))
  .AddTypedef(type_1684, Reflex::Literal("std::vector<coral::Attribute*>::_Base"))
  .AddTypedef(type_1550, Reflex::Literal("std::vector<coral::Attribute*>::_Tp_alloc_type"))
  .AddTypedef(type_2048, Reflex::Literal("std::vector<coral::Attribute*>::_Alloc_traits"))
  .AddTypedef(type_3161, Reflex::Literal("std::vector<coral::Attribute*>::value_type"))
  .AddTypedef(type_3164, Reflex::Literal("std::vector<coral::Attribute*>::pointer"))
  .AddTypedef(type_3175, Reflex::Literal("std::vector<coral::Attribute*>::const_pointer"))
  .AddTypedef(type_3166, Reflex::Literal("std::vector<coral::Attribute*>::reference"))
  .AddTypedef(type_3177, Reflex::Literal("std::vector<coral::Attribute*>::const_reference"))
  .AddTypedef(type_2143, Reflex::Literal("std::vector<coral::Attribute*>::iterator"))
  .AddTypedef(type_2144, Reflex::Literal("std::vector<coral::Attribute*>::const_iterator"))
  .AddTypedef(type_1667, Reflex::Literal("std::vector<coral::Attribute*>::const_reverse_iterator"))
  .AddTypedef(type_1668, Reflex::Literal("std::vector<coral::Attribute*>::reverse_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<coral::Attribute*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::vector<coral::Attribute*>::difference_type"))
  .AddTypedef(type_1550, Reflex::Literal("std::vector<coral::Attribute*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3827, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9345), Reflex::Literal("vector"), constructor_3828, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_3177, type_9345), Reflex::Literal("vector"), constructor_3829, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9346), Reflex::Literal("vector"), constructor_3830, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3831, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1407, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_coral__Attributep__funcmem_bld);
}

//------Delayed data member builder for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std__vector_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std__vector_coral__Attributep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9347, type_9346), Reflex::Literal("operator="), operator_3832, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3177), Reflex::Literal("assign"), method_3833, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143), Reflex::Literal("begin"), method_3834, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144), Reflex::Literal("begin"), method_3835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143), Reflex::Literal("end"), method_3836, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144), Reflex::Literal("end"), method_3837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_3842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_3843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636, type_3161), Reflex::Literal("resize"), method_3844, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("capacity"), method_3845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_3846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1636), Reflex::Literal("reserve"), method_3847, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3166, type_1636), Reflex::Literal("operator[]"), operator_3848, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3177, type_1636), Reflex::Literal("operator[]"), operator_3849, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3166, type_1636), Reflex::Literal("at"), method_3851, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3177, type_1636), Reflex::Literal("at"), method_3852, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3166), Reflex::Literal("front"), method_3853, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3177), Reflex::Literal("front"), method_3854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3166), Reflex::Literal("back"), method_3855, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3177), Reflex::Literal("back"), method_3856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3164), Reflex::Literal("data"), method_3857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3175), Reflex::Literal("data"), method_3858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3177), Reflex::Literal("push_back"), method_3859, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("pop_back"), method_3860, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143, type_2143, type_3177), Reflex::Literal("insert"), method_3861, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2143, type_1636, type_3177), Reflex::Literal("insert"), method_3862, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143, type_2143), Reflex::Literal("erase"), method_3863, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143, type_2143, type_2143), Reflex::Literal("erase"), method_3864, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9347), Reflex::Literal("swap"), method_3865, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_3866, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
static  void operator_4732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_4733( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >();
}

static void constructor_4734( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void destructor_4735(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IRecord> >*)o)->::std::allocator<boost::shared_ptr<cool::IRecord> >::~allocator();
}
static void method_newdel_1540( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >")), ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IRecord> >,::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >"), typeid(::std::allocator<boost::shared_ptr<cool::IRecord> >), sizeof(::std::allocator<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_2067, ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IRecord> >, ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::difference_type"))
  .AddTypedef(type_3119, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::pointer"))
  .AddTypedef(type_3343, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::const_pointer"))
  .AddTypedef(type_3121, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::reference"))
  .AddTypedef(type_3346, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::const_reference"))
  .AddTypedef(type_2399, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9567, type_9309), Reflex::Literal("operator="), operator_4732, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4733, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9309), Reflex::Literal("allocator"), constructor_4734, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4735, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1540, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<boost::shared_ptr<cool::IObject> > -------------------------------
static  void operator_4743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_4744( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >();
}

static void constructor_4745( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void destructor_4746(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IObject> >*)o)->::std::allocator<boost::shared_ptr<cool::IObject> >::~allocator();
}
static void method_newdel_1541( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >")), ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IObject> >,::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<boost::shared_ptr<cool::IObject> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >"), typeid(::std::allocator<boost::shared_ptr<cool::IObject> >), sizeof(::std::allocator<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_2068, ::Reflex::BaseOffset< ::std::allocator<boost::shared_ptr<cool::IObject> >, ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::difference_type"))
  .AddTypedef(type_3130, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::pointer"))
  .AddTypedef(type_3409, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::const_pointer"))
  .AddTypedef(type_3132, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::reference"))
  .AddTypedef(type_3412, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::const_reference"))
  .AddTypedef(type_2290, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9568, type_9313), Reflex::Literal("operator="), operator_4743, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4744, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9313), Reflex::Literal("allocator"), constructor_4745, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4746, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1541, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::IField*> -------------------------------
static  void operator_4754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else   (((::std::allocator<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void constructor_4755( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>();
  else ::new(mem) ::std::allocator<cool::IField*>();
}

static void constructor_4756( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IField*>(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void destructor_4757(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IField*>*)o)->::std::allocator<cool::IField*>::~allocator();
}
static void method_newdel_1542( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>")), ::Reflex::BaseOffset< ::std::allocator<cool::IField*>,::__gnu_cxx::new_allocator<cool::IField*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::IField*> -------------------------------
void __std__allocator_cool__IFieldp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp__datamem_bld(&__std__allocator_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp__funcmem_bld(&__std__allocator_cool__IFieldp__db_funcmem);
void __std__allocator_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IField*>"), typeid(::std::allocator<cool::IField*>), sizeof(::std::allocator<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_2070, ::Reflex::BaseOffset< ::std::allocator<cool::IField*>, ::__gnu_cxx::new_allocator<cool::IField*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<cool::IField*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<cool::IField*>::difference_type"))
  .AddTypedef(type_3475, Reflex::Literal("std::allocator<cool::IField*>::pointer"))
  .AddTypedef(type_3477, Reflex::Literal("std::allocator<cool::IField*>::const_pointer"))
  .AddTypedef(type_3479, Reflex::Literal("std::allocator<cool::IField*>::reference"))
  .AddTypedef(type_3481, Reflex::Literal("std::allocator<cool::IField*>::const_reference"))
  .AddTypedef(type_3469, Reflex::Literal("std::allocator<cool::IField*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9569, type_9317), Reflex::Literal("operator="), operator_4754, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4755, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9317), Reflex::Literal("allocator"), constructor_4756, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4757, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1542, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::IField*> -------------------
void __std__allocator_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::IField*> -------------------
void __std__allocator_cool__IFieldp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::IRecordSelection*> -------------------------------
static  void operator_4765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else   (((::std::allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_4766( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>();
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>();
}

static void constructor_4767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void destructor_4768(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IRecordSelection*>*)o)->::std::allocator<cool::IRecordSelection*>::~allocator();
}
static void method_newdel_1543( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>")), ::Reflex::BaseOffset< ::std::allocator<cool::IRecordSelection*>,::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::IRecordSelection*> -------------------------------
void __std__allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp__datamem_bld(&__std__allocator_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp__funcmem_bld(&__std__allocator_cool__IRecordSelectionp__db_funcmem);
void __std__allocator_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>"), typeid(::std::allocator<cool::IRecordSelection*>), sizeof(::std::allocator<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_2069, ::Reflex::BaseOffset< ::std::allocator<cool::IRecordSelection*>, ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<cool::IRecordSelection*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<cool::IRecordSelection*>::difference_type"))
  .AddTypedef(type_3544, Reflex::Literal("std::allocator<cool::IRecordSelection*>::pointer"))
  .AddTypedef(type_3546, Reflex::Literal("std::allocator<cool::IRecordSelection*>::const_pointer"))
  .AddTypedef(type_3548, Reflex::Literal("std::allocator<cool::IRecordSelection*>::reference"))
  .AddTypedef(type_3550, Reflex::Literal("std::allocator<cool::IRecordSelection*>::const_reference"))
  .AddTypedef(type_3538, Reflex::Literal("std::allocator<cool::IRecordSelection*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9570, type_9321), Reflex::Literal("operator="), operator_4765, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4766, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9321), Reflex::Literal("allocator"), constructor_4767, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4768, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1543, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::IFieldSpecification*> -------------------------------
static  void operator_4776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else   (((::std::allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_4777( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>();
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>();
}

static void constructor_4778( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void destructor_4779(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IFieldSpecification*>*)o)->::std::allocator<cool::IFieldSpecification*>::~allocator();
}
static void method_newdel_1545( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>")), ::Reflex::BaseOffset< ::std::allocator<cool::IFieldSpecification*>,::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::IFieldSpecification*> -------------------------------
void __std__allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp__datamem_bld(&__std__allocator_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp__funcmem_bld(&__std__allocator_cool__IFieldSpecificationp__db_funcmem);
void __std__allocator_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>"), typeid(::std::allocator<cool::IFieldSpecification*>), sizeof(::std::allocator<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_2071, ::Reflex::BaseOffset< ::std::allocator<cool::IFieldSpecification*>, ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::difference_type"))
  .AddTypedef(type_3613, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::pointer"))
  .AddTypedef(type_3615, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::const_pointer"))
  .AddTypedef(type_3617, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::reference"))
  .AddTypedef(type_3619, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::const_reference"))
  .AddTypedef(type_3607, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9571, type_9325), Reflex::Literal("operator="), operator_4776, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4777, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9325), Reflex::Literal("allocator"), constructor_4778, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4779, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1545, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<cool::ChannelSelection::ChannelRange> -------------------------------
static  void operator_4787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::std::allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_4788( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>();
}

static void constructor_4789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void destructor_4790(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::ChannelSelection::ChannelRange>*)o)->::std::allocator<cool::ChannelSelection::ChannelRange>::~allocator();
}
static void method_newdel_1546( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>")), ::Reflex::BaseOffset< ::std::allocator<cool::ChannelSelection::ChannelRange>,::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<cool::ChannelSelection::ChannelRange> -------------------------------
void __std__allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void __std__allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange__datamem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange__funcmem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange__db_funcmem);
void __std__allocator_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>"), typeid(::std::allocator<cool::ChannelSelection::ChannelRange>), sizeof(::std::allocator<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddBase(type_2072, ::Reflex::BaseOffset< ::std::allocator<cool::ChannelSelection::ChannelRange>, ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::difference_type"))
  .AddTypedef(type_3682, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::pointer"))
  .AddTypedef(type_3684, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::const_pointer"))
  .AddTypedef(type_3686, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::reference"))
  .AddTypedef(type_3688, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::const_reference"))
  .AddTypedef(type_3676, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9572, type_9339), Reflex::Literal("operator="), operator_4787, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4788, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9339), Reflex::Literal("allocator"), constructor_4789, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4790, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1546, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<coral::AttributeSpecification*> -------------------------------
static  void operator_4798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else   (((::std::allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_4799( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>();
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>();
}

static void constructor_4800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void destructor_4801(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::AttributeSpecification*>*)o)->::std::allocator<coral::AttributeSpecification*>::~allocator();
}
static void method_newdel_1547( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>")), ::Reflex::BaseOffset< ::std::allocator<coral::AttributeSpecification*>,::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<coral::AttributeSpecification*> -------------------------------
void __std__allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp__datamem_bld(&__std__allocator_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp__funcmem_bld(&__std__allocator_coral__AttributeSpecificationp__db_funcmem);
void __std__allocator_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>"), typeid(::std::allocator<coral::AttributeSpecification*>), sizeof(::std::allocator<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_2075, ::Reflex::BaseOffset< ::std::allocator<coral::AttributeSpecification*>, ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::difference_type"))
  .AddTypedef(type_3750, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::pointer"))
  .AddTypedef(type_3152, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::const_pointer"))
  .AddTypedef(type_3753, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::reference"))
  .AddTypedef(type_3154, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::const_reference"))
  .AddTypedef(type_3149, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9573, type_9342), Reflex::Literal("operator="), operator_4798, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4799, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9342), Reflex::Literal("allocator"), constructor_4800, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4801, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1547, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<coral::Attribute*> -------------------------------
static  void operator_4839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else   (((::std::allocator<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_4840( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>();
  else ::new(mem) ::std::allocator<coral::Attribute*>();
}

static void constructor_4841( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void destructor_4842(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::Attribute*>*)o)->::std::allocator<coral::Attribute*>::~allocator();
}
static void method_newdel_1550( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x56( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>")), ::Reflex::BaseOffset< ::std::allocator<coral::Attribute*>,::__gnu_cxx::new_allocator<coral::Attribute*> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<coral::Attribute*> -------------------------------
void __std__allocator_coral__Attributep__db_datamem(Reflex::Class*);
void __std__allocator_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep__datamem_bld(&__std__allocator_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep__funcmem_bld(&__std__allocator_coral__Attributep__db_funcmem);
void __std__allocator_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::Attribute*>"), typeid(::std::allocator<coral::Attribute*>), sizeof(::std::allocator<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddBase(type_2076, ::Reflex::BaseOffset< ::std::allocator<coral::Attribute*>, ::__gnu_cxx::new_allocator<coral::Attribute*> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1636, Reflex::Literal("std::allocator<coral::Attribute*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::allocator<coral::Attribute*>::difference_type"))
  .AddTypedef(type_3164, Reflex::Literal("std::allocator<coral::Attribute*>::pointer"))
  .AddTypedef(type_3175, Reflex::Literal("std::allocator<coral::Attribute*>::const_pointer"))
  .AddTypedef(type_3166, Reflex::Literal("std::allocator<coral::Attribute*>::reference"))
  .AddTypedef(type_3177, Reflex::Literal("std::allocator<coral::Attribute*>::const_reference"))
  .AddTypedef(type_3161, Reflex::Literal("std::allocator<coral::Attribute*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9580, type_9345), Reflex::Literal("operator="), operator_4839, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_4840, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9345), Reflex::Literal("allocator"), constructor_4841, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_4842, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1550, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x56, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
static void destructor_4884(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >::~rebind();
}
static  void operator_4885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_4886( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_4887( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >();
}

static void method_newdel_1557( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >"), typeid(::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >), sizeof(::std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1540, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4884, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9592, type_9593), Reflex::Literal("operator="), operator_4885, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9593), Reflex::Literal("rebind"), constructor_4886, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4887, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1557, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
static void destructor_4889(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)o)->::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >::~rebind();
}
static  void operator_4890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_4891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_4892( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >();
}

static void method_newdel_1558( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__datamem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__funcmem_bld(&__std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem);
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >"), typeid(::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >), sizeof(::std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1541, Reflex::Literal("std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4889, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9594, type_9595), Reflex::Literal("operator="), operator_4890, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9595), Reflex::Literal("rebind"), constructor_4891, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4892, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1558, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IRecordSelection*> -------------------------------
static void destructor_4894(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)o)->::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>::~rebind();
}
static  void operator_4895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
  else   (((::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_4896( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>(*(const ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_4897( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>();
  else ::new(mem) ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>();
}

static void method_newdel_1559( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IRecordSelection*> -------------------------------
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__datamem_bld(&__std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__funcmem_bld(&__std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_funcmem);
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>"), typeid(::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>), sizeof(::std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1543, Reflex::Literal("std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4894, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9596, type_9597), Reflex::Literal("operator="), operator_4895, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9597), Reflex::Literal("rebind"), constructor_4896, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4897, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1559, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IRecordSelection*> -------------------
void __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IField*> -------------------------------
static void destructor_4899(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IField*>::rebind<cool::IField*>*)o)->::std::allocator<cool::IField*>::rebind<cool::IField*>::~rebind();
}
static  void operator_4900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IField*>::rebind<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
  else   (((::std::allocator<cool::IField*>::rebind<cool::IField*>*)o)->operator=)(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
}

static void constructor_4901( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>(*(const ::std::allocator<cool::IField*>::rebind<cool::IField*>*)arg[0]);
}

static void constructor_4902( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>();
  else ::new(mem) ::std::allocator<cool::IField*>::rebind<cool::IField*>();
}

static void method_newdel_1560( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IField*>::rebind<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IField*> -------------------------------
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp___rebind_cool__IFieldp__datamem_bld(&__std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldp___rebind_cool__IFieldp__funcmem_bld(&__std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_funcmem);
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IField*>::rebind<cool::IField*>"), typeid(::std::allocator<cool::IField*>::rebind<cool::IField*>), sizeof(::std::allocator<cool::IField*>::rebind<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1542, Reflex::Literal("std::allocator<cool::IField*>::rebind<cool::IField*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4899, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9598, type_9599), Reflex::Literal("operator="), operator_4900, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9599), Reflex::Literal("rebind"), constructor_4901, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4902, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1560, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IField*> -------------------
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IField*> -------------------
void __std__allocator_cool__IFieldp___rebind_cool__IFieldp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IFieldSpecification*> -------------------------------
static void destructor_4904(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)o)->::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>::~rebind();
}
static  void operator_4905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
  else   (((::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_4906( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>(*(const ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_4907( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>();
  else ::new(mem) ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>();
}

static void method_newdel_1561( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IFieldSpecification*> -------------------------------
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__datamem_bld(&__std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__funcmem_bld(&__std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_funcmem);
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>"), typeid(::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>), sizeof(::std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1545, Reflex::Literal("std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4904, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9600, type_9601), Reflex::Literal("operator="), operator_4905, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9601), Reflex::Literal("rebind"), constructor_4906, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4907, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1561, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IFieldSpecification*> -------------------
void __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
static void destructor_4909(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)o)->::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>::~rebind();
}
static  void operator_4910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_4911( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_4912( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>();
}

static void method_newdel_1562( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__datamem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__funcmem_bld(&__std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_funcmem);
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>"), typeid(::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>), sizeof(::std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1546, Reflex::Literal("std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4909, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9602, type_9603), Reflex::Literal("operator="), operator_4910, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9603), Reflex::Literal("rebind"), constructor_4911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4912, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1562, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::AttributeSpecification*> -------------------------------
static void destructor_4924(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)o)->::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>::~rebind();
}
static  void operator_4925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
  else   (((::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_4926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>(*(const ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_4927( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>();
  else ::new(mem) ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>();
}

static void method_newdel_1565( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::AttributeSpecification*> -------------------------------
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__datamem_bld(&__std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__funcmem_bld(&__std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_funcmem);
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>"), typeid(::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>), sizeof(::std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1547, Reflex::Literal("std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4924, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9608, type_9609), Reflex::Literal("operator="), operator_4925, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9609), Reflex::Literal("rebind"), constructor_4926, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1565, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::AttributeSpecification*> -------------------
void __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::Attribute*> -------------------------------
static void destructor_4929(void*, void * o, const std::vector<void*>&, void *) {
((::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)o)->::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>::~rebind();
}
static  void operator_4930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
  else   (((::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)o)->operator=)(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_4931( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>(*(const ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_4932( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>();
  else ::new(mem) ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>();
}

static void method_newdel_1566( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<coral::Attribute*>::rebind<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::Attribute*> -------------------------------
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_datamem(Reflex::Class*);
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep___rebind_coral__Attributep__datamem_bld(&__std__allocator_coral__Attributep___rebind_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_coral__Attributep___rebind_coral__Attributep__funcmem_bld(&__std__allocator_coral__Attributep___rebind_coral__Attributep__db_funcmem);
void __std__allocator_coral__Attributep___rebind_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<coral::Attribute*>::rebind<coral::Attribute*>"), typeid(::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>), sizeof(::std::allocator<coral::Attribute*>::rebind<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1550, Reflex::Literal("std::allocator<coral::Attribute*>::rebind<coral::Attribute*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_4929, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9610, type_9611), Reflex::Literal("operator="), operator_4930, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9611), Reflex::Literal("rebind"), constructor_4931, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_4932, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1566, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::Attribute*> -------------------
void __std__allocator_coral__Attributep___rebind_coral__Attributep__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_5147(void*, void * o, const std::vector<void*>&, void *) {
((::std::map<unsigned int,std::basic_string<char> >*)o)->::std::map<unsigned int,std::basic_string<char> >::~map();
}
static void constructor_5148( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >();
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >();
}

static void constructor_5149( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
  }
}

static void constructor_5150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void operator_5151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_5152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->get_allocator)();
}

static  void method_5153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->begin)();
}

static  void method_5154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->begin)();
}

static  void method_5155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->end)());
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->end)();
}

static  void method_5156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->end)();
}

static  void method_5161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->empty)();
}

static  void method_5162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->size)();
}

static  void method_5163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->max_size)();
}

static  void operator_5164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_5165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_5166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_5167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,bool>)((((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_5168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[1]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[1]);
}

static  void method_5169( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void method_5170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_5171( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
}

static  void method_5172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->swap)(*(::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_5173( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->clear)();
}

static  void method_5174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->key_comp)();
}

static  void method_5176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_5177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_5178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_5179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_5184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1624( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x66( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::basic_string<char> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__basic_string_char_s__datamem_bld(&__std__map_unsignedsint_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__basic_string_char_s__funcmem_bld(&__std__map_unsignedsint_std__basic_string_char_s__db_funcmem);
void __std__map_unsignedsint_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >"), typeid(::std::map<unsigned int,std::basic_string<char> >), sizeof(::std::map<unsigned int,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddTypedef(type_80, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::key_type"))
  .AddTypedef(type_1443, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::mapped_type"))
  .AddTypedef(type_1428, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::value_type"))
  .AddTypedef(type_1810, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::key_compare"))
  .AddTypedef(type_1537, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::allocator_type"))
  .AddTypedef(type_1428, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1537, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Pair_alloc_type"))
  .AddTypedef(type_1761, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Rep_type"))
  .AddTypedef(type_2036, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Alloc_traits"))
  .AddTypedef(type_4381, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::pointer"))
  .AddTypedef(type_4690, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_4379, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::reference"))
  .AddTypedef(type_4693, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_reference"))
  .AddTypedef(type_1477, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::iterator"))
  .AddTypedef(type_1695, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1648, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1647, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_5147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_5148, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9646, type_9562), Reflex::Literal("map"), constructor_5149, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9647), Reflex::Literal("map"), constructor_5150, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1624, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x66, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__basic_string_char_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1761, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__basic_string_char_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9648, type_9647), Reflex::Literal("operator="), operator_5151, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1537), Reflex::Literal("get_allocator"), method_5152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477), Reflex::Literal("begin"), method_5153, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1695), Reflex::Literal("begin"), method_5154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477), Reflex::Literal("end"), method_5155, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1695), Reflex::Literal("end"), method_5156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_5161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("size"), method_5162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_5163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3280), Reflex::Literal("operator[]"), operator_5164, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_3280), Reflex::Literal("at"), method_5165, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3213, type_3280), Reflex::Literal("at"), method_5166, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1431, type_4693), Reflex::Literal("insert"), method_5167, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477, type_1477, type_4693), Reflex::Literal("insert"), method_5168, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1477), Reflex::Literal("erase"), method_5169, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3280), Reflex::Literal("erase"), method_5170, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1477, type_1477), Reflex::Literal("erase"), method_5171, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9648), Reflex::Literal("swap"), method_5172, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("clear"), method_5173, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1810), Reflex::Literal("key_comp"), method_5174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477, type_3280), Reflex::Literal("find"), method_5176, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1695, type_3280), Reflex::Literal("find"), method_5177, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_3280), Reflex::Literal("count"), method_5178, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477, type_3280), Reflex::Literal("lower_bound"), method_5179, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1695, type_3280), Reflex::Literal("lower_bound"), method_5180, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477, type_3280), Reflex::Literal("upper_bound"), method_5181, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1695, type_3280), Reflex::Literal("upper_bound"), method_5182, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1430, type_3280), Reflex::Literal("equal_range"), method_5183, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1429, type_3280), Reflex::Literal("equal_range"), method_5184, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
static  void operator_5381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_5382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_5383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<boost::shared_ptr<cool::IRecord> >)((((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->get_allocator)();
}

static void constructor_5386( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >();
}

static void constructor_5387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_5388( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0]);
}

static void constructor_5389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[1]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[1]);
}

static void destructor_5390(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::~_Vector_base();
}
static  void method_5391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_M_deallocate)((::boost::shared_ptr<cool::IRecord>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1677( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >"), typeid(::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >), sizeof(::std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1540, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::_Tp_alloc_type"))
  .AddTypedef(type_3119, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::pointer"))
  .AddTypedef(type_1540, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9697, type_9698), Reflex::Literal("operator="), operator_5381, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9698), Reflex::Literal("_Vector_base"), constructor_5382, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5386, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9309), Reflex::Literal("_Vector_base"), constructor_5387, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5388, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9309), Reflex::Literal("_Vector_base"), constructor_5389, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5390, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1677, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5379, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9567), Reflex::Literal("_M_get_Tp_allocator"), method_5383, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9309), Reflex::Literal("_M_get_Tp_allocator"), method_5384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1540), Reflex::Literal("get_allocator"), method_5385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3119, type_1636), Reflex::Literal("_M_allocate"), method_5391, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3119, type_1636), Reflex::Literal("_M_deallocate"), method_5392, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
static  void operator_5399( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_5400( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_5401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_get_Tp_allocator)();
}

static  void method_5403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<boost::shared_ptr<cool::IObject> >)((((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->get_allocator)();
}

static void constructor_5404( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >();
}

static void constructor_5405( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_5406( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0]);
}

static void constructor_5407( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[1]);
  else ::new(mem) ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[1]);
}

static void destructor_5408(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::~_Vector_base();
}
static  void method_5409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_M_deallocate)((::boost::shared_ptr<cool::IObject>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1678( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >"), typeid(::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >), sizeof(::std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1541, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::_Tp_alloc_type"))
  .AddTypedef(type_3130, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::pointer"))
  .AddTypedef(type_1541, Reflex::Literal("std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9708, type_9709), Reflex::Literal("operator="), operator_5399, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9709), Reflex::Literal("_Vector_base"), constructor_5400, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5404, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9313), Reflex::Literal("_Vector_base"), constructor_5405, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5406, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9313), Reflex::Literal("_Vector_base"), constructor_5407, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5408, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1678, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5397, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9568), Reflex::Literal("_M_get_Tp_allocator"), method_5401, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9313), Reflex::Literal("_M_get_Tp_allocator"), method_5402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1541), Reflex::Literal("get_allocator"), method_5403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130, type_1636), Reflex::Literal("_M_allocate"), method_5409, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3130, type_1636), Reflex::Literal("_M_deallocate"), method_5410, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
static  void operator_5417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else   (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static void constructor_5418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static  void method_5419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::IRecordSelection*>)((((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->get_allocator)();
}

static void constructor_5422( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >();
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >();
}

static void constructor_5423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_5424( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5425( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IRecordSelection*>*)arg[1]);
}

static void destructor_5426(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::~_Vector_base();
}
static  void method_5427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >*)o)->_M_deallocate)((::cool::IRecordSelection**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1679( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------------------
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__datamem_bld(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__funcmem_bld(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_funcmem);
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >"), typeid(::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >), sizeof(::std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1543, Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::_Tp_alloc_type"))
  .AddTypedef(type_3544, Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::pointer"))
  .AddTypedef(type_1543, Reflex::Literal("std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9719, type_9720), Reflex::Literal("operator="), operator_5417, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9720), Reflex::Literal("_Vector_base"), constructor_5418, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5422, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9321), Reflex::Literal("_Vector_base"), constructor_5423, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5424, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9321), Reflex::Literal("_Vector_base"), constructor_5425, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5426, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1679, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5415, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > -------------------
void __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9570), Reflex::Literal("_M_get_Tp_allocator"), method_5419, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9321), Reflex::Literal("_M_get_Tp_allocator"), method_5420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1543), Reflex::Literal("get_allocator"), method_5421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3544, type_1636), Reflex::Literal("_M_allocate"), method_5427, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3544, type_1636), Reflex::Literal("_M_deallocate"), method_5428, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------------------
static  void operator_5435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
  else   (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
}

static void constructor_5436( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)arg[0]);
}

static  void method_5437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::IField*>)((((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->get_allocator)();
}

static void constructor_5440( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >();
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >();
}

static void constructor_5441( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static void constructor_5442( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5443( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IField*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IField*>*)arg[1]);
}

static void destructor_5444(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::~_Vector_base();
}
static  void method_5445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5446( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >*)o)->_M_deallocate)((::cool::IField**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1680( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------------------
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__datamem_bld(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__funcmem_bld(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_funcmem);
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >"), typeid(::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >), sizeof(::std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1542, Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::_Tp_alloc_type"))
  .AddTypedef(type_3475, Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::pointer"))
  .AddTypedef(type_1542, Reflex::Literal("std::_Vector_base<cool::IField*,std::allocator<cool::IField*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9730, type_9731), Reflex::Literal("operator="), operator_5435, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9731), Reflex::Literal("_Vector_base"), constructor_5436, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5440, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9317), Reflex::Literal("_Vector_base"), constructor_5441, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5442, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9317), Reflex::Literal("_Vector_base"), constructor_5443, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5444, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1680, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5433, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::IField*,std::allocator<cool::IField*> > -------------------
void __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9569), Reflex::Literal("_M_get_Tp_allocator"), method_5437, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9317), Reflex::Literal("_M_get_Tp_allocator"), method_5438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1542), Reflex::Literal("get_allocator"), method_5439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3475, type_1636), Reflex::Literal("_M_allocate"), method_5445, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3475, type_1636), Reflex::Literal("_M_deallocate"), method_5446, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
static  void operator_5453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else   (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static void constructor_5454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static  void method_5455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::IFieldSpecification*>)((((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->get_allocator)();
}

static void constructor_5458( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >();
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >();
}

static void constructor_5459( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_5460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5461( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::IFieldSpecification*>*)arg[1]);
}

static void destructor_5462(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::~_Vector_base();
}
static  void method_5463( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >*)o)->_M_deallocate)((::cool::IFieldSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1681( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------------------
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__datamem_bld(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_funcmem);
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >"), typeid(::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >), sizeof(::std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1545, Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::_Tp_alloc_type"))
  .AddTypedef(type_3613, Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::pointer"))
  .AddTypedef(type_1545, Reflex::Literal("std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9741, type_9742), Reflex::Literal("operator="), operator_5453, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9742), Reflex::Literal("_Vector_base"), constructor_5454, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5458, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9325), Reflex::Literal("_Vector_base"), constructor_5459, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5460, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9325), Reflex::Literal("_Vector_base"), constructor_5461, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5462, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1681, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5451, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > -------------------
void __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9571), Reflex::Literal("_M_get_Tp_allocator"), method_5455, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9325), Reflex::Literal("_M_get_Tp_allocator"), method_5456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1545), Reflex::Literal("get_allocator"), method_5457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3613, type_1636), Reflex::Literal("_M_allocate"), method_5463, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3613, type_1636), Reflex::Literal("_M_deallocate"), method_5464, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
static  void operator_5471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else   (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static void constructor_5472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static  void method_5473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<cool::ChannelSelection::ChannelRange>)((((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->get_allocator)();
}

static void constructor_5476( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >();
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >();
}

static void constructor_5477( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_5478( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0]);
}

static void constructor_5479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[1]);
}

static void destructor_5480(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::~_Vector_base();
}
static  void method_5481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5482( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_M_deallocate)((::cool::ChannelSelection::ChannelRange*)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1682( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class*);
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__datamem_bld(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem);
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >"), typeid(::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >), sizeof(::std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1546, Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::_Tp_alloc_type"))
  .AddTypedef(type_3682, Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::pointer"))
  .AddTypedef(type_1546, Reflex::Literal("std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9752, type_9753), Reflex::Literal("operator="), operator_5471, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9753), Reflex::Literal("_Vector_base"), constructor_5472, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5476, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9339), Reflex::Literal("_Vector_base"), constructor_5477, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5478, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9339), Reflex::Literal("_Vector_base"), constructor_5479, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5480, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1682, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5469, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9572), Reflex::Literal("_M_get_Tp_allocator"), method_5473, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9339), Reflex::Literal("_M_get_Tp_allocator"), method_5474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1546), Reflex::Literal("get_allocator"), method_5475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3682, type_1636), Reflex::Literal("_M_allocate"), method_5481, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3682, type_1636), Reflex::Literal("_M_deallocate"), method_5482, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
static  void operator_5489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_5490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static  void method_5491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<coral::AttributeSpecification*>)((((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->get_allocator)();
}

static void constructor_5494( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >();
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >();
}

static void constructor_5495( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_5496( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5497( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::AttributeSpecification*>*)arg[1]);
}

static void destructor_5498(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::~_Vector_base();
}
static  void method_5499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5500( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >*)o)->_M_deallocate)((::coral::AttributeSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1683( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------------------
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__datamem_bld(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_funcmem);
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >"), typeid(::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >), sizeof(::std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1547, Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::_Tp_alloc_type"))
  .AddTypedef(type_3750, Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::pointer"))
  .AddTypedef(type_1547, Reflex::Literal("std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9763, type_9764), Reflex::Literal("operator="), operator_5489, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9764), Reflex::Literal("_Vector_base"), constructor_5490, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5494, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9342), Reflex::Literal("_Vector_base"), constructor_5495, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5496, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9342), Reflex::Literal("_Vector_base"), constructor_5497, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5498, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1683, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5487, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > -------------------
void __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9573), Reflex::Literal("_M_get_Tp_allocator"), method_5491, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9342), Reflex::Literal("_M_get_Tp_allocator"), method_5492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1547), Reflex::Literal("get_allocator"), method_5493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3750, type_1636), Reflex::Literal("_M_allocate"), method_5499, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3750, type_1636), Reflex::Literal("_M_deallocate"), method_5500, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
static  void operator_5507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
  else   (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
}

static void constructor_5508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)arg[0]);
}

static  void method_5509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
  else   (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
  else   (((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_get_Tp_allocator)();
}

static  void method_5511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<coral::Attribute*>)((((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->get_allocator)());
  else   (((const ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->get_allocator)();
}

static void constructor_5512( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >();
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >();
}

static void constructor_5513( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_5514( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0]);
}

static void constructor_5515( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::Attribute*>*)arg[1]);
  else ::new(mem) ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >(*(::std::size_t*)arg[0],
      *(const ::std::allocator<coral::Attribute*>*)arg[1]);
}

static void destructor_5516(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::~_Vector_base();
}
static  void method_5517( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]));
  else   (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_allocate)(*(::std::size_t*)arg[0]);
}

static  void method_5518( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >*)o)->_M_deallocate)((::coral::Attribute**)arg[0],
    *(::std::size_t*)arg[1]);
}

static void method_newdel_1684( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------------------
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class*);
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__datamem_bld(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__funcmem_bld(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_funcmem);
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >"), typeid(::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >), sizeof(::std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1550, Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::_Tp_alloc_type"))
  .AddTypedef(type_3164, Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::pointer"))
  .AddTypedef(type_1550, Reflex::Literal("std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9774, type_9775), Reflex::Literal("operator="), operator_5507, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9775), Reflex::Literal("_Vector_base"), constructor_5508, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Vector_base"), constructor_5512, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9345), Reflex::Literal("_Vector_base"), constructor_5513, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636), Reflex::Literal("_Vector_base"), constructor_5514, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1636, type_9345), Reflex::Literal("_Vector_base"), constructor_5515, 0, "__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Vector_base"), destructor_5516, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1684, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5505, Reflex::Literal("_M_impl"), OffsetOf(__shadow__::__std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s_, _M_impl), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > -------------------
void __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9580), Reflex::Literal("_M_get_Tp_allocator"), method_5509, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9345), Reflex::Literal("_M_get_Tp_allocator"), method_5510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1550), Reflex::Literal("get_allocator"), method_5511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3164, type_1636), Reflex::Literal("_M_allocate"), method_5517, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3164, type_1636), Reflex::Literal("_M_deallocate"), method_5518, 0, "__p;__n", ::Reflex::PUBLIC);
}
//------Stub functions for class type_info -------------------------------
static void destructor_5627(void*, void * o, const std::vector<void*>&, void *) {
((::std::type_info*)o)->::std::type_info::~type_info();
}
static  void method_5628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::type_info*)o)->name)());
  else   (((const ::std::type_info*)o)->name)();
}

static  void method_5629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->before)(*(const ::std::type_info*)arg[0]));
  else   (((const ::std::type_info*)o)->before)(*(const ::std::type_info*)arg[0]);
}

static  void operator_5630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->operator==)(*(const ::std::type_info*)arg[0]));
  else   (((const ::std::type_info*)o)->operator==)(*(const ::std::type_info*)arg[0]);
}

static  void operator_5631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->operator!=)(*(const ::std::type_info*)arg[0]));
  else   (((const ::std::type_info*)o)->operator!=)(*(const ::std::type_info*)arg[0]);
}

static  void method_5632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__is_pointer_p)());
  else   (((const ::std::type_info*)o)->__is_pointer_p)();
}

static  void method_5633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__is_function_p)());
  else   (((const ::std::type_info*)o)->__is_function_p)();
}

static  void method_5634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__do_catch)((const ::std::type_info*)arg[0],
    (void**)arg[1],
    *(unsigned int*)arg[2]));
  else   (((const ::std::type_info*)o)->__do_catch)((const ::std::type_info*)arg[0],
    (void**)arg[1],
    *(unsigned int*)arg[2]);
}

static  void method_5635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::type_info*)o)->__do_upcast)((const ::__cxxabiv1::__class_type_info*)arg[0],
    (void**)arg[1]));
  else   (((const ::std::type_info*)o)->__do_upcast)((const ::__cxxabiv1::__class_type_info*)arg[0],
    (void**)arg[1]);
}

//------Dictionary for class type_info -------------------------------
void __std__type_info_db_datamem(Reflex::Class*);
void __std__type_info_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__type_info_datamem_bld(&__std__type_info_db_datamem);
Reflex::GenreflexMemberBuilder __std__type_info_funcmem_bld(&__std__type_info_db_funcmem);
void __std__type_info_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::type_info"), typeid(::std::type_info), sizeof(::std::type_info), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~type_info"), destructor_5627, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__std__type_info_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__type_info_funcmem_bld);
}

//------Delayed data member builder for class type_info -------------------
void __std__type_info_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1841, Reflex::Literal("__name"), OffsetOf(__shadow__::__std__type_info, __name), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class type_info -------------------
void __std__type_info_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1841), Reflex::Literal("name"), method_5628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9791), Reflex::Literal("before"), method_5629, 0, "__arg", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9791), Reflex::Literal("operator=="), operator_5630, 0, "__arg", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9791), Reflex::Literal("operator!="), operator_5631, 0, "__arg", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("__is_pointer_p"), method_5632, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("__is_function_p"), method_5633, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9792, type_2000, type_80), Reflex::Literal("__do_catch"), method_5634, 0, "__thr_type;__thr_obj;__outer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9793, type_2000), Reflex::Literal("__do_upcast"), method_5635, 0, "__target;__obj_ptr", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------------------
static void destructor_6684(void*, void * o, const std::vector<void*>&, void *) {
((::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)o)->::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>::~__are_same();
}
static  void operator_6685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)o)->operator=)(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
  else   (((::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)o)->operator=)(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
}

static void constructor_6686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
  else ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>(*(const ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>*)arg[0]);
}

static void constructor_6687( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>();
  else ::new(mem) ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>();
}

static void method_newdel_1821( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------------------
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_datamem(Reflex::Class*);
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__datamem_bld(&__std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_datamem);
Reflex::GenreflexMemberBuilder __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__funcmem_bld(&__std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_funcmem);
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>"), typeid(::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>), sizeof(::std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddEnum(Reflex::Literal("_1"), Reflex::Literal("__value=0"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1367, Reflex::Literal("std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**>::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__are_same"), destructor_6684, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9892, type_9893), Reflex::Literal("operator="), operator_6685, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9893), Reflex::Literal("__are_same"), constructor_6686, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__are_same"), constructor_6687, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1821, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> -------------------
void __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------------------
static void destructor_6690(void*, void * o, const std::vector<void*>&, void *) {
((::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)o)->::std::__are_same<coral::Attribute* const*,coral::Attribute**>::~__are_same();
}
static  void operator_6691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
  else   (((::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
}

static void constructor_6692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
  else ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute* const*,coral::Attribute**>*)arg[0]);
}

static void constructor_6693( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>();
  else ::new(mem) ::std::__are_same<coral::Attribute* const*,coral::Attribute**>();
}

static void method_newdel_1822( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute* const*,coral::Attribute**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------------------
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_datamem(Reflex::Class*);
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepsconstp_coral__Attributepp__datamem_bld(&__std____are_same_coral__Attributepsconstp_coral__Attributepp__db_datamem);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepsconstp_coral__Attributepp__funcmem_bld(&__std____are_same_coral__Attributepsconstp_coral__Attributepp__db_funcmem);
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::__are_same<coral::Attribute* const*,coral::Attribute**>"), typeid(::std::__are_same<coral::Attribute* const*,coral::Attribute**>), sizeof(::std::__are_same<coral::Attribute* const*,coral::Attribute**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddEnum(Reflex::Literal("_1"), Reflex::Literal("__value=0"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1367, Reflex::Literal("std::__are_same<coral::Attribute* const*,coral::Attribute**>::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__are_same"), destructor_6690, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9894, type_9895), Reflex::Literal("operator="), operator_6691, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9895), Reflex::Literal("__are_same"), constructor_6692, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__are_same"), constructor_6693, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1822, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __are_same<coral::Attribute* const*,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepsconstp_coral__Attributepp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __are_same<coral::Attribute**,coral::Attribute**> -------------------------------
static void destructor_6696(void*, void * o, const std::vector<void*>&, void *) {
((::std::__are_same<coral::Attribute**,coral::Attribute**>*)o)->::std::__are_same<coral::Attribute**,coral::Attribute**>::~__are_same();
}
static  void operator_6697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::__are_same<coral::Attribute**,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
  else   (((::std::__are_same<coral::Attribute**,coral::Attribute**>*)o)->operator=)(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
}

static void constructor_6698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
  else ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>(*(const ::std::__are_same<coral::Attribute**,coral::Attribute**>*)arg[0]);
}

static void constructor_6699( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>();
  else ::new(mem) ::std::__are_same<coral::Attribute**,coral::Attribute**>();
}

static void method_newdel_1823( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::__are_same<coral::Attribute**,coral::Attribute**> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __are_same<coral::Attribute**,coral::Attribute**> -------------------------------
void __std____are_same_coral__Attributepp_coral__Attributepp__db_datamem(Reflex::Class*);
void __std____are_same_coral__Attributepp_coral__Attributepp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepp_coral__Attributepp__datamem_bld(&__std____are_same_coral__Attributepp_coral__Attributepp__db_datamem);
Reflex::GenreflexMemberBuilder __std____are_same_coral__Attributepp_coral__Attributepp__funcmem_bld(&__std____are_same_coral__Attributepp_coral__Attributepp__db_funcmem);
void __std____are_same_coral__Attributepp_coral__Attributepp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::__are_same<coral::Attribute**,coral::Attribute**>"), typeid(::std::__are_same<coral::Attribute**,coral::Attribute**>), sizeof(::std::__are_same<coral::Attribute**,coral::Attribute**>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddEnum(Reflex::Literal("_2"), Reflex::Literal("__value=1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1809, Reflex::Literal("std::__are_same<coral::Attribute**,coral::Attribute**>::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__are_same"), destructor_6696, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9896, type_9897), Reflex::Literal("operator="), operator_6697, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9897), Reflex::Literal("__are_same"), constructor_6698, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__are_same"), constructor_6699, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1823, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __are_same<coral::Attribute**,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepp_coral__Attributepp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __are_same<coral::Attribute**,coral::Attribute**> -------------------
void __std____are_same_coral__Attributepp_coral__Attributepp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
static void destructor_6905(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::~__alloc_traits();
}
static  void operator_6906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_6907( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_6908( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >();
}

static  void method_6909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->deallocate)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    (::boost::shared_ptr<cool::IRecord>*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->destroy)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    (::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_6912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_6913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static  void method_6914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >*)o)->_S_on_swap)(*(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[0],
    *(::std::allocator<boost::shared_ptr<cool::IRecord> >*)arg[1]);
}

static void method_newdel_2039( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1540, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::allocator_type"))
  .AddTypedef(type_3119, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::pointer"))
  .AddTypedef(type_3343, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::const_pointer"))
  .AddTypedef(type_2399, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::value_type"))
  .AddTypedef(type_3121, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::reference"))
  .AddTypedef(type_3346, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6905, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9938, type_9939), Reflex::Literal("operator="), operator_6906, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9939), Reflex::Literal("__alloc_traits"), constructor_6907, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6908, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2039, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3119, type_9567, type_1636), Reflex::Literal("allocate"), method_6909, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9567, type_3119, type_1636), Reflex::Literal("deallocate"), method_6910, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9567, type_3119), Reflex::Literal("destroy"), method_6911, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9309), Reflex::Literal("max_size"), method_6912, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9309, type_9309), Reflex::Literal("_S_select_on_copy"), method_6913, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9567, type_9567), Reflex::Literal("_S_on_swap"), method_6914, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
static void destructor_6923(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::~__alloc_traits();
}
static  void operator_6924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_6925( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_6926( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >();
}

static  void method_6927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->allocate)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->deallocate)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    (::boost::shared_ptr<cool::IObject>*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6929( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->destroy)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    (::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_6930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->max_size)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_6931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_S_select_on_copy)(*(const ::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static  void method_6932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >*)o)->_S_on_swap)(*(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[0],
    *(::std::allocator<boost::shared_ptr<cool::IObject> >*)arg[1]);
}

static void method_newdel_2040( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1541, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::allocator_type"))
  .AddTypedef(type_3130, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::pointer"))
  .AddTypedef(type_3409, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::const_pointer"))
  .AddTypedef(type_2290, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::value_type"))
  .AddTypedef(type_3132, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::reference"))
  .AddTypedef(type_3412, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6923, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9940, type_9941), Reflex::Literal("operator="), operator_6924, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9941), Reflex::Literal("__alloc_traits"), constructor_6925, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6926, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2040, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130, type_9568, type_1636), Reflex::Literal("allocate"), method_6927, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9568, type_3130, type_1636), Reflex::Literal("deallocate"), method_6928, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9568, type_3130), Reflex::Literal("destroy"), method_6929, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9313), Reflex::Literal("max_size"), method_6930, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9313, type_9313), Reflex::Literal("_S_select_on_copy"), method_6931, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9568, type_9568), Reflex::Literal("_S_on_swap"), method_6932, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------------------
static void destructor_6941(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::~__alloc_traits();
}
static  void operator_6942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static void constructor_6943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)arg[0]);
}

static void constructor_6944( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >();
}

static  void method_6945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->allocate)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->allocate)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6946( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->deallocate)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    (::cool::IRecordSelection**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->destroy)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    (::cool::IRecordSelection**)arg[1]);
}

static  void method_6948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->max_size)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->max_size)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static  void method_6949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IRecordSelection*>*)arg[0]);
}

static  void method_6950( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >*)o)->_S_on_swap)(*(::std::allocator<cool::IRecordSelection*>*)arg[0],
    *(::std::allocator<cool::IRecordSelection*>*)arg[1]);
}

static void method_newdel_2041( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1543, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::allocator_type"))
  .AddTypedef(type_3544, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::pointer"))
  .AddTypedef(type_3546, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::const_pointer"))
  .AddTypedef(type_3538, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::value_type"))
  .AddTypedef(type_3548, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::reference"))
  .AddTypedef(type_3550, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9942, type_9943), Reflex::Literal("operator="), operator_6942, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9943), Reflex::Literal("__alloc_traits"), constructor_6943, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6944, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2041, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::IRecordSelection*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3544, type_9570, type_1636), Reflex::Literal("allocate"), method_6945, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9570, type_3544, type_1636), Reflex::Literal("deallocate"), method_6946, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9570, type_3544), Reflex::Literal("destroy"), method_6947, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9321), Reflex::Literal("max_size"), method_6948, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9321, type_9321), Reflex::Literal("_S_select_on_copy"), method_6949, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9570, type_9570), Reflex::Literal("_S_on_swap"), method_6950, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::IField*> > -------------------------------
static void destructor_6959(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::~__alloc_traits();
}
static  void operator_6960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
}

static void constructor_6961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)arg[0]);
}

static void constructor_6962( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >();
}

static  void method_6963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->allocate)(*(::std::allocator<cool::IField*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->allocate)(*(::std::allocator<cool::IField*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6964( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->deallocate)(*(::std::allocator<cool::IField*>*)arg[0],
    (::cool::IField**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->destroy)(*(::std::allocator<cool::IField*>*)arg[0],
    (::cool::IField**)arg[1]);
}

static  void method_6966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->max_size)(*(const ::std::allocator<cool::IField*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->max_size)(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static  void method_6967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IField*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IField*>*)arg[0]);
}

static  void method_6968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >*)o)->_S_on_swap)(*(::std::allocator<cool::IField*>*)arg[0],
    *(::std::allocator<cool::IField*>*)arg[1]);
}

static void method_newdel_2042( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::IField*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1542, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::allocator_type"))
  .AddTypedef(type_3475, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::pointer"))
  .AddTypedef(type_3477, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::const_pointer"))
  .AddTypedef(type_3469, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::value_type"))
  .AddTypedef(type_3479, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::reference"))
  .AddTypedef(type_3481, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6959, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9944, type_9945), Reflex::Literal("operator="), operator_6960, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9945), Reflex::Literal("__alloc_traits"), constructor_6961, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6962, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2042, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::IField*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::IField*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3475, type_9569, type_1636), Reflex::Literal("allocate"), method_6963, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9569, type_3475, type_1636), Reflex::Literal("deallocate"), method_6964, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9569, type_3475), Reflex::Literal("destroy"), method_6965, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9317), Reflex::Literal("max_size"), method_6966, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9317, type_9317), Reflex::Literal("_S_select_on_copy"), method_6967, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9569, type_9569), Reflex::Literal("_S_on_swap"), method_6968, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------------------
static void destructor_6977(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::~__alloc_traits();
}
static  void operator_6978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static void constructor_6979( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)arg[0]);
}

static void constructor_6980( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >();
}

static  void method_6981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->allocate)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->allocate)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->deallocate)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    (::cool::IFieldSpecification**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->destroy)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    (::cool::IFieldSpecification**)arg[1]);
}

static  void method_6984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->max_size)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->max_size)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_6985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::IFieldSpecification*>*)arg[0]);
}

static  void method_6986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >*)o)->_S_on_swap)(*(::std::allocator<cool::IFieldSpecification*>*)arg[0],
    *(::std::allocator<cool::IFieldSpecification*>*)arg[1]);
}

static void method_newdel_2043( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1545, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::allocator_type"))
  .AddTypedef(type_3613, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::pointer"))
  .AddTypedef(type_3615, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::const_pointer"))
  .AddTypedef(type_3607, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::value_type"))
  .AddTypedef(type_3617, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::reference"))
  .AddTypedef(type_3619, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6977, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9946, type_9947), Reflex::Literal("operator="), operator_6978, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9947), Reflex::Literal("__alloc_traits"), constructor_6979, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6980, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2043, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::IFieldSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3613, type_9571, type_1636), Reflex::Literal("allocate"), method_6981, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9571, type_3613, type_1636), Reflex::Literal("deallocate"), method_6982, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9571, type_3613), Reflex::Literal("destroy"), method_6983, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9325), Reflex::Literal("max_size"), method_6984, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9325, type_9325), Reflex::Literal("_S_select_on_copy"), method_6985, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9571, type_9571), Reflex::Literal("_S_on_swap"), method_6986, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
static void destructor_6995(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::~__alloc_traits();
}
static  void operator_6996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static void constructor_6997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)arg[0]);
}

static void constructor_6998( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >();
}

static  void method_6999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->allocate)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->allocate)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->deallocate)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    (::cool::ChannelSelection::ChannelRange*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_7001( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->destroy)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    (::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_7002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->max_size)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->max_size)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_7003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_S_select_on_copy)(*(const ::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static  void method_7004( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >*)o)->_S_on_swap)(*(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[0],
    *(::std::allocator<cool::ChannelSelection::ChannelRange>*)arg[1]);
}

static void method_newdel_2044( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1546, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::allocator_type"))
  .AddTypedef(type_3682, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::pointer"))
  .AddTypedef(type_3684, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::const_pointer"))
  .AddTypedef(type_3676, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::value_type"))
  .AddTypedef(type_3686, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::reference"))
  .AddTypedef(type_3688, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_6995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9948, type_9949), Reflex::Literal("operator="), operator_6996, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9949), Reflex::Literal("__alloc_traits"), constructor_6997, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_6998, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2044, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3682, type_9572, type_1636), Reflex::Literal("allocate"), method_6999, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9572, type_3682, type_1636), Reflex::Literal("deallocate"), method_7000, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9572, type_3682), Reflex::Literal("destroy"), method_7001, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9339), Reflex::Literal("max_size"), method_7002, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9339, type_9339), Reflex::Literal("_S_select_on_copy"), method_7003, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9572, type_9572), Reflex::Literal("_S_on_swap"), method_7004, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------------------
static void destructor_7031(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::~__alloc_traits();
}
static  void operator_7032( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7033( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7034( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >();
}

static  void method_7035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->allocate)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->allocate)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->deallocate)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    (::coral::AttributeSpecification**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_7037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->destroy)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    (::coral::AttributeSpecification**)arg[1]);
}

static  void method_7038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->max_size)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->max_size)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_7039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::AttributeSpecification*>*)arg[0]);
}

static  void method_7040( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >*)o)->_S_on_swap)(*(::std::allocator<coral::AttributeSpecification*>*)arg[0],
    *(::std::allocator<coral::AttributeSpecification*>*)arg[1]);
}

static void method_newdel_2047( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1547, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::allocator_type"))
  .AddTypedef(type_3750, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::pointer"))
  .AddTypedef(type_3152, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::const_pointer"))
  .AddTypedef(type_3149, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::value_type"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::reference"))
  .AddTypedef(type_3154, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_7031, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9952, type_9953), Reflex::Literal("operator="), operator_7032, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9953), Reflex::Literal("__alloc_traits"), constructor_7033, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_7034, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2047, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<coral::AttributeSpecification*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3750, type_9573, type_1636), Reflex::Literal("allocate"), method_7035, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9573, type_3750, type_1636), Reflex::Literal("deallocate"), method_7036, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9573, type_3750), Reflex::Literal("destroy"), method_7037, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9342), Reflex::Literal("max_size"), method_7038, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9342, type_9342), Reflex::Literal("_S_select_on_copy"), method_7039, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9573, type_9573), Reflex::Literal("_S_on_swap"), method_7040, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------------------
static void destructor_7049(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::~__alloc_traits();
}
static  void operator_7050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
}

static void constructor_7051( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)arg[0]);
}

static void constructor_7052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >();
}

static  void method_7053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->allocate)(*(::std::allocator<coral::Attribute*>*)arg[0],
    *(::std::size_t*)arg[1]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->allocate)(*(::std::allocator<coral::Attribute*>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->deallocate)(*(::std::allocator<coral::Attribute*>*)arg[0],
    (::coral::Attribute**)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_7055( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->destroy)(*(::std::allocator<coral::Attribute*>*)arg[0],
    (::coral::Attribute**)arg[1]);
}

static  void method_7056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->max_size)(*(const ::std::allocator<coral::Attribute*>*)arg[0]));
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->max_size)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static  void method_7057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->_S_select_on_copy)(*(const ::std::allocator<coral::Attribute*>*)arg[0]);
}

static  void method_7058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >*)o)->_S_on_swap)(*(::std::allocator<coral::Attribute*>*)arg[0],
    *(::std::allocator<coral::Attribute*>*)arg[1]);
}

static void method_newdel_2048( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1550, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::allocator_type"))
  .AddTypedef(type_3164, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::pointer"))
  .AddTypedef(type_3175, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::const_pointer"))
  .AddTypedef(type_3161, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::value_type"))
  .AddTypedef(type_3166, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::reference"))
  .AddTypedef(type_3177, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::const_reference"))
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__alloc_traits"), destructor_7049, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9954, type_9955), Reflex::Literal("operator="), operator_7050, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9955), Reflex::Literal("__alloc_traits"), constructor_7051, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__alloc_traits"), constructor_7052, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2048, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __alloc_traits<std::allocator<coral::Attribute*> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3164, type_9580, type_1636), Reflex::Literal("allocate"), method_7053, 0, "__a;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9580, type_3164, type_1636), Reflex::Literal("deallocate"), method_7054, 0, "__a;__p;__n", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9580, type_3164), Reflex::Literal("destroy"), method_7055, 0, "__a;__p", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636, type_9345), Reflex::Literal("max_size"), method_7056, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9345, type_9345), Reflex::Literal("_S_select_on_copy"), method_7057, 0, "__a", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9580, type_9580), Reflex::Literal("_S_on_swap"), method_7058, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
static void destructor_7080(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >::~rebind();
}
static  void operator_7081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_7082( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_7083( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >();
}

static void method_newdel_2053( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IRecord> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1540, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7080, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9964, type_9965), Reflex::Literal("operator="), operator_7081, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9965), Reflex::Literal("rebind"), constructor_7082, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7083, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2053, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
static void destructor_7085(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)o)->::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >::~rebind();
}
static  void operator_7086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_7087( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_7088( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >();
}

static void method_newdel_2054( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<boost::shared_ptr<cool::IObject> > -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1541, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> >::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7085, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9966, type_9967), Reflex::Literal("operator="), operator_7086, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9967), Reflex::Literal("rebind"), constructor_7087, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7088, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2054, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IRecordSelection*> -------------------------------
static void destructor_7090(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>::~rebind();
}
static  void operator_7091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_7092( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_7093( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>();
}

static void method_newdel_2055( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IRecordSelection*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1543, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7090, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9968, type_9969), Reflex::Literal("operator="), operator_7091, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9969), Reflex::Literal("rebind"), constructor_7092, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7093, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2055, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IRecordSelection*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IRecordSelection*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IField*> -------------------------------
static void destructor_7095(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>::~rebind();
}
static  void operator_7096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
}

static void constructor_7097( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>*)arg[0]);
}

static void constructor_7098( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>();
}

static void method_newdel_2056( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IField*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1542, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7095, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9970, type_9971), Reflex::Literal("operator="), operator_7096, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9971), Reflex::Literal("rebind"), constructor_7097, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7098, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2056, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IField*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IField*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::IFieldSpecification*> -------------------------------
static void destructor_7100(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>::~rebind();
}
static  void operator_7101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_7102( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_7103( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>();
}

static void method_newdel_2057( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::IFieldSpecification*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1545, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9972, type_9973), Reflex::Literal("operator="), operator_7101, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9973), Reflex::Literal("rebind"), constructor_7102, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2057, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::IFieldSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::IFieldSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
static void destructor_7105(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>::~rebind();
}
static  void operator_7106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_7107( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_7108( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>();
}

static void method_newdel_2058( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<cool::ChannelSelection::ChannelRange> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1546, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9974, type_9975), Reflex::Literal("operator="), operator_7106, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9975), Reflex::Literal("rebind"), constructor_7107, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2058, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::AttributeSpecification*> -------------------------------
static void destructor_7120(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>::~rebind();
}
static  void operator_7121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_7122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_7123( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>();
}

static void method_newdel_2061( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::AttributeSpecification*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1547, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9980, type_9981), Reflex::Literal("operator="), operator_7121, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9981), Reflex::Literal("rebind"), constructor_7122, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2061, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::AttributeSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::AttributeSpecification*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class rebind<coral::Attribute*> -------------------------------
static void destructor_7125(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)o)->::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>::~rebind();
}
static  void operator_7126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
  else   (((::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_7127( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>(*(const ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>*)arg[0]);
}

static void constructor_7128( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>();
  else ::new(mem) ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>();
}

static void method_newdel_2062( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class rebind<coral::Attribute*> -------------------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_datamem(Reflex::Class*);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__datamem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__funcmem_bld(&____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_funcmem);
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>"), typeid(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>), sizeof(::__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1550, Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*>::other"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~rebind"), destructor_7125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9982, type_9983), Reflex::Literal("operator="), operator_7126, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9983), Reflex::Literal("rebind"), constructor_7127, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("rebind"), constructor_7128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class rebind<coral::Attribute*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class rebind<coral::Attribute*> -------------------
void ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
static  void operator_7208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void constructor_7209( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >();
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >();
}

static void constructor_7210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)arg[0]);
}

static void destructor_7211(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::~new_allocator();
}
static  void method_7212( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(::boost::shared_ptr<cool::IRecord>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_7213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->address)(*(const ::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static  void method_7214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7215( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->deallocate)((::boost::shared_ptr<cool::IRecord>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->max_size)();
}

static  void method_7217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->construct)((::boost::shared_ptr<cool::IRecord>*)arg[0],
    *(const ::boost::shared_ptr<cool::IRecord>*)arg[1]);
}

static  void method_7218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >*)o)->destroy)((::boost::shared_ptr<cool::IRecord>*)arg[0]);
}

static void method_newdel_2067( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__datamem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__funcmem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >"), typeid(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >), sizeof(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::difference_type"))
  .AddTypedef(type_3119, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::pointer"))
  .AddTypedef(type_3343, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::const_pointer"))
  .AddTypedef(type_3121, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::reference"))
  .AddTypedef(type_3346, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::const_reference"))
  .AddTypedef(type_2399, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9992, type_9993), Reflex::Literal("operator="), operator_7208, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7209, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9993), Reflex::Literal("new_allocator"), constructor_7210, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7211, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2067, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<boost::shared_ptr<cool::IRecord> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3119, type_3121), Reflex::Literal("address"), method_7212, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3343, type_3346), Reflex::Literal("address"), method_7213, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3119, type_1636, type_2021), Reflex::Literal("allocate"), method_7214, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3119, type_1636), Reflex::Literal("deallocate"), method_7215, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3119, type_3346), Reflex::Literal("construct"), method_7217, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3119), Reflex::Literal("destroy"), method_7218, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------------------
static  void operator_7226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void constructor_7227( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >();
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >();
}

static void constructor_7228( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >(*(const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)arg[0]);
}

static void destructor_7229(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::~new_allocator();
}
static  void method_7230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(::boost::shared_ptr<cool::IObject>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_7231( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->address)(*(const ::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static  void method_7232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7233( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->deallocate)((::boost::shared_ptr<cool::IObject>*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->max_size)();
}

static  void method_7235( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->construct)((::boost::shared_ptr<cool::IObject>*)arg[0],
    *(const ::boost::shared_ptr<cool::IObject>*)arg[1]);
}

static  void method_7236( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >*)o)->destroy)((::boost::shared_ptr<cool::IObject>*)arg[0]);
}

static void method_newdel_2068( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__datamem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__funcmem_bld(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_funcmem);
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >"), typeid(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >), sizeof(::__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::difference_type"))
  .AddTypedef(type_3130, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::pointer"))
  .AddTypedef(type_3409, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::const_pointer"))
  .AddTypedef(type_3132, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::reference"))
  .AddTypedef(type_3412, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::const_reference"))
  .AddTypedef(type_2290, Reflex::Literal("__gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9994, type_9995), Reflex::Literal("operator="), operator_7226, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7227, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9995), Reflex::Literal("new_allocator"), constructor_7228, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7229, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2068, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<boost::shared_ptr<cool::IObject> > -------------------
void ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130, type_3132), Reflex::Literal("address"), method_7230, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3409, type_3412), Reflex::Literal("address"), method_7231, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130, type_1636, type_2021), Reflex::Literal("allocate"), method_7232, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3130, type_1636), Reflex::Literal("deallocate"), method_7233, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3130, type_3412), Reflex::Literal("construct"), method_7235, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3130), Reflex::Literal("destroy"), method_7236, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::IRecordSelection*> -------------------------------
static  void operator_7244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
}

static void constructor_7245( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>();
}

static void constructor_7246( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IRecordSelection*>(*(const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)arg[0]);
}

static void destructor_7247(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->::__gnu_cxx::new_allocator<cool::IRecordSelection*>::~new_allocator();
}
static  void method_7248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection**)arg[0]);
}

static  void method_7249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->address)(*(::cool::IRecordSelection* const*)arg[0]);
}

static  void method_7250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->deallocate)((::cool::IRecordSelection**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->max_size)();
}

static  void method_7253( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->construct)((::cool::IRecordSelection**)arg[0],
    *(::cool::IRecordSelection* const*)arg[1]);
}

static  void method_7254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IRecordSelection*>*)o)->destroy)((::cool::IRecordSelection**)arg[0]);
}

static void method_newdel_2069( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IRecordSelection*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::IRecordSelection*> -------------------------------
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IRecordSelectionp__datamem_bld(&____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IRecordSelectionp__funcmem_bld(&____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_funcmem);
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>"), typeid(::__gnu_cxx::new_allocator<cool::IRecordSelection*>), sizeof(::__gnu_cxx::new_allocator<cool::IRecordSelection*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::difference_type"))
  .AddTypedef(type_3544, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::pointer"))
  .AddTypedef(type_3546, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::const_pointer"))
  .AddTypedef(type_3548, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::reference"))
  .AddTypedef(type_3550, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::const_reference"))
  .AddTypedef(type_3538, Reflex::Literal("__gnu_cxx::new_allocator<cool::IRecordSelection*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9996, type_9997), Reflex::Literal("operator="), operator_7244, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7245, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9997), Reflex::Literal("new_allocator"), constructor_7246, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7247, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2069, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__IRecordSelectionp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::IRecordSelection*> -------------------
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::IRecordSelection*> -------------------
void ____gnu_cxx__new_allocator_cool__IRecordSelectionp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3544, type_3548), Reflex::Literal("address"), method_7248, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3546, type_3550), Reflex::Literal("address"), method_7249, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3544, type_1636, type_2021), Reflex::Literal("allocate"), method_7250, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3544, type_1636), Reflex::Literal("deallocate"), method_7251, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3544, type_3550), Reflex::Literal("construct"), method_7253, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3544), Reflex::Literal("destroy"), method_7254, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::IField*> -------------------------------
static  void operator_7262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
}

static void constructor_7263( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>();
}

static void constructor_7264( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IField*>(*(const ::__gnu_cxx::new_allocator<cool::IField*>*)arg[0]);
}

static void destructor_7265(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::IField*>*)o)->::__gnu_cxx::new_allocator<cool::IField*>::~new_allocator();
}
static  void method_7266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField**)arg[0]);
}

static  void method_7267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->address)(*(::cool::IField* const*)arg[0]);
}

static  void method_7268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->deallocate)((::cool::IField**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::IField*>*)o)->max_size)();
}

static  void method_7271( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->construct)((::cool::IField**)arg[0],
    *(::cool::IField* const*)arg[1]);
}

static  void method_7272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IField*>*)o)->destroy)((::cool::IField**)arg[0]);
}

static void method_newdel_2070( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IField*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::IField*> -------------------------------
void ____gnu_cxx__new_allocator_cool__IFieldp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__IFieldp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldp__datamem_bld(&____gnu_cxx__new_allocator_cool__IFieldp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldp__funcmem_bld(&____gnu_cxx__new_allocator_cool__IFieldp__db_funcmem);
void ____gnu_cxx__new_allocator_cool__IFieldp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>"), typeid(::__gnu_cxx::new_allocator<cool::IField*>), sizeof(::__gnu_cxx::new_allocator<cool::IField*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::difference_type"))
  .AddTypedef(type_3475, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::pointer"))
  .AddTypedef(type_3477, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::const_pointer"))
  .AddTypedef(type_3479, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::reference"))
  .AddTypedef(type_3481, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::const_reference"))
  .AddTypedef(type_3469, Reflex::Literal("__gnu_cxx::new_allocator<cool::IField*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9998, type_9999), Reflex::Literal("operator="), operator_7262, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7263, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9999), Reflex::Literal("new_allocator"), constructor_7264, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7265, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2070, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__IFieldp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::IField*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::IField*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3475, type_3479), Reflex::Literal("address"), method_7266, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3477, type_3481), Reflex::Literal("address"), method_7267, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3475, type_1636, type_2021), Reflex::Literal("allocate"), method_7268, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3475, type_1636), Reflex::Literal("deallocate"), method_7269, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3475, type_3481), Reflex::Literal("construct"), method_7271, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3475), Reflex::Literal("destroy"), method_7272, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::IFieldSpecification*> -------------------------------
static  void operator_7280( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void constructor_7281( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>();
}

static void constructor_7282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>(*(const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)arg[0]);
}

static void destructor_7283(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->::__gnu_cxx::new_allocator<cool::IFieldSpecification*>::~new_allocator();
}
static  void method_7284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification**)arg[0]);
}

static  void method_7285( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->address)(*(::cool::IFieldSpecification* const*)arg[0]);
}

static  void method_7286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7287( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->deallocate)((::cool::IFieldSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->max_size)();
}

static  void method_7289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->construct)((::cool::IFieldSpecification**)arg[0],
    *(::cool::IFieldSpecification* const*)arg[1]);
}

static  void method_7290( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::IFieldSpecification*>*)o)->destroy)((::cool::IFieldSpecification**)arg[0]);
}

static void method_newdel_2071( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::IFieldSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::IFieldSpecification*> -------------------------------
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__datamem_bld(&____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__funcmem_bld(&____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_funcmem);
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>"), typeid(::__gnu_cxx::new_allocator<cool::IFieldSpecification*>), sizeof(::__gnu_cxx::new_allocator<cool::IFieldSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::difference_type"))
  .AddTypedef(type_3613, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::pointer"))
  .AddTypedef(type_3615, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::const_pointer"))
  .AddTypedef(type_3617, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::reference"))
  .AddTypedef(type_3619, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::const_reference"))
  .AddTypedef(type_3607, Reflex::Literal("__gnu_cxx::new_allocator<cool::IFieldSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10000, type_10001), Reflex::Literal("operator="), operator_7280, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7281, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10001), Reflex::Literal("new_allocator"), constructor_7282, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7283, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2071, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__IFieldSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::IFieldSpecification*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::IFieldSpecification*> -------------------
void ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3613, type_3617), Reflex::Literal("address"), method_7284, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3615, type_3619), Reflex::Literal("address"), method_7285, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3613, type_1636, type_2021), Reflex::Literal("allocate"), method_7286, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3613, type_1636), Reflex::Literal("deallocate"), method_7287, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7288, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3613, type_3619), Reflex::Literal("construct"), method_7289, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3613), Reflex::Literal("destroy"), method_7290, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------------------
static  void operator_7298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void constructor_7299( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>();
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>();
}

static void constructor_7300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>(*(const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)arg[0]);
}

static void destructor_7301(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::~new_allocator();
}
static  void method_7302( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(::cool::ChannelSelection::ChannelRange*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static  void method_7303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->address)(*(const ::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static  void method_7304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7305( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->deallocate)((::cool::ChannelSelection::ChannelRange*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->max_size)();
}

static  void method_7307( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->construct)((::cool::ChannelSelection::ChannelRange*)arg[0],
    *(const ::cool::ChannelSelection::ChannelRange*)arg[1]);
}

static  void method_7308( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>*)o)->destroy)((::cool::ChannelSelection::ChannelRange*)arg[0]);
}

static void method_newdel_2072( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------------------
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__datamem_bld(&____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__funcmem_bld(&____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_funcmem);
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>"), typeid(::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>), sizeof(::__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::difference_type"))
  .AddTypedef(type_3682, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::pointer"))
  .AddTypedef(type_3684, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::const_pointer"))
  .AddTypedef(type_3686, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::reference"))
  .AddTypedef(type_3688, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::const_reference"))
  .AddTypedef(type_3676, Reflex::Literal("__gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10002, type_10003), Reflex::Literal("operator="), operator_7298, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7299, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10003), Reflex::Literal("new_allocator"), constructor_7300, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7301, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2072, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<cool::ChannelSelection::ChannelRange> -------------------
void ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3682, type_3686), Reflex::Literal("address"), method_7302, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3684, type_3688), Reflex::Literal("address"), method_7303, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3682, type_1636, type_2021), Reflex::Literal("allocate"), method_7304, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3682, type_1636), Reflex::Literal("deallocate"), method_7305, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3682, type_3688), Reflex::Literal("construct"), method_7307, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3682), Reflex::Literal("destroy"), method_7308, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<coral::AttributeSpecification*> -------------------------------
static  void operator_7352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void constructor_7353( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>();
}

static void constructor_7354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>(*(const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)arg[0]);
}

static void destructor_7355(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->::__gnu_cxx::new_allocator<coral::AttributeSpecification*>::~new_allocator();
}
static  void method_7356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification**)arg[0]);
}

static  void method_7357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->address)(*(::coral::AttributeSpecification* const*)arg[0]);
}

static  void method_7358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7359( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->deallocate)((::coral::AttributeSpecification**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->max_size)();
}

static  void method_7361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->construct)((::coral::AttributeSpecification**)arg[0],
    *(::coral::AttributeSpecification* const*)arg[1]);
}

static  void method_7362( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::AttributeSpecification*>*)o)->destroy)((::coral::AttributeSpecification**)arg[0]);
}

static void method_newdel_2075( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::AttributeSpecification*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<coral::AttributeSpecification*> -------------------------------
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__datamem_bld(&____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__funcmem_bld(&____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_funcmem);
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>"), typeid(::__gnu_cxx::new_allocator<coral::AttributeSpecification*>), sizeof(::__gnu_cxx::new_allocator<coral::AttributeSpecification*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::difference_type"))
  .AddTypedef(type_3750, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::pointer"))
  .AddTypedef(type_3152, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::const_pointer"))
  .AddTypedef(type_3753, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::reference"))
  .AddTypedef(type_3154, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::const_reference"))
  .AddTypedef(type_3149, Reflex::Literal("__gnu_cxx::new_allocator<coral::AttributeSpecification*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10008, type_10009), Reflex::Literal("operator="), operator_7352, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7353, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10009), Reflex::Literal("new_allocator"), constructor_7354, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7355, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2075, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_coral__AttributeSpecificationp__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<coral::AttributeSpecification*> -------------------
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<coral::AttributeSpecification*> -------------------
void ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3750, type_3753), Reflex::Literal("address"), method_7356, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3152, type_3154), Reflex::Literal("address"), method_7357, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3750, type_1636, type_2021), Reflex::Literal("allocate"), method_7358, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3750, type_1636), Reflex::Literal("deallocate"), method_7359, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3750, type_3154), Reflex::Literal("construct"), method_7361, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3750), Reflex::Literal("destroy"), method_7362, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class new_allocator<coral::Attribute*> -------------------------------
static  void operator_7370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
  else   (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->operator=)(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
}

static void constructor_7371( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>();
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>();
}

static void constructor_7372( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::new_allocator<coral::Attribute*>(*(const ::__gnu_cxx::new_allocator<coral::Attribute*>*)arg[0]);
}

static void destructor_7373(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->::__gnu_cxx::new_allocator<coral::Attribute*>::~new_allocator();
}
static  void method_7374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute**)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute**)arg[0]);
}

static  void method_7375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute* const*)arg[0]));
  else   (((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->address)(*(::coral::Attribute* const*)arg[0]);
}

static  void method_7376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0]));
    else     (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]));
    else     (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->allocate)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_7377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->deallocate)((::coral::Attribute**)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_7378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->max_size)());
  else   (((const ::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->max_size)();
}

static  void method_7379( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->construct)((::coral::Attribute**)arg[0],
    *(::coral::Attribute* const*)arg[1]);
}

static  void method_7380( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::new_allocator<coral::Attribute*>*)o)->destroy)((::coral::Attribute**)arg[0]);
}

static void method_newdel_2076( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::new_allocator<coral::Attribute*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class new_allocator<coral::Attribute*> -------------------------------
void ____gnu_cxx__new_allocator_coral__Attributep__db_datamem(Reflex::Class*);
void ____gnu_cxx__new_allocator_coral__Attributep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__Attributep__datamem_bld(&____gnu_cxx__new_allocator_coral__Attributep__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__new_allocator_coral__Attributep__funcmem_bld(&____gnu_cxx__new_allocator_coral__Attributep__db_funcmem);
void ____gnu_cxx__new_allocator_coral__Attributep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>"), typeid(::__gnu_cxx::new_allocator<coral::Attribute*>), sizeof(::__gnu_cxx::new_allocator<coral::Attribute*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1636, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::size_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::difference_type"))
  .AddTypedef(type_3164, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::pointer"))
  .AddTypedef(type_3175, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::const_pointer"))
  .AddTypedef(type_3166, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::reference"))
  .AddTypedef(type_3177, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::const_reference"))
  .AddTypedef(type_3161, Reflex::Literal("__gnu_cxx::new_allocator<coral::Attribute*>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10010, type_10011), Reflex::Literal("operator="), operator_7370, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("new_allocator"), constructor_7371, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10011), Reflex::Literal("new_allocator"), constructor_7372, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~new_allocator"), destructor_7373, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2076, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__new_allocator_coral__Attributep__funcmem_bld);
}

//------Delayed data member builder for class new_allocator<coral::Attribute*> -------------------
void ____gnu_cxx__new_allocator_coral__Attributep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class new_allocator<coral::Attribute*> -------------------
void ____gnu_cxx__new_allocator_coral__Attributep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3164, type_3166), Reflex::Literal("address"), method_7374, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3175, type_3177), Reflex::Literal("address"), method_7375, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3164, type_1636, type_2021), Reflex::Literal("allocate"), method_7376, 0, "__n;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3164, type_1636), Reflex::Literal("deallocate"), method_7377, 0, "__p;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("max_size"), method_7378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3164, type_3177), Reflex::Literal("construct"), method_7379, 0, "__p;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3164), Reflex::Literal("destroy"), method_7380, 0, "__p", ::Reflex::PUBLIC);
}
//------Stub functions for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
static void destructor_7493(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)o)->::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >::~__enable_if();
}
static  void operator_7494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7495( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7496( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >();
}

static void method_newdel_2112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__datamem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__funcmem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_funcmem);
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >"), typeid(::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >), sizeof(::__gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__enable_if"), destructor_7493, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10064, type_10065), Reflex::Literal("operator="), operator_7494, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10065), Reflex::Literal("__enable_if"), constructor_7495, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__enable_if"), constructor_7496, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __enable_if<false,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7497(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >::~__enable_if();
}
static  void operator_7498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7500( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >();
}

static void method_newdel_2113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__enable_if"), destructor_7497, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10066, type_10067), Reflex::Literal("operator="), operator_7498, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10067), Reflex::Literal("__enable_if"), constructor_7499, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__enable_if"), constructor_7500, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __enable_if<false,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7502(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >::~__enable_if();
}
static  void operator_7503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7505( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >();
}

static void method_newdel_2114( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1407, Reflex::Literal("__gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> >::__type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__enable_if"), destructor_7502, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10068, type_10069), Reflex::Literal("operator="), operator_7503, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10069), Reflex::Literal("__enable_if"), constructor_7504, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__enable_if"), constructor_7505, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class __enable_if<true,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
static void destructor_7549(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::~__normal_iterator();
}
static  void operator_7550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_7551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_7552( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >();
}

static void constructor_7553( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(::boost::shared_ptr<cool::IRecord>* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >(*(::boost::shared_ptr<cool::IRecord>* const*)arg[0]);
}

static  void operator_7554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
}

static  void operator_7555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)();
}

static  void operator_7556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)();
}

static  void operator_7557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)();
}

static  void operator_7559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->base)();
}

static void method_newdel_2128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >"), typeid(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >), sizeof(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1389, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::__traits_type"))
  .AddTypedef(type_3119, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::iterator_type"))
  .AddTypedef(type_1533, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::iterator_category"))
  .AddTypedef(type_2399, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::difference_type"))
  .AddTypedef(type_3121, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::reference"))
  .AddTypedef(type_3119, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7549, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10084, type_10085), Reflex::Literal("operator="), operator_7550, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10085), Reflex::Literal("__normal_iterator"), constructor_7551, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7552, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10086), Reflex::Literal("__normal_iterator"), constructor_7553, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3119, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3121), Reflex::Literal("operator*"), operator_7554, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3119), Reflex::Literal("operator->"), operator_7555, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10084), Reflex::Literal("operator++"), operator_7556, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_31), Reflex::Literal("operator++"), operator_7557, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10084), Reflex::Literal("operator--"), operator_7558, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_31), Reflex::Literal("operator--"), operator_7559, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3121, type_1581), Reflex::Literal("operator[]"), operator_7560, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10084, type_1581), Reflex::Literal("operator+="), operator_7561, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_1581), Reflex::Literal("operator+"), operator_7562, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10084, type_1581), Reflex::Literal("operator-="), operator_7563, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_1581), Reflex::Literal("operator-"), operator_7564, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10086), Reflex::Literal("base"), method_7565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
static void destructor_7574(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::~__normal_iterator();
}
static  void operator_7575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_7576( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_7577( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >();
}

static void constructor_7578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(::boost::shared_ptr<cool::IObject>* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >(*(::boost::shared_ptr<cool::IObject>* const*)arg[0]);
}

static  void operator_7579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
}

static  void operator_7580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)();
}

static  void operator_7581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)();
}

static  void operator_7582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)();
}

static  void operator_7584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >)((((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >*)o)->base)();
}

static void method_newdel_2130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >"), typeid(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >), sizeof(::__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*cool::*>")
  .AddTypedef(type_1390, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::__traits_type"))
  .AddTypedef(type_3130, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::iterator_type"))
  .AddTypedef(type_1533, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::iterator_category"))
  .AddTypedef(type_2290, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::difference_type"))
  .AddTypedef(type_3132, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::reference"))
  .AddTypedef(type_3130, Reflex::Literal("__gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7574, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10087, type_10088), Reflex::Literal("operator="), operator_7575, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10088), Reflex::Literal("__normal_iterator"), constructor_7576, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7577, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10089), Reflex::Literal("__normal_iterator"), constructor_7578, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3130, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132), Reflex::Literal("operator*"), operator_7579, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130), Reflex::Literal("operator->"), operator_7580, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10087), Reflex::Literal("operator++"), operator_7581, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130, type_31), Reflex::Literal("operator++"), operator_7582, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10087), Reflex::Literal("operator--"), operator_7583, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130, type_31), Reflex::Literal("operator--"), operator_7584, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132, type_1581), Reflex::Literal("operator[]"), operator_7585, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10087, type_1581), Reflex::Literal("operator+="), operator_7586, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130, type_1581), Reflex::Literal("operator+"), operator_7587, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10087, type_1581), Reflex::Literal("operator-="), operator_7588, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2130, type_1581), Reflex::Literal("operator-"), operator_7589, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10089), Reflex::Literal("base"), method_7590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
static void destructor_7624(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::~__normal_iterator();
}
static  void operator_7625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7626( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)arg[0]);
}

static void constructor_7627( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >();
}

static void constructor_7628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(::coral::AttributeSpecification* const* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >(*(::coral::AttributeSpecification* const* const*)arg[0]);
}

static  void operator_7629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator*)();
}

static  void operator_7630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator->)();
}

static  void operator_7631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)();
}

static  void operator_7632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)();
}

static  void operator_7634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >)((((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >*)o)->base)();
}

static void method_newdel_2141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------------------
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__datamem_bld(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__funcmem_bld(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_funcmem);
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >"), typeid(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >), sizeof(::__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1392, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::__traits_type"))
  .AddTypedef(type_3152, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::iterator_type"))
  .AddTypedef(type_1533, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::iterator_category"))
  .AddTypedef(type_3149, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::difference_type"))
  .AddTypedef(type_3154, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::reference"))
  .AddTypedef(type_3152, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7624, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10093, type_7476), Reflex::Literal("operator="), operator_7625, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7476), Reflex::Literal("__normal_iterator"), constructor_7626, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7627, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10094), Reflex::Literal("__normal_iterator"), constructor_7628, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3152, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*, std::allocator<coral::AttributeSpecification*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3154), Reflex::Literal("operator*"), operator_7629, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3152), Reflex::Literal("operator->"), operator_7630, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10093), Reflex::Literal("operator++"), operator_7631, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141, type_31), Reflex::Literal("operator++"), operator_7632, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10093), Reflex::Literal("operator--"), operator_7633, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141, type_31), Reflex::Literal("operator--"), operator_7634, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3154, type_1581), Reflex::Literal("operator[]"), operator_7635, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10093, type_1581), Reflex::Literal("operator+="), operator_7636, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141, type_1581), Reflex::Literal("operator+"), operator_7637, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10093, type_1581), Reflex::Literal("operator-="), operator_7638, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141, type_1581), Reflex::Literal("operator-"), operator_7639, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10094), Reflex::Literal("base"), method_7640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7649(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::~__normal_iterator();
}
static  void operator_7650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7651( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7652( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >();
}

static void constructor_7653( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(::coral::Attribute** const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >(*(::coral::Attribute** const*)arg[0]);
}

static  void operator_7654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator*)();
}

static  void operator_7655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator->)();
}

static  void operator_7656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)();
}

static  void operator_7657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)();
}

static  void operator_7659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >*)o)->base)();
}

static void method_newdel_2143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1393, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::__traits_type"))
  .AddTypedef(type_3164, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::iterator_type"))
  .AddTypedef(type_1533, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::iterator_category"))
  .AddTypedef(type_3161, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::difference_type"))
  .AddTypedef(type_3166, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::reference"))
  .AddTypedef(type_3164, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7649, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10095, type_10096), Reflex::Literal("operator="), operator_7650, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10096), Reflex::Literal("__normal_iterator"), constructor_7651, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7652, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10097), Reflex::Literal("__normal_iterator"), constructor_7653, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3164, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<coral::Attribute**,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3166), Reflex::Literal("operator*"), operator_7654, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3164), Reflex::Literal("operator->"), operator_7655, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10095), Reflex::Literal("operator++"), operator_7656, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143, type_31), Reflex::Literal("operator++"), operator_7657, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10095), Reflex::Literal("operator--"), operator_7658, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143, type_31), Reflex::Literal("operator--"), operator_7659, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3166, type_1581), Reflex::Literal("operator[]"), operator_7660, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10095, type_1581), Reflex::Literal("operator+="), operator_7661, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143, type_1581), Reflex::Literal("operator+"), operator_7662, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10095, type_1581), Reflex::Literal("operator-="), operator_7663, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2143, type_1581), Reflex::Literal("operator-"), operator_7664, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10097), Reflex::Literal("base"), method_7665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
static void destructor_7674(void*, void * o, const std::vector<void*>&, void *) {
((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::~__normal_iterator();
}
static  void operator_7675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7676( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)arg[0]);
}

static void constructor_7677( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >();
}

static void constructor_7678( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(::coral::Attribute* const* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >(*(::coral::Attribute* const* const*)arg[0]);
}

static  void operator_7679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator*)();
}

static  void operator_7680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator->)();
}

static  void operator_7681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)();
}

static  void operator_7682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_7683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)();
}

static  void operator_7684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_7685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator[])(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator+)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-=)(*(::std::ptrdiff_t*)arg[0]);
}

static  void operator_7689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >)((((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->operator-)(*(::std::ptrdiff_t*)arg[0]);
}

static  void method_7690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >*)o)->base)();
}

static void method_newdel_2144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------------------
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__datamem_bld(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__funcmem_bld(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_funcmem);
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >"), typeid(::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >), sizeof(::__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "*<*coral::*>")
  .AddTypedef(type_1394, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::__traits_type"))
  .AddTypedef(type_3175, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::iterator_type"))
  .AddTypedef(type_1533, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::iterator_category"))
  .AddTypedef(type_3161, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::value_type"))
  .AddTypedef(type_1581, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::difference_type"))
  .AddTypedef(type_3177, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::reference"))
  .AddTypedef(type_3175, Reflex::Literal("__gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_7674, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10098, type_7477), Reflex::Literal("operator="), operator_7675, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7477), Reflex::Literal("__normal_iterator"), constructor_7676, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_7677, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10099), Reflex::Literal("__normal_iterator"), constructor_7678, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3175, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*, std::allocator<coral::Attribute*> > > -------------------
void ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3177), Reflex::Literal("operator*"), operator_7679, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3175), Reflex::Literal("operator->"), operator_7680, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10098), Reflex::Literal("operator++"), operator_7681, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144, type_31), Reflex::Literal("operator++"), operator_7682, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10098), Reflex::Literal("operator--"), operator_7683, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144, type_31), Reflex::Literal("operator--"), operator_7684, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3177, type_1581), Reflex::Literal("operator[]"), operator_7685, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10098, type_1581), Reflex::Literal("operator+="), operator_7686, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144, type_1581), Reflex::Literal("operator+"), operator_7687, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10098, type_1581), Reflex::Literal("operator-="), operator_7688, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144, type_1581), Reflex::Literal("operator-"), operator_7689, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10099), Reflex::Literal("base"), method_7690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IObjectIterator -------------------------------
static void destructor_7791(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IObjectIterator*)o)->::cool::IObjectIterator::~IObjectIterator();
}
static  void method_7792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IObjectIterator*)o)->isEmpty)());
  else   (((::cool::IObjectIterator*)o)->isEmpty)();
}

static  void method_7793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IObjectIterator*)o)->goToNext)());
  else   (((::cool::IObjectIterator*)o)->goToNext)();
}

static  void method_7794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::IObjectIterator*)o)->currentRef)();
  else   (((::cool::IObjectIterator*)o)->currentRef)();
}

static  void method_7795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::cool::IObjectIterator*)o)->size)());
  else   (((::cool::IObjectIterator*)o)->size)();
}

static  void method_7796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IObjectVectorPtr)((((::cool::IObjectIterator*)o)->fetchAllAsVector)());
  else   (((::cool::IObjectIterator*)o)->fetchAllAsVector)();
}

static  void method_7797( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IObjectIterator*)o)->close)();
}

//------Dictionary for class IObjectIterator -------------------------------
void __cool__IObjectIterator_db_datamem(Reflex::Class*);
void __cool__IObjectIterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IObjectIterator_datamem_bld(&__cool__IObjectIterator_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IObjectIterator_funcmem_bld(&__cool__IObjectIterator_db_funcmem);
void __cool__IObjectIterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IObjectIterator"), typeid(::cool::IObjectIterator), sizeof(::cool::IObjectIterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IObjectIterator"), destructor_7791, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IObjectIterator_funcmem_bld);
}

//------Delayed data member builder for class IObjectIterator -------------------
void __cool__IObjectIterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IObjectIterator -------------------
void __cool__IObjectIterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isEmpty"), method_7792, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("goToNext"), method_7793, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8527), Reflex::Literal("currentRef"), method_7794, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_80), Reflex::Literal("size"), method_7795, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2335c), Reflex::Literal("fetchAllAsVector"), method_7796, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("close"), method_7797, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class FieldSelection -------------------------------
static  void method_7802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Relation*)arg[0]));
  else   (((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Relation*)arg[0]);
}

static  void method_7803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Nullness*)arg[0]));
  else   (((::cool::FieldSelection*)o)->describe)(*(::cool::FieldSelection::Nullness*)arg[0]);
}

static void destructor_7804(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSelection*)o)->::cool::FieldSelection::~FieldSelection();
}
static void constructor_7817( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Nullness*)arg[2]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Nullness*)arg[2]);
}

static  void method_7818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::FieldSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::FieldSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_7820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::FieldSelection*)o)->clone)());
  else   (((const ::cool::FieldSelection*)o)->clone)();
}

static  void method_7821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::FieldSelection*)o)->nullness)());
  else   (((const ::cool::FieldSelection*)o)->nullness)();
}

static  void method_7822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::FieldSelection*)o)->relation)());
  else   (((const ::cool::FieldSelection*)o)->relation)();
}

static  void method_7823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FieldSelection*)o)->referenceValue)();
  else   (((const ::cool::FieldSelection*)o)->referenceValue)();
}

static void constructor_7805( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::coral::Blob*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::coral::Blob*)arg[3]);
}

static void constructor_7806( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
}

static void constructor_7807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const double*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const double*)arg[3]);
}

static void constructor_7808( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const float*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const float*)arg[3]);
}

static void constructor_7809( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned long long*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned long long*)arg[3]);
}

static void constructor_7810( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const long long*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const long long*)arg[3]);
}

static void constructor_7811( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned int*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned int*)arg[3]);
}

static void constructor_7812( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const int*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const int*)arg[3]);
}

static void constructor_7813( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned short*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned short*)arg[3]);
}

static void constructor_7814( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const short*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const short*)arg[3]);
}

static void constructor_7815( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned char*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const unsigned char*)arg[3]);
}

static void constructor_7816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const bool*)arg[3]);
  else ::new(mem) ::cool::FieldSelection(*(const ::std::basic_string<char>*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1],
      *(::cool::FieldSelection::Relation*)arg[2],
      *(const bool*)arg[3]);
}

static void method_x110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSelection")), ::Reflex::BaseOffset< ::cool::FieldSelection,::cool::IRecordSelection >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSelection -------------------------------
void __cool__FieldSelection_db_datamem(Reflex::Class*);
void __cool__FieldSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSelection_datamem_bld(&__cool__FieldSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSelection_funcmem_bld(&__cool__FieldSelection_db_funcmem);
void __cool__FieldSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSelection"), typeid(::cool::FieldSelection), sizeof(::cool::FieldSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2336, ::Reflex::BaseOffset< ::cool::FieldSelection, ::cool::IRecordSelection >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("cool::FieldSelection::Relation"), Reflex::Literal("EQ=0;NE=1;GT=2;GE=3;LT=4;LE=5"), &typeid(cool::FieldSelection::Relation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("cool::FieldSelection::Nullness"), Reflex::Literal("IS_NULL=0;IS_NOT_NULL=1"), &typeid(cool::FieldSelection::Nullness), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSelection"), destructor_7804, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_7704c, type_7801), Reflex::Literal("FieldSelection"), constructor_7817, 0, "name;typeId;nullness", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10125), Reflex::Literal("FieldSelection<coral::Blob>"), constructor_7805, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_3213), Reflex::Literal("FieldSelection<std::string>"), constructor_7806, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10126), Reflex::Literal("FieldSelection<double>"), constructor_7807, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10127), Reflex::Literal("FieldSelection<float>"), constructor_7808, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10128), Reflex::Literal("FieldSelection<unsigned long long>"), constructor_7809, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10129), Reflex::Literal("FieldSelection<long long>"), constructor_7810, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_3280), Reflex::Literal("FieldSelection<unsigned int>"), constructor_7811, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_6021), Reflex::Literal("FieldSelection<int>"), constructor_7812, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10130), Reflex::Literal("FieldSelection<unsigned short>"), constructor_7813, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10131), Reflex::Literal("FieldSelection<short>"), constructor_7814, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_10132), Reflex::Literal("FieldSelection<unsigned char>"), constructor_7815, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3213, type_7704c, type_7706, type_6020), Reflex::Literal("FieldSelection<bool>"), constructor_7816, 0, "name;typeId;relation;refValue", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FieldSelection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FieldSelection_funcmem_bld);
}

//------Delayed data member builder for class FieldSelection -------------------
void __cool__FieldSelection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2310, Reflex::Literal("m_refValue"), OffsetOf(__shadow__::__cool__FieldSelection, m_refValue), ::Reflex::PRIVATE)
  .AddDataMember(type_7706, Reflex::Literal("m_relation"), OffsetOf(__shadow__::__cool__FieldSelection, m_relation), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FieldSelection -------------------
void __cool__FieldSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_7706), Reflex::Literal("describe"), method_7802, 0, "relation", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_7801), Reflex::Literal("describe"), method_7803, 0, "nullness", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10133), Reflex::Literal("canSelect"), method_7818, 0, "spec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8529), Reflex::Literal("select"), method_7819, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3538), Reflex::Literal("clone"), method_7820, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7801), Reflex::Literal("nullness"), method_7821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7706), Reflex::Literal("relation"), method_7822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530), Reflex::Literal("referenceValue"), method_7823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FieldSpecificationWrongStorageType -------------------------------
static  void operator_7828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldSpecificationWrongStorageType*)o)->operator=)(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
  else   (((::cool::FieldSpecificationWrongStorageType*)o)->operator=)(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
}

static void constructor_7829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
  else ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::cool::FieldSpecificationWrongStorageType*)arg[0]);
}

static void constructor_7830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::cool::StorageType*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::FieldSpecificationWrongStorageType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::cool::StorageType*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_7831(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecificationWrongStorageType*)o)->::cool::FieldSpecificationWrongStorageType::~FieldSpecificationWrongStorageType();
}
static void method_x111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecificationWrongStorageType -------------------------------
void __cool__FieldSpecificationWrongStorageType_db_datamem(Reflex::Class*);
void __cool__FieldSpecificationWrongStorageType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongStorageType_datamem_bld(&__cool__FieldSpecificationWrongStorageType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongStorageType_funcmem_bld(&__cool__FieldSpecificationWrongStorageType_db_funcmem);
void __cool__FieldSpecificationWrongStorageType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecificationWrongStorageType"), typeid(::cool::FieldSpecificationWrongStorageType), sizeof(::cool::FieldSpecificationWrongStorageType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongStorageType, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10136, type_10137), Reflex::Literal("operator="), operator_7828, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10137), Reflex::Literal("FieldSpecificationWrongStorageType"), constructor_7829, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10138, type_10138, type_4135), Reflex::Literal("FieldSpecificationWrongStorageType"), constructor_7830, 0, "expectedName;expectedStorageType;actualStorageType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecificationWrongStorageType"), destructor_7831, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldSpecificationWrongStorageType -------------------
void __cool__FieldSpecificationWrongStorageType_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldSpecificationWrongStorageType -------------------
void __cool__FieldSpecificationWrongStorageType_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagNotFound -------------------------------
static  void operator_7833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagNotFound*)o)->operator=)(*(const ::cool::TagNotFound*)arg[0]);
  else   (((::cool::TagNotFound*)o)->operator=)(*(const ::cool::TagNotFound*)arg[0]);
}

static void constructor_7834( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::cool::TagNotFound*)arg[0]);
  else ::new(mem) ::cool::TagNotFound(*(const ::cool::TagNotFound*)arg[0]);
}

static void constructor_7835( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_7836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_7837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::TagNotFound(*(const ::std::string*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_7838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::TagNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7839(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagNotFound*)o)->::cool::TagNotFound::~TagNotFound();
}
static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagNotFound -------------------------------
void __cool__TagNotFound_db_datamem(Reflex::Class*);
void __cool__TagNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagNotFound_datamem_bld(&__cool__TagNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagNotFound_funcmem_bld(&__cool__TagNotFound_db_funcmem);
void __cool__TagNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagNotFound"), typeid(::cool::TagNotFound), sizeof(::cool::TagNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::TagNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10139, type_10140), Reflex::Literal("operator="), operator_7833, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10140), Reflex::Literal("TagNotFound"), constructor_7834, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("TagNotFound"), constructor_7835, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_4135), Reflex::Literal("TagNotFound"), constructor_7836, 0, "tagName;nodeName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_2367, type_4135), Reflex::Literal("TagNotFound"), constructor_7837, 0, "tagName;nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_2367, type_4135), Reflex::Literal("TagNotFound"), constructor_7838, 0, "tagId;nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagNotFound"), destructor_7839, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagNotFound -------------------
void __cool__TagNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagNotFound -------------------
void __cool__TagNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PayloadSpecificationTooManyFields -------------------------------
static  void operator_7840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationTooManyFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
  else   (((::cool::PayloadSpecificationTooManyFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
}

static void constructor_7841( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(const ::cool::PayloadSpecificationTooManyFields*)arg[0]);
}

static void constructor_7842( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_7843(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationTooManyFields*)o)->::cool::PayloadSpecificationTooManyFields::~PayloadSpecificationTooManyFields();
}
static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationTooManyFields -------------------------------
void __cool__PayloadSpecificationTooManyFields_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationTooManyFields_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyFields_datamem_bld(&__cool__PayloadSpecificationTooManyFields_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyFields_funcmem_bld(&__cool__PayloadSpecificationTooManyFields_db_funcmem);
void __cool__PayloadSpecificationTooManyFields_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyFields"), typeid(::cool::PayloadSpecificationTooManyFields), sizeof(::cool::PayloadSpecificationTooManyFields), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2315, ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyFields, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10141, type_10142), Reflex::Literal("operator="), operator_7840, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10142), Reflex::Literal("PayloadSpecificationTooManyFields"), constructor_7841, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_4135), Reflex::Literal("PayloadSpecificationTooManyFields"), constructor_7842, 0, "nFields;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationTooManyFields"), destructor_7843, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationTooManyFields -------------------
void __cool__PayloadSpecificationTooManyFields_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationTooManyFields -------------------
void __cool__PayloadSpecificationTooManyFields_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ChannelExists -------------------------------
static  void operator_7844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelExists*)o)->operator=)(*(const ::cool::ChannelExists*)arg[0]);
  else   (((::cool::ChannelExists*)o)->operator=)(*(const ::cool::ChannelExists*)arg[0]);
}

static void constructor_7845( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelExists(*(const ::cool::ChannelExists*)arg[0]);
  else ::new(mem) ::cool::ChannelExists(*(const ::cool::ChannelExists*)arg[0]);
}

static void constructor_7846( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_7847( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ChannelExists(*(const ::std::string*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7848(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelExists*)o)->::cool::ChannelExists::~ChannelExists();
}
static void method_x114( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ChannelExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ChannelExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ChannelExists -------------------------------
void __cool__ChannelExists_db_datamem(Reflex::Class*);
void __cool__ChannelExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelExists_datamem_bld(&__cool__ChannelExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelExists_funcmem_bld(&__cool__ChannelExists_db_funcmem);
void __cool__ChannelExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelExists"), typeid(::cool::ChannelExists), sizeof(::cool::ChannelExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::ChannelExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10143, type_10144), Reflex::Literal("operator="), operator_7844, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10144), Reflex::Literal("ChannelExists"), constructor_7845, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_4135), Reflex::Literal("ChannelExists"), constructor_7846, 0, "folderName;channelName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10145, type_4135), Reflex::Literal("ChannelExists"), constructor_7847, 0, "folderName;channelId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelExists"), destructor_7848, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ChannelExists -------------------
void __cool__ChannelExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ChannelExists -------------------
void __cool__ChannelExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IField -------------------------------
static void destructor_7851(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IField*)o)->::cool::IField::~IField();
}
static  void method_7852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->specification)();
  else   (((const ::cool::IField*)o)->specification)();
}

static  void method_7853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->name)();
  else   (((const ::cool::IField*)o)->name)();
}

static  void method_7854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->storageType)();
  else   (((const ::cool::IField*)o)->storageType)();
}

static  void method_7855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IField*)o)->isNull)());
  else   (((const ::cool::IField*)o)->isNull)();
}

static  void method_7868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IField*)o)->addressOfData)());
  else   (((const ::cool::IField*)o)->addressOfData)();
}

static  void method_7869( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IField*)o)->setNull)();
}

static  void method_7882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue)(*(const ::cool::IField*)arg[0]);
}

static  void operator_7883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IField*)o)->operator==)(*(const ::cool::IField*)arg[0]));
  else   (((const ::cool::IField*)o)->operator==)(*(const ::cool::IField*)arg[0]);
}

static  void operator_7884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IField*)o)->operator!=)(*(const ::cool::IField*)arg[0]));
  else   (((const ::cool::IField*)o)->operator!=)(*(const ::cool::IField*)arg[0]);
}

static  void method_7885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IField*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void method_7886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->printValue)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::IField*)o)->printValue)(*(::std::ostream*)arg[0]);
}

static  void method_7887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->attribute)();
  else   (((const ::cool::IField*)o)->attribute)();
}

static  void method_7856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<coral::Blob>)();
  else   (((const ::cool::IField*)o)->data<coral::Blob>)();
}

static  void method_7857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<std::string>)();
  else   (((const ::cool::IField*)o)->data<std::string>)();
}

static  void method_7858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<double>)();
  else   (((const ::cool::IField*)o)->data<double>)();
}

static  void method_7859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<float>)();
  else   (((const ::cool::IField*)o)->data<float>)();
}

static  void method_7860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned long long>)();
  else   (((const ::cool::IField*)o)->data<unsigned long long>)();
}

static  void method_7861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<long long>)();
  else   (((const ::cool::IField*)o)->data<long long>)();
}

static  void method_7862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned int>)();
  else   (((const ::cool::IField*)o)->data<unsigned int>)();
}

static  void method_7863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<int>)();
  else   (((const ::cool::IField*)o)->data<int>)();
}

static  void method_7864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned short>)();
  else   (((const ::cool::IField*)o)->data<unsigned short>)();
}

static  void method_7865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<short>)();
  else   (((const ::cool::IField*)o)->data<short>)();
}

static  void method_7866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<unsigned char>)();
  else   (((const ::cool::IField*)o)->data<unsigned char>)();
}

static  void method_7867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IField*)o)->data<bool>)();
  else   (((const ::cool::IField*)o)->data<bool>)();
}

static  void method_7870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<coral::Blob>)(*(const ::coral::Blob*)arg[0]);
}

static  void method_7871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<std::string>)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_7872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<double>)(*(const double*)arg[0]);
}

static  void method_7873( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<float>)(*(const float*)arg[0]);
}

static  void method_7874( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned long long>)(*(const ::cool::UInt63*)arg[0]);
}

static  void method_7875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<long long>)(*(const ::cool::Int64*)arg[0]);
}

static  void method_7876( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned int>)(*(const ::cool::UInt32*)arg[0]);
}

static  void method_7877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<int>)(*(const ::cool::Int32*)arg[0]);
}

static  void method_7878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned short>)(*(const ::cool::UInt16*)arg[0]);
}

static  void method_7879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<short>)(*(const ::cool::Int16*)arg[0]);
}

static  void method_7880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<unsigned char>)(*(const ::cool::UChar*)arg[0]);
}

static  void method_7881( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IField*)o)->setValue<bool>)(*(const bool*)arg[0]);
}

//------Dictionary for class IField -------------------------------
void __cool__IField_db_datamem(Reflex::Class*);
void __cool__IField_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IField_datamem_bld(&__cool__IField_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IField_funcmem_bld(&__cool__IField_db_funcmem);
void __cool__IField_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IField"), typeid(::cool::IField), sizeof(::cool::IField), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IField"), destructor_7851, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IField_funcmem_bld);
}

//------Delayed data member builder for class IField -------------------
void __cool__IField_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IField -------------------
void __cool__IField_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10146), Reflex::Literal("specification"), method_7852, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("name"), method_7853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10138), Reflex::Literal("storageType"), method_7854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isNull"), method_7855, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("addressOfData"), method_7868, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("setNull"), method_7869, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8530), Reflex::Literal("setValue"), method_7882, 0, "field", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8530), Reflex::Literal("operator=="), operator_7883, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8530), Reflex::Literal("operator!="), operator_7884, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525), Reflex::Literal("print"), method_7885, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525), Reflex::Literal("printValue"), method_7886, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8914), Reflex::Literal("attribute"), method_7887, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10125), Reflex::Literal("data<coral::Blob>"), method_7856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3213), Reflex::Literal("data<std::string>"), method_7857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10126), Reflex::Literal("data<double>"), method_7858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10127), Reflex::Literal("data<float>"), method_7859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10128), Reflex::Literal("data<unsigned long long>"), method_7860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10129), Reflex::Literal("data<long long>"), method_7861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3280), Reflex::Literal("data<unsigned int>"), method_7862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6021), Reflex::Literal("data<int>"), method_7863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10130), Reflex::Literal("data<unsigned short>"), method_7864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10131), Reflex::Literal("data<short>"), method_7865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10132), Reflex::Literal("data<unsigned char>"), method_7866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6020), Reflex::Literal("data<bool>"), method_7867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10125), Reflex::Literal("setValue<coral::Blob>"), method_7870, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3213), Reflex::Literal("setValue<std::string>"), method_7871, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10126), Reflex::Literal("setValue<double>"), method_7872, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10127), Reflex::Literal("setValue<float>"), method_7873, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10147), Reflex::Literal("setValue<unsigned long long>"), method_7874, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_7714), Reflex::Literal("setValue<long long>"), method_7875, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_7711), Reflex::Literal("setValue<unsigned int>"), method_7876, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_7709), Reflex::Literal("setValue<int>"), method_7877, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_7744), Reflex::Literal("setValue<unsigned short>"), method_7878, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_7715), Reflex::Literal("setValue<short>"), method_7879, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_7712), Reflex::Literal("setValue<unsigned char>"), method_7880, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_6020), Reflex::Literal("setValue<bool>"), method_7881, 0, "value", ::Reflex::PUBLIC);
}
//------Stub functions for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
static void destructor_7895(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::~shared_ptr();
}
static void constructor_7896( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void constructor_7897( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >();
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >();
}

static  void operator_7898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
  else   (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_7899( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->reset)();
}

static  void operator_7900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator*)();
}

static  void operator_7901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator->)();
}

static  void method_7903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->get)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->get)();
}

static  void converter_7904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*)();
}

static  void operator_7905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator!)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->operator!)();
}

static  void method_7906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->unique)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->unique)();
}

static  void method_7907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->use_count)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->use_count)();
}

static  void method_7908( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->swap)(*(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static  void method_7909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_7910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_get_untyped_deleter)();
}

static  void method_7911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >*)arg[0]);
}

static void method_newdel_2271( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class*);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >"), typeid(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >), sizeof(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_1399, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::element_type"))
  .AddTypedef(type_10150, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_7895, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10151), Reflex::Literal("shared_ptr"), constructor_7896, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_7897, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2271, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10149, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IRecord>, std::allocator<boost::shared_ptr<cool::IRecord> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10152, type_10151), Reflex::Literal("operator="), operator_7898, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_7899, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9311), Reflex::Literal("operator*"), operator_7900, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10149), Reflex::Literal("operator->"), operator_7901, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10149), Reflex::Literal("get"), method_7903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10150), Reflex::Literal("operator std::vector<boost::shared_ptr<cool::IRecord> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > >::*"), converter_7904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_7905, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_7906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_7907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10152), Reflex::Literal("swap"), method_7908, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_7909, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_7910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10151), Reflex::Literal("_internal_equiv"), method_7911, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class InvalidChannelRange -------------------------------
static  void operator_7912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidChannelRange*)o)->operator=)(*(const ::cool::InvalidChannelRange*)arg[0]);
  else   (((::cool::InvalidChannelRange*)o)->operator=)(*(const ::cool::InvalidChannelRange*)arg[0]);
}

static void constructor_7913( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::InvalidChannelRange*)arg[0]);
  else ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::InvalidChannelRange*)arg[0]);
}

static void constructor_7914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::InvalidChannelRange(*(const ::cool::ChannelId*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_7915(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidChannelRange*)o)->::cool::InvalidChannelRange::~InvalidChannelRange();
}
static void method_x116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelRange,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelRange,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidChannelRange -------------------------------
void __cool__InvalidChannelRange_db_datamem(Reflex::Class*);
void __cool__InvalidChannelRange_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelRange_datamem_bld(&__cool__InvalidChannelRange_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelRange_funcmem_bld(&__cool__InvalidChannelRange_db_funcmem);
void __cool__InvalidChannelRange_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidChannelRange"), typeid(::cool::InvalidChannelRange), sizeof(::cool::InvalidChannelRange), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::InvalidChannelRange, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10154, type_10155), Reflex::Literal("operator="), operator_7912, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10155), Reflex::Literal("InvalidChannelRange"), constructor_7913, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10145, type_10145, type_4135), Reflex::Literal("InvalidChannelRange"), constructor_7914, 0, "firstChannel;lastChannel;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidChannelRange"), destructor_7915, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidChannelRange -------------------
void __cool__InvalidChannelRange_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidChannelRange -------------------
void __cool__InvalidChannelRange_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeStringTooLong -------------------------------
static  void operator_7916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeStringTooLong*)o)->operator=)(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
  else   (((::cool::StorageTypeStringTooLong*)o)->operator=)(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
}

static void constructor_7917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
  else ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::cool::StorageTypeStringTooLong*)arg[0]);
}

static void constructor_7918( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::StorageTypeStringTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(::size_t*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_7919(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeStringTooLong*)o)->::cool::StorageTypeStringTooLong::~StorageTypeStringTooLong();
}
static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeStringTooLong -------------------------------
void __cool__StorageTypeStringTooLong_db_datamem(Reflex::Class*);
void __cool__StorageTypeStringTooLong_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringTooLong_datamem_bld(&__cool__StorageTypeStringTooLong_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringTooLong_funcmem_bld(&__cool__StorageTypeStringTooLong_db_funcmem);
void __cool__StorageTypeStringTooLong_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeStringTooLong"), typeid(::cool::StorageTypeStringTooLong), sizeof(::cool::StorageTypeStringTooLong), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2388, ::Reflex::BaseOffset< ::cool::StorageTypeStringTooLong, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10156, type_10157), Reflex::Literal("operator="), operator_7916, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10157), Reflex::Literal("StorageTypeStringTooLong"), constructor_7917, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10138, type_869, type_4135), Reflex::Literal("StorageTypeStringTooLong"), constructor_7918, 0, "expectedName;expectedStorageType;actualSize;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeStringTooLong"), destructor_7919, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeStringTooLong -------------------
void __cool__StorageTypeStringTooLong_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeStringTooLong -------------------
void __cool__StorageTypeStringTooLong_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFolderSet -------------------------------
static void destructor_7922(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFolderSet*)o)->::cool::IFolderSet::~IFolderSet();
}
static  void method_7923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolders)());
    else     (((::cool::IFolderSet*)o)->listFolders)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolders)(*(bool*)arg[0]));
    else     (((::cool::IFolderSet*)o)->listFolders)(*(bool*)arg[0]);
  }
}

static  void method_7924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolderSets)());
    else     (((::cool::IFolderSet*)o)->listFolderSets)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IFolderSet*)o)->listFolderSets)(*(bool*)arg[0]));
    else     (((::cool::IFolderSet*)o)->listFolderSets)(*(bool*)arg[0]);
  }
}

static  void method_7925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSet*)o)->folderSetAttributes)();
  else   (((const ::cool::IFolderSet*)o)->folderSetAttributes)();
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNode")), ::Reflex::BaseOffset< ::cool::IFolderSet,::cool::IHvsNode >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord")), ::Reflex::BaseOffset< ::cool::IFolderSet,::cool::IHvsNodeRecord >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IFolderSet -------------------------------
void __cool__IFolderSet_db_datamem(Reflex::Class*);
void __cool__IFolderSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFolderSet_datamem_bld(&__cool__IFolderSet_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFolderSet_funcmem_bld(&__cool__IFolderSet_db_funcmem);
void __cool__IFolderSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFolderSet"), typeid(::cool::IFolderSet), sizeof(::cool::IFolderSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2339, ::Reflex::BaseOffset< ::cool::IFolderSet, ::cool::IHvsNode >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFolderSet"), destructor_7922, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__IFolderSet_funcmem_bld);
}

//------Delayed data member builder for class IFolderSet -------------------
void __cool__IFolderSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFolderSet -------------------
void __cool__IFolderSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1397, type_1881), Reflex::Literal("listFolders"), method_7923, 0, "ascending=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1397, type_1881), Reflex::Literal("listFolderSets"), method_7924, 0, "ascending=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8529), Reflex::Literal("folderSetAttributes"), method_7925, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class CompositeSelection -------------------------------
static  void method_7930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::CompositeSelection*)o)->describe)(*(::cool::CompositeSelection::Connective*)arg[0]));
  else   (((::cool::CompositeSelection*)o)->describe)(*(::cool::CompositeSelection::Connective*)arg[0]);
}

static void destructor_7931(void*, void * o, const std::vector<void*>&, void *) {
((::cool::CompositeSelection*)o)->::cool::CompositeSelection::~CompositeSelection();
}
static void constructor_7932( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::CompositeSelection((const ::cool::IRecordSelection*)arg[0],
      *(::cool::CompositeSelection::Connective*)arg[1],
      (const ::cool::IRecordSelection*)arg[2]);
  else ::new(mem) ::cool::CompositeSelection((const ::cool::IRecordSelection*)arg[0],
      *(::cool::CompositeSelection::Connective*)arg[1],
      (const ::cool::IRecordSelection*)arg[2]);
}

static void constructor_7933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::CompositeSelection(*(::cool::CompositeSelection::Connective*)arg[0],
      *(const ::std::vector<const cool::IRecordSelection*>*)arg[1]);
  else ::new(mem) ::cool::CompositeSelection(*(::cool::CompositeSelection::Connective*)arg[0],
      *(const ::std::vector<const cool::IRecordSelection*>*)arg[1]);
}

static  void method_7934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::CompositeSelection*)o)->connect)(*(::cool::CompositeSelection::Connective*)arg[0],
    (const ::cool::IRecordSelection*)arg[1]);
}

static  void method_7935( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::CompositeSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::CompositeSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::CompositeSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::CompositeSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_7937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::CompositeSelection*)o)->clone)());
  else   (((const ::cool::CompositeSelection*)o)->clone)();
}

static  void method_7938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::CompositeSelection*)o)->connective)());
  else   (((const ::cool::CompositeSelection*)o)->connective)();
}

static  void method_7939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::CompositeSelection*)o)->size)());
  else   (((const ::cool::CompositeSelection*)o)->size)();
}

static  void operator_7940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::CompositeSelection*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::cool::CompositeSelection*)o)->operator[])(*(unsigned int*)arg[0]);
}

static void method_x119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSelection")), ::Reflex::BaseOffset< ::cool::CompositeSelection,::cool::IRecordSelection >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CompositeSelection -------------------------------
void __cool__CompositeSelection_db_datamem(Reflex::Class*);
void __cool__CompositeSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__CompositeSelection_datamem_bld(&__cool__CompositeSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__CompositeSelection_funcmem_bld(&__cool__CompositeSelection_db_funcmem);
void __cool__CompositeSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::CompositeSelection"), typeid(::cool::CompositeSelection), sizeof(::cool::CompositeSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2336, ::Reflex::BaseOffset< ::cool::CompositeSelection, ::cool::IRecordSelection >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("cool::CompositeSelection::Connective"), Reflex::Literal("AND=0;OR=1"), &typeid(cool::CompositeSelection::Connective), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CompositeSelection"), destructor_7931, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10160, type_7929, type_10160), Reflex::Literal("CompositeSelection"), constructor_7932, 0, "sel1;conn;sel2", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7929, type_10161), Reflex::Literal("CompositeSelection"), constructor_7933, 0, "conn;selVec", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__CompositeSelection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__CompositeSelection_funcmem_bld);
}

//------Delayed data member builder for class CompositeSelection -------------------
void __cool__CompositeSelection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7929, Reflex::Literal("m_conn"), OffsetOf(__shadow__::__cool__CompositeSelection, m_conn), ::Reflex::PRIVATE)
  .AddDataMember(type_1402, Reflex::Literal("m_selVec"), OffsetOf(__shadow__::__cool__CompositeSelection, m_selVec), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class CompositeSelection -------------------
void __cool__CompositeSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_7929), Reflex::Literal("describe"), method_7930, 0, "conn", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_7929, type_10160), Reflex::Literal("connect"), method_7934, 0, "conn;sel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10133), Reflex::Literal("canSelect"), method_7935, 0, "spec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8529), Reflex::Literal("select"), method_7936, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3538), Reflex::Literal("clone"), method_7937, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7929), Reflex::Literal("connective"), method_7938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_80), Reflex::Literal("size"), method_7939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10160, type_80), Reflex::Literal("operator[]"), operator_7940, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class StorageType -------------------------------
static void destructor_7946(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageType*)o)->::cool::StorageType::~StorageType();
}
static  void method_7947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageType*)o)->storageType)(*(const ::cool::StorageType::TypeId*)arg[0]);
  else   (((::cool::StorageType*)o)->storageType)(*(const ::cool::StorageType::TypeId*)arg[0]);
}

static  void method_7948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::StorageType*)o)->id)();
  else   (((const ::cool::StorageType*)o)->id)();
}

static  void method_7949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::StorageType*)o)->name)());
  else   (((const ::cool::StorageType*)o)->name)();
}

static  void method_7950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::StorageType*)o)->cppType)();
  else   (((const ::cool::StorageType*)o)->cppType)();
}

static  void method_7951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::cool::StorageType*)o)->maxSize)());
  else   (((const ::cool::StorageType*)o)->maxSize)();
}

static  void operator_7952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType*)arg[0]);
}

static  void operator_7953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType*)arg[0]);
}

static  void operator_7954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType::TypeId*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator==)(*(const ::cool::StorageType::TypeId*)arg[0]);
}

static  void operator_7955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType::TypeId*)arg[0]));
  else   (((const ::cool::StorageType*)o)->operator!=)(*(const ::cool::StorageType::TypeId*)arg[0]);
}

//------Dictionary for class StorageType -------------------------------
void __cool__StorageType_db_datamem(Reflex::Class*);
void __cool__StorageType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageType_datamem_bld(&__cool__StorageType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageType_funcmem_bld(&__cool__StorageType_db_funcmem);
void __cool__StorageType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageType"), typeid(::cool::StorageType), sizeof(::cool::StorageType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddEnum(Reflex::Literal("cool::StorageType::TypeId"), Reflex::Literal("Bool=0;UChar=1;Int16=2;UInt16=3;Int32=4;UInt32=5;UInt63=6;Int64=7;Float=8;Double=9;String255=10;String4k=11;String64k=12;String16M=13;Blob64k=14;Blob16M=15"), &typeid(cool::StorageType::TypeId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageType"), destructor_7946, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__cool__StorageType_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__StorageType_funcmem_bld);
}

//------Delayed data member builder for class StorageType -------------------
void __cool__StorageType_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7704c, Reflex::Literal("m_id"), OffsetOf(__shadow__::__cool__StorageType, m_id), ::Reflex::PRIVATE | ::Reflex::CONST);
}
//------Delayed function member builder for class StorageType -------------------
void __cool__StorageType_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10138, type_10164), Reflex::Literal("storageType"), method_7947, 0, "id", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10164), Reflex::Literal("id"), method_7948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c), Reflex::Literal("name"), method_7949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9791), Reflex::Literal("cppType"), method_7950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_869), Reflex::Literal("maxSize"), method_7951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10138), Reflex::Literal("operator=="), operator_7952, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10138), Reflex::Literal("operator!="), operator_7953, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10164), Reflex::Literal("operator=="), operator_7954, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10164), Reflex::Literal("operator!="), operator_7955, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class IRecordSpecification -------------------------------
static void destructor_7963(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecordSpecification*)o)->::cool::IRecordSpecification::~IRecordSpecification();
}
static  void method_7964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecordSpecification*)o)->size)());
  else   (((const ::cool::IRecordSpecification*)o)->size)();
}

static  void operator_7965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void operator_7966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_7967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void operator_7968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::IRecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_7969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IRecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::IRecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void method_7970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IRecordSpecification*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IRecordSpecification*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void method_7971( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_7972( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IRecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0],
      *(bool*)arg[1]);
  }
}

//------Dictionary for class IRecordSpecification -------------------------------
void __cool__IRecordSpecification_db_datamem(Reflex::Class*);
void __cool__IRecordSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecordSpecification_datamem_bld(&__cool__IRecordSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecordSpecification_funcmem_bld(&__cool__IRecordSpecification_db_funcmem);
void __cool__IRecordSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecordSpecification"), typeid(::cool::IRecordSpecification), sizeof(::cool::IRecordSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecordSpecification"), destructor_7963, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecordSpecification_funcmem_bld);
}

//------Delayed data member builder for class IRecordSpecification -------------------
void __cool__IRecordSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecordSpecification -------------------
void __cool__IRecordSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("size"), method_7964, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10133), Reflex::Literal("operator=="), operator_7965, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10133), Reflex::Literal("operator!="), operator_7966, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("exists"), method_7967, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10146, type_2367), Reflex::Literal("operator[]"), operator_7968, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10146, type_4135), Reflex::Literal("operator[]"), operator_7969, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367, type_4135), Reflex::Literal("index"), method_7970, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8529, type_1881), Reflex::Literal("validate"), method_7971, 0, "record;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8913, type_1881), Reflex::Literal("validate"), method_7972, 0, "attributeList;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<cool::IObjectIterator> -------------------------------
static void destructor_7978(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IObjectIterator>*)o)->::boost::shared_ptr<cool::IObjectIterator>::~shared_ptr();
}
static void constructor_7979( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static void constructor_7980( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>();
  else ::new(mem) ::boost::shared_ptr<cool::IObjectIterator>();
}

static  void operator_7981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IObjectIterator>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IObjectIterator>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static  void method_7982( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IObjectIterator>*)o)->reset)();
}

static  void operator_7983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator*)();
}

static  void operator_7984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator->)();
}

static  void method_7986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->get)();
}

static  void converter_7987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*)();
}

static  void operator_7988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->operator!)();
}

static  void method_7989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->unique)();
}

static  void method_7990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->use_count)();
}

static  void method_7991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IObjectIterator>*)o)->swap)(*(::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static  void method_7992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_7993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_get_untyped_deleter)();
}

static  void method_7994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IObjectIterator>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IObjectIterator>*)arg[0]);
}

static void method_newdel_2282( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IObjectIterator> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IObjectIterator> -------------------------------
void __boost__shared_ptr_cool__IObjectIterator__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IObjectIterator__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObjectIterator__datamem_bld(&__boost__shared_ptr_cool__IObjectIterator__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IObjectIterator__funcmem_bld(&__boost__shared_ptr_cool__IObjectIterator__db_funcmem);
void __boost__shared_ptr_cool__IObjectIterator__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>"), typeid(::boost::shared_ptr<cool::IObjectIterator>), sizeof(::boost::shared_ptr<cool::IObjectIterator>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2263, Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>::element_type"))
  .AddTypedef(type_10168, Reflex::Literal("boost::shared_ptr<cool::IObjectIterator>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_7978, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10169), Reflex::Literal("shared_ptr"), constructor_7979, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_7980, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2282, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IObjectIterator__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IObjectIterator__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IObjectIterator> -------------------
void __boost__shared_ptr_cool__IObjectIterator__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10167, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObjectIterator_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IObjectIterator_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IObjectIterator> -------------------
void __boost__shared_ptr_cool__IObjectIterator__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10170, type_10169), Reflex::Literal("operator="), operator_7981, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_7982, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10124), Reflex::Literal("operator*"), operator_7983, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10167), Reflex::Literal("operator->"), operator_7984, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10167), Reflex::Literal("get"), method_7986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10168), Reflex::Literal("operator cool::IObjectIterator* boost::shared_ptr<cool::IObjectIterator>::*"), converter_7987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_7988, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_7989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_7990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10170), Reflex::Literal("swap"), method_7991, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_7992, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_7993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10169), Reflex::Literal("_internal_equiv"), method_7994, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RecordSpecificationUnknownField -------------------------------
static  void operator_7997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecificationUnknownField*)o)->operator=)(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
  else   (((::cool::RecordSpecificationUnknownField*)o)->operator=)(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
}

static void constructor_7998( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
  else ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::cool::RecordSpecificationUnknownField*)arg[0]);
}

static void constructor_7999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::RecordSpecificationUnknownField(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8000( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationUnknownField(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::RecordSpecificationUnknownField(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8001(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecificationUnknownField*)o)->::cool::RecordSpecificationUnknownField::~RecordSpecificationUnknownField();
}
static void method_x121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecificationUnknownField -------------------------------
void __cool__RecordSpecificationUnknownField_db_datamem(Reflex::Class*);
void __cool__RecordSpecificationUnknownField_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationUnknownField_datamem_bld(&__cool__RecordSpecificationUnknownField_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationUnknownField_funcmem_bld(&__cool__RecordSpecificationUnknownField_db_funcmem);
void __cool__RecordSpecificationUnknownField_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecificationUnknownField"), typeid(::cool::RecordSpecificationUnknownField), sizeof(::cool::RecordSpecificationUnknownField), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::RecordSpecificationUnknownField, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10181, type_10182), Reflex::Literal("operator="), operator_7997, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10182), Reflex::Literal("RecordSpecificationUnknownField"), constructor_7998, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("RecordSpecificationUnknownField"), constructor_7999, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_48c, type_48c, type_4135), Reflex::Literal("RecordSpecificationUnknownField"), constructor_8000, 0, "index;size;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecificationUnknownField"), destructor_8001, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordSpecificationUnknownField -------------------
void __cool__RecordSpecificationUnknownField_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordSpecificationUnknownField -------------------
void __cool__RecordSpecificationUnknownField_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagRelationNotFound -------------------------------
static  void operator_8003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagRelationNotFound*)o)->operator=)(*(const ::cool::TagRelationNotFound*)arg[0]);
  else   (((::cool::TagRelationNotFound*)o)->operator=)(*(const ::cool::TagRelationNotFound*)arg[0]);
}

static void constructor_8004( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationNotFound(*(const ::cool::TagRelationNotFound*)arg[0]);
  else ::new(mem) ::cool::TagRelationNotFound(*(const ::cool::TagRelationNotFound*)arg[0]);
}

static void constructor_8005( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::TagRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8006(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagRelationNotFound*)o)->::cool::TagRelationNotFound::~TagRelationNotFound();
}
static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagRelationNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagRelationNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagRelationNotFound -------------------------------
void __cool__TagRelationNotFound_db_datamem(Reflex::Class*);
void __cool__TagRelationNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagRelationNotFound_datamem_bld(&__cool__TagRelationNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagRelationNotFound_funcmem_bld(&__cool__TagRelationNotFound_db_funcmem);
void __cool__TagRelationNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagRelationNotFound"), typeid(::cool::TagRelationNotFound), sizeof(::cool::TagRelationNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::TagRelationNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10183, type_10184), Reflex::Literal("operator="), operator_8003, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10184), Reflex::Literal("TagRelationNotFound"), constructor_8004, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_2367, type_2367, type_4135), Reflex::Literal("TagRelationNotFound"), constructor_8005, 0, "parentNodeId;parentTagId;childNodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagRelationNotFound"), destructor_8006, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagRelationNotFound -------------------
void __cool__TagRelationNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagRelationNotFound -------------------
void __cool__TagRelationNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FolderSetNotFound -------------------------------
static  void operator_8029( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderSetNotFound*)o)->operator=)(*(const ::cool::FolderSetNotFound*)arg[0]);
  else   (((::cool::FolderSetNotFound*)o)->operator=)(*(const ::cool::FolderSetNotFound*)arg[0]);
}

static void constructor_8030( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSetNotFound(*(const ::cool::FolderSetNotFound*)arg[0]);
  else ::new(mem) ::cool::FolderSetNotFound(*(const ::cool::FolderSetNotFound*)arg[0]);
}

static void constructor_8031( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::cool::FolderSetNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static void destructor_8032(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderSetNotFound*)o)->::cool::FolderSetNotFound::~FolderSetNotFound();
}
static  void method_8033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FolderSetNotFound*)o)->isFolder)());
  else   (((const ::cool::FolderSetNotFound*)o)->isFolder)();
}

static void method_x123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeNotFound")), ::Reflex::BaseOffset< ::cool::FolderSetNotFound,::cool::NodeNotFound >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FolderSetNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FolderSetNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderSetNotFound -------------------------------
void __cool__FolderSetNotFound_db_datamem(Reflex::Class*);
void __cool__FolderSetNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderSetNotFound_datamem_bld(&__cool__FolderSetNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderSetNotFound_funcmem_bld(&__cool__FolderSetNotFound_db_funcmem);
void __cool__FolderSetNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderSetNotFound"), typeid(::cool::FolderSetNotFound), sizeof(::cool::FolderSetNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2379, ::Reflex::BaseOffset< ::cool::FolderSetNotFound, ::cool::NodeNotFound >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10188, type_10189), Reflex::Literal("operator="), operator_8029, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10189), Reflex::Literal("FolderSetNotFound"), constructor_8030, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_1881), Reflex::Literal("FolderSetNotFound"), constructor_8031, 0, "fullPath;domain;isFolder=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderSetNotFound"), destructor_8032, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FolderSetNotFound_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FolderSetNotFound_funcmem_bld);
}

//------Delayed data member builder for class FolderSetNotFound -------------------
void __cool__FolderSetNotFound_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1881, Reflex::Literal("m_isFolder"), OffsetOf(__shadow__::__cool__FolderSetNotFound, m_isFolder), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FolderSetNotFound -------------------
void __cool__FolderSetNotFound_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isFolder"), method_8033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FieldWrongCppType -------------------------------
static  void operator_8036( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldWrongCppType*)o)->operator=)(*(const ::cool::FieldWrongCppType*)arg[0]);
  else   (((::cool::FieldWrongCppType*)o)->operator=)(*(const ::cool::FieldWrongCppType*)arg[0]);
}

static void constructor_8037( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldWrongCppType(*(const ::cool::FieldWrongCppType*)arg[0]);
  else ::new(mem) ::cool::FieldWrongCppType(*(const ::cool::FieldWrongCppType*)arg[0]);
}

static void constructor_8038( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::FieldWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8039(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldWrongCppType*)o)->::cool::FieldWrongCppType::~FieldWrongCppType();
}
static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldWrongCppType,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldWrongCppType,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldWrongCppType,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldWrongCppType -------------------------------
void __cool__FieldWrongCppType_db_datamem(Reflex::Class*);
void __cool__FieldWrongCppType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldWrongCppType_datamem_bld(&__cool__FieldWrongCppType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldWrongCppType_funcmem_bld(&__cool__FieldWrongCppType_db_funcmem);
void __cool__FieldWrongCppType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldWrongCppType"), typeid(::cool::FieldWrongCppType), sizeof(::cool::FieldWrongCppType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::FieldWrongCppType, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10190, type_10191), Reflex::Literal("operator="), operator_8036, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10191), Reflex::Literal("FieldWrongCppType"), constructor_8037, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10138, type_9791, type_4135), Reflex::Literal("FieldWrongCppType"), constructor_8038, 0, "name;storageType;templateCppType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldWrongCppType"), destructor_8039, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldWrongCppType -------------------
void __cool__FieldWrongCppType_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldWrongCppType -------------------
void __cool__FieldWrongCppType_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class shared_ptr<cool::IFolderSet> -------------------------------
static void destructor_8044(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IFolderSet>*)o)->::boost::shared_ptr<cool::IFolderSet>::~shared_ptr();
}
static void constructor_8045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolderSet>(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IFolderSet>(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static void constructor_8046( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolderSet>();
  else ::new(mem) ::boost::shared_ptr<cool::IFolderSet>();
}

static  void operator_8047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IFolderSet>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IFolderSet>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static  void method_8048( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IFolderSet>*)o)->reset)();
}

static  void operator_8049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator*)();
}

static  void operator_8050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator->)();
}

static  void method_8052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->get)();
}

static  void converter_8053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*)();
}

static  void operator_8054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->operator!)();
}

static  void method_8055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->unique)();
}

static  void method_8056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->use_count)();
}

static  void method_8057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IFolderSet>*)o)->swap)(*(::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static  void method_8058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolderSet>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolderSet>*)arg[0]);
}

static void method_newdel_2298( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolderSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IFolderSet> -------------------------------
void __boost__shared_ptr_cool__IFolderSet__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IFolderSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolderSet__datamem_bld(&__boost__shared_ptr_cool__IFolderSet__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolderSet__funcmem_bld(&__boost__shared_ptr_cool__IFolderSet__db_funcmem);
void __boost__shared_ptr_cool__IFolderSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolderSet>"), typeid(::boost::shared_ptr<cool::IFolderSet>), sizeof(::boost::shared_ptr<cool::IFolderSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2277, Reflex::Literal("boost::shared_ptr<cool::IFolderSet>::element_type"))
  .AddTypedef(type_10193, Reflex::Literal("boost::shared_ptr<cool::IFolderSet>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8044, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10194), Reflex::Literal("shared_ptr"), constructor_8045, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8046, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2298, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IFolderSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IFolderSet__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IFolderSet> -------------------
void __boost__shared_ptr_cool__IFolderSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10192, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolderSet_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolderSet_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IFolderSet> -------------------
void __boost__shared_ptr_cool__IFolderSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10195, type_10194), Reflex::Literal("operator="), operator_8047, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_8048, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10159), Reflex::Literal("operator*"), operator_8049, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10192), Reflex::Literal("operator->"), operator_8050, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10192), Reflex::Literal("get"), method_8052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10193), Reflex::Literal("operator cool::IFolderSet* boost::shared_ptr<cool::IFolderSet>::*"), converter_8053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_8054, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_8055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_8056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10195), Reflex::Literal("swap"), method_8057, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_8058, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_8059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10194), Reflex::Literal("_internal_equiv"), method_8060, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FieldSpecificationWrongName -------------------------------
static  void operator_8079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldSpecificationWrongName*)o)->operator=)(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
  else   (((::cool::FieldSpecificationWrongName*)o)->operator=)(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
}

static void constructor_8080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
  else ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::cool::FieldSpecificationWrongName*)arg[0]);
}

static void constructor_8081( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::FieldSpecificationWrongName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8082(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecificationWrongName*)o)->::cool::FieldSpecificationWrongName::~FieldSpecificationWrongName();
}
static void method_x126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecificationWrongName -------------------------------
void __cool__FieldSpecificationWrongName_db_datamem(Reflex::Class*);
void __cool__FieldSpecificationWrongName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongName_datamem_bld(&__cool__FieldSpecificationWrongName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationWrongName_funcmem_bld(&__cool__FieldSpecificationWrongName_db_funcmem);
void __cool__FieldSpecificationWrongName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecificationWrongName"), typeid(::cool::FieldSpecificationWrongName), sizeof(::cool::FieldSpecificationWrongName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::FieldSpecificationWrongName, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10197, type_10198), Reflex::Literal("operator="), operator_8079, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10198), Reflex::Literal("FieldSpecificationWrongName"), constructor_8080, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_4135), Reflex::Literal("FieldSpecificationWrongName"), constructor_8081, 0, "expectedName;actualName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecificationWrongName"), destructor_8082, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldSpecificationWrongName -------------------
void __cool__FieldSpecificationWrongName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldSpecificationWrongName -------------------
void __cool__FieldSpecificationWrongName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RecordSpecification -------------------------------
static void destructor_8084(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecification*)o)->::cool::RecordSpecification::~RecordSpecification();
}
static void constructor_8085( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecification();
  else ::new(mem) ::cool::RecordSpecification();
}

static void constructor_8086( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecification(*(const ::cool::RecordSpecification*)arg[0]);
  else ::new(mem) ::cool::RecordSpecification(*(const ::cool::RecordSpecification*)arg[0]);
}

static void constructor_8087( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
  else ::new(mem) ::cool::RecordSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void operator_8088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::RecordSpecification*)arg[0]);
  else   (((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::RecordSpecification*)arg[0]);
}

static  void operator_8089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::IRecordSpecification*)arg[0]);
  else   (((::cool::RecordSpecification*)o)->operator=)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_8090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::cool::StorageType::TypeId*)arg[1]);
}

static  void method_8091( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::cool::StorageType*)arg[1]);
}

static  void method_8092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void method_8093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::RecordSpecification*)o)->extend)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_8094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::RecordSpecification*)o)->size)());
  else   (((const ::cool::RecordSpecification*)o)->size)();
}

static  void operator_8095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::RecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->operator==)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void operator_8096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::RecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->operator!=)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_8097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::RecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void operator_8098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::RecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::RecordSpecification*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_8099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::RecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::RecordSpecification*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void method_8100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::RecordSpecification*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::RecordSpecification*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void method_8101( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::cool::IRecord*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8102( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::RecordSpecification*)o)->validate)(*(const ::coral::AttributeList*)arg[0],
      *(bool*)arg[1]);
  }
}

static void method_newdel_2304( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::RecordSpecification >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecordSpecification")), ::Reflex::BaseOffset< ::cool::RecordSpecification,::cool::IRecordSpecification >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecification -------------------------------
void __cool__RecordSpecification_db_datamem(Reflex::Class*);
void __cool__RecordSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecification_datamem_bld(&__cool__RecordSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecification_funcmem_bld(&__cool__RecordSpecification_db_funcmem);
void __cool__RecordSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecification"), typeid(::cool::RecordSpecification), sizeof(::cool::RecordSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2281, ::Reflex::BaseOffset< ::cool::RecordSpecification, ::cool::IRecordSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecification"), destructor_8084, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RecordSpecification"), constructor_8085, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10199), Reflex::Literal("RecordSpecification"), constructor_8086, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10133), Reflex::Literal("RecordSpecification"), constructor_8087, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__RecordSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__RecordSpecification_funcmem_bld);
}

//------Delayed data member builder for class RecordSpecification -------------------
void __cool__RecordSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1404, Reflex::Literal("m_fSpecs"), OffsetOf(__shadow__::__cool__RecordSpecification, m_fSpecs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RecordSpecification -------------------
void __cool__RecordSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10200, type_10199), Reflex::Literal("operator="), operator_8088, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10200, type_10133), Reflex::Literal("operator="), operator_8089, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_7704c), Reflex::Literal("extend"), method_8090, 0, "name;typeId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_10138), Reflex::Literal("extend"), method_8091, 0, "name;type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10146), Reflex::Literal("extend"), method_8092, 0, "fldSpec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10133), Reflex::Literal("extend"), method_8093, 0, "recSpec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("size"), method_8094, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10133), Reflex::Literal("operator=="), operator_8095, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10133), Reflex::Literal("operator!="), operator_8096, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("exists"), method_8097, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10146, type_2367), Reflex::Literal("operator[]"), operator_8098, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10146, type_4135), Reflex::Literal("operator[]"), operator_8099, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367, type_4135), Reflex::Literal("index"), method_8100, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8529, type_1881), Reflex::Literal("validate"), method_8101, 0, "record;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8913, type_1881), Reflex::Literal("validate"), method_8102, 0, "attributeList;checkSize=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class ObjectNotFound -------------------------------
static  void operator_8104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ObjectNotFound*)o)->operator=)(*(const ::cool::ObjectNotFound*)arg[0]);
  else   (((::cool::ObjectNotFound*)o)->operator=)(*(const ::cool::ObjectNotFound*)arg[0]);
}

static void constructor_8105( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ObjectNotFound(*(const ::cool::ObjectNotFound*)arg[0]);
  else ::new(mem) ::cool::ObjectNotFound(*(const ::cool::ObjectNotFound*)arg[0]);
}

static void constructor_8106( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_8107( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ObjectNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8108(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ObjectNotFound*)o)->::cool::ObjectNotFound::~ObjectNotFound();
}
static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ObjectNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ObjectNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ObjectNotFound -------------------------------
void __cool__ObjectNotFound_db_datamem(Reflex::Class*);
void __cool__ObjectNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ObjectNotFound_datamem_bld(&__cool__ObjectNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ObjectNotFound_funcmem_bld(&__cool__ObjectNotFound_db_funcmem);
void __cool__ObjectNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ObjectNotFound"), typeid(::cool::ObjectNotFound), sizeof(::cool::ObjectNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::ObjectNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10201, type_10202), Reflex::Literal("operator="), operator_8104, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10202), Reflex::Literal("ObjectNotFound"), constructor_8105, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_4135), Reflex::Literal("ObjectNotFound"), constructor_8106, 0, "objectIdentity;objectContainer;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("ObjectNotFound"), constructor_8107, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ObjectNotFound"), destructor_8108, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ObjectNotFound -------------------
void __cool__ObjectNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ObjectNotFound -------------------
void __cool__ObjectNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ChannelNotFound -------------------------------
static  void operator_8110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ChannelNotFound*)o)->operator=)(*(const ::cool::ChannelNotFound*)arg[0]);
  else   (((::cool::ChannelNotFound*)o)->operator=)(*(const ::cool::ChannelNotFound*)arg[0]);
}

static void constructor_8111( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelNotFound*)arg[0]);
  else ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelNotFound*)arg[0]);
}

static void constructor_8112( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ChannelNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ChannelNotFound(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8114(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ChannelNotFound*)o)->::cool::ChannelNotFound::~ChannelNotFound();
}
static void method_x130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ChannelNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ChannelNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ChannelNotFound -------------------------------
void __cool__ChannelNotFound_db_datamem(Reflex::Class*);
void __cool__ChannelNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ChannelNotFound_datamem_bld(&__cool__ChannelNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ChannelNotFound_funcmem_bld(&__cool__ChannelNotFound_db_funcmem);
void __cool__ChannelNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ChannelNotFound"), typeid(::cool::ChannelNotFound), sizeof(::cool::ChannelNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::ChannelNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10203, type_10204), Reflex::Literal("operator="), operator_8110, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10204), Reflex::Literal("ChannelNotFound"), constructor_8111, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("ChannelNotFound"), constructor_8112, 0, "channelName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10145, type_4135), Reflex::Literal("ChannelNotFound"), constructor_8113, 0, "channelId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ChannelNotFound"), destructor_8114, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ChannelNotFound -------------------
void __cool__ChannelNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ChannelNotFound -------------------
void __cool__ChannelNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeException -------------------------------
static  void operator_8115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeException*)o)->operator=)(*(const ::cool::StorageTypeException*)arg[0]);
  else   (((::cool::StorageTypeException*)o)->operator=)(*(const ::cool::StorageTypeException*)arg[0]);
}

static void constructor_8116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeException(*(const ::cool::StorageTypeException*)arg[0]);
  else ::new(mem) ::cool::StorageTypeException(*(const ::cool::StorageTypeException*)arg[0]);
}

static void method_x131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeException,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeException,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeException,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeException -------------------------------
void __cool__StorageTypeException_db_datamem(Reflex::Class*);
void __cool__StorageTypeException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeException_datamem_bld(&__cool__StorageTypeException_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeException_funcmem_bld(&__cool__StorageTypeException_db_funcmem);
void __cool__StorageTypeException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeException"), typeid(::cool::StorageTypeException), sizeof(::cool::StorageTypeException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::StorageTypeException, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10205, type_10206), Reflex::Literal("operator="), operator_8115, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10206), Reflex::Literal("StorageTypeException"), constructor_8116, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeException -------------------
void __cool__StorageTypeException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeException -------------------
void __cool__StorageTypeException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeWrongCppType -------------------------------
static  void operator_8119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeWrongCppType*)o)->operator=)(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
  else   (((::cool::StorageTypeWrongCppType*)o)->operator=)(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
}

static void constructor_8120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
  else ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::cool::StorageTypeWrongCppType*)arg[0]);
}

static void constructor_8121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::StorageTypeWrongCppType(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::type_info*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8122(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeWrongCppType*)o)->::cool::StorageTypeWrongCppType::~StorageTypeWrongCppType();
}
static void method_x132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::cool::RecordException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeWrongCppType -------------------------------
void __cool__StorageTypeWrongCppType_db_datamem(Reflex::Class*);
void __cool__StorageTypeWrongCppType_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeWrongCppType_datamem_bld(&__cool__StorageTypeWrongCppType_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeWrongCppType_funcmem_bld(&__cool__StorageTypeWrongCppType_db_funcmem);
void __cool__StorageTypeWrongCppType_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeWrongCppType"), typeid(::cool::StorageTypeWrongCppType), sizeof(::cool::StorageTypeWrongCppType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2308, ::Reflex::BaseOffset< ::cool::StorageTypeWrongCppType, ::cool::StorageTypeException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10207, type_10208), Reflex::Literal("operator="), operator_8119, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10208), Reflex::Literal("StorageTypeWrongCppType"), constructor_8120, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10138, type_9791, type_4135), Reflex::Literal("StorageTypeWrongCppType"), constructor_8121, 0, "expectedName;expectedStorageType;actualCppType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeWrongCppType"), destructor_8122, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeWrongCppType -------------------
void __cool__StorageTypeWrongCppType_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeWrongCppType -------------------
void __cool__StorageTypeWrongCppType_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Record -------------------------------
static void destructor_8126(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Record*)o)->::cool::Record::~Record();
}
static void constructor_8127( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record();
  else ::new(mem) ::cool::Record();
}

static void constructor_8128( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0]);
}

static void constructor_8129( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IFieldSpecification*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::IFieldSpecification*)arg[0]);
}

static void constructor_8130( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
  else ::new(mem) ::cool::Record(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
}

static void constructor_8131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::Record*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::Record*)arg[0]);
}

static void constructor_8132( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Record(*(const ::cool::IRecord*)arg[0]);
  else ::new(mem) ::cool::Record(*(const ::cool::IRecord*)arg[0]);
}

static  void operator_8133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator=)(*(const ::cool::Record*)arg[0]);
  else   (((::cool::Record*)o)->operator=)(*(const ::cool::Record*)arg[0]);
}

static  void operator_8134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator=)(*(const ::cool::IRecord*)arg[0]);
  else   (((::cool::Record*)o)->operator=)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8135( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::Record*)o)->extend)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->specification)();
  else   (((const ::cool::Record*)o)->specification)();
}

static  void operator_8137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((::cool::Record*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void operator_8140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((::cool::Record*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void method_8141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Record*)o)->attributeList)();
  else   (((const ::cool::Record*)o)->attributeList)();
}

static void method_newdel_2310( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::Record >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::Record >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::Record >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::Record >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::Record >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord")), ::Reflex::BaseOffset< ::cool::Record,::cool::IRecord >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Record -------------------------------
void __cool__Record_db_datamem(Reflex::Class*);
void __cool__Record_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Record_datamem_bld(&__cool__Record_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Record_funcmem_bld(&__cool__Record_db_funcmem);
void __cool__Record_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Record"), typeid(::cool::Record), sizeof(::cool::Record), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2302, ::Reflex::BaseOffset< ::cool::Record, ::cool::IRecord >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Record"), destructor_8126, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Record"), constructor_8127, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10133), Reflex::Literal("Record"), constructor_8128, 0, "spec", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10146), Reflex::Literal("Record"), constructor_8129, 0, "spec", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10133, type_8913), Reflex::Literal("Record"), constructor_8130, 0, "spec;al", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10209), Reflex::Literal("Record"), constructor_8131, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8529), Reflex::Literal("Record"), constructor_8132, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2310, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Record_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Record_funcmem_bld);
}

//------Delayed data member builder for class Record -------------------
void __cool__Record_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2304, Reflex::Literal("m_spec"), OffsetOf(__shadow__::__cool__Record, m_spec), ::Reflex::PRIVATE)
  .AddDataMember(type_2452, Reflex::Literal("m_attrList"), OffsetOf(__shadow__::__cool__Record, m_attrList), ::Reflex::PRIVATE)
  .AddDataMember(type_1401, Reflex::Literal("m_fields"), OffsetOf(__shadow__::__cool__Record, m_fields), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Record -------------------
void __cool__Record_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10210, type_10209), Reflex::Literal("operator="), operator_8133, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10210, type_8529), Reflex::Literal("operator="), operator_8134, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8529), Reflex::Literal("extend"), method_8135, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10133), Reflex::Literal("specification"), method_8136, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_4135), Reflex::Literal("operator[]"), operator_8137, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10148, type_4135), Reflex::Literal("operator[]"), operator_8138, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_2367), Reflex::Literal("operator[]"), operator_8139, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10148, type_2367), Reflex::Literal("operator[]"), operator_8140, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913), Reflex::Literal("attributeList"), method_8141, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class ValidityKeyException -------------------------------
static  void operator_8145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ValidityKeyException*)o)->operator=)(*(const ::cool::ValidityKeyException*)arg[0]);
  else   (((::cool::ValidityKeyException*)o)->operator=)(*(const ::cool::ValidityKeyException*)arg[0]);
}

static void constructor_8146( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyException(*(const ::cool::ValidityKeyException*)arg[0]);
  else ::new(mem) ::cool::ValidityKeyException(*(const ::cool::ValidityKeyException*)arg[0]);
}

static void constructor_8147( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ValidityKeyException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8148(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ValidityKeyException*)o)->::cool::ValidityKeyException::~ValidityKeyException();
}
static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyException,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ValidityKeyException -------------------------------
void __cool__ValidityKeyException_db_datamem(Reflex::Class*);
void __cool__ValidityKeyException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyException_datamem_bld(&__cool__ValidityKeyException_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyException_funcmem_bld(&__cool__ValidityKeyException_db_funcmem);
void __cool__ValidityKeyException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ValidityKeyException"), typeid(::cool::ValidityKeyException), sizeof(::cool::ValidityKeyException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::ValidityKeyException, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10211, type_10212), Reflex::Literal("operator="), operator_8145, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10212), Reflex::Literal("ValidityKeyException"), constructor_8146, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("ValidityKeyException"), constructor_8147, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValidityKeyException"), destructor_8148, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ValidityKeyException -------------------
void __cool__ValidityKeyException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ValidityKeyException -------------------
void __cool__ValidityKeyException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FieldIsNull -------------------------------
static  void operator_8149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldIsNull*)o)->operator=)(*(const ::cool::FieldIsNull*)arg[0]);
  else   (((::cool::FieldIsNull*)o)->operator=)(*(const ::cool::FieldIsNull*)arg[0]);
}

static void constructor_8150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldIsNull(*(const ::cool::FieldIsNull*)arg[0]);
  else ::new(mem) ::cool::FieldIsNull(*(const ::cool::FieldIsNull*)arg[0]);
}

static void constructor_8151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldIsNull(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::FieldIsNull(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8152(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldIsNull*)o)->::cool::FieldIsNull::~FieldIsNull();
}
static void method_x136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldIsNull,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldIsNull,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldIsNull,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldIsNull -------------------------------
void __cool__FieldIsNull_db_datamem(Reflex::Class*);
void __cool__FieldIsNull_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldIsNull_datamem_bld(&__cool__FieldIsNull_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldIsNull_funcmem_bld(&__cool__FieldIsNull_db_funcmem);
void __cool__FieldIsNull_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldIsNull"), typeid(::cool::FieldIsNull), sizeof(::cool::FieldIsNull), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::FieldIsNull, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10213, type_10214), Reflex::Literal("operator="), operator_8149, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10214), Reflex::Literal("FieldIsNull"), constructor_8150, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10138, type_4135), Reflex::Literal("FieldIsNull"), constructor_8151, 0, "name;storageType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldIsNull"), destructor_8152, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldIsNull -------------------
void __cool__FieldIsNull_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldIsNull -------------------
void __cool__FieldIsNull_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class InvalidPayloadSpecification -------------------------------
static  void operator_8153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidPayloadSpecification*)o)->operator=)(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
  else   (((::cool::InvalidPayloadSpecification*)o)->operator=)(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
}

static void constructor_8154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
  else ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::cool::InvalidPayloadSpecification*)arg[0]);
}

static void constructor_8155( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::InvalidPayloadSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8156(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidPayloadSpecification*)o)->::cool::InvalidPayloadSpecification::~InvalidPayloadSpecification();
}
static void method_x137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidPayloadSpecification -------------------------------
void __cool__InvalidPayloadSpecification_db_datamem(Reflex::Class*);
void __cool__InvalidPayloadSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidPayloadSpecification_datamem_bld(&__cool__InvalidPayloadSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidPayloadSpecification_funcmem_bld(&__cool__InvalidPayloadSpecification_db_funcmem);
void __cool__InvalidPayloadSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidPayloadSpecification"), typeid(::cool::InvalidPayloadSpecification), sizeof(::cool::InvalidPayloadSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2363, ::Reflex::BaseOffset< ::cool::InvalidPayloadSpecification, ::cool::InvalidFolderSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10215, type_10216), Reflex::Literal("operator="), operator_8153, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10216), Reflex::Literal("InvalidPayloadSpecification"), constructor_8154, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("InvalidPayloadSpecification"), constructor_8155, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidPayloadSpecification"), destructor_8156, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidPayloadSpecification -------------------
void __cool__InvalidPayloadSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidPayloadSpecification -------------------
void __cool__InvalidPayloadSpecification_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFieldSpecification -------------------------------
static void destructor_8159(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFieldSpecification*)o)->::cool::IFieldSpecification::~IFieldSpecification();
}
static  void method_8160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFieldSpecification*)o)->name)();
  else   (((const ::cool::IFieldSpecification*)o)->name)();
}

static  void method_8161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFieldSpecification*)o)->storageType)();
  else   (((const ::cool::IFieldSpecification*)o)->storageType)();
}

static  void operator_8162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::IFieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void operator_8163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::IFieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void method_8164( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8165( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IFieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0],
      *(bool*)arg[1]);
  }
}

//------Dictionary for class IFieldSpecification -------------------------------
void __cool__IFieldSpecification_db_datamem(Reflex::Class*);
void __cool__IFieldSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFieldSpecification_datamem_bld(&__cool__IFieldSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFieldSpecification_funcmem_bld(&__cool__IFieldSpecification_db_funcmem);
void __cool__IFieldSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFieldSpecification"), typeid(::cool::IFieldSpecification), sizeof(::cool::IFieldSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFieldSpecification"), destructor_8159, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IFieldSpecification_funcmem_bld);
}

//------Delayed data member builder for class IFieldSpecification -------------------
void __cool__IFieldSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFieldSpecification -------------------
void __cool__IFieldSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("name"), method_8160, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10138), Reflex::Literal("storageType"), method_8161, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10146), Reflex::Literal("operator=="), operator_8162, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10146), Reflex::Literal("operator!="), operator_8163, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8530, type_1881), Reflex::Literal("validate"), method_8164, 0, "field;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8914, type_1881), Reflex::Literal("validate"), method_8165, 0, "attribute;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class FolderIsSingleVersion -------------------------------
static  void operator_8167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderIsSingleVersion*)o)->operator=)(*(const ::cool::FolderIsSingleVersion*)arg[0]);
  else   (((::cool::FolderIsSingleVersion*)o)->operator=)(*(const ::cool::FolderIsSingleVersion*)arg[0]);
}

static void constructor_8168( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(const ::cool::FolderIsSingleVersion*)arg[0]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(const ::cool::FolderIsSingleVersion*)arg[0]);
}

static void constructor_8169( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8170( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void constructor_8171( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderIsSingleVersion(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderIsSingleVersion(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8172(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderIsSingleVersion*)o)->::cool::FolderIsSingleVersion::~FolderIsSingleVersion();
}
static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeIsSingleVersion")), ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion,::cool::NodeIsSingleVersion >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderIsSingleVersion -------------------------------
void __cool__FolderIsSingleVersion_db_datamem(Reflex::Class*);
void __cool__FolderIsSingleVersion_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderIsSingleVersion_datamem_bld(&__cool__FolderIsSingleVersion_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderIsSingleVersion_funcmem_bld(&__cool__FolderIsSingleVersion_db_funcmem);
void __cool__FolderIsSingleVersion_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderIsSingleVersion"), typeid(::cool::FolderIsSingleVersion), sizeof(::cool::FolderIsSingleVersion), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2381, ::Reflex::BaseOffset< ::cool::FolderIsSingleVersion, ::cool::NodeIsSingleVersion >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10218, type_10219), Reflex::Literal("operator="), operator_8167, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10219), Reflex::Literal("FolderIsSingleVersion"), constructor_8168, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("FolderIsSingleVersion"), constructor_8169, 0, "fullPath;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_4135), Reflex::Literal("FolderIsSingleVersion"), constructor_8170, 0, "fullPath;message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_4135), Reflex::Literal("FolderIsSingleVersion"), constructor_8171, 0, "nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderIsSingleVersion"), destructor_8172, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FolderIsSingleVersion -------------------
void __cool__FolderIsSingleVersion_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FolderIsSingleVersion -------------------
void __cool__FolderIsSingleVersion_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ITime -------------------------------
static void destructor_8175(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ITime*)o)->::cool::ITime::~ITime();
}
static  void method_8176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->year)());
  else   (((const ::cool::ITime*)o)->year)();
}

static  void method_8177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->month)());
  else   (((const ::cool::ITime*)o)->month)();
}

static  void method_8178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->day)());
  else   (((const ::cool::ITime*)o)->day)();
}

static  void method_8179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->hour)());
  else   (((const ::cool::ITime*)o)->hour)();
}

static  void method_8180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->minute)());
  else   (((const ::cool::ITime*)o)->minute)();
}

static  void method_8181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::ITime*)o)->second)());
  else   (((const ::cool::ITime*)o)->second)();
}

static  void method_8182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::cool::ITime*)o)->nanosecond)());
  else   (((const ::cool::ITime*)o)->nanosecond)();
}

static  void method_8183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ITime*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::ITime*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void operator_8184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator==)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator==)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator>)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator>)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator>=)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator>=)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator<)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator<)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator<=)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator<=)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::ITime*)o)->operator!=)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::ITime*)o)->operator!=)(*(const ::cool::ITime*)arg[0]);
}

//------Dictionary for class ITime -------------------------------
void __cool__ITime_db_datamem(Reflex::Class*);
void __cool__ITime_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ITime_datamem_bld(&__cool__ITime_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ITime_funcmem_bld(&__cool__ITime_db_funcmem);
void __cool__ITime_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ITime"), typeid(::cool::ITime), sizeof(::cool::ITime), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ITime"), destructor_8175, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__ITime_funcmem_bld);
}

//------Delayed data member builder for class ITime -------------------
void __cool__ITime_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ITime -------------------
void __cool__ITime_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("year"), method_8176, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("month"), method_8177, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("day"), method_8178, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("hour"), method_8179, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("minute"), method_8180, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("second"), method_8181, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("nanosecond"), method_8182, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525), Reflex::Literal("print"), method_8183, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator=="), operator_8184, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator>"), operator_8185, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator>="), operator_8186, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator<"), operator_8187, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator<="), operator_8188, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator!="), operator_8189, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class ConstRecordAdapter -------------------------------
static void destructor_8195(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ConstRecordAdapter*)o)->::cool::ConstRecordAdapter::~ConstRecordAdapter();
}
static void constructor_8196( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ConstRecordAdapter(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
  else ::new(mem) ::cool::ConstRecordAdapter(*(const ::cool::IRecordSpecification*)arg[0],
      *(const ::coral::AttributeList*)arg[1]);
}

static  void method_8197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->specification)();
  else   (((const ::cool::ConstRecordAdapter*)o)->specification)();
}

static  void operator_8198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::cool::ConstRecordAdapter*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->operator[])(*(::cool::UInt32*)arg[0]);
  else   (((const ::cool::ConstRecordAdapter*)o)->operator[])(*(::cool::UInt32*)arg[0]);
}

static  void method_8200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::ConstRecordAdapter*)o)->attributeList)();
  else   (((const ::cool::ConstRecordAdapter*)o)->attributeList)();
}

static void method_x139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IRecord")), ::Reflex::BaseOffset< ::cool::ConstRecordAdapter,::cool::IRecord >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ConstRecordAdapter -------------------------------
void __cool__ConstRecordAdapter_db_datamem(Reflex::Class*);
void __cool__ConstRecordAdapter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ConstRecordAdapter_datamem_bld(&__cool__ConstRecordAdapter_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ConstRecordAdapter_funcmem_bld(&__cool__ConstRecordAdapter_db_funcmem);
void __cool__ConstRecordAdapter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ConstRecordAdapter"), typeid(::cool::ConstRecordAdapter), sizeof(::cool::ConstRecordAdapter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2302, ::Reflex::BaseOffset< ::cool::ConstRecordAdapter, ::cool::IRecord >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ConstRecordAdapter"), destructor_8195, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10133, type_8913), Reflex::Literal("ConstRecordAdapter"), constructor_8196, 0, "spec;al", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__ConstRecordAdapter_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__ConstRecordAdapter_funcmem_bld);
}

//------Delayed data member builder for class ConstRecordAdapter -------------------
void __cool__ConstRecordAdapter_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2304, Reflex::Literal("m_spec"), OffsetOf(__shadow__::__cool__ConstRecordAdapter, m_spec), ::Reflex::PRIVATE)
  .AddDataMember(type_1401, Reflex::Literal("m_fields"), OffsetOf(__shadow__::__cool__ConstRecordAdapter, m_fields), ::Reflex::PRIVATE)
  .AddDataMember(type_2452, Reflex::Literal("m_publicAttrList"), OffsetOf(__shadow__::__cool__ConstRecordAdapter, m_publicAttrList), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ConstRecordAdapter -------------------
void __cool__ConstRecordAdapter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10133), Reflex::Literal("specification"), method_8197, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_4135), Reflex::Literal("operator[]"), operator_8198, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_2367), Reflex::Literal("operator[]"), operator_8199, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8913), Reflex::Literal("attributeList"), method_8200, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class InvalidTagRelation -------------------------------
static  void operator_8224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidTagRelation*)o)->operator=)(*(const ::cool::InvalidTagRelation*)arg[0]);
  else   (((::cool::InvalidTagRelation*)o)->operator=)(*(const ::cool::InvalidTagRelation*)arg[0]);
}

static void constructor_8225( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidTagRelation(*(const ::cool::InvalidTagRelation*)arg[0]);
  else ::new(mem) ::cool::InvalidTagRelation(*(const ::cool::InvalidTagRelation*)arg[0]);
}

static void constructor_8226( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidTagRelation(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::cool::InvalidTagRelation(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]);
}

static void destructor_8227(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidTagRelation*)o)->::cool::InvalidTagRelation::~InvalidTagRelation();
}
static void method_x140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidTagRelation,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidTagRelation,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidTagRelation -------------------------------
void __cool__InvalidTagRelation_db_datamem(Reflex::Class*);
void __cool__InvalidTagRelation_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidTagRelation_datamem_bld(&__cool__InvalidTagRelation_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidTagRelation_funcmem_bld(&__cool__InvalidTagRelation_db_funcmem);
void __cool__InvalidTagRelation_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidTagRelation"), typeid(::cool::InvalidTagRelation), sizeof(::cool::InvalidTagRelation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::InvalidTagRelation, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10225, type_10226), Reflex::Literal("operator="), operator_8224, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10226), Reflex::Literal("InvalidTagRelation"), constructor_8225, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_2367, type_4135, type_4135), Reflex::Literal("InvalidTagRelation"), constructor_8226, 0, "parentTagName;childTagName;childNodeId;details;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidTagRelation"), destructor_8227, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidTagRelation -------------------
void __cool__InvalidTagRelation_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidTagRelation -------------------
void __cool__InvalidTagRelation_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseNotOpen -------------------------------
static  void operator_8228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseNotOpen*)o)->operator=)(*(const ::cool::DatabaseNotOpen*)arg[0]);
  else   (((::cool::DatabaseNotOpen*)o)->operator=)(*(const ::cool::DatabaseNotOpen*)arg[0]);
}

static void constructor_8229( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseNotOpen(*(const ::cool::DatabaseNotOpen*)arg[0]);
  else ::new(mem) ::cool::DatabaseNotOpen(*(const ::cool::DatabaseNotOpen*)arg[0]);
}

static void constructor_8230( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseNotOpen(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::DatabaseNotOpen(*(const ::std::string*)arg[0]);
}

static void destructor_8231(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseNotOpen*)o)->::cool::DatabaseNotOpen::~DatabaseNotOpen();
}
static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::DatabaseNotOpen,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::DatabaseNotOpen,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DatabaseNotOpen -------------------------------
void __cool__DatabaseNotOpen_db_datamem(Reflex::Class*);
void __cool__DatabaseNotOpen_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseNotOpen_datamem_bld(&__cool__DatabaseNotOpen_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseNotOpen_funcmem_bld(&__cool__DatabaseNotOpen_db_funcmem);
void __cool__DatabaseNotOpen_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseNotOpen"), typeid(::cool::DatabaseNotOpen), sizeof(::cool::DatabaseNotOpen), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::DatabaseNotOpen, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10227, type_10228), Reflex::Literal("operator="), operator_8228, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10228), Reflex::Literal("DatabaseNotOpen"), constructor_8229, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135), Reflex::Literal("DatabaseNotOpen"), constructor_8230, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseNotOpen"), destructor_8231, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DatabaseNotOpen -------------------
void __cool__DatabaseNotOpen_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseNotOpen -------------------
void __cool__DatabaseNotOpen_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseDoesNotExist -------------------------------
static  void operator_8232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseDoesNotExist*)o)->operator=)(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
  else   (((::cool::DatabaseDoesNotExist*)o)->operator=)(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
}

static void constructor_8233( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
  else ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::cool::DatabaseDoesNotExist*)arg[0]);
}

static void constructor_8234( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::DatabaseDoesNotExist(*(const ::std::string*)arg[0]);
}

static void destructor_8235(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseDoesNotExist*)o)->::cool::DatabaseDoesNotExist::~DatabaseDoesNotExist();
}
static void method_x142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::DatabaseDoesNotExist,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::DatabaseDoesNotExist,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DatabaseDoesNotExist -------------------------------
void __cool__DatabaseDoesNotExist_db_datamem(Reflex::Class*);
void __cool__DatabaseDoesNotExist_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseDoesNotExist_datamem_bld(&__cool__DatabaseDoesNotExist_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseDoesNotExist_funcmem_bld(&__cool__DatabaseDoesNotExist_db_funcmem);
void __cool__DatabaseDoesNotExist_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseDoesNotExist"), typeid(::cool::DatabaseDoesNotExist), sizeof(::cool::DatabaseDoesNotExist), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::DatabaseDoesNotExist, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10229, type_10230), Reflex::Literal("operator="), operator_8232, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10230), Reflex::Literal("DatabaseDoesNotExist"), constructor_8233, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135), Reflex::Literal("DatabaseDoesNotExist"), constructor_8234, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseDoesNotExist"), destructor_8235, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DatabaseDoesNotExist -------------------
void __cool__DatabaseDoesNotExist_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseDoesNotExist -------------------
void __cool__DatabaseDoesNotExist_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFolder -------------------------------
static void destructor_8654(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFolder*)o)->::cool::IFolder::~IFolder();
}
static  void method_8655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolder*)o)->folderSpecification)();
  else   (((const ::cool::IFolder*)o)->folderSpecification)();
}

static  void method_8656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolder*)o)->payloadSpecification)();
  else   (((const ::cool::IFolder*)o)->payloadSpecification)();
}

static  void method_8657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::IFolder*)o)->versioningMode)());
  else   (((const ::cool::IFolder*)o)->versioningMode)();
}

static  void method_8658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolder*)o)->folderAttributes)();
  else   (((const ::cool::IFolder*)o)->folderAttributes)();
}

static  void method_8659( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::cool::IFolder*)o)->setupStorageBuffer)();
  }
  else if ( arg.size() == 1 ) { 
    (((::cool::IFolder*)o)->setupStorageBuffer)(*(bool*)arg[0]);
  }
}

static  void method_8660( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IFolder*)o)->flushStorageBuffer)();
}

static  void method_8661( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::IRecord*)arg[2],
      *(const ::cool::ChannelId*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::IRecord*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::IRecord*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_8662( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[2],
      *(const ::cool::ChannelId*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::vector<boost::shared_ptr<cool::IRecord> >*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_8663( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::coral::AttributeList*)arg[2],
      *(const ::cool::ChannelId*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::coral::AttributeList*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::cool::IFolder*)o)->storeObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::coral::AttributeList*)arg[2],
      *(const ::cool::ChannelId*)arg[3],
      *(const ::std::string*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_8664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::cool::IFolder*)o)->truncateObjectValidity)(*(const ::cool::ValidityKey*)arg[0],
    *(const ::cool::ChannelSelection*)arg[1]));
  else   (((::cool::IFolder*)o)->truncateObjectValidity)(*(const ::cool::ValidityKey*)arg[0],
    *(const ::cool::ChannelSelection*)arg[1]);
}

static  void method_8665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IObjectPtr)((((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1]));
    else     (((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IObjectPtr)((((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::cool::IFolder*)o)->findObject)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelId*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1]));
    else     (((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::cool::IFolder*)o)->findObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ChannelSelection*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]));
    else     (((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]));
    else     (((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (cool::IObjectIteratorPtr)((((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]));
    else     (((const ::cool::IFolder*)o)->browseObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]);
  }
}

static  void method_8668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (unsigned int)((((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]));
    else     (((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (unsigned int)((((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]));
    else     (((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (unsigned int)((((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]));
    else     (((const ::cool::IFolder*)o)->countObjects)(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::cool::ChannelSelection*)arg[2],
      *(const ::std::string*)arg[3],
      (const ::cool::IRecordSelection*)arg[4]);
  }
}

static  void method_8669( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->setPrefetchAll)(*(bool*)arg[0]);
}

static  void method_8670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->renamePayload)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->extendPayloadSpecification)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8672( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::IFolder*)o)->tagCurrentHead)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::IFolder*)o)->tagCurrentHead)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_8673( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::cool::IFolder*)o)->cloneTagAsUserTag)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::cool::IFolder*)o)->cloneTagAsUserTag)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::cool::IFolder*)o)->cloneTagAsUserTag)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_8674( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((const ::cool::IFolder*)o)->tagHeadAsOfDate)(*(const ::cool::ITime*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((const ::cool::IFolder*)o)->tagHeadAsOfDate)(*(const ::cool::ITime*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::Time)((((const ::cool::IFolder*)o)->insertionTimeOfLastObjectInTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->insertionTimeOfLastObjectInTag)(*(const ::std::string*)arg[0]);
}

static  void method_8676( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->deleteTag)(*(const ::std::string*)arg[0]);
}

static  void method_8677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolder*)o)->existsUserTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->existsUserTag)(*(const ::std::string*)arg[0]);
}

static  void method_8678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<unsigned int>)((((const ::cool::IFolder*)o)->listChannels)());
  else   (((const ::cool::IFolder*)o)->listChannels)();
}

static  void method_8679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::map<unsigned int,std::basic_string<char> >)((((const ::cool::IFolder*)o)->listChannelsWithNames)());
  else   (((const ::cool::IFolder*)o)->listChannelsWithNames)();
}

static  void method_8680( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::cool::IFolder*)o)->createChannel)(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::cool::IFolder*)o)->createChannel)(*(const ::cool::ChannelId*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IFolder*)o)->dropChannel)(*(const ::cool::ChannelId*)arg[0]));
  else   (((::cool::IFolder*)o)->dropChannel)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8682( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->setChannelName)(*(const ::cool::ChannelId*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IFolder*)o)->channelName)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::IFolder*)o)->channelName)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::ChannelId)((((const ::cool::IFolder*)o)->channelId)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->channelId)(*(const ::std::string*)arg[0]);
}

static  void method_8685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolder*)o)->existsChannel)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::IFolder*)o)->existsChannel)(*(const ::cool::ChannelId*)arg[0]);
}

static  void method_8686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolder*)o)->existsChannel)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IFolder*)o)->existsChannel)(*(const ::std::string*)arg[0]);
}

static  void method_8687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IFolder*)o)->setChannelDescription)(*(const ::cool::ChannelId*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IFolder*)o)->channelDescription)(*(const ::cool::ChannelId*)arg[0]));
  else   (((const ::cool::IFolder*)o)->channelDescription)(*(const ::cool::ChannelId*)arg[0]);
}

static void method_x143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNode")), ::Reflex::BaseOffset< ::cool::IFolder,::cool::IHvsNode >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord")), ::Reflex::BaseOffset< ::cool::IFolder,::cool::IHvsNodeRecord >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IFolder -------------------------------
void __cool__IFolder_db_datamem(Reflex::Class*);
void __cool__IFolder_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFolder_datamem_bld(&__cool__IFolder_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFolder_funcmem_bld(&__cool__IFolder_db_funcmem);
void __cool__IFolder_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFolder"), typeid(::cool::IFolder), sizeof(::cool::IFolder), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2339, ::Reflex::BaseOffset< ::cool::IFolder, ::cool::IHvsNode >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFolder"), destructor_8654, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__IFolder_funcmem_bld);
}

//------Delayed data member builder for class IFolder -------------------
void __cool__IFolder_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFolder -------------------
void __cool__IFolder_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10282), Reflex::Literal("folderSpecification"), method_8655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10133), Reflex::Literal("payloadSpecification"), method_8656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8690), Reflex::Literal("versioningMode"), method_8657, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8529), Reflex::Literal("folderAttributes"), method_8658, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1881), Reflex::Literal("setupStorageBuffer"), method_8659, 0, "useBuffer=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("flushStorageBuffer"), method_8660, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10223, type_10223, type_8529, type_10145, type_4135, type_1881), Reflex::Literal("storeObject"), method_8661, 0, "since;until;payload;channelId;userTagName=\"\";userTagOnly=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10223, type_10223, type_9310, type_10145, type_4135, type_1881), Reflex::Literal("storeObject"), method_8662, 0, "since;until;payload;channelId;userTagName=\"\";userTagOnly=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10223, type_10223, type_8913, type_10145, type_4135, type_1881), Reflex::Literal("storeObject"), method_8663, 0, "since;until;payload;channelId;userTagName=\"\";userTagOnly=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_10223, type_10321), Reflex::Literal("truncateObjectValidity"), method_8664, 0, "until;channels", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2291, type_10223, type_10145, type_4135), Reflex::Literal("findObject"), method_8665, 0, "pointInTime;channelId;tagName=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2283, type_10223, type_10321, type_4135), Reflex::Literal("findObjects"), method_8666, 0, "pointInTime;channels;tagName=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2283, type_10223, type_10223, type_10321, type_4135, type_10160), Reflex::Literal("browseObjects"), method_8667, 0, "since;until;channels;tagName=\"\";payloadQuery=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_80, type_10223, type_10223, type_10321, type_4135, type_10160), Reflex::Literal("countObjects"), method_8668, 0, "since;until;channels;tagName=\"\";payloadQuery=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1881), Reflex::Literal("setPrefetchAll"), method_8669, 0, "prefetchAll", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135), Reflex::Literal("renamePayload"), method_8670, 0, "oldName;newName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8529), Reflex::Literal("extendPayloadSpecification"), method_8671, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135), Reflex::Literal("tagCurrentHead"), method_8672, 0, "tagName;description=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135, type_4135, type_1881), Reflex::Literal("cloneTagAsUserTag"), method_8673, 0, "tagName;tagClone;description=\"\";forceOverwriteTag=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8526, type_4135, type_4135), Reflex::Literal("tagHeadAsOfDate"), method_8674, 0, "asOfDate;tagName;description=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2331c, type_4135), Reflex::Literal("insertionTimeOfLastObjectInTag"), method_8675, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135), Reflex::Literal("deleteTag"), method_8676, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("existsUserTag"), method_8677, 0, "userTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1398c), Reflex::Literal("listChannels"), method_8678, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1624c), Reflex::Literal("listChannelsWithNames"), method_8679, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10145, type_4135, type_4135), Reflex::Literal("createChannel"), method_8680, 0, "channelId;channelName;description=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10145), Reflex::Literal("dropChannel"), method_8681, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10145, type_4135), Reflex::Literal("setChannelName"), method_8682, 0, "channelId;channelName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_10145), Reflex::Literal("channelName"), method_8683, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314, type_4135), Reflex::Literal("channelId"), method_8684, 0, "channelName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10145), Reflex::Literal("existsChannel"), method_8685, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("existsChannel"), method_8686, 0, "channelName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10145, type_4135), Reflex::Literal("setChannelDescription"), method_8687, 0, "channelId;description", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_10145), Reflex::Literal("channelDescription"), method_8688, 0, "channelId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<cool::IFolder> -------------------------------
static void destructor_8240(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IFolder>*)o)->::boost::shared_ptr<cool::IFolder>::~shared_ptr();
}
static void constructor_8241( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolder>(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IFolder>(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static void constructor_8242( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IFolder>();
  else ::new(mem) ::boost::shared_ptr<cool::IFolder>();
}

static  void operator_8243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IFolder>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IFolder>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static  void method_8244( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IFolder>*)o)->reset)();
}

static  void operator_8245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IFolder>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator*)();
}

static  void operator_8246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator->)();
}

static  void method_8248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->get)();
}

static  void converter_8249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IFolder* boost::shared_ptr<cool::IFolder>::*)((((const ::boost::shared_ptr<cool::IFolder>*)o)->operator cool::IFolder* boost::shared_ptr<cool::IFolder>::*)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator cool::IFolder* boost::shared_ptr<cool::IFolder>::*)();
}

static  void operator_8250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolder>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->operator!)();
}

static  void method_8251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolder>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->unique)();
}

static  void method_8252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IFolder>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->use_count)();
}

static  void method_8253( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IFolder>*)o)->swap)(*(::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static  void method_8254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IFolder>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IFolder>*)arg[0]);
}

static void method_newdel_2325( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IFolder> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IFolder> -------------------------------
void __boost__shared_ptr_cool__IFolder__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IFolder__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolder__datamem_bld(&__boost__shared_ptr_cool__IFolder__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IFolder__funcmem_bld(&__boost__shared_ptr_cool__IFolder__db_funcmem);
void __boost__shared_ptr_cool__IFolder__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IFolder>"), typeid(::boost::shared_ptr<cool::IFolder>), sizeof(::boost::shared_ptr<cool::IFolder>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2410, Reflex::Literal("boost::shared_ptr<cool::IFolder>::element_type"))
  .AddTypedef(type_10232, Reflex::Literal("boost::shared_ptr<cool::IFolder>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8240, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10233), Reflex::Literal("shared_ptr"), constructor_8241, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8242, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2325, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IFolder__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IFolder__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IFolder> -------------------
void __boost__shared_ptr_cool__IFolder__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10231, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolder_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IFolder_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IFolder> -------------------
void __boost__shared_ptr_cool__IFolder__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234, type_10233), Reflex::Literal("operator="), operator_8243, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_8244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10235), Reflex::Literal("operator*"), operator_8245, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10231), Reflex::Literal("operator->"), operator_8246, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10231), Reflex::Literal("get"), method_8248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10232), Reflex::Literal("operator cool::IFolder* boost::shared_ptr<cool::IFolder>::*"), converter_8249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_8250, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_8251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_8252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10234), Reflex::Literal("swap"), method_8253, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_8254, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_8255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10233), Reflex::Literal("_internal_equiv"), method_8256, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValidityIntervalBackwards -------------------------------
static  void operator_8259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ValidityIntervalBackwards*)o)->operator=)(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
  else   (((::cool::ValidityIntervalBackwards*)o)->operator=)(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
}

static void constructor_8260( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
  else ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityIntervalBackwards*)arg[0]);
}

static void constructor_8261( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::ValidityIntervalBackwards(*(const ::cool::ValidityKey*)arg[0],
      *(const ::cool::ValidityKey*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8262(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ValidityIntervalBackwards*)o)->::cool::ValidityIntervalBackwards::~ValidityIntervalBackwards();
}
static void method_x145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyException")), ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards,::cool::ValidityKeyException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ValidityIntervalBackwards -------------------------------
void __cool__ValidityIntervalBackwards_db_datamem(Reflex::Class*);
void __cool__ValidityIntervalBackwards_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ValidityIntervalBackwards_datamem_bld(&__cool__ValidityIntervalBackwards_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ValidityIntervalBackwards_funcmem_bld(&__cool__ValidityIntervalBackwards_db_funcmem);
void __cool__ValidityIntervalBackwards_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ValidityIntervalBackwards"), typeid(::cool::ValidityIntervalBackwards), sizeof(::cool::ValidityIntervalBackwards), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2312, ::Reflex::BaseOffset< ::cool::ValidityIntervalBackwards, ::cool::ValidityKeyException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10236, type_10237), Reflex::Literal("operator="), operator_8259, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10237), Reflex::Literal("ValidityIntervalBackwards"), constructor_8260, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10223, type_10223, type_4135), Reflex::Literal("ValidityIntervalBackwards"), constructor_8261, 0, "since;until;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValidityIntervalBackwards"), destructor_8262, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ValidityIntervalBackwards -------------------
void __cool__ValidityIntervalBackwards_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ValidityIntervalBackwards -------------------
void __cool__ValidityIntervalBackwards_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Time -------------------------------
static void destructor_8270(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Time*)o)->::cool::Time::~Time();
}
static void constructor_8271( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time();
  else ::new(mem) ::cool::Time();
}

static void constructor_8272( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(long*)arg[6]);
  else ::new(mem) ::cool::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(long*)arg[6]);
}

static void constructor_8273( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time(*(const ::cool::Time*)arg[0]);
  else ::new(mem) ::cool::Time(*(const ::cool::Time*)arg[0]);
}

static  void operator_8274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Time*)o)->operator=)(*(const ::cool::Time*)arg[0]);
  else   (((::cool::Time*)o)->operator=)(*(const ::cool::Time*)arg[0]);
}

static void constructor_8275( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Time(*(const ::cool::ITime*)arg[0]);
  else ::new(mem) ::cool::Time(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Time*)o)->operator=)(*(const ::cool::ITime*)arg[0]);
  else   (((::cool::Time*)o)->operator=)(*(const ::cool::ITime*)arg[0]);
}

static  void method_8277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->year)());
  else   (((const ::cool::Time*)o)->year)();
}

static  void method_8278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->month)());
  else   (((const ::cool::Time*)o)->month)();
}

static  void method_8279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->day)());
  else   (((const ::cool::Time*)o)->day)();
}

static  void method_8280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->hour)());
  else   (((const ::cool::Time*)o)->hour)();
}

static  void method_8281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->minute)());
  else   (((const ::cool::Time*)o)->minute)();
}

static  void method_8282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::Time*)o)->second)());
  else   (((const ::cool::Time*)o)->second)();
}

static  void method_8283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::cool::Time*)o)->nanosecond)());
  else   (((const ::cool::Time*)o)->nanosecond)();
}

static  void method_8284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Time*)o)->print)(*(::std::ostream*)arg[0]);
  else   (((const ::cool::Time*)o)->print)(*(::std::ostream*)arg[0]);
}

static  void operator_8285( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::Time*)o)->operator==)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::Time*)o)->operator==)(*(const ::cool::ITime*)arg[0]);
}

static  void operator_8286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::Time*)o)->operator>)(*(const ::cool::ITime*)arg[0]));
  else   (((const ::cool::Time*)o)->operator>)(*(const ::cool::ITime*)arg[0]);
}

static void method_newdel_2331( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::Time >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::Time >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::Time >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::Time >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::Time >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::ITime")), ::Reflex::BaseOffset< ::cool::Time,::cool::ITime >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Time -------------------------------
void __cool__Time_db_datamem(Reflex::Class*);
void __cool__Time_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Time_datamem_bld(&__cool__Time_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Time_funcmem_bld(&__cool__Time_db_funcmem);
void __cool__Time_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Time"), typeid(::cool::Time), sizeof(::cool::Time), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2319, ::Reflex::BaseOffset< ::cool::Time, ::cool::ITime >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Time"), destructor_8270, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Time"), constructor_8271, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31, type_31, type_31, type_31, type_31, type_31, type_124), Reflex::Literal("Time"), constructor_8272, 0, "year;month;day;hour;minute;second;nanosecond", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10238), Reflex::Literal("Time"), constructor_8273, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8526), Reflex::Literal("Time"), constructor_8275, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2331, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Time_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Time_funcmem_bld);
}

//------Delayed data member builder for class Time -------------------
void __cool__Time_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31, Reflex::Literal("m_year"), OffsetOf(__shadow__::__cool__Time, m_year), ::Reflex::PRIVATE)
  .AddDataMember(type_31, Reflex::Literal("m_month"), OffsetOf(__shadow__::__cool__Time, m_month), ::Reflex::PRIVATE)
  .AddDataMember(type_31, Reflex::Literal("m_day"), OffsetOf(__shadow__::__cool__Time, m_day), ::Reflex::PRIVATE)
  .AddDataMember(type_31, Reflex::Literal("m_hour"), OffsetOf(__shadow__::__cool__Time, m_hour), ::Reflex::PRIVATE)
  .AddDataMember(type_31, Reflex::Literal("m_minute"), OffsetOf(__shadow__::__cool__Time, m_minute), ::Reflex::PRIVATE)
  .AddDataMember(type_31, Reflex::Literal("m_second"), OffsetOf(__shadow__::__cool__Time, m_second), ::Reflex::PRIVATE)
  .AddDataMember(type_124, Reflex::Literal("m_nanosecond"), OffsetOf(__shadow__::__cool__Time, m_nanosecond), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Time -------------------
void __cool__Time_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10239, type_10238), Reflex::Literal("operator="), operator_8274, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10239, type_8526), Reflex::Literal("operator="), operator_8276, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("year"), method_8277, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("month"), method_8278, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("day"), method_8279, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("hour"), method_8280, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("minute"), method_8281, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("second"), method_8282, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("nanosecond"), method_8283, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525), Reflex::Literal("print"), method_8284, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator=="), operator_8285, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8526), Reflex::Literal("operator>"), operator_8286, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
static void destructor_8291(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::~shared_ptr();
}
static void constructor_8292( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void constructor_8293( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >();
  else ::new(mem) ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >();
}

static  void operator_8294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
  else   (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator=)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_8295( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->reset)();
}

static  void operator_8296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator*)();
}

static  void operator_8297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator->)();
}

static  void method_8299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->get)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->get)();
}

static  void converter_8300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*)();
}

static  void operator_8301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator!)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->operator!)();
}

static  void method_8302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->unique)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->unique)();
}

static  void method_8303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->use_count)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->use_count)();
}

static  void method_8304( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->swap)(*(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static  void method_8305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_get_untyped_deleter)();
}

static  void method_8307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]));
  else   (((const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)o)->_internal_equiv)(*(const ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >*)arg[0]);
}

static void method_newdel_2334( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class*);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem);
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >"), typeid(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >), sizeof(::boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_1400, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::element_type"))
  .AddTypedef(type_10241, Reflex::Literal("boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8291, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10242), Reflex::Literal("shared_ptr"), constructor_8292, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8293, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2334, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10240, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<std::vector<boost::shared_ptr<cool::IObject>, std::allocator<boost::shared_ptr<cool::IObject> > > > -------------------
void __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10243, type_10242), Reflex::Literal("operator="), operator_8294, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_8295, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9315), Reflex::Literal("operator*"), operator_8296, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10240), Reflex::Literal("operator->"), operator_8297, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10240), Reflex::Literal("get"), method_8299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10241), Reflex::Literal("operator std::vector<boost::shared_ptr<cool::IObject> >* boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > >::*"), converter_8300, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_8301, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_8302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_8303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10243), Reflex::Literal("swap"), method_8304, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_8305, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_8306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10242), Reflex::Literal("_internal_equiv"), method_8307, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IRecordSelection -------------------------------
static void destructor_8310(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecordSelection*)o)->::cool::IRecordSelection::~IRecordSelection();
}
static  void method_8311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]));
  else   (((const ::cool::IRecordSelection*)o)->canSelect)(*(const ::cool::IRecordSpecification*)arg[0]);
}

static  void method_8312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IRecordSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]));
  else   (((const ::cool::IRecordSelection*)o)->select)(*(const ::cool::IRecord*)arg[0]);
}

static  void method_8313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IRecordSelection*)o)->clone)());
  else   (((const ::cool::IRecordSelection*)o)->clone)();
}

//------Dictionary for class IRecordSelection -------------------------------
void __cool__IRecordSelection_db_datamem(Reflex::Class*);
void __cool__IRecordSelection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecordSelection_datamem_bld(&__cool__IRecordSelection_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecordSelection_funcmem_bld(&__cool__IRecordSelection_db_funcmem);
void __cool__IRecordSelection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecordSelection"), typeid(::cool::IRecordSelection), sizeof(::cool::IRecordSelection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecordSelection"), destructor_8310, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecordSelection_funcmem_bld);
}

//------Delayed data member builder for class IRecordSelection -------------------
void __cool__IRecordSelection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecordSelection -------------------
void __cool__IRecordSelection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10133), Reflex::Literal("canSelect"), method_8311, 0, "spec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8529), Reflex::Literal("select"), method_8312, 0, "record", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3538), Reflex::Literal("clone"), method_8313, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IDatabase -------------------------------
static void destructor_8442(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IDatabase*)o)->::cool::IDatabase::~IDatabase();
}
static  void method_8443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IDatabase*)o)->databaseId)();
  else   (((const ::cool::IDatabase*)o)->databaseId)();
}

static  void method_8444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IDatabase*)o)->databaseAttributes)();
  else   (((const ::cool::IDatabase*)o)->databaseAttributes)();
}

static  void method_8445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0]));
    else     (((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]));
    else     (((::cool::IDatabase*)o)->createFolderSet)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_8446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IDatabase*)o)->existsFolderSet)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->existsFolderSet)(*(const ::std::string*)arg[0]);
}

static  void method_8447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IFolderSetPtr)((((::cool::IDatabase*)o)->getFolderSet)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->getFolderSet)(*(const ::std::string*)arg[0]);
}

static  void method_8448( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IFolderSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_8449( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3],
      *(bool*)arg[4]));
    else     (((::cool::IDatabase*)o)->createFolder)(*(const ::std::string*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(const ::std::string*)arg[2],
      *(::cool::FolderVersioning::Mode*)arg[3],
      *(bool*)arg[4]);
  }
}

static  void method_8450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IDatabase*)o)->existsFolder)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->existsFolder)(*(const ::std::string*)arg[0]);
}

static  void method_8451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IFolderPtr)((((::cool::IDatabase*)o)->getFolder)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->getFolder)(*(const ::std::string*)arg[0]);
}

static  void method_8452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IDatabase*)o)->listAllNodes)());
    else     (((::cool::IDatabase*)o)->listAllNodes)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::cool::IDatabase*)o)->listAllNodes)(*(bool*)arg[0]));
    else     (((::cool::IDatabase*)o)->listAllNodes)(*(bool*)arg[0]);
  }
}

static  void method_8453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IDatabase*)o)->dropNode)(*(const ::std::string*)arg[0]));
  else   (((::cool::IDatabase*)o)->dropNode)(*(const ::std::string*)arg[0]);
}

static  void method_8454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IDatabase*)o)->existsTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IDatabase*)o)->existsTag)(*(const ::std::string*)arg[0]);
}

static  void method_8455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::IDatabase*)o)->tagNameScope)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IDatabase*)o)->tagNameScope)(*(const ::std::string*)arg[0]);
}

static  void method_8456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::cool::IDatabase*)o)->taggedNodes)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IDatabase*)o)->taggedNodes)(*(const ::std::string*)arg[0]);
}

static  void method_8457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IDatabase*)o)->isOpen)());
  else   (((const ::cool::IDatabase*)o)->isOpen)();
}

static  void method_8458( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IDatabase*)o)->openDatabase)();
}

static  void method_8459( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IDatabase*)o)->closeDatabase)();
}

static  void method_8460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IDatabase*)o)->databaseName)();
  else   (((const ::cool::IDatabase*)o)->databaseName)();
}

//------Dictionary for class IDatabase -------------------------------
void __cool__IDatabase_db_datamem(Reflex::Class*);
void __cool__IDatabase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IDatabase_datamem_bld(&__cool__IDatabase_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IDatabase_funcmem_bld(&__cool__IDatabase_db_funcmem);
void __cool__IDatabase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IDatabase"), typeid(::cool::IDatabase), sizeof(::cool::IDatabase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDatabase"), destructor_8442, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IDatabase_funcmem_bld);
}

//------Delayed data member builder for class IDatabase -------------------
void __cool__IDatabase_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDatabase -------------------
void __cool__IDatabase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10268), Reflex::Literal("databaseId"), method_8443, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8529), Reflex::Literal("databaseAttributes"), method_8444, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2299, type_4135, type_4135, type_1881), Reflex::Literal("createFolderSet"), method_8445, 0, "fullPath;description=\"\";createParents=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("existsFolderSet"), method_8446, 0, "folderSetName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2299, type_4135), Reflex::Literal("getFolderSet"), method_8447, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2326, type_4135, type_10282, type_4135, type_1881), Reflex::Literal("createFolder"), method_8448, 0, "fullPath;folderSpec;description=\"\";createParents=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2326, type_4135, type_10133, type_4135, type_8690, type_1881), Reflex::Literal("createFolder"), method_8449, 0, "fullPath;payloadSpec;description=\"\";mode=SINGLE_VERSION;createParents=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("existsFolder"), method_8450, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2326, type_4135), Reflex::Literal("getFolder"), method_8451, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1397c, type_1881), Reflex::Literal("listAllNodes"), method_8452, 0, "ascending=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("dropNode"), method_8453, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("existsTag"), method_8454, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8336, type_4135), Reflex::Literal("tagNameScope"), method_8455, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1397c, type_4135), Reflex::Literal("taggedNodes"), method_8456, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isOpen"), method_8457, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("openDatabase"), method_8458, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("closeDatabase"), method_8459, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("databaseName"), method_8460, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class shared_ptr<cool::IDatabase> -------------------------------
static void destructor_8319(void*, void * o, const std::vector<void*>&, void *) {
((::boost::shared_ptr<cool::IDatabase>*)o)->::boost::shared_ptr<cool::IDatabase>::~shared_ptr();
}
static void constructor_8320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IDatabase>(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
  else ::new(mem) ::boost::shared_ptr<cool::IDatabase>(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static void constructor_8321( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::shared_ptr<cool::IDatabase>();
  else ::new(mem) ::boost::shared_ptr<cool::IDatabase>();
}

static  void operator_8322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::shared_ptr<cool::IDatabase>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
  else   (((::boost::shared_ptr<cool::IDatabase>*)o)->operator=)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static  void method_8323( void*, void* o, const std::vector<void*>&, void*)
{
  (((::boost::shared_ptr<cool::IDatabase>*)o)->reset)();
}

static  void operator_8324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator*)();
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator*)();
}

static  void operator_8325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator->)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator->)();
}

static  void method_8327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->get)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->get)();
}

static  void converter_8328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*)();
}

static  void operator_8329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator!)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->operator!)();
}

static  void method_8330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->unique)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->unique)();
}

static  void method_8331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->use_count)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->use_count)();
}

static  void method_8332( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::shared_ptr<cool::IDatabase>*)o)->swap)(*(::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static  void method_8333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_8334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_untyped_deleter)());
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_get_untyped_deleter)();
}

static  void method_8335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]));
  else   (((const ::boost::shared_ptr<cool::IDatabase>*)o)->_internal_equiv)(*(const ::boost::shared_ptr<cool::IDatabase>*)arg[0]);
}

static void method_newdel_2337( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::shared_ptr<cool::IDatabase> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_ptr<cool::IDatabase> -------------------------------
void __boost__shared_ptr_cool__IDatabase__db_datamem(Reflex::Class*);
void __boost__shared_ptr_cool__IDatabase__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IDatabase__datamem_bld(&__boost__shared_ptr_cool__IDatabase__db_datamem);
Reflex::GenreflexMemberBuilder __boost__shared_ptr_cool__IDatabase__funcmem_bld(&__boost__shared_ptr_cool__IDatabase__db_funcmem);
void __boost__shared_ptr_cool__IDatabase__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::shared_ptr<cool::IDatabase>"), typeid(::boost::shared_ptr<cool::IDatabase>), sizeof(::boost::shared_ptr<cool::IDatabase>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2361, Reflex::Literal("boost::shared_ptr<cool::IDatabase>::element_type"))
  .AddTypedef(type_10247, Reflex::Literal("boost::shared_ptr<cool::IDatabase>::unspecified_bool_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_ptr"), destructor_8319, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10248), Reflex::Literal("shared_ptr"), constructor_8320, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_ptr"), constructor_8321, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2337, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__shared_ptr_cool__IDatabase__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__shared_ptr_cool__IDatabase__funcmem_bld);
}

//------Delayed data member builder for class shared_ptr<cool::IDatabase> -------------------
void __boost__shared_ptr_cool__IDatabase__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10246, Reflex::Literal("px"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IDatabase_, px), ::Reflex::PRIVATE)
  .AddDataMember(type_9031, Reflex::Literal("pn"), OffsetOf(__shadow__::__boost__shared_ptr_cool__IDatabase_, pn), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_ptr<cool::IDatabase> -------------------
void __boost__shared_ptr_cool__IDatabase__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10249, type_10248), Reflex::Literal("operator="), operator_8322, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("reset"), method_8323, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10250), Reflex::Literal("operator*"), operator_8324, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10246), Reflex::Literal("operator->"), operator_8325, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10246), Reflex::Literal("get"), method_8327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10247), Reflex::Literal("operator cool::IDatabase* boost::shared_ptr<cool::IDatabase>::*"), converter_8328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("operator!"), operator_8329, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_8330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_8331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10249), Reflex::Literal("swap"), method_8332, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("_internal_get_deleter"), method_8333, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("_internal_get_untyped_deleter"), method_8334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10248), Reflex::Literal("_internal_equiv"), method_8335, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IHvsNode -------------------------------
static void destructor_8339(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IHvsNode*)o)->::cool::IHvsNode::~IHvsNode();
}
static  void method_8340( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IHvsNode*)o)->setDescription)(*(const ::std::string*)arg[0]);
}

static  void method_8341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::cool::IHvsNode*)o)->listTags)());
  else   (((const ::cool::IHvsNode*)o)->listTags)();
}

static  void method_8342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::Time)((((const ::cool::IHvsNode*)o)->tagInsertionTime)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->tagInsertionTime)(*(const ::std::string*)arg[0]);
}

static  void method_8343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IHvsNode*)o)->tagDescription)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->tagDescription)(*(const ::std::string*)arg[0]);
}

static  void method_8344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IHvsNode*)o)->setTagLockStatus)(*(const ::std::string*)arg[0],
    *(::cool::HvsTagLock::Status*)arg[1]);
}

static  void method_8345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::IHvsNode*)o)->tagLockStatus)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->tagLockStatus)(*(const ::std::string*)arg[0]);
}

static  void method_8346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IHvsNode*)o)->isHeadTag)(*(const ::std::string*)arg[0]));
  else   (((::cool::IHvsNode*)o)->isHeadTag)(*(const ::std::string*)arg[0]);
}

static  void method_8347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::cool::IHvsNode*)o)->headTag)());
  else   (((::cool::IHvsNode*)o)->headTag)();
}

static  void method_8348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::cool::IHvsNode*)o)->createTagRelation)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8349( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::cool::IHvsNode*)o)->deleteTagRelation)(*(const ::std::string*)arg[0]);
}

static  void method_8350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IHvsNode*)o)->findTagRelation)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->findTagRelation)(*(const ::std::string*)arg[0]);
}

static  void method_8351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IHvsNode*)o)->resolveTag)(*(const ::std::string*)arg[0]));
  else   (((const ::cool::IHvsNode*)o)->resolveTag)(*(const ::std::string*)arg[0]);
}

static  void method_8352( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IHvsNode*)o)->setTagDescription)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void method_x150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IHvsNodeRecord")), ::Reflex::BaseOffset< ::cool::IHvsNode,::cool::IHvsNodeRecord >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IHvsNode -------------------------------
void __cool__IHvsNode_db_datamem(Reflex::Class*);
void __cool__IHvsNode_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IHvsNode_datamem_bld(&__cool__IHvsNode_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IHvsNode_funcmem_bld(&__cool__IHvsNode_db_funcmem);
void __cool__IHvsNode_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IHvsNode"), typeid(::cool::IHvsNode), sizeof(::cool::IHvsNode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2346, ::Reflex::BaseOffset< ::cool::IHvsNode, ::cool::IHvsNodeRecord >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("cool::IHvsNode::Type"), Reflex::Literal("INNER_NODE=0;LEAF_NODE=1"), &typeid(cool::IHvsNode::Type), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IHvsNode"), destructor_8339, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__IHvsNode_funcmem_bld);
}

//------Delayed data member builder for class IHvsNode -------------------
void __cool__IHvsNode_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IHvsNode -------------------
void __cool__IHvsNode_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135), Reflex::Literal("setDescription"), method_8340, 0, "description", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1397c), Reflex::Literal("listTags"), method_8341, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2331c, type_4135), Reflex::Literal("tagInsertionTime"), method_8342, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_4135), Reflex::Literal("tagDescription"), method_8343, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_7996), Reflex::Literal("setTagLockStatus"), method_8344, 0, "tagName;tagLockStatus", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7996, type_4135), Reflex::Literal("tagLockStatus"), method_8345, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("isHeadTag"), method_8346, 0, "tagName", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c), Reflex::Literal("headTag"), method_8347, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135), Reflex::Literal("createTagRelation"), method_8348, 0, "parentTagName;tagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135), Reflex::Literal("deleteTagRelation"), method_8349, 0, "parentTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_4135), Reflex::Literal("findTagRelation"), method_8350, 0, "parentTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c, type_4135), Reflex::Literal("resolveTag"), method_8351, 0, "ancestorTagName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135), Reflex::Literal("setTagDescription"), method_8352, 0, "tagName;description", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class RecordSpecificationCannotExtend -------------------------------
static  void operator_8354( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecificationCannotExtend*)o)->operator=)(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
  else   (((::cool::RecordSpecificationCannotExtend*)o)->operator=)(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
}

static void constructor_8355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
  else ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::cool::RecordSpecificationCannotExtend*)arg[0]);
}

static void constructor_8356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::RecordSpecificationCannotExtend(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8357(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecificationCannotExtend*)o)->::cool::RecordSpecificationCannotExtend::~RecordSpecificationCannotExtend();
}
static void method_x151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecificationCannotExtend -------------------------------
void __cool__RecordSpecificationCannotExtend_db_datamem(Reflex::Class*);
void __cool__RecordSpecificationCannotExtend_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationCannotExtend_datamem_bld(&__cool__RecordSpecificationCannotExtend_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationCannotExtend_funcmem_bld(&__cool__RecordSpecificationCannotExtend_db_funcmem);
void __cool__RecordSpecificationCannotExtend_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecificationCannotExtend"), typeid(::cool::RecordSpecificationCannotExtend), sizeof(::cool::RecordSpecificationCannotExtend), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::RecordSpecificationCannotExtend, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10255, type_10256), Reflex::Literal("operator="), operator_8354, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10256), Reflex::Literal("RecordSpecificationCannotExtend"), constructor_8355, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("RecordSpecificationCannotExtend"), constructor_8356, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecificationCannotExtend"), destructor_8357, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordSpecificationCannotExtend -------------------
void __cool__RecordSpecificationCannotExtend_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordSpecificationCannotExtend -------------------
void __cool__RecordSpecificationCannotExtend_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Blob -------------------------------
static void constructor_8360( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::Blob();
  else ::new(mem) ::coral::Blob();
}

static void constructor_8361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::Blob(*(long*)arg[0]);
  else ::new(mem) ::coral::Blob(*(long*)arg[0]);
}

static void destructor_8362(void*, void * o, const std::vector<void*>&, void *) {
((::coral::Blob*)o)->::coral::Blob::~Blob();
}
static void constructor_8363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::Blob(*(const ::coral::Blob*)arg[0]);
  else ::new(mem) ::coral::Blob(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Blob*)o)->operator=)(*(const ::coral::Blob*)arg[0]);
  else   (((::coral::Blob*)o)->operator=)(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Blob*)o)->operator+=)(*(const ::coral::Blob*)arg[0]);
  else   (((::coral::Blob*)o)->operator+=)(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Blob*)o)->operator==)(*(const ::coral::Blob*)arg[0]));
  else   (((const ::coral::Blob*)o)->operator==)(*(const ::coral::Blob*)arg[0]);
}

static  void operator_8367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Blob*)o)->operator!=)(*(const ::coral::Blob*)arg[0]));
  else   (((const ::coral::Blob*)o)->operator!=)(*(const ::coral::Blob*)arg[0]);
}

static  void method_8368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::Blob*)o)->startingAddress)());
  else   (((const ::coral::Blob*)o)->startingAddress)();
}

static  void method_8369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::Blob*)o)->startingAddress)());
  else   (((::coral::Blob*)o)->startingAddress)();
}

static  void method_8370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::coral::Blob*)o)->size)());
  else   (((const ::coral::Blob*)o)->size)();
}

static  void method_8371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Blob*)o)->extend)(*(long*)arg[0]);
}

static  void method_8372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Blob*)o)->resize)(*(long*)arg[0]);
}

static void method_newdel_2342( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::Blob >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::Blob >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::Blob >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::Blob >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::Blob >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Blob -------------------------------
void __coral__Blob_db_datamem(Reflex::Class*);
void __coral__Blob_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__Blob_datamem_bld(&__coral__Blob_db_datamem);
Reflex::GenreflexMemberBuilder __coral__Blob_funcmem_bld(&__coral__Blob_db_funcmem);
void __coral__Blob_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::Blob"), typeid(::coral::Blob), sizeof(::coral::Blob), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Blob"), constructor_8360, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_124), Reflex::Literal("Blob"), constructor_8361, 0, "initialSizeInBytes", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Blob"), destructor_8362, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10125), Reflex::Literal("Blob"), constructor_8363, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2342, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__coral__Blob_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__Blob_funcmem_bld);
}

//------Delayed data member builder for class Blob -------------------
void __coral__Blob_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_124, Reflex::Literal("m_size"), OffsetOf(__shadow__::__coral__Blob, m_size), ::Reflex::PRIVATE)
  .AddDataMember(type_185, Reflex::Literal("m_data"), OffsetOf(__shadow__::__coral__Blob, m_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Blob -------------------
void __coral__Blob_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10257, type_10125), Reflex::Literal("operator="), operator_8364, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10257, type_10125), Reflex::Literal("operator+="), operator_8365, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10125), Reflex::Literal("operator=="), operator_8366, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10125), Reflex::Literal("operator!="), operator_8367, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("startingAddress"), method_8368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("startingAddress"), method_8369, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("size"), method_8370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_124), Reflex::Literal("extend"), method_8371, 0, "additionalSizeInBytes", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_124), Reflex::Literal("resize"), method_8372, 0, "sizeInBytes", ::Reflex::PUBLIC);
}
//------Stub functions for class IApplication -------------------------------
static void destructor_8375(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IApplication*)o)->::cool::IApplication::~IApplication();
}
static  void method_8376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::IApplication*)o)->databaseService)();
  else   (((::cool::IApplication*)o)->databaseService)();
}

static  void method_8377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::cool::IApplication*)o)->outputLevel)());
  else   (((::cool::IApplication*)o)->outputLevel)();
}

static  void method_8378( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::IApplication*)o)->setOutputLevel)(*(::cool::MSG::Level*)arg[0]);
}

static  void method_8379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::IApplication*)o)->context)());
  else   (((const ::cool::IApplication*)o)->context)();
}

static  void method_8380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IApplication*)o)->connectionSvc)();
  else   (((const ::cool::IApplication*)o)->connectionSvc)();
}

//------Dictionary for class IApplication -------------------------------
void __cool__IApplication_db_datamem(Reflex::Class*);
void __cool__IApplication_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IApplication_datamem_bld(&__cool__IApplication_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IApplication_funcmem_bld(&__cool__IApplication_db_funcmem);
void __cool__IApplication_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IApplication"), typeid(::cool::IApplication), sizeof(::cool::IApplication), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IApplication"), destructor_8375, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IApplication_funcmem_bld);
}

//------Delayed data member builder for class IApplication -------------------
void __cool__IApplication_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IApplication -------------------
void __cool__IApplication_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10259), Reflex::Literal("databaseService"), method_8376, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8002), Reflex::Literal("outputLevel"), method_8377, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8002), Reflex::Literal("setOutputLevel"), method_8378, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10260), Reflex::Literal("context"), method_8379, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10261), Reflex::Literal("connectionSvc"), method_8380, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IHvsNodeRecord -------------------------------
static void destructor_8384(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IHvsNodeRecord*)o)->::cool::IHvsNodeRecord::~IHvsNodeRecord();
}
static  void method_8385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IHvsNodeRecord*)o)->fullPath)();
  else   (((const ::cool::IHvsNodeRecord*)o)->fullPath)();
}

static  void method_8386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IHvsNodeRecord*)o)->description)();
  else   (((const ::cool::IHvsNodeRecord*)o)->description)();
}

static  void method_8387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IHvsNodeRecord*)o)->isLeaf)());
  else   (((const ::cool::IHvsNodeRecord*)o)->isLeaf)();
}

static  void method_8388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IHvsNodeRecord*)o)->isStored)());
  else   (((const ::cool::IHvsNodeRecord*)o)->isStored)();
}

static  void method_8389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IHvsNodeRecord*)o)->insertionTime)();
  else   (((const ::cool::IHvsNodeRecord*)o)->insertionTime)();
}

static  void method_8390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IHvsNodeRecord*)o)->id)());
  else   (((const ::cool::IHvsNodeRecord*)o)->id)();
}

static  void method_8391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::UInt32)((((const ::cool::IHvsNodeRecord*)o)->parentId)());
  else   (((const ::cool::IHvsNodeRecord*)o)->parentId)();
}

//------Dictionary for class IHvsNodeRecord -------------------------------
void __cool__IHvsNodeRecord_db_datamem(Reflex::Class*);
void __cool__IHvsNodeRecord_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IHvsNodeRecord_datamem_bld(&__cool__IHvsNodeRecord_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IHvsNodeRecord_funcmem_bld(&__cool__IHvsNodeRecord_db_funcmem);
void __cool__IHvsNodeRecord_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IHvsNodeRecord"), typeid(::cool::IHvsNodeRecord), sizeof(::cool::IHvsNodeRecord), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IHvsNodeRecord"), destructor_8384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IHvsNodeRecord_funcmem_bld);
}

//------Delayed data member builder for class IHvsNodeRecord -------------------
void __cool__IHvsNodeRecord_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IHvsNodeRecord -------------------
void __cool__IHvsNodeRecord_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("fullPath"), method_8385, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("description"), method_8386, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isLeaf"), method_8387, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isStored"), method_8388, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8526), Reflex::Literal("insertionTime"), method_8389, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("id"), method_8390, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("parentId"), method_8391, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class TagExists -------------------------------
static  void operator_8395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagExists*)o)->operator=)(*(const ::cool::TagExists*)arg[0]);
  else   (((::cool::TagExists*)o)->operator=)(*(const ::cool::TagExists*)arg[0]);
}

static void constructor_8396( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagExists(*(const ::cool::TagExists*)arg[0]);
  else ::new(mem) ::cool::TagExists(*(const ::cool::TagExists*)arg[0]);
}

static void constructor_8397( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::TagExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8398(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagExists*)o)->::cool::TagExists::~TagExists();
}
static void method_x153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagExists -------------------------------
void __cool__TagExists_db_datamem(Reflex::Class*);
void __cool__TagExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagExists_datamem_bld(&__cool__TagExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagExists_funcmem_bld(&__cool__TagExists_db_funcmem);
void __cool__TagExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagExists"), typeid(::cool::TagExists), sizeof(::cool::TagExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::TagExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10265, type_10266), Reflex::Literal("operator="), operator_8395, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10266), Reflex::Literal("TagExists"), constructor_8396, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("TagExists"), constructor_8397, 0, "tagName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagExists"), destructor_8398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagExists -------------------
void __cool__TagExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagExists -------------------
void __cool__TagExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IDatabaseSvc -------------------------------
static void destructor_8401(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IDatabaseSvc*)o)->::cool::IDatabaseSvc::~IDatabaseSvc();
}
static  void method_8402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IDatabasePtr)((((const ::cool::IDatabaseSvc*)o)->createDatabase)(*(const ::cool::DatabaseId*)arg[0]));
  else   (((const ::cool::IDatabaseSvc*)o)->createDatabase)(*(const ::cool::DatabaseId*)arg[0]);
}

static  void method_8403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (cool::IDatabasePtr)((((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0]));
    else     (((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (cool::IDatabasePtr)((((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::cool::IDatabaseSvc*)o)->openDatabase)(*(const ::cool::DatabaseId*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IDatabaseSvc*)o)->dropDatabase)(*(const ::cool::DatabaseId*)arg[0]));
  else   (((const ::cool::IDatabaseSvc*)o)->dropDatabase)(*(const ::cool::DatabaseId*)arg[0]);
}

static  void method_8405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::cool::IDatabaseSvc*)o)->serviceVersion)());
  else   (((const ::cool::IDatabaseSvc*)o)->serviceVersion)();
}

//------Dictionary for class IDatabaseSvc -------------------------------
void __cool__IDatabaseSvc_db_datamem(Reflex::Class*);
void __cool__IDatabaseSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IDatabaseSvc_datamem_bld(&__cool__IDatabaseSvc_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IDatabaseSvc_funcmem_bld(&__cool__IDatabaseSvc_db_funcmem);
void __cool__IDatabaseSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IDatabaseSvc"), typeid(::cool::IDatabaseSvc), sizeof(::cool::IDatabaseSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDatabaseSvc"), destructor_8401, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IDatabaseSvc_funcmem_bld);
}

//------Delayed data member builder for class IDatabaseSvc -------------------
void __cool__IDatabaseSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDatabaseSvc -------------------
void __cool__IDatabaseSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2338, type_10268), Reflex::Literal("createDatabase"), method_8402, 0, "dbId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2338, type_10268, type_1881), Reflex::Literal("openDatabase"), method_8403, 0, "dbId;readOnly=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10268), Reflex::Literal("dropDatabase"), method_8404, 0, "dbId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450c), Reflex::Literal("serviceVersion"), method_8405, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class FieldSpecification -------------------------------
static void destructor_8409(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecification*)o)->::cool::FieldSpecification::~FieldSpecification();
}
static void constructor_8410( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecification(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1]);
  else ::new(mem) ::cool::FieldSpecification(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType::TypeId*)arg[1]);
}

static void constructor_8411( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecification(*(const ::cool::FieldSpecification*)arg[0]);
  else ::new(mem) ::cool::FieldSpecification(*(const ::cool::FieldSpecification*)arg[0]);
}

static  void method_8412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FieldSpecification*)o)->name)();
  else   (((const ::cool::FieldSpecification*)o)->name)();
}

static  void method_8413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FieldSpecification*)o)->storageType)();
  else   (((const ::cool::FieldSpecification*)o)->storageType)();
}

static  void operator_8414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::FieldSpecification*)o)->operator==)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void operator_8415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]));
  else   (((const ::cool::FieldSpecification*)o)->operator!=)(*(const ::cool::IFieldSpecification*)arg[0]);
}

static  void method_8416( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::cool::IField*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8417( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::cool::FieldSpecification*)o)->validate)(*(const ::coral::Attribute*)arg[0],
      *(bool*)arg[1]);
  }
}

static void method_x154( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IFieldSpecification")), ::Reflex::BaseOffset< ::cool::FieldSpecification,::cool::IFieldSpecification >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecification -------------------------------
void __cool__FieldSpecification_db_datamem(Reflex::Class*);
void __cool__FieldSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecification_datamem_bld(&__cool__FieldSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecification_funcmem_bld(&__cool__FieldSpecification_db_funcmem);
void __cool__FieldSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecification"), typeid(::cool::FieldSpecification), sizeof(::cool::FieldSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2316, ::Reflex::BaseOffset< ::cool::FieldSpecification, ::cool::IFieldSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecification"), destructor_8409, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_7704c), Reflex::Literal("FieldSpecification"), constructor_8410, 0, "name;typeId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10269), Reflex::Literal("FieldSpecification"), constructor_8411, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x154, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FieldSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FieldSpecification_funcmem_bld);
}

//------Delayed data member builder for class FieldSpecification -------------------
void __cool__FieldSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1450c, Reflex::Literal("m_name"), OffsetOf(__shadow__::__cool__FieldSpecification, m_name), ::Reflex::PRIVATE | ::Reflex::CONST);
}
//------Delayed function member builder for class FieldSpecification -------------------
void __cool__FieldSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("name"), method_8412, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10138), Reflex::Literal("storageType"), method_8413, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10146), Reflex::Literal("operator=="), operator_8414, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10146), Reflex::Literal("operator!="), operator_8415, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8530, type_1881), Reflex::Literal("validate"), method_8416, 0, "field;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8914, type_1881), Reflex::Literal("validate"), method_8417, 0, "attribute;checkName=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class RecordException -------------------------------
static  void operator_8420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordException*)o)->operator=)(*(const ::cool::RecordException*)arg[0]);
  else   (((::cool::RecordException*)o)->operator=)(*(const ::cool::RecordException*)arg[0]);
}

static void constructor_8421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordException(*(const ::cool::RecordException*)arg[0]);
  else ::new(mem) ::cool::RecordException(*(const ::cool::RecordException*)arg[0]);
}

static void constructor_8422( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::RecordException(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8423(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordException*)o)->::cool::RecordException::~RecordException();
}
static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordException,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordException -------------------------------
void __cool__RecordException_db_datamem(Reflex::Class*);
void __cool__RecordException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordException_datamem_bld(&__cool__RecordException_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordException_funcmem_bld(&__cool__RecordException_db_funcmem);
void __cool__RecordException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordException"), typeid(::cool::RecordException), sizeof(::cool::RecordException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::RecordException, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10271, type_10272), Reflex::Literal("operator="), operator_8420, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10272), Reflex::Literal("RecordException"), constructor_8421, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("RecordException"), constructor_8422, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordException"), destructor_8423, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordException -------------------
void __cool__RecordException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordException -------------------
void __cool__RecordException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ReservedHeadTag -------------------------------
static  void operator_8424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ReservedHeadTag*)o)->operator=)(*(const ::cool::ReservedHeadTag*)arg[0]);
  else   (((::cool::ReservedHeadTag*)o)->operator=)(*(const ::cool::ReservedHeadTag*)arg[0]);
}

static void constructor_8425( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ReservedHeadTag(*(const ::cool::ReservedHeadTag*)arg[0]);
  else ::new(mem) ::cool::ReservedHeadTag(*(const ::cool::ReservedHeadTag*)arg[0]);
}

static void constructor_8426( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ReservedHeadTag(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ReservedHeadTag(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8427(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ReservedHeadTag*)o)->::cool::ReservedHeadTag::~ReservedHeadTag();
}
static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ReservedHeadTag,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ReservedHeadTag,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ReservedHeadTag -------------------------------
void __cool__ReservedHeadTag_db_datamem(Reflex::Class*);
void __cool__ReservedHeadTag_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ReservedHeadTag_datamem_bld(&__cool__ReservedHeadTag_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ReservedHeadTag_funcmem_bld(&__cool__ReservedHeadTag_db_funcmem);
void __cool__ReservedHeadTag_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ReservedHeadTag"), typeid(::cool::ReservedHeadTag), sizeof(::cool::ReservedHeadTag), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::ReservedHeadTag, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10273, type_10274), Reflex::Literal("operator="), operator_8424, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10274), Reflex::Literal("ReservedHeadTag"), constructor_8425, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("ReservedHeadTag"), constructor_8426, 0, "tagName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ReservedHeadTag"), destructor_8427, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ReservedHeadTag -------------------
void __cool__ReservedHeadTag_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ReservedHeadTag -------------------
void __cool__ReservedHeadTag_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ValidityKeyOutOfBoundaries -------------------------------
static  void operator_8428( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::ValidityKeyOutOfBoundaries*)o)->operator=)(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
  else   (((::cool::ValidityKeyOutOfBoundaries*)o)->operator=)(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
}

static void constructor_8429( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
  else ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKeyOutOfBoundaries*)arg[0]);
}

static void constructor_8430( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKey*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::ValidityKeyOutOfBoundaries(*(const ::cool::ValidityKey*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8431(void*, void * o, const std::vector<void*>&, void *) {
((::cool::ValidityKeyOutOfBoundaries*)o)->::cool::ValidityKeyOutOfBoundaries::~ValidityKeyOutOfBoundaries();
}
static void method_x157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::ValidityKeyException")), ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries,::cool::ValidityKeyException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ValidityKeyOutOfBoundaries -------------------------------
void __cool__ValidityKeyOutOfBoundaries_db_datamem(Reflex::Class*);
void __cool__ValidityKeyOutOfBoundaries_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyOutOfBoundaries_datamem_bld(&__cool__ValidityKeyOutOfBoundaries_db_datamem);
Reflex::GenreflexMemberBuilder __cool__ValidityKeyOutOfBoundaries_funcmem_bld(&__cool__ValidityKeyOutOfBoundaries_db_funcmem);
void __cool__ValidityKeyOutOfBoundaries_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::ValidityKeyOutOfBoundaries"), typeid(::cool::ValidityKeyOutOfBoundaries), sizeof(::cool::ValidityKeyOutOfBoundaries), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2312, ::Reflex::BaseOffset< ::cool::ValidityKeyOutOfBoundaries, ::cool::ValidityKeyException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10275, type_10276), Reflex::Literal("operator="), operator_8428, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10276), Reflex::Literal("ValidityKeyOutOfBoundaries"), constructor_8429, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10223, type_4135), Reflex::Literal("ValidityKeyOutOfBoundaries"), constructor_8430, 0, "key;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValidityKeyOutOfBoundaries"), destructor_8431, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class ValidityKeyOutOfBoundaries -------------------
void __cool__ValidityKeyOutOfBoundaries_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ValidityKeyOutOfBoundaries -------------------
void __cool__ValidityKeyOutOfBoundaries_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FieldSpecificationInvalidName -------------------------------
static  void operator_8432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FieldSpecificationInvalidName*)o)->operator=)(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
  else   (((::cool::FieldSpecificationInvalidName*)o)->operator=)(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
}

static void constructor_8433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
  else ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::cool::FieldSpecificationInvalidName*)arg[0]);
}

static void constructor_8434( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FieldSpecificationInvalidName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8435(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FieldSpecificationInvalidName*)o)->::cool::FieldSpecificationInvalidName::~FieldSpecificationInvalidName();
}
static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FieldSpecificationInvalidName -------------------------------
void __cool__FieldSpecificationInvalidName_db_datamem(Reflex::Class*);
void __cool__FieldSpecificationInvalidName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationInvalidName_datamem_bld(&__cool__FieldSpecificationInvalidName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FieldSpecificationInvalidName_funcmem_bld(&__cool__FieldSpecificationInvalidName_db_funcmem);
void __cool__FieldSpecificationInvalidName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FieldSpecificationInvalidName"), typeid(::cool::FieldSpecificationInvalidName), sizeof(::cool::FieldSpecificationInvalidName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::FieldSpecificationInvalidName, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10277, type_10278), Reflex::Literal("operator="), operator_8432, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10278), Reflex::Literal("FieldSpecificationInvalidName"), constructor_8433, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("FieldSpecificationInvalidName"), constructor_8434, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FieldSpecificationInvalidName"), destructor_8435, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class FieldSpecificationInvalidName -------------------
void __cool__FieldSpecificationInvalidName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class FieldSpecificationInvalidName -------------------
void __cool__FieldSpecificationInvalidName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeDoubleIsNaN -------------------------------
static  void operator_8436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeDoubleIsNaN*)o)->operator=)(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
  else   (((::cool::StorageTypeDoubleIsNaN*)o)->operator=)(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
}

static void constructor_8437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
  else ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::cool::StorageTypeDoubleIsNaN*)arg[0]);
}

static void constructor_8438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::StorageTypeDoubleIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8439(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeDoubleIsNaN*)o)->::cool::StorageTypeDoubleIsNaN::~StorageTypeDoubleIsNaN();
}
static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeDoubleIsNaN -------------------------------
void __cool__StorageTypeDoubleIsNaN_db_datamem(Reflex::Class*);
void __cool__StorageTypeDoubleIsNaN_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeDoubleIsNaN_datamem_bld(&__cool__StorageTypeDoubleIsNaN_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeDoubleIsNaN_funcmem_bld(&__cool__StorageTypeDoubleIsNaN_db_funcmem);
void __cool__StorageTypeDoubleIsNaN_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeDoubleIsNaN"), typeid(::cool::StorageTypeDoubleIsNaN), sizeof(::cool::StorageTypeDoubleIsNaN), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2388, ::Reflex::BaseOffset< ::cool::StorageTypeDoubleIsNaN, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10279, type_10280), Reflex::Literal("operator="), operator_8436, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10280), Reflex::Literal("StorageTypeDoubleIsNaN"), constructor_8437, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("StorageTypeDoubleIsNaN"), constructor_8438, 0, "expectedName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeDoubleIsNaN"), destructor_8439, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeDoubleIsNaN -------------------
void __cool__StorageTypeDoubleIsNaN_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeDoubleIsNaN -------------------
void __cool__StorageTypeDoubleIsNaN_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagRelationExists -------------------------------
static  void operator_8462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagRelationExists*)o)->operator=)(*(const ::cool::TagRelationExists*)arg[0]);
  else   (((::cool::TagRelationExists*)o)->operator=)(*(const ::cool::TagRelationExists*)arg[0]);
}

static void constructor_8463( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationExists(*(const ::cool::TagRelationExists*)arg[0]);
  else ::new(mem) ::cool::TagRelationExists(*(const ::cool::TagRelationExists*)arg[0]);
}

static void constructor_8464( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagRelationExists(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::TagRelationExists(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(::cool::UInt32*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8465(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagRelationExists*)o)->::cool::TagRelationExists::~TagRelationExists();
}
static void method_x160( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagRelationExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagRelationExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagRelationExists -------------------------------
void __cool__TagRelationExists_db_datamem(Reflex::Class*);
void __cool__TagRelationExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagRelationExists_datamem_bld(&__cool__TagRelationExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagRelationExists_funcmem_bld(&__cool__TagRelationExists_db_funcmem);
void __cool__TagRelationExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagRelationExists"), typeid(::cool::TagRelationExists), sizeof(::cool::TagRelationExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::TagRelationExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10283, type_10284), Reflex::Literal("operator="), operator_8462, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10284), Reflex::Literal("TagRelationExists"), constructor_8463, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_2367, type_2367, type_4135), Reflex::Literal("TagRelationExists"), constructor_8464, 0, "parentNodeId;parentTagId;childNodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagRelationExists"), destructor_8465, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x160, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagRelationExists -------------------
void __cool__TagRelationExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagRelationExists -------------------
void __cool__TagRelationExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class InvalidFolderSpecification -------------------------------
static  void operator_8466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidFolderSpecification*)o)->operator=)(*(const ::cool::InvalidFolderSpecification*)arg[0]);
  else   (((::cool::InvalidFolderSpecification*)o)->operator=)(*(const ::cool::InvalidFolderSpecification*)arg[0]);
}

static void constructor_8467( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidFolderSpecification(*(const ::cool::InvalidFolderSpecification*)arg[0]);
  else ::new(mem) ::cool::InvalidFolderSpecification(*(const ::cool::InvalidFolderSpecification*)arg[0]);
}

static void constructor_8468( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidFolderSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::InvalidFolderSpecification(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8469(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidFolderSpecification*)o)->::cool::InvalidFolderSpecification::~InvalidFolderSpecification();
}
static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidFolderSpecification,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidFolderSpecification,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidFolderSpecification -------------------------------
void __cool__InvalidFolderSpecification_db_datamem(Reflex::Class*);
void __cool__InvalidFolderSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidFolderSpecification_datamem_bld(&__cool__InvalidFolderSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidFolderSpecification_funcmem_bld(&__cool__InvalidFolderSpecification_db_funcmem);
void __cool__InvalidFolderSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidFolderSpecification"), typeid(::cool::InvalidFolderSpecification), sizeof(::cool::InvalidFolderSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::InvalidFolderSpecification, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10285, type_10286), Reflex::Literal("operator="), operator_8466, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10286), Reflex::Literal("InvalidFolderSpecification"), constructor_8467, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("InvalidFolderSpecification"), constructor_8468, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidFolderSpecification"), destructor_8469, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidFolderSpecification -------------------
void __cool__InvalidFolderSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidFolderSpecification -------------------
void __cool__InvalidFolderSpecification_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeStringContainsNullChar -------------------------------
static  void operator_8470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeStringContainsNullChar*)o)->operator=)(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
  else   (((::cool::StorageTypeStringContainsNullChar*)o)->operator=)(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
}

static void constructor_8471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
  else ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::cool::StorageTypeStringContainsNullChar*)arg[0]);
}

static void constructor_8472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::StorageTypeStringContainsNullChar(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8473(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeStringContainsNullChar*)o)->::cool::StorageTypeStringContainsNullChar::~StorageTypeStringContainsNullChar();
}
static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeStringContainsNullChar -------------------------------
void __cool__StorageTypeStringContainsNullChar_db_datamem(Reflex::Class*);
void __cool__StorageTypeStringContainsNullChar_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringContainsNullChar_datamem_bld(&__cool__StorageTypeStringContainsNullChar_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeStringContainsNullChar_funcmem_bld(&__cool__StorageTypeStringContainsNullChar_db_funcmem);
void __cool__StorageTypeStringContainsNullChar_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeStringContainsNullChar"), typeid(::cool::StorageTypeStringContainsNullChar), sizeof(::cool::StorageTypeStringContainsNullChar), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2388, ::Reflex::BaseOffset< ::cool::StorageTypeStringContainsNullChar, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10287, type_10288), Reflex::Literal("operator="), operator_8470, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10288), Reflex::Literal("StorageTypeStringContainsNullChar"), constructor_8471, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10138, type_4135), Reflex::Literal("StorageTypeStringContainsNullChar"), constructor_8472, 0, "expectedName;expectedStorageType;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeStringContainsNullChar"), destructor_8473, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeStringContainsNullChar -------------------
void __cool__StorageTypeStringContainsNullChar_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeStringContainsNullChar -------------------
void __cool__StorageTypeStringContainsNullChar_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeInvalidUInt63 -------------------------------
static  void operator_8474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeInvalidUInt63*)o)->operator=)(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
  else   (((::cool::StorageTypeInvalidUInt63*)o)->operator=)(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
}

static void constructor_8475( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
  else ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::cool::StorageTypeInvalidUInt63*)arg[0]);
}

static void constructor_8476( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::std::string*)arg[0],
      *(const ::cool::UInt63*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::StorageTypeInvalidUInt63(*(const ::std::string*)arg[0],
      *(const ::cool::UInt63*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8477(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeInvalidUInt63*)o)->::cool::StorageTypeInvalidUInt63::~StorageTypeInvalidUInt63();
}
static void method_x163( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeInvalidUInt63 -------------------------------
void __cool__StorageTypeInvalidUInt63_db_datamem(Reflex::Class*);
void __cool__StorageTypeInvalidUInt63_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidUInt63_datamem_bld(&__cool__StorageTypeInvalidUInt63_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidUInt63_funcmem_bld(&__cool__StorageTypeInvalidUInt63_db_funcmem);
void __cool__StorageTypeInvalidUInt63_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeInvalidUInt63"), typeid(::cool::StorageTypeInvalidUInt63), sizeof(::cool::StorageTypeInvalidUInt63), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2388, ::Reflex::BaseOffset< ::cool::StorageTypeInvalidUInt63, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10289, type_10290), Reflex::Literal("operator="), operator_8474, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10290), Reflex::Literal("StorageTypeInvalidUInt63"), constructor_8475, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10147, type_4135), Reflex::Literal("StorageTypeInvalidUInt63"), constructor_8476, 0, "expectedName;value;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeInvalidUInt63"), destructor_8477, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x163, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeInvalidUInt63 -------------------
void __cool__StorageTypeInvalidUInt63_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeInvalidUInt63 -------------------
void __cool__StorageTypeInvalidUInt63_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseSvcFactory -------------------------------
static void destructor_8478(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseSvcFactory*)o)->::cool::DatabaseSvcFactory::~DatabaseSvcFactory();
}
static  void operator_8479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseSvcFactory*)o)->operator=)(*(const ::cool::DatabaseSvcFactory*)arg[0]);
  else   (((::cool::DatabaseSvcFactory*)o)->operator=)(*(const ::cool::DatabaseSvcFactory*)arg[0]);
}

static void constructor_8480( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseSvcFactory(*(const ::cool::DatabaseSvcFactory*)arg[0]);
  else ::new(mem) ::cool::DatabaseSvcFactory(*(const ::cool::DatabaseSvcFactory*)arg[0]);
}

static void constructor_8481( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseSvcFactory();
  else ::new(mem) ::cool::DatabaseSvcFactory();
}

static  void method_8482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseSvcFactory*)o)->databaseService)();
  else   (((::cool::DatabaseSvcFactory*)o)->databaseService)();
}

static void method_newdel_2366( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::DatabaseSvcFactory >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DatabaseSvcFactory -------------------------------
void __cool__DatabaseSvcFactory_db_datamem(Reflex::Class*);
void __cool__DatabaseSvcFactory_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseSvcFactory_datamem_bld(&__cool__DatabaseSvcFactory_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseSvcFactory_funcmem_bld(&__cool__DatabaseSvcFactory_db_funcmem);
void __cool__DatabaseSvcFactory_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseSvcFactory"), typeid(::cool::DatabaseSvcFactory), sizeof(::cool::DatabaseSvcFactory), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseSvcFactory"), destructor_8478, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10291, type_10292), Reflex::Literal("operator="), operator_8479, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10292), Reflex::Literal("DatabaseSvcFactory"), constructor_8480, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DatabaseSvcFactory"), constructor_8481, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2366, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__DatabaseSvcFactory_funcmem_bld);
}

//------Delayed data member builder for class DatabaseSvcFactory -------------------
void __cool__DatabaseSvcFactory_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseSvcFactory -------------------
void __cool__DatabaseSvcFactory_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10259), Reflex::Literal("databaseService"), method_8482, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class InvalidChannelName -------------------------------
static  void operator_8484( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::InvalidChannelName*)o)->operator=)(*(const ::cool::InvalidChannelName*)arg[0]);
  else   (((::cool::InvalidChannelName*)o)->operator=)(*(const ::cool::InvalidChannelName*)arg[0]);
}

static void constructor_8485( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelName(*(const ::cool::InvalidChannelName*)arg[0]);
  else ::new(mem) ::cool::InvalidChannelName(*(const ::cool::InvalidChannelName*)arg[0]);
}

static void constructor_8486( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelName(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::InvalidChannelName(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8487( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::InvalidChannelName(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::InvalidChannelName(*(const ::std::string*)arg[0]);
}

static void destructor_8488(void*, void * o, const std::vector<void*>&, void *) {
((::cool::InvalidChannelName*)o)->::cool::InvalidChannelName::~InvalidChannelName();
}
static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelName,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::InvalidChannelName,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class InvalidChannelName -------------------------------
void __cool__InvalidChannelName_db_datamem(Reflex::Class*);
void __cool__InvalidChannelName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelName_datamem_bld(&__cool__InvalidChannelName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__InvalidChannelName_funcmem_bld(&__cool__InvalidChannelName_db_funcmem);
void __cool__InvalidChannelName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::InvalidChannelName"), typeid(::cool::InvalidChannelName), sizeof(::cool::InvalidChannelName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::InvalidChannelName, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10293, type_10294), Reflex::Literal("operator="), operator_8484, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10294), Reflex::Literal("InvalidChannelName"), constructor_8485, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_869, type_4135), Reflex::Literal("InvalidChannelName"), constructor_8486, 0, "size;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135), Reflex::Literal("InvalidChannelName"), constructor_8487, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InvalidChannelName"), destructor_8488, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class InvalidChannelName -------------------
void __cool__InvalidChannelName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class InvalidChannelName -------------------
void __cool__InvalidChannelName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeBlobTooLong -------------------------------
static  void operator_8489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeBlobTooLong*)o)->operator=)(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
  else   (((::cool::StorageTypeBlobTooLong*)o)->operator=)(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
}

static void constructor_8490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
  else ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::cool::StorageTypeBlobTooLong*)arg[0]);
}

static void constructor_8491( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(long*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::cool::StorageTypeBlobTooLong(*(const ::std::string*)arg[0],
      *(const ::cool::StorageType*)arg[1],
      *(long*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void destructor_8492(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeBlobTooLong*)o)->::cool::StorageTypeBlobTooLong::~StorageTypeBlobTooLong();
}
static void method_x166( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeBlobTooLong -------------------------------
void __cool__StorageTypeBlobTooLong_db_datamem(Reflex::Class*);
void __cool__StorageTypeBlobTooLong_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeBlobTooLong_datamem_bld(&__cool__StorageTypeBlobTooLong_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeBlobTooLong_funcmem_bld(&__cool__StorageTypeBlobTooLong_db_funcmem);
void __cool__StorageTypeBlobTooLong_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeBlobTooLong"), typeid(::cool::StorageTypeBlobTooLong), sizeof(::cool::StorageTypeBlobTooLong), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2388, ::Reflex::BaseOffset< ::cool::StorageTypeBlobTooLong, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10295, type_10296), Reflex::Literal("operator="), operator_8489, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10296), Reflex::Literal("StorageTypeBlobTooLong"), constructor_8490, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_10138, type_124, type_4135), Reflex::Literal("StorageTypeBlobTooLong"), constructor_8491, 0, "expectedName;expectedStorageType;actualSize;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeBlobTooLong"), destructor_8492, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x166, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeBlobTooLong -------------------
void __cool__StorageTypeBlobTooLong_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeBlobTooLong -------------------
void __cool__StorageTypeBlobTooLong_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PayloadSpecificationInvalidFieldName -------------------------------
static  void operator_8493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationInvalidFieldName*)o)->operator=)(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
  else   (((::cool::PayloadSpecificationInvalidFieldName*)o)->operator=)(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
}

static void constructor_8494( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::cool::PayloadSpecificationInvalidFieldName*)arg[0]);
}

static void constructor_8495( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationInvalidFieldName(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8496(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationInvalidFieldName*)o)->::cool::PayloadSpecificationInvalidFieldName::~PayloadSpecificationInvalidFieldName();
}
static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationInvalidFieldName -------------------------------
void __cool__PayloadSpecificationInvalidFieldName_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationInvalidFieldName_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationInvalidFieldName_datamem_bld(&__cool__PayloadSpecificationInvalidFieldName_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationInvalidFieldName_funcmem_bld(&__cool__PayloadSpecificationInvalidFieldName_db_funcmem);
void __cool__PayloadSpecificationInvalidFieldName_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationInvalidFieldName"), typeid(::cool::PayloadSpecificationInvalidFieldName), sizeof(::cool::PayloadSpecificationInvalidFieldName), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2315, ::Reflex::BaseOffset< ::cool::PayloadSpecificationInvalidFieldName, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10297, type_10298), Reflex::Literal("operator="), operator_8493, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10298), Reflex::Literal("PayloadSpecificationInvalidFieldName"), constructor_8494, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("PayloadSpecificationInvalidFieldName"), constructor_8495, 0, "name;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationInvalidFieldName"), destructor_8496, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationInvalidFieldName -------------------
void __cool__PayloadSpecificationInvalidFieldName_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationInvalidFieldName -------------------
void __cool__PayloadSpecificationInvalidFieldName_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DatabaseOpenInReadOnlyMode -------------------------------
static  void operator_8498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::DatabaseOpenInReadOnlyMode*)o)->operator=)(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
  else   (((::cool::DatabaseOpenInReadOnlyMode*)o)->operator=)(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
}

static void constructor_8499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
  else ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::cool::DatabaseOpenInReadOnlyMode*)arg[0]);
}

static void constructor_8500( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::std::string*)arg[0]);
  else ::new(mem) ::cool::DatabaseOpenInReadOnlyMode(*(const ::std::string*)arg[0]);
}

static void destructor_8501(void*, void * o, const std::vector<void*>&, void *) {
((::cool::DatabaseOpenInReadOnlyMode*)o)->::cool::DatabaseOpenInReadOnlyMode::~DatabaseOpenInReadOnlyMode();
}
static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::DatabaseOpenInReadOnlyMode,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::DatabaseOpenInReadOnlyMode,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DatabaseOpenInReadOnlyMode -------------------------------
void __cool__DatabaseOpenInReadOnlyMode_db_datamem(Reflex::Class*);
void __cool__DatabaseOpenInReadOnlyMode_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__DatabaseOpenInReadOnlyMode_datamem_bld(&__cool__DatabaseOpenInReadOnlyMode_db_datamem);
Reflex::GenreflexMemberBuilder __cool__DatabaseOpenInReadOnlyMode_funcmem_bld(&__cool__DatabaseOpenInReadOnlyMode_db_funcmem);
void __cool__DatabaseOpenInReadOnlyMode_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::DatabaseOpenInReadOnlyMode"), typeid(::cool::DatabaseOpenInReadOnlyMode), sizeof(::cool::DatabaseOpenInReadOnlyMode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::DatabaseOpenInReadOnlyMode, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299, type_10300), Reflex::Literal("operator="), operator_8498, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10300), Reflex::Literal("DatabaseOpenInReadOnlyMode"), constructor_8499, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135), Reflex::Literal("DatabaseOpenInReadOnlyMode"), constructor_8500, 0, "domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DatabaseOpenInReadOnlyMode"), destructor_8501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DatabaseOpenInReadOnlyMode -------------------
void __cool__DatabaseOpenInReadOnlyMode_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DatabaseOpenInReadOnlyMode -------------------
void __cool__DatabaseOpenInReadOnlyMode_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeFloatIsNaN -------------------------------
static  void operator_8502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeFloatIsNaN*)o)->operator=)(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
  else   (((::cool::StorageTypeFloatIsNaN*)o)->operator=)(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
}

static void constructor_8503( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
  else ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::cool::StorageTypeFloatIsNaN*)arg[0]);
}

static void constructor_8504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::StorageTypeFloatIsNaN(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8505(void*, void * o, const std::vector<void*>&, void *) {
((::cool::StorageTypeFloatIsNaN*)o)->::cool::StorageTypeFloatIsNaN::~StorageTypeFloatIsNaN();
}
static void method_x169( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeInvalidValue")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::StorageTypeInvalidValue >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::RecordException >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::cool::Exception >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN,::std::exception >::Get(),::Reflex::PUBLIC), 4));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeFloatIsNaN -------------------------------
void __cool__StorageTypeFloatIsNaN_db_datamem(Reflex::Class*);
void __cool__StorageTypeFloatIsNaN_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeFloatIsNaN_datamem_bld(&__cool__StorageTypeFloatIsNaN_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeFloatIsNaN_funcmem_bld(&__cool__StorageTypeFloatIsNaN_db_funcmem);
void __cool__StorageTypeFloatIsNaN_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeFloatIsNaN"), typeid(::cool::StorageTypeFloatIsNaN), sizeof(::cool::StorageTypeFloatIsNaN), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2388, ::Reflex::BaseOffset< ::cool::StorageTypeFloatIsNaN, ::cool::StorageTypeInvalidValue >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10301, type_10302), Reflex::Literal("operator="), operator_8502, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10302), Reflex::Literal("StorageTypeFloatIsNaN"), constructor_8503, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("StorageTypeFloatIsNaN"), constructor_8504, 0, "expectedName;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StorageTypeFloatIsNaN"), destructor_8505, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x169, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeFloatIsNaN -------------------
void __cool__StorageTypeFloatIsNaN_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeFloatIsNaN -------------------
void __cool__StorageTypeFloatIsNaN_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class NodeNotFound -------------------------------
static  void operator_8506( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeNotFound*)o)->operator=)(*(const ::cool::NodeNotFound*)arg[0]);
  else   (((::cool::NodeNotFound*)o)->operator=)(*(const ::cool::NodeNotFound*)arg[0]);
}

static void constructor_8507( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeNotFound(*(const ::cool::NodeNotFound*)arg[0]);
  else ::new(mem) ::cool::NodeNotFound(*(const ::cool::NodeNotFound*)arg[0]);
}

static void constructor_8508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void constructor_8509( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeNotFound(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeNotFound(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8510(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeNotFound*)o)->::cool::NodeNotFound::~NodeNotFound();
}
static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeNotFound -------------------------------
void __cool__NodeNotFound_db_datamem(Reflex::Class*);
void __cool__NodeNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeNotFound_datamem_bld(&__cool__NodeNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeNotFound_funcmem_bld(&__cool__NodeNotFound_db_funcmem);
void __cool__NodeNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeNotFound"), typeid(::cool::NodeNotFound), sizeof(::cool::NodeNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::NodeNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10303, type_10304), Reflex::Literal("operator="), operator_8506, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10304), Reflex::Literal("NodeNotFound"), constructor_8507, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("NodeNotFound"), constructor_8508, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_4135), Reflex::Literal("NodeNotFound"), constructor_8509, 0, "nodeId;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeNotFound"), destructor_8510, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class NodeNotFound -------------------
void __cool__NodeNotFound_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class NodeNotFound -------------------
void __cool__NodeNotFound_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Application -------------------------------
static void constructor_8512( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Application();
  else ::new(mem) ::cool::Application();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Application((::coral::IConnectionService*)arg[0]);
  else ::new(mem) ::cool::Application((::coral::IConnectionService*)arg[0]);
  }
}

static void destructor_8513(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Application*)o)->::cool::Application::~Application();
}
static  void method_8514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Application*)o)->databaseService)();
  else   (((::cool::Application*)o)->databaseService)();
}

static  void method_8515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::cool::Application*)o)->outputLevel)());
  else   (((::cool::Application*)o)->outputLevel)();
}

static  void method_8516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::cool::Application*)o)->setOutputLevel)(*(::cool::MSG::Level*)arg[0]);
}

static  void method_8517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::Application*)o)->context)());
  else   (((const ::cool::Application*)o)->context)();
}

static  void method_8518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Application*)o)->connectionSvc)();
  else   (((const ::cool::Application*)o)->connectionSvc)();
}

static void constructor_x171( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Application();
  else ::new(mem) ::cool::Application();
}

static void method_newdel_2380( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::Application >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::Application >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::Application >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::Application >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::Application >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IApplication")), ::Reflex::BaseOffset< ::cool::Application,::cool::IApplication >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Application -------------------------------
void __cool__Application_db_datamem(Reflex::Class*);
void __cool__Application_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Application_datamem_bld(&__cool__Application_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Application_funcmem_bld(&__cool__Application_db_funcmem);
void __cool__Application_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Application"), typeid(::cool::Application), sizeof(::cool::Application), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2344, ::Reflex::BaseOffset< ::cool::Application, ::cool::IApplication >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10306), Reflex::Literal("Application"), constructor_8512, 0, "connSvc=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Application"), destructor_8513, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Application"), constructor_x171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2380, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Application_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Application_funcmem_bld);
}

//------Delayed data member builder for class Application -------------------
void __cool__Application_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10305, Reflex::Literal("m_application"), OffsetOf(__shadow__::__cool__Application, m_application), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Application -------------------
void __cool__Application_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10259), Reflex::Literal("databaseService"), method_8514, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8002), Reflex::Literal("outputLevel"), method_8515, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8002), Reflex::Literal("setOutputLevel"), method_8516, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10260), Reflex::Literal("context"), method_8517, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10261), Reflex::Literal("connectionSvc"), method_8518, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class NodeIsSingleVersion -------------------------------
static  void operator_8521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeIsSingleVersion*)o)->operator=)(*(const ::cool::NodeIsSingleVersion*)arg[0]);
  else   (((::cool::NodeIsSingleVersion*)o)->operator=)(*(const ::cool::NodeIsSingleVersion*)arg[0]);
}

static void constructor_8522( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeIsSingleVersion(*(const ::cool::NodeIsSingleVersion*)arg[0]);
  else ::new(mem) ::cool::NodeIsSingleVersion(*(const ::cool::NodeIsSingleVersion*)arg[0]);
}

static void constructor_8523( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeIsSingleVersion(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8524(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeIsSingleVersion*)o)->::cool::NodeIsSingleVersion::~NodeIsSingleVersion();
}
static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeIsSingleVersion,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeIsSingleVersion,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeIsSingleVersion -------------------------------
void __cool__NodeIsSingleVersion_db_datamem(Reflex::Class*);
void __cool__NodeIsSingleVersion_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeIsSingleVersion_datamem_bld(&__cool__NodeIsSingleVersion_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeIsSingleVersion_funcmem_bld(&__cool__NodeIsSingleVersion_db_funcmem);
void __cool__NodeIsSingleVersion_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeIsSingleVersion"), typeid(::cool::NodeIsSingleVersion), sizeof(::cool::NodeIsSingleVersion), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::NodeIsSingleVersion, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10309, type_10310), Reflex::Literal("operator="), operator_8521, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10310), Reflex::Literal("NodeIsSingleVersion"), constructor_8522, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("NodeIsSingleVersion"), constructor_8523, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeIsSingleVersion"), destructor_8524, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class NodeIsSingleVersion -------------------
void __cool__NodeIsSingleVersion_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class NodeIsSingleVersion -------------------
void __cool__NodeIsSingleVersion_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class NodeExists -------------------------------
static  void operator_8531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeExists*)o)->operator=)(*(const ::cool::NodeExists*)arg[0]);
  else   (((::cool::NodeExists*)o)->operator=)(*(const ::cool::NodeExists*)arg[0]);
}

static void constructor_8532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeExists(*(const ::cool::NodeExists*)arg[0]);
  else ::new(mem) ::cool::NodeExists(*(const ::cool::NodeExists*)arg[0]);
}

static void constructor_8533( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::NodeExists(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8534(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeExists*)o)->::cool::NodeExists::~NodeExists();
}
static void method_x175( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeExists,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeExists,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeExists -------------------------------
void __cool__NodeExists_db_datamem(Reflex::Class*);
void __cool__NodeExists_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeExists_datamem_bld(&__cool__NodeExists_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeExists_funcmem_bld(&__cool__NodeExists_db_funcmem);
void __cool__NodeExists_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeExists"), typeid(::cool::NodeExists), sizeof(::cool::NodeExists), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::NodeExists, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10316, type_10317), Reflex::Literal("operator="), operator_8531, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10317), Reflex::Literal("NodeExists"), constructor_8532, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("NodeExists"), constructor_8533, 0, "fullPath;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeExists"), destructor_8534, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x175, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class NodeExists -------------------
void __cool__NodeExists_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class NodeExists -------------------
void __cool__NodeExists_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class StorageTypeInvalidValue -------------------------------
static  void operator_8535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::StorageTypeInvalidValue*)o)->operator=)(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
  else   (((::cool::StorageTypeInvalidValue*)o)->operator=)(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
}

static void constructor_8536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::StorageTypeInvalidValue(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
  else ::new(mem) ::cool::StorageTypeInvalidValue(*(const ::cool::StorageTypeInvalidValue*)arg[0]);
}

static void method_x176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::StorageTypeException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::cool::StorageTypeException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::cool::RecordException >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StorageTypeInvalidValue -------------------------------
void __cool__StorageTypeInvalidValue_db_datamem(Reflex::Class*);
void __cool__StorageTypeInvalidValue_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidValue_datamem_bld(&__cool__StorageTypeInvalidValue_db_datamem);
Reflex::GenreflexMemberBuilder __cool__StorageTypeInvalidValue_funcmem_bld(&__cool__StorageTypeInvalidValue_db_funcmem);
void __cool__StorageTypeInvalidValue_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::StorageTypeInvalidValue"), typeid(::cool::StorageTypeInvalidValue), sizeof(::cool::StorageTypeInvalidValue), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2308, ::Reflex::BaseOffset< ::cool::StorageTypeInvalidValue, ::cool::StorageTypeException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10318, type_10319), Reflex::Literal("operator="), operator_8535, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10319), Reflex::Literal("StorageTypeInvalidValue"), constructor_8536, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class StorageTypeInvalidValue -------------------
void __cool__StorageTypeInvalidValue_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StorageTypeInvalidValue -------------------
void __cool__StorageTypeInvalidValue_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TagIsLocked -------------------------------
static  void operator_8568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::TagIsLocked*)o)->operator=)(*(const ::cool::TagIsLocked*)arg[0]);
  else   (((::cool::TagIsLocked*)o)->operator=)(*(const ::cool::TagIsLocked*)arg[0]);
}

static void constructor_8569( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagIsLocked(*(const ::cool::TagIsLocked*)arg[0]);
  else ::new(mem) ::cool::TagIsLocked(*(const ::cool::TagIsLocked*)arg[0]);
}

static void constructor_8570( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::TagIsLocked(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::TagIsLocked(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8571(void*, void * o, const std::vector<void*>&, void *) {
((::cool::TagIsLocked*)o)->::cool::TagIsLocked::~TagIsLocked();
}
static void method_x177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::TagIsLocked,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::TagIsLocked,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagIsLocked -------------------------------
void __cool__TagIsLocked_db_datamem(Reflex::Class*);
void __cool__TagIsLocked_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__TagIsLocked_datamem_bld(&__cool__TagIsLocked_db_datamem);
Reflex::GenreflexMemberBuilder __cool__TagIsLocked_funcmem_bld(&__cool__TagIsLocked_db_funcmem);
void __cool__TagIsLocked_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::TagIsLocked"), typeid(::cool::TagIsLocked), sizeof(::cool::TagIsLocked), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::TagIsLocked, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10324, type_10325), Reflex::Literal("operator="), operator_8568, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10325), Reflex::Literal("TagIsLocked"), constructor_8569, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("TagIsLocked"), constructor_8570, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagIsLocked"), destructor_8571, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class TagIsLocked -------------------
void __cool__TagIsLocked_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TagIsLocked -------------------
void __cool__TagIsLocked_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IRecordIterator -------------------------------
static void destructor_8574(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IRecordIterator*)o)->::cool::IRecordIterator::~IRecordIterator();
}
static  void method_8575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IRecordIterator*)o)->isEmpty)());
  else   (((::cool::IRecordIterator*)o)->isEmpty)();
}

static  void method_8576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::cool::IRecordIterator*)o)->goToNext)());
  else   (((::cool::IRecordIterator*)o)->goToNext)();
}

static  void method_8577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::IRecordIterator*)o)->currentRef)();
  else   (((::cool::IRecordIterator*)o)->currentRef)();
}

static  void method_8578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (cool::IRecordVectorPtr)((((::cool::IRecordIterator*)o)->fetchAllAsVector)());
  else   (((::cool::IRecordIterator*)o)->fetchAllAsVector)();
}

static  void method_8579( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::IRecordIterator*)o)->close)();
}

//------Dictionary for class IRecordIterator -------------------------------
void __cool__IRecordIterator_db_datamem(Reflex::Class*);
void __cool__IRecordIterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IRecordIterator_datamem_bld(&__cool__IRecordIterator_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IRecordIterator_funcmem_bld(&__cool__IRecordIterator_db_funcmem);
void __cool__IRecordIterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IRecordIterator"), typeid(::cool::IRecordIterator), sizeof(::cool::IRecordIterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRecordIterator"), destructor_8574, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IRecordIterator_funcmem_bld);
}

//------Delayed data member builder for class IRecordIterator -------------------
void __cool__IRecordIterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRecordIterator -------------------
void __cool__IRecordIterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isEmpty"), method_8575, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("goToNext"), method_8576, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8529), Reflex::Literal("currentRef"), method_8577, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2272c), Reflex::Literal("fetchAllAsVector"), method_8578, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("close"), method_8579, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class NodeRelationNotFound -------------------------------
static  void operator_8582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::NodeRelationNotFound*)o)->operator=)(*(const ::cool::NodeRelationNotFound*)arg[0]);
  else   (((::cool::NodeRelationNotFound*)o)->operator=)(*(const ::cool::NodeRelationNotFound*)arg[0]);
}

static void constructor_8583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeRelationNotFound(*(const ::cool::NodeRelationNotFound*)arg[0]);
  else ::new(mem) ::cool::NodeRelationNotFound(*(const ::cool::NodeRelationNotFound*)arg[0]);
}

static void constructor_8584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  else ::new(mem) ::cool::NodeRelationNotFound(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2],
      *(bool*)arg[3]);
  }
}

static void destructor_8585(void*, void * o, const std::vector<void*>&, void *) {
((::cool::NodeRelationNotFound*)o)->::cool::NodeRelationNotFound::~NodeRelationNotFound();
}
static  void method_8586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::NodeRelationNotFound*)o)->parentOnly)());
  else   (((const ::cool::NodeRelationNotFound*)o)->parentOnly)();
}

static void method_x178( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::NodeRelationNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::NodeRelationNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NodeRelationNotFound -------------------------------
void __cool__NodeRelationNotFound_db_datamem(Reflex::Class*);
void __cool__NodeRelationNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__NodeRelationNotFound_datamem_bld(&__cool__NodeRelationNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__NodeRelationNotFound_funcmem_bld(&__cool__NodeRelationNotFound_db_funcmem);
void __cool__NodeRelationNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::NodeRelationNotFound"), typeid(::cool::NodeRelationNotFound), sizeof(::cool::NodeRelationNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2402, ::Reflex::BaseOffset< ::cool::NodeRelationNotFound, ::cool::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10328, type_10329), Reflex::Literal("operator="), operator_8582, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10329), Reflex::Literal("NodeRelationNotFound"), constructor_8583, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_2367, type_4135, type_1881), Reflex::Literal("NodeRelationNotFound"), constructor_8584, 0, "ancestorNodeId;descendantNodeId;domain;parentOnly=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NodeRelationNotFound"), destructor_8585, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x178, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__NodeRelationNotFound_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__NodeRelationNotFound_funcmem_bld);
}

//------Delayed data member builder for class NodeRelationNotFound -------------------
void __cool__NodeRelationNotFound_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1881, Reflex::Literal("m_parentOnly"), OffsetOf(__shadow__::__cool__NodeRelationNotFound, m_parentOnly), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class NodeRelationNotFound -------------------
void __cool__NodeRelationNotFound_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("parentOnly"), method_8586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FolderNotFound -------------------------------
static  void operator_8588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderNotFound*)o)->operator=)(*(const ::cool::FolderNotFound*)arg[0]);
  else   (((::cool::FolderNotFound*)o)->operator=)(*(const ::cool::FolderNotFound*)arg[0]);
}

static void constructor_8589( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderNotFound(*(const ::cool::FolderNotFound*)arg[0]);
  else ::new(mem) ::cool::FolderNotFound(*(const ::cool::FolderNotFound*)arg[0]);
}

static void constructor_8590( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::cool::FolderNotFound(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(bool*)arg[2]);
  }
}

static void destructor_8591(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderNotFound*)o)->::cool::FolderNotFound::~FolderNotFound();
}
static  void method_8592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::FolderNotFound*)o)->isFolderSet)());
  else   (((const ::cool::FolderNotFound*)o)->isFolderSet)();
}

static void method_x179( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::NodeNotFound")), ::Reflex::BaseOffset< ::cool::FolderNotFound,::cool::NodeNotFound >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::FolderNotFound,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::FolderNotFound,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderNotFound -------------------------------
void __cool__FolderNotFound_db_datamem(Reflex::Class*);
void __cool__FolderNotFound_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderNotFound_datamem_bld(&__cool__FolderNotFound_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderNotFound_funcmem_bld(&__cool__FolderNotFound_db_funcmem);
void __cool__FolderNotFound_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderNotFound"), typeid(::cool::FolderNotFound), sizeof(::cool::FolderNotFound), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2379, ::Reflex::BaseOffset< ::cool::FolderNotFound, ::cool::NodeNotFound >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10330, type_10331), Reflex::Literal("operator="), operator_8588, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10331), Reflex::Literal("FolderNotFound"), constructor_8589, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135, type_1881), Reflex::Literal("FolderNotFound"), constructor_8590, 0, "fullPath;domain;isFolderSet=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderNotFound"), destructor_8591, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FolderNotFound_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FolderNotFound_funcmem_bld);
}

//------Delayed data member builder for class FolderNotFound -------------------
void __cool__FolderNotFound_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1881, Reflex::Literal("m_isFolderSet"), OffsetOf(__shadow__::__cool__FolderNotFound, m_isFolderSet), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FolderNotFound -------------------
void __cool__FolderNotFound_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isFolderSet"), method_8592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RecordSpecificationWrongSize -------------------------------
static  void operator_8593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::RecordSpecificationWrongSize*)o)->operator=)(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
  else   (((::cool::RecordSpecificationWrongSize*)o)->operator=)(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
}

static void constructor_8594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationWrongSize(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
  else ::new(mem) ::cool::RecordSpecificationWrongSize(*(const ::cool::RecordSpecificationWrongSize*)arg[0]);
}

static void constructor_8595( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::RecordSpecificationWrongSize(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::cool::RecordSpecificationWrongSize(*(::cool::UInt32*)arg[0],
      *(::cool::UInt32*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_8596(void*, void * o, const std::vector<void*>&, void *) {
((::cool::RecordSpecificationWrongSize*)o)->::cool::RecordSpecificationWrongSize::~RecordSpecificationWrongSize();
}
static void method_x180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::RecordException")), ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize,::cool::RecordException >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize,::cool::Exception >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize,::std::exception >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RecordSpecificationWrongSize -------------------------------
void __cool__RecordSpecificationWrongSize_db_datamem(Reflex::Class*);
void __cool__RecordSpecificationWrongSize_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationWrongSize_datamem_bld(&__cool__RecordSpecificationWrongSize_db_datamem);
Reflex::GenreflexMemberBuilder __cool__RecordSpecificationWrongSize_funcmem_bld(&__cool__RecordSpecificationWrongSize_db_funcmem);
void __cool__RecordSpecificationWrongSize_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::RecordSpecificationWrongSize"), typeid(::cool::RecordSpecificationWrongSize), sizeof(::cool::RecordSpecificationWrongSize), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2356, ::Reflex::BaseOffset< ::cool::RecordSpecificationWrongSize, ::cool::RecordException >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10332, type_10333), Reflex::Literal("operator="), operator_8593, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10333), Reflex::Literal("RecordSpecificationWrongSize"), constructor_8594, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_2367, type_4135), Reflex::Literal("RecordSpecificationWrongSize"), constructor_8595, 0, "expectedSize;actualSize;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RecordSpecificationWrongSize"), destructor_8596, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RecordSpecificationWrongSize -------------------
void __cool__RecordSpecificationWrongSize_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RecordSpecificationWrongSize -------------------
void __cool__RecordSpecificationWrongSize_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IFolderSpecification -------------------------------
static void destructor_8599(void*, void * o, const std::vector<void*>&, void *) {
((::cool::IFolderSpecification*)o)->::cool::IFolderSpecification::~IFolderSpecification();
}
static  void method_8600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSpecification*)o)->versioningMode)();
  else   (((const ::cool::IFolderSpecification*)o)->versioningMode)();
}

static  void method_8601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSpecification*)o)->payloadSpecification)();
  else   (((const ::cool::IFolderSpecification*)o)->payloadSpecification)();
}

static  void method_8602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::IFolderSpecification*)o)->payloadMode)();
  else   (((const ::cool::IFolderSpecification*)o)->payloadMode)();
}

static  void operator_8603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolderSpecification*)o)->operator==)(*(const ::cool::IFolderSpecification*)arg[0]));
  else   (((const ::cool::IFolderSpecification*)o)->operator==)(*(const ::cool::IFolderSpecification*)arg[0]);
}

static  void operator_8604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::IFolderSpecification*)o)->operator!=)(*(const ::cool::IFolderSpecification*)arg[0]));
  else   (((const ::cool::IFolderSpecification*)o)->operator!=)(*(const ::cool::IFolderSpecification*)arg[0]);
}

//------Dictionary for class IFolderSpecification -------------------------------
void __cool__IFolderSpecification_db_datamem(Reflex::Class*);
void __cool__IFolderSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__IFolderSpecification_datamem_bld(&__cool__IFolderSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__IFolderSpecification_funcmem_bld(&__cool__IFolderSpecification_db_funcmem);
void __cool__IFolderSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::IFolderSpecification"), typeid(::cool::IFolderSpecification), sizeof(::cool::IFolderSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IFolderSpecification"), destructor_8599, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__cool__IFolderSpecification_funcmem_bld);
}

//------Delayed data member builder for class IFolderSpecification -------------------
void __cool__IFolderSpecification_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IFolderSpecification -------------------
void __cool__IFolderSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10334), Reflex::Literal("versioningMode"), method_8600, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10133), Reflex::Literal("payloadSpecification"), method_8601, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10335), Reflex::Literal("payloadMode"), method_8602, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10282), Reflex::Literal("operator=="), operator_8603, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10282), Reflex::Literal("operator!="), operator_8604, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class Exception -------------------------------
static  void operator_8629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::Exception*)o)->operator=)(*(const ::cool::Exception*)arg[0]);
  else   (((::cool::Exception*)o)->operator=)(*(const ::cool::Exception*)arg[0]);
}

static void constructor_8630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Exception(*(const ::cool::Exception*)arg[0]);
  else ::new(mem) ::cool::Exception(*(const ::cool::Exception*)arg[0]);
}

static void constructor_8631( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::Exception(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::Exception(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8632(void*, void * o, const std::vector<void*>&, void *) {
((::cool::Exception*)o)->::cool::Exception::~Exception();
}
static  void method_8633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::cool::Exception*)o)->what)());
  else   (((const ::cool::Exception*)o)->what)();
}

static  void method_8634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::Exception*)o)->domain)();
  else   (((const ::cool::Exception*)o)->domain)();
}

static void method_x181( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::Exception,::std::exception >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Exception -------------------------------
void __cool__Exception_db_datamem(Reflex::Class*);
void __cool__Exception_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__Exception_datamem_bld(&__cool__Exception_db_datamem);
Reflex::GenreflexMemberBuilder __cool__Exception_funcmem_bld(&__cool__Exception_db_funcmem);
void __cool__Exception_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::Exception"), typeid(::cool::Exception), sizeof(::cool::Exception), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_1703, ::Reflex::BaseOffset< ::cool::Exception, ::std::exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10339, type_10340), Reflex::Literal("operator="), operator_8629, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10340), Reflex::Literal("Exception"), constructor_8630, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4135, type_4135), Reflex::Literal("Exception"), constructor_8631, 0, "message;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Exception"), destructor_8632, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__Exception_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__Exception_funcmem_bld);
}

//------Delayed data member builder for class Exception -------------------
void __cool__Exception_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1450, Reflex::Literal("m_message"), OffsetOf(__shadow__::__cool__Exception, m_message), ::Reflex::PRIVATE)
  .AddDataMember(type_1450, Reflex::Literal("m_domain"), OffsetOf(__shadow__::__cool__Exception, m_domain), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Exception -------------------
void __cool__Exception_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1841), Reflex::Literal("what"), method_8633, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4135), Reflex::Literal("domain"), method_8634, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PayloadSpecificationTooManyBlobFields -------------------------------
static  void operator_8636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationTooManyBlobFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
  else   (((::cool::PayloadSpecificationTooManyBlobFields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
}

static void constructor_8637( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(const ::cool::PayloadSpecificationTooManyBlobFields*)arg[0]);
}

static void constructor_8638( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyBlobFields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8639(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationTooManyBlobFields*)o)->::cool::PayloadSpecificationTooManyBlobFields::~PayloadSpecificationTooManyBlobFields();
}
static void method_x182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationTooManyBlobFields -------------------------------
void __cool__PayloadSpecificationTooManyBlobFields_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationTooManyBlobFields_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyBlobFields_datamem_bld(&__cool__PayloadSpecificationTooManyBlobFields_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyBlobFields_funcmem_bld(&__cool__PayloadSpecificationTooManyBlobFields_db_funcmem);
void __cool__PayloadSpecificationTooManyBlobFields_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyBlobFields"), typeid(::cool::PayloadSpecificationTooManyBlobFields), sizeof(::cool::PayloadSpecificationTooManyBlobFields), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2315, ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyBlobFields, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10341, type_10342), Reflex::Literal("operator="), operator_8636, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10342), Reflex::Literal("PayloadSpecificationTooManyBlobFields"), constructor_8637, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_4135), Reflex::Literal("PayloadSpecificationTooManyBlobFields"), constructor_8638, 0, "nBlobFields;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationTooManyBlobFields"), destructor_8639, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationTooManyBlobFields -------------------
void __cool__PayloadSpecificationTooManyBlobFields_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationTooManyBlobFields -------------------
void __cool__PayloadSpecificationTooManyBlobFields_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class FolderSpecification -------------------------------
static void destructor_8643(void*, void * o, const std::vector<void*>&, void *) {
((::cool::FolderSpecification*)o)->::cool::FolderSpecification::~FolderSpecification();
}
static void constructor_8644( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
  else ::new(mem) ::cool::FolderSpecification(*(const ::cool::IRecordSpecification*)arg[0]);
}

static void constructor_8645( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]);
  else ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(::cool::PayloadMode::Mode*)arg[2]);
  else ::new(mem) ::cool::FolderSpecification(*(::cool::FolderVersioning::Mode*)arg[0],
      *(const ::cool::IRecordSpecification*)arg[1],
      *(::cool::PayloadMode::Mode*)arg[2]);
  }
}

static void constructor_8646( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::FolderSpecification(*(const ::cool::FolderSpecification*)arg[0]);
  else ::new(mem) ::cool::FolderSpecification(*(const ::cool::FolderSpecification*)arg[0]);
}

static  void operator_8647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::FolderSpecification*)o)->operator=)(*(const ::cool::FolderSpecification*)arg[0]);
  else   (((::cool::FolderSpecification*)o)->operator=)(*(const ::cool::FolderSpecification*)arg[0]);
}

static  void method_8648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FolderSpecification*)o)->versioningMode)();
  else   (((const ::cool::FolderSpecification*)o)->versioningMode)();
}

static  void method_8649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FolderSpecification*)o)->payloadSpecification)();
  else   (((const ::cool::FolderSpecification*)o)->payloadSpecification)();
}

static  void method_8650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::cool::FolderSpecification*)o)->payloadMode)();
  else   (((const ::cool::FolderSpecification*)o)->payloadMode)();
}

static void method_x183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::IFolderSpecification")), ::Reflex::BaseOffset< ::cool::FolderSpecification,::cool::IFolderSpecification >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FolderSpecification -------------------------------
void __cool__FolderSpecification_db_datamem(Reflex::Class*);
void __cool__FolderSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__FolderSpecification_datamem_bld(&__cool__FolderSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __cool__FolderSpecification_funcmem_bld(&__cool__FolderSpecification_db_funcmem);
void __cool__FolderSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::FolderSpecification"), typeid(::cool::FolderSpecification), sizeof(::cool::FolderSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2397, ::Reflex::BaseOffset< ::cool::FolderSpecification, ::cool::IFolderSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FolderSpecification"), destructor_8643, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10133), Reflex::Literal("FolderSpecification"), constructor_8644, 0, "payloadSpecification", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8690, type_10133, type_8034), Reflex::Literal("FolderSpecification"), constructor_8645, 0, "mode;payloadSpecification;payloadMode=INLINEPAYLOAD", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10343), Reflex::Literal("FolderSpecification"), constructor_8646, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cool__FolderSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__cool__FolderSpecification_funcmem_bld);
}

//------Delayed data member builder for class FolderSpecification -------------------
void __cool__FolderSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8690, Reflex::Literal("m_versioningMode"), OffsetOf(__shadow__::__cool__FolderSpecification, m_versioningMode), ::Reflex::PRIVATE)
  .AddDataMember(type_2304, Reflex::Literal("m_payloadSpec"), OffsetOf(__shadow__::__cool__FolderSpecification, m_payloadSpec), ::Reflex::PRIVATE)
  .AddDataMember(type_8034, Reflex::Literal("m_payloadMode"), OffsetOf(__shadow__::__cool__FolderSpecification, m_payloadMode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FolderSpecification -------------------
void __cool__FolderSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10344, type_10343), Reflex::Literal("operator="), operator_8647, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10334), Reflex::Literal("versioningMode"), method_8648, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10133), Reflex::Literal("payloadSpecification"), method_8649, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10335), Reflex::Literal("payloadMode"), method_8650, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PayloadSpecificationTooManyString255Fields -------------------------------
static  void operator_8691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PayloadSpecificationTooManyString255Fields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
  else   (((::cool::PayloadSpecificationTooManyString255Fields*)o)->operator=)(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
}

static void constructor_8692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(const ::cool::PayloadSpecificationTooManyString255Fields*)arg[0]);
}

static void constructor_8693( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::cool::PayloadSpecificationTooManyString255Fields(*(::cool::UInt32*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_8694(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PayloadSpecificationTooManyString255Fields*)o)->::cool::PayloadSpecificationTooManyString255Fields::~PayloadSpecificationTooManyString255Fields();
}
static void method_x184( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidPayloadSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::cool::InvalidPayloadSpecification >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::InvalidFolderSpecification")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::cool::InvalidFolderSpecification >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("cool::Exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::cool::Exception >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields,::std::exception >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PayloadSpecificationTooManyString255Fields -------------------------------
void __cool__PayloadSpecificationTooManyString255Fields_db_datamem(Reflex::Class*);
void __cool__PayloadSpecificationTooManyString255Fields_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyString255Fields_datamem_bld(&__cool__PayloadSpecificationTooManyString255Fields_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PayloadSpecificationTooManyString255Fields_funcmem_bld(&__cool__PayloadSpecificationTooManyString255Fields_db_funcmem);
void __cool__PayloadSpecificationTooManyString255Fields_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PayloadSpecificationTooManyString255Fields"), typeid(::cool::PayloadSpecificationTooManyString255Fields), sizeof(::cool::PayloadSpecificationTooManyString255Fields), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddBase(type_2315, ::Reflex::BaseOffset< ::cool::PayloadSpecificationTooManyString255Fields, ::cool::InvalidPayloadSpecification >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10348, type_10349), Reflex::Literal("operator="), operator_8691, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10349), Reflex::Literal("PayloadSpecificationTooManyString255Fields"), constructor_8692, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367, type_4135), Reflex::Literal("PayloadSpecificationTooManyString255Fields"), constructor_8693, 0, "nString255Fields;domain", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PayloadSpecificationTooManyString255Fields"), destructor_8694, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x184, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PayloadSpecificationTooManyString255Fields -------------------
void __cool__PayloadSpecificationTooManyString255Fields_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PayloadSpecificationTooManyString255Fields -------------------
void __cool__PayloadSpecificationTooManyString255Fields_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class AttributeListSpecification -------------------------------
static void constructor_8715( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListSpecification();
  else ::new(mem) ::coral::AttributeListSpecification();
}

static void constructor_8716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListSpecification(*(const ::coral::AttributeListSpecification*)arg[0]);
  else ::new(mem) ::coral::AttributeListSpecification(*(const ::coral::AttributeListSpecification*)arg[0]);
}

static  void method_8717( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::coral::AttributeListSpecification*)o)->release)();
}

static  void method_8718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeListSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::type_info*)arg[1]);
}

static  void method_8719( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeListSpecification*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::coral::AttributeListSpecification*)o)->size)());
  else   (((const ::coral::AttributeListSpecification*)o)->size)();
}

static  void operator_8721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification*)o)->operator==)(*(const ::coral::AttributeListSpecification*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->operator==)(*(const ::coral::AttributeListSpecification*)arg[0]);
}

static  void operator_8722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification*)o)->operator!=)(*(const ::coral::AttributeListSpecification*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->operator!=)(*(const ::coral::AttributeListSpecification*)arg[0]);
}

static  void method_8723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void method_8724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::AttributeListSpecification*)o)->index)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::AttributeListSpecification*)o)->index)(*(const ::std::string*)arg[0]);
}

static  void operator_8725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeListSpecification*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::coral::AttributeListSpecification*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_8726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeListSpecification*)o)->specificationForAttribute)(*(int*)arg[0]);
  else   (((const ::coral::AttributeListSpecification*)o)->specificationForAttribute)(*(int*)arg[0]);
}

static  void method_8727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeListSpecification::const_iterator)((((const ::coral::AttributeListSpecification*)o)->begin)());
  else   (((const ::coral::AttributeListSpecification*)o)->begin)();
}

static  void method_8728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeListSpecification::const_iterator)((((const ::coral::AttributeListSpecification*)o)->end)());
  else   (((const ::coral::AttributeListSpecification*)o)->end)();
}

//------Dictionary for class AttributeListSpecification -------------------------------
void __coral__AttributeListSpecification_db_datamem(Reflex::Class*);
void __coral__AttributeListSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification_datamem_bld(&__coral__AttributeListSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification_funcmem_bld(&__coral__AttributeListSpecification_db_funcmem);
void __coral__AttributeListSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeListSpecification"), typeid(::coral::AttributeListSpecification), sizeof(::coral::AttributeListSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeListSpecification"), constructor_8715, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10363), Reflex::Literal("AttributeListSpecification"), constructor_8716, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__coral__AttributeListSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeListSpecification_funcmem_bld);
}

//------Delayed data member builder for class AttributeListSpecification -------------------
void __coral__AttributeListSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31, Reflex::Literal("m_counter"), OffsetOf(__shadow__::__coral__AttributeListSpecification, m_counter), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1406, Reflex::Literal("m_attributeSpecifications"), OffsetOf(__shadow__::__coral__AttributeListSpecification, m_attributeSpecifications), ::Reflex::PRIVATE)
  .AddDataMember(type_1625, Reflex::Literal("m_mapOfNameToIndex"), OffsetOf(__shadow__::__coral__AttributeListSpecification, m_mapOfNameToIndex), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class AttributeListSpecification -------------------
void __coral__AttributeListSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("release"), method_8717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_9791), Reflex::Literal("extend"), method_8718, 0, "name;type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135), Reflex::Literal("extend"), method_8719, 0, "name;typeName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_869), Reflex::Literal("size"), method_8720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10363), Reflex::Literal("operator=="), operator_8721, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10363), Reflex::Literal("operator!="), operator_8722, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("exists"), method_8723, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31, type_4135), Reflex::Literal("index"), method_8724, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10364, type_869), Reflex::Literal("operator[]"), operator_8725, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10364, type_31), Reflex::Literal("specificationForAttribute"), method_8726, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8711), Reflex::Literal("begin"), method_8727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8711), Reflex::Literal("end"), method_8728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class AttributeSpecification -------------------------------
static  void operator_8738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeSpecification*)o)->operator=)(*(const ::coral::AttributeSpecification*)arg[0]);
  else   (((::coral::AttributeSpecification*)o)->operator=)(*(const ::coral::AttributeSpecification*)arg[0]);
}

static  void method_8739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::coral::AttributeSpecification*)o)->name)());
  else   (((const ::coral::AttributeSpecification*)o)->name)();
}

static  void method_8740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeSpecification*)o)->type)();
  else   (((const ::coral::AttributeSpecification*)o)->type)();
}

static  void method_8741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::coral::AttributeSpecification*)o)->typeName)());
  else   (((const ::coral::AttributeSpecification*)o)->typeName)();
}

static  void operator_8742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeSpecification*)o)->operator==)(*(const ::coral::AttributeSpecification*)arg[0]));
  else   (((const ::coral::AttributeSpecification*)o)->operator==)(*(const ::coral::AttributeSpecification*)arg[0]);
}

static  void operator_8743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeSpecification*)o)->operator!=)(*(const ::coral::AttributeSpecification*)arg[0]));
  else   (((const ::coral::AttributeSpecification*)o)->operator!=)(*(const ::coral::AttributeSpecification*)arg[0]);
}

static  void method_8744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::coral::AttributeSpecification*)o)->typeNameForId)(*(const ::std::type_info*)arg[0]));
  else   (((::coral::AttributeSpecification*)o)->typeNameForId)(*(const ::std::type_info*)arg[0]);
}

static  void method_8745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::AttributeSpecification*)o)->typeIdForName)(*(const ::std::string*)arg[0]));
  else   (((::coral::AttributeSpecification*)o)->typeIdForName)(*(const ::std::string*)arg[0]);
}

//------Dictionary for class AttributeSpecification -------------------------------
void __coral__AttributeSpecification_db_datamem(Reflex::Class*);
void __coral__AttributeSpecification_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeSpecification_datamem_bld(&__coral__AttributeSpecification_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeSpecification_funcmem_bld(&__coral__AttributeSpecification_db_funcmem);
void __coral__AttributeSpecification_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeSpecification"), typeid(::coral::AttributeSpecification), sizeof(::coral::AttributeSpecification), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddOnDemandDataMemberBuilder(&__coral__AttributeSpecification_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeSpecification_funcmem_bld);
}

//------Delayed data member builder for class AttributeSpecification -------------------
void __coral__AttributeSpecification_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1450, Reflex::Literal("m_name"), OffsetOf(__shadow__::__coral__AttributeSpecification, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_9792, Reflex::Literal("m_type"), OffsetOf(__shadow__::__coral__AttributeSpecification, m_type), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class AttributeSpecification -------------------
void __coral__AttributeSpecification_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10366, type_10364), Reflex::Literal("operator="), operator_8738, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450), Reflex::Literal("name"), method_8739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9791), Reflex::Literal("type"), method_8740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450), Reflex::Literal("typeName"), method_8741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10364), Reflex::Literal("operator=="), operator_8742, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_10364), Reflex::Literal("operator!="), operator_8743, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1450, type_9791), Reflex::Literal("typeNameForId"), method_8744, 0, "type", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9792, type_4135), Reflex::Literal("typeIdForName"), method_8745, 0, "typeName", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IConnectionServiceConfiguration -------------------------------
static  void operator_8747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionServiceConfiguration*)o)->operator=)(*(const ::coral::IConnectionServiceConfiguration*)arg[0]);
  else   (((::coral::IConnectionServiceConfiguration*)o)->operator=)(*(const ::coral::IConnectionServiceConfiguration*)arg[0]);
}

static  void method_8750( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enableReplicaFailOver)();
}

static  void method_8751( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disableReplicaFailOver)();
}

static  void method_8752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isReplicaFailoverEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isReplicaFailoverEnabled)();
}

static  void method_8753( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enableConnectionSharing)();
}

static  void method_8754( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disableConnectionSharing)();
}

static  void method_8755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isConnectionSharingEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isConnectionSharingEnabled)();
}

static  void method_8756( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enableReadOnlySessionOnUpdateConnections)();
}

static  void method_8757( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disableReadOnlySessionOnUpdateConnections)();
}

static  void method_8758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isReadOnlySessionOnUpdateConnectionsEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isReadOnlySessionOnUpdateConnectionsEnabled)();
}

static  void method_8759( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setConnectionRetrialPeriod)(*(int*)arg[0]);
}

static  void method_8760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialPeriod)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialPeriod)();
}

static  void method_8761( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setConnectionRetrialTimeOut)(*(int*)arg[0]);
}

static  void method_8762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialTimeOut)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->connectionRetrialTimeOut)();
}

static  void method_8763( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setConnectionTimeOut)(*(int*)arg[0]);
}

static  void method_8764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->connectionTimeOut)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->connectionTimeOut)();
}

static  void method_8765( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->enablePoolAutomaticCleanUp)();
}

static  void method_8766( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->disablePoolAutomaticCleanUp)();
}

static  void method_8767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IConnectionServiceConfiguration*)o)->isPoolAutomaticCleanUpEnabled)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->isPoolAutomaticCleanUpEnabled)();
}

static  void method_8768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMissingConnectionExclusionTime)(*(int*)arg[0]);
}

static  void method_8769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->missingConnectionExclusionTime)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->missingConnectionExclusionTime)();
}

static  void method_8770( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMonitoringLevel)(*(::coral::monitor::Level*)arg[0]);
}

static  void method_8771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::IConnectionServiceConfiguration*)o)->monitoringLevel)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->monitoringLevel)();
}

static  void method_8772( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setAuthenticationService)(*(const ::std::string*)arg[0]);
}

static  void method_8773( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setLookupService)(*(const ::std::string*)arg[0]);
}

static  void method_8774( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setRelationalService)(*(const ::std::string*)arg[0]);
}

static  void method_8775( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMonitoringService)(*(const ::std::string*)arg[0]);
}

static  void method_8776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setAuthenticationService)(*(::coral::IAuthenticationService*)arg[0]);
}

static  void method_8777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setLookupService)(*(::coral::ILookupService*)arg[0]);
}

static  void method_8778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setRelationalService)(*(::coral::IRelationalService*)arg[0]);
}

static  void method_8779( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setMonitoringService)(*(::coral::monitor::IMonitoringService*)arg[0]);
}

static  void method_8780( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IConnectionServiceConfiguration*)o)->setReplicaSortingAlgorithm)(*(::coral::IReplicaSortingAlgorithm*)arg[0]);
}

static  void method_8781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->authenticationService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->authenticationService)();
}

static  void method_8782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->lookupService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->lookupService)();
}

static  void method_8783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->relationalService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->relationalService)();
}

static  void method_8784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionServiceConfiguration*)o)->monitoringService)();
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->monitoringService)();
}

static  void method_8785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::IConnectionServiceConfiguration*)o)->replicaSortingAlgorithm)());
  else   (((const ::coral::IConnectionServiceConfiguration*)o)->replicaSortingAlgorithm)();
}

//------Dictionary for class IConnectionServiceConfiguration -------------------------------
void __coral__IConnectionServiceConfiguration_db_datamem(Reflex::Class*);
void __coral__IConnectionServiceConfiguration_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IConnectionServiceConfiguration_datamem_bld(&__coral__IConnectionServiceConfiguration_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IConnectionServiceConfiguration_funcmem_bld(&__coral__IConnectionServiceConfiguration_db_funcmem);
void __coral__IConnectionServiceConfiguration_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IConnectionServiceConfiguration"), typeid(::coral::IConnectionServiceConfiguration), sizeof(::coral::IConnectionServiceConfiguration), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IConnectionServiceConfiguration")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10367, type_10368), Reflex::Literal("operator="), operator_8747, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IConnectionServiceConfiguration_funcmem_bld);
}

//------Delayed data member builder for class IConnectionServiceConfiguration -------------------
void __coral__IConnectionServiceConfiguration_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IConnectionServiceConfiguration -------------------
void __coral__IConnectionServiceConfiguration_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("enableReplicaFailOver"), method_8750, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("disableReplicaFailOver"), method_8751, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isReplicaFailoverEnabled"), method_8752, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("enableConnectionSharing"), method_8753, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("disableConnectionSharing"), method_8754, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isConnectionSharingEnabled"), method_8755, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("enableReadOnlySessionOnUpdateConnections"), method_8756, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("disableReadOnlySessionOnUpdateConnections"), method_8757, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isReadOnlySessionOnUpdateConnectionsEnabled"), method_8758, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_31), Reflex::Literal("setConnectionRetrialPeriod"), method_8759, 0, "timeInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("connectionRetrialPeriod"), method_8760, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_31), Reflex::Literal("setConnectionRetrialTimeOut"), method_8761, 0, "timeOutInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("connectionRetrialTimeOut"), method_8762, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_31), Reflex::Literal("setConnectionTimeOut"), method_8763, 0, "timeOutInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("connectionTimeOut"), method_8764, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("enablePoolAutomaticCleanUp"), method_8765, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("disablePoolAutomaticCleanUp"), method_8766, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isPoolAutomaticCleanUpEnabled"), method_8767, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_31), Reflex::Literal("setMissingConnectionExclusionTime"), method_8768, 0, "timeInSeconds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("missingConnectionExclusionTime"), method_8769, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8861), Reflex::Literal("setMonitoringLevel"), method_8770, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8861), Reflex::Literal("monitoringLevel"), method_8771, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1450c), Reflex::Literal("setAuthenticationService"), method_8772, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135), Reflex::Literal("setLookupService"), method_8773, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135), Reflex::Literal("setRelationalService"), method_8774, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135), Reflex::Literal("setMonitoringService"), method_8775, 0, "serviceName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10369), Reflex::Literal("setAuthenticationService"), method_8776, 0, "customAuthenticationService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10370), Reflex::Literal("setLookupService"), method_8777, 0, "customLookupService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10371), Reflex::Literal("setRelationalService"), method_8778, 0, "customRelationalService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10372), Reflex::Literal("setMonitoringService"), method_8779, 0, "customMonitoringService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10373), Reflex::Literal("setReplicaSortingAlgorithm"), method_8780, 0, "algorithm", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10369), Reflex::Literal("authenticationService"), method_8781, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10370), Reflex::Literal("lookupService"), method_8782, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10371), Reflex::Literal("relationalService"), method_8783, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10372), Reflex::Literal("monitoringService"), method_8784, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10374), Reflex::Literal("replicaSortingAlgorithm"), method_8785, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class Attribute -------------------------------
static  void operator_8789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->operator=)(*(const ::coral::Attribute*)arg[0]);
  else   (((::coral::Attribute*)o)->operator=)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8790( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->fastCopy)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->specification)();
  else   (((const ::coral::Attribute*)o)->specification)();
}

static  void method_8840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValueFromAddress)((const void*)arg[0]);
}

static  void method_8841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::coral::Attribute*)o)->copyValueToAddress)((void*)arg[0]);
}

static  void method_8842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::Attribute*)o)->addressOfData)());
  else   (((::coral::Attribute*)o)->addressOfData)();
}

static  void method_8843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::Attribute*)o)->addressOfData)());
  else   (((const ::coral::Attribute*)o)->addressOfData)();
}

static  void method_8844( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->shareData)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8845( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->bindUnsafely)((const void*)arg[0]);
}

static  void method_8846( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->bindUnsafely)((void*)arg[0]);
}

static  void method_8847( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::coral::Attribute*)o)->setNull)();
  }
  else if ( arg.size() == 1 ) { 
    (((::coral::Attribute*)o)->setNull)(*(bool*)arg[0]);
  }
}

static  void method_8848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->isNull)());
  else   (((const ::coral::Attribute*)o)->isNull)();
}

static  void method_8849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::coral::Attribute*)o)->size)());
  else   (((const ::coral::Attribute*)o)->size)();
}

static  void operator_8850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->operator==)(*(const ::coral::Attribute*)arg[0]));
  else   (((const ::coral::Attribute*)o)->operator==)(*(const ::coral::Attribute*)arg[0]);
}

static  void operator_8851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->operator!=)(*(const ::coral::Attribute*)arg[0]));
  else   (((const ::coral::Attribute*)o)->operator!=)(*(const ::coral::Attribute*)arg[0]);
}

static  void method_8852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
    else     (((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0],
      *(bool*)arg[1]);
    else     (((const ::coral::Attribute*)o)->toOutputStream)(*(::std::ostream*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_8853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::Attribute*)o)->isValidData)());
  else   (((const ::coral::Attribute*)o)->isValidData)();
}

static  void method_8792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<coral::Blob>)();
  else   (((::coral::Attribute*)o)->data<coral::Blob>)();
}

static  void method_8793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<std::string>)();
  else   (((::coral::Attribute*)o)->data<std::string>)();
}

static  void method_8794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<long double>)();
  else   (((::coral::Attribute*)o)->data<long double>)();
}

static  void method_8795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<double>)();
  else   (((::coral::Attribute*)o)->data<double>)();
}

static  void method_8796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<float>)();
  else   (((::coral::Attribute*)o)->data<float>)();
}

static  void method_8797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned long long>)();
  else   (((::coral::Attribute*)o)->data<unsigned long long>)();
}

static  void method_8798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<long long>)();
  else   (((::coral::Attribute*)o)->data<long long>)();
}

static  void method_8799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned long>)();
  else   (((::coral::Attribute*)o)->data<unsigned long>)();
}

static  void method_8800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<long>)();
  else   (((::coral::Attribute*)o)->data<long>)();
}

static  void method_8801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned int>)();
  else   (((::coral::Attribute*)o)->data<unsigned int>)();
}

static  void method_8802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<int>)();
  else   (((::coral::Attribute*)o)->data<int>)();
}

static  void method_8803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned short>)();
  else   (((::coral::Attribute*)o)->data<unsigned short>)();
}

static  void method_8804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<short>)();
  else   (((::coral::Attribute*)o)->data<short>)();
}

static  void method_8805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<unsigned char>)();
  else   (((::coral::Attribute*)o)->data<unsigned char>)();
}

static  void method_8806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<char>)();
  else   (((::coral::Attribute*)o)->data<char>)();
}

static  void method_8807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::Attribute*)o)->data<bool>)();
  else   (((::coral::Attribute*)o)->data<bool>)();
}

static  void method_8808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<coral::Blob>)();
  else   (((const ::coral::Attribute*)o)->data<coral::Blob>)();
}

static  void method_8809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<std::string>)();
  else   (((const ::coral::Attribute*)o)->data<std::string>)();
}

static  void method_8810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<long double>)();
  else   (((const ::coral::Attribute*)o)->data<long double>)();
}

static  void method_8811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<double>)();
  else   (((const ::coral::Attribute*)o)->data<double>)();
}

static  void method_8812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<float>)();
  else   (((const ::coral::Attribute*)o)->data<float>)();
}

static  void method_8813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned long long>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned long long>)();
}

static  void method_8814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<long long>)();
  else   (((const ::coral::Attribute*)o)->data<long long>)();
}

static  void method_8815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned long>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned long>)();
}

static  void method_8816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<long>)();
  else   (((const ::coral::Attribute*)o)->data<long>)();
}

static  void method_8817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned int>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned int>)();
}

static  void method_8818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<int>)();
  else   (((const ::coral::Attribute*)o)->data<int>)();
}

static  void method_8819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned short>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned short>)();
}

static  void method_8820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<short>)();
  else   (((const ::coral::Attribute*)o)->data<short>)();
}

static  void method_8821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<unsigned char>)();
  else   (((const ::coral::Attribute*)o)->data<unsigned char>)();
}

static  void method_8822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<char>)();
  else   (((const ::coral::Attribute*)o)->data<char>)();
}

static  void method_8823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::Attribute*)o)->data<bool>)();
  else   (((const ::coral::Attribute*)o)->data<bool>)();
}

static  void method_8824( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<coral::Blob>)(*(const ::coral::Blob*)arg[0]);
}

static  void method_8825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<std::string>)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_8826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<long double>)(*(const long double*)arg[0]);
}

static  void method_8827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<double>)(*(const double*)arg[0]);
}

static  void method_8828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<float>)(*(const float*)arg[0]);
}

static  void method_8829( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned long long>)(*(const unsigned long long*)arg[0]);
}

static  void method_8830( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<long long>)(*(const long long*)arg[0]);
}

static  void method_8831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned long>)(*(const unsigned long*)arg[0]);
}

static  void method_8832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<long>)(*(const long*)arg[0]);
}

static  void method_8833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned int>)(*(const unsigned int*)arg[0]);
}

static  void method_8834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<int>)(*(const int*)arg[0]);
}

static  void method_8835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned short>)(*(const unsigned short*)arg[0]);
}

static  void method_8836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<short>)(*(const short*)arg[0]);
}

static  void method_8837( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<unsigned char>)(*(const unsigned char*)arg[0]);
}

static  void method_8838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<char>)(*(const char*)arg[0]);
}

static  void method_8839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::Attribute*)o)->setValue<bool>)(*(const bool*)arg[0]);
}

//------Dictionary for class Attribute -------------------------------
void __coral__Attribute_db_datamem(Reflex::Class*);
void __coral__Attribute_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__Attribute_datamem_bld(&__coral__Attribute_db_datamem);
Reflex::GenreflexMemberBuilder __coral__Attribute_funcmem_bld(&__coral__Attribute_db_funcmem);
void __coral__Attribute_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::Attribute"), typeid(::coral::Attribute), sizeof(::coral::Attribute), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddOnDemandDataMemberBuilder(&__coral__Attribute_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__Attribute_funcmem_bld);
}

//------Delayed data member builder for class Attribute -------------------
void __coral__Attribute_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10375, Reflex::Literal("m_specification"), OffsetOf(__shadow__::__coral__Attribute, m_specification), ::Reflex::PRIVATE)
  .AddDataMember(type_10376, Reflex::Literal("m_data"), OffsetOf(__shadow__::__coral__Attribute, m_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Attribute -------------------
void __coral__Attribute_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10377, type_8914), Reflex::Literal("operator="), operator_8789, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8914), Reflex::Literal("fastCopy"), method_8790, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10364), Reflex::Literal("specification"), method_8791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2021), Reflex::Literal("setValueFromAddress"), method_8840, 0, "externalAddress", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_185), Reflex::Literal("copyValueToAddress"), method_8841, 0, "externalAddress", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("addressOfData"), method_8842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("addressOfData"), method_8843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8914), Reflex::Literal("shareData"), method_8844, 0, "sourceAttribute", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_2021), Reflex::Literal("bindUnsafely"), method_8845, 0, "externalAddress", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_185), Reflex::Literal("bindUnsafely"), method_8846, 0, "externalAddress", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_1881), Reflex::Literal("setNull"), method_8847, 0, "isVariableNull=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isNull"), method_8848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("size"), method_8849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8914), Reflex::Literal("operator=="), operator_8850, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8914), Reflex::Literal("operator!="), operator_8851, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525, type_1881), Reflex::Literal("toOutputStream"), method_8852, 0, "os;valueOnly=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isValidData"), method_8853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10257), Reflex::Literal("data<coral::Blob>"), method_8792, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("data<std::string>"), method_8793, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4624), Reflex::Literal("data<long double>"), method_8794, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4625), Reflex::Literal("data<double>"), method_8795, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4626), Reflex::Literal("data<float>"), method_8796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9239), Reflex::Literal("data<unsigned long long>"), method_8797, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9238), Reflex::Literal("data<long long>"), method_8798, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9237), Reflex::Literal("data<unsigned long>"), method_8799, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9236), Reflex::Literal("data<long>"), method_8800, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3278), Reflex::Literal("data<unsigned int>"), method_8801, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9235), Reflex::Literal("data<int>"), method_8802, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9234), Reflex::Literal("data<unsigned short>"), method_8803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9233), Reflex::Literal("data<short>"), method_8804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5776), Reflex::Literal("data<unsigned char>"), method_8805, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3142), Reflex::Literal("data<char>"), method_8806, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4495), Reflex::Literal("data<bool>"), method_8807, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10125), Reflex::Literal("data<coral::Blob>"), method_8808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3213), Reflex::Literal("data<std::string>"), method_8809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10378), Reflex::Literal("data<long double>"), method_8810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10126), Reflex::Literal("data<double>"), method_8811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10127), Reflex::Literal("data<float>"), method_8812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10128), Reflex::Literal("data<unsigned long long>"), method_8813, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10129), Reflex::Literal("data<long long>"), method_8814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10379), Reflex::Literal("data<unsigned long>"), method_8815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10380), Reflex::Literal("data<long>"), method_8816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3280), Reflex::Literal("data<unsigned int>"), method_8817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6021), Reflex::Literal("data<int>"), method_8818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10130), Reflex::Literal("data<unsigned short>"), method_8819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10131), Reflex::Literal("data<short>"), method_8820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10132), Reflex::Literal("data<unsigned char>"), method_8821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3993), Reflex::Literal("data<char>"), method_8822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6020), Reflex::Literal("data<bool>"), method_8823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10125), Reflex::Literal("setValue<coral::Blob>"), method_8824, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3213), Reflex::Literal("setValue<std::string>"), method_8825, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10378), Reflex::Literal("setValue<long double>"), method_8826, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10126), Reflex::Literal("setValue<double>"), method_8827, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10127), Reflex::Literal("setValue<float>"), method_8828, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10128), Reflex::Literal("setValue<unsigned long long>"), method_8829, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10129), Reflex::Literal("setValue<long long>"), method_8830, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10379), Reflex::Literal("setValue<unsigned long>"), method_8831, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10380), Reflex::Literal("setValue<long>"), method_8832, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3280), Reflex::Literal("setValue<unsigned int>"), method_8833, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_6021), Reflex::Literal("setValue<int>"), method_8834, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10130), Reflex::Literal("setValue<unsigned short>"), method_8835, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10131), Reflex::Literal("setValue<short>"), method_8836, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_10132), Reflex::Literal("setValue<unsigned char>"), method_8837, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_3993), Reflex::Literal("setValue<char>"), method_8838, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_6020), Reflex::Literal("setValue<bool>"), method_8839, 0, "value", ::Reflex::PUBLIC);
}
//------Stub functions for class AttributeList -------------------------------
static void constructor_8869( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList();
  else ::new(mem) ::coral::AttributeList();
}

static void constructor_8870( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0]);
  else ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeListSpecification*)arg[0],
      *(bool*)arg[1]);
  }
}

static void constructor_8871( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeList*)arg[0]);
  else ::new(mem) ::coral::AttributeList(*(const ::coral::AttributeList*)arg[0]);
}

static void destructor_8872(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeList*)o)->::coral::AttributeList::~AttributeList();
}
static  void operator_8873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->operator=)(*(const ::coral::AttributeList*)arg[0]);
  else   (((::coral::AttributeList*)o)->operator=)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8874( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->copyData)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->fastCopyData)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->specification)();
  else   (((const ::coral::AttributeList*)o)->specification)();
}

static  void method_8877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::AttributeList*)o)->extend)(*(const ::std::string*)arg[0],
    *(const ::std::type_info*)arg[1]);
}

static  void method_8879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::coral::AttributeList*)o)->size)());
  else   (((const ::coral::AttributeList*)o)->size)();
}

static  void operator_8880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList*)o)->operator==)(*(const ::coral::AttributeList*)arg[0]));
  else   (((const ::coral::AttributeList*)o)->operator==)(*(const ::coral::AttributeList*)arg[0]);
}

static  void operator_8881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList*)o)->operator!=)(*(const ::coral::AttributeList*)arg[0]));
  else   (((const ::coral::AttributeList*)o)->operator!=)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::AttributeList*)o)->exists)(*(const ::std::string*)arg[0]);
}

static  void operator_8883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::coral::AttributeList*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_8885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_8886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::coral::AttributeList*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_8887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList*)o)->merge)(*(const ::coral::AttributeList*)arg[0]);
  else   (((::coral::AttributeList*)o)->merge)(*(const ::coral::AttributeList*)arg[0]);
}

static  void method_8888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
  else   (((const ::coral::AttributeList*)o)->toOutputStream)(*(::std::ostream*)arg[0]);
}

static  void method_8889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::iterator)((((::coral::AttributeList*)o)->begin)());
  else   (((::coral::AttributeList*)o)->begin)();
}

static  void method_8890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::iterator)((((::coral::AttributeList*)o)->end)());
  else   (((::coral::AttributeList*)o)->end)();
}

static  void method_8891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::const_iterator)((((const ::coral::AttributeList*)o)->begin)());
  else   (((const ::coral::AttributeList*)o)->begin)();
}

static  void method_8892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::AttributeList::const_iterator)((((const ::coral::AttributeList*)o)->end)());
  else   (((const ::coral::AttributeList*)o)->end)();
}

static void method_newdel_2452( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::AttributeList >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AttributeList -------------------------------
void __coral__AttributeList_db_datamem(Reflex::Class*);
void __coral__AttributeList_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList_datamem_bld(&__coral__AttributeList_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList_funcmem_bld(&__coral__AttributeList_db_funcmem);
void __coral__AttributeList_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList"), typeid(::coral::AttributeList), sizeof(::coral::AttributeList), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeList"), constructor_8869, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10363, type_1881), Reflex::Literal("AttributeList"), constructor_8870, 0, "spec;sharedSpecification=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8913), Reflex::Literal("AttributeList"), constructor_8871, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AttributeList"), destructor_8872, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2452, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__coral__AttributeList_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList_funcmem_bld);
}

//------Delayed data member builder for class AttributeList -------------------
void __coral__AttributeList_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10381, Reflex::Literal("m_specification"), OffsetOf(__shadow__::__coral__AttributeList, m_specification), ::Reflex::PRIVATE)
  .AddDataMember(type_1881, Reflex::Literal("m_ownSpecification"), OffsetOf(__shadow__::__coral__AttributeList, m_ownSpecification), ::Reflex::PRIVATE)
  .AddDataMember(type_1407, Reflex::Literal("m_data"), OffsetOf(__shadow__::__coral__AttributeList, m_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class AttributeList -------------------
void __coral__AttributeList_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10406, type_8913), Reflex::Literal("operator="), operator_8873, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8913), Reflex::Literal("copyData"), method_8874, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_8913), Reflex::Literal("fastCopyData"), method_8875, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10363), Reflex::Literal("specification"), method_8876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135), Reflex::Literal("extend"), method_8877, 0, "name;typeName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_9791), Reflex::Literal("extend"), method_8878, 0, "name;type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_869), Reflex::Literal("size"), method_8879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8913), Reflex::Literal("operator=="), operator_8880, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_8913), Reflex::Literal("operator!="), operator_8881, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("exists"), method_8882, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10377, type_1450c), Reflex::Literal("operator[]"), operator_8883, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8914, type_1450c), Reflex::Literal("operator[]"), operator_8884, 0, "name", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10377, type_80), Reflex::Literal("operator[]"), operator_8885, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8914, type_80), Reflex::Literal("operator[]"), operator_8886, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10406, type_8913), Reflex::Literal("merge"), method_8887, 0, "rhs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8525, type_8525), Reflex::Literal("toOutputStream"), method_8888, 0, "os", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8864), Reflex::Literal("begin"), method_8889, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8864), Reflex::Literal("end"), method_8890, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8863), Reflex::Literal("begin"), method_8891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8863), Reflex::Literal("end"), method_8892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IWebCacheInfo -------------------------------
static  void operator_8893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IWebCacheInfo*)o)->operator=)(*(const ::coral::IWebCacheInfo*)arg[0]);
  else   (((::coral::IWebCacheInfo*)o)->operator=)(*(const ::coral::IWebCacheInfo*)arg[0]);
}

static  void method_8896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IWebCacheInfo*)o)->isSchemaInfoCached)());
  else   (((const ::coral::IWebCacheInfo*)o)->isSchemaInfoCached)();
}

static  void method_8897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::IWebCacheInfo*)o)->isTableCached)(*(const ::std::string*)arg[0]));
  else   (((const ::coral::IWebCacheInfo*)o)->isTableCached)(*(const ::std::string*)arg[0]);
}

//------Dictionary for class IWebCacheInfo -------------------------------
void __coral__IWebCacheInfo_db_datamem(Reflex::Class*);
void __coral__IWebCacheInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IWebCacheInfo_datamem_bld(&__coral__IWebCacheInfo_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IWebCacheInfo_funcmem_bld(&__coral__IWebCacheInfo_db_funcmem);
void __coral__IWebCacheInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IWebCacheInfo"), typeid(::coral::IWebCacheInfo), sizeof(::coral::IWebCacheInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IWebCacheInfo")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10407, type_10408), Reflex::Literal("operator="), operator_8893, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IWebCacheInfo_funcmem_bld);
}

//------Delayed data member builder for class IWebCacheInfo -------------------
void __coral__IWebCacheInfo_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IWebCacheInfo -------------------
void __coral__IWebCacheInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("isSchemaInfoCached"), method_8896, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_4135), Reflex::Literal("isTableCached"), method_8897, 0, "tableName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IWebCacheControl -------------------------------
static  void operator_8899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IWebCacheControl*)o)->operator=)(*(const ::coral::IWebCacheControl*)arg[0]);
  else   (((::coral::IWebCacheControl*)o)->operator=)(*(const ::coral::IWebCacheControl*)arg[0]);
}

static  void method_8902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->refreshSchemaInfo)(*(const ::std::string*)arg[0]);
}

static  void method_8903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->refreshTable)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IWebCacheControl*)o)->webCacheInfo)(*(const ::std::string*)arg[0]);
  else   (((const ::coral::IWebCacheControl*)o)->webCacheInfo)(*(const ::std::string*)arg[0]);
}

static  void method_8905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::coral::IWebCacheControl*)o)->compressionLevel)());
  else   (((::coral::IWebCacheControl*)o)->compressionLevel)();
}

static  void method_8906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->setCompressionLevel)(*(int*)arg[0]);
}

static  void method_8907( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::coral::IWebCacheControl*)o)->setProxyList)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

//------Dictionary for class IWebCacheControl -------------------------------
void __coral__IWebCacheControl_db_datamem(Reflex::Class*);
void __coral__IWebCacheControl_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IWebCacheControl_datamem_bld(&__coral__IWebCacheControl_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IWebCacheControl_funcmem_bld(&__coral__IWebCacheControl_db_funcmem);
void __coral__IWebCacheControl_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IWebCacheControl"), typeid(::coral::IWebCacheControl), sizeof(::coral::IWebCacheControl), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IWebCacheControl")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10409, type_10410), Reflex::Literal("operator="), operator_8899, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IWebCacheControl_funcmem_bld);
}

//------Delayed data member builder for class IWebCacheControl -------------------
void __coral__IWebCacheControl_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IWebCacheControl -------------------
void __coral__IWebCacheControl_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135), Reflex::Literal("refreshSchemaInfo"), method_8902, 0, "connection", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_4135, type_4135), Reflex::Literal("refreshTable"), method_8903, 0, "connection;tableName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10408, type_4135), Reflex::Literal("webCacheInfo"), method_8904, 0, "connection", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("compressionLevel"), method_8905, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_31), Reflex::Literal("setCompressionLevel"), method_8906, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_9302), Reflex::Literal("setProxyList"), method_8907, 0, "proxyList", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class AttributeListException -------------------------------
static  void operator_8909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeListException*)o)->operator=)(*(const ::coral::AttributeListException*)arg[0]);
  else   (((::coral::AttributeListException*)o)->operator=)(*(const ::coral::AttributeListException*)arg[0]);
}

static void constructor_8910( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException(*(const ::coral::AttributeListException*)arg[0]);
  else ::new(mem) ::coral::AttributeListException(*(const ::coral::AttributeListException*)arg[0]);
}

static void constructor_8911( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException();
  else ::new(mem) ::coral::AttributeListException();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException(*(::std::string*)arg[0]);
  else ::new(mem) ::coral::AttributeListException(*(::std::string*)arg[0]);
  }
}

static void destructor_8912(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeListException*)o)->::coral::AttributeListException::~AttributeListException();
}
static void constructor_x186( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListException();
  else ::new(mem) ::coral::AttributeListException();
}

static void method_newdel_2457( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::AttributeListException >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::Exception")), ::Reflex::BaseOffset< ::coral::AttributeListException,::coral::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::coral::AttributeListException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class AttributeListException -------------------------------
void __coral__AttributeListException_db_datamem(Reflex::Class*);
void __coral__AttributeListException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeListException_datamem_bld(&__coral__AttributeListException_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeListException_funcmem_bld(&__coral__AttributeListException_db_funcmem);
void __coral__AttributeListException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeListException"), typeid(::coral::AttributeListException), sizeof(::coral::AttributeListException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_2464, ::Reflex::BaseOffset< ::coral::AttributeListException, ::coral::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10411, type_10412), Reflex::Literal("operator="), operator_8909, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10412), Reflex::Literal("AttributeListException"), constructor_8910, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1450), Reflex::Literal("AttributeListException"), constructor_8911, 0, "errorMessage=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AttributeListException"), destructor_8912, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeListException"), constructor_x186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2457, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class AttributeListException -------------------
void __coral__AttributeListException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class AttributeListException -------------------
void __coral__AttributeListException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class AttributeException -------------------------------
static  void operator_8915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeException*)o)->operator=)(*(const ::coral::AttributeException*)arg[0]);
  else   (((::coral::AttributeException*)o)->operator=)(*(const ::coral::AttributeException*)arg[0]);
}

static void constructor_8916( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException(*(const ::coral::AttributeException*)arg[0]);
  else ::new(mem) ::coral::AttributeException(*(const ::coral::AttributeException*)arg[0]);
}

static void constructor_8917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException();
  else ::new(mem) ::coral::AttributeException();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException(*(::std::string*)arg[0]);
  else ::new(mem) ::coral::AttributeException(*(::std::string*)arg[0]);
  }
}

static void destructor_8918(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeException*)o)->::coral::AttributeException::~AttributeException();
}
static void constructor_x189( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeException();
  else ::new(mem) ::coral::AttributeException();
}

static void method_newdel_2461( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::coral::AttributeException >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::Exception")), ::Reflex::BaseOffset< ::coral::AttributeException,::coral::Exception >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::exception")), ::Reflex::BaseOffset< ::coral::AttributeException,::std::exception >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class AttributeException -------------------------------
void __coral__AttributeException_db_datamem(Reflex::Class*);
void __coral__AttributeException_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeException_datamem_bld(&__coral__AttributeException_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeException_funcmem_bld(&__coral__AttributeException_db_funcmem);
void __coral__AttributeException_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeException"), typeid(::coral::AttributeException), sizeof(::coral::AttributeException), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_2464, ::Reflex::BaseOffset< ::coral::AttributeException, ::coral::Exception >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10415, type_10416), Reflex::Literal("operator="), operator_8915, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10416), Reflex::Literal("AttributeException"), constructor_8916, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1450), Reflex::Literal("AttributeException"), constructor_8917, 0, "errorMessage=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AttributeException"), destructor_8918, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AttributeException"), constructor_x189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2461, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class AttributeException -------------------
void __coral__AttributeException_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class AttributeException -------------------
void __coral__AttributeException_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IConnectionService -------------------------------
static  void operator_8928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionService*)o)->operator=)(*(const ::coral::IConnectionService*)arg[0]);
  else   (((::coral::IConnectionService*)o)->operator=)(*(const ::coral::IConnectionService*)arg[0]);
}

static  void method_8931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(::coral::AccessMode*)arg[1]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(::coral::AccessMode*)arg[1]);
  }
}

static  void method_8932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::coral::AccessMode*)arg[2]));
    else     (((::coral::IConnectionService*)o)->connect)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::coral::AccessMode*)arg[2]);
  }
}

static  void method_8933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionService*)o)->configuration)();
  else   (((::coral::IConnectionService*)o)->configuration)();
}

static  void method_8934( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::IConnectionService*)o)->purgeConnectionPool)();
}

static  void method_8935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::IConnectionService*)o)->monitoringReporter)();
  else   (((const ::coral::IConnectionService*)o)->monitoringReporter)();
}

static  void method_8936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::IConnectionService*)o)->webCacheControl)();
  else   (((::coral::IConnectionService*)o)->webCacheControl)();
}

//------Dictionary for class IConnectionService -------------------------------
void __coral__IConnectionService_db_datamem(Reflex::Class*);
void __coral__IConnectionService_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__IConnectionService_datamem_bld(&__coral__IConnectionService_db_datamem);
Reflex::GenreflexMemberBuilder __coral__IConnectionService_funcmem_bld(&__coral__IConnectionService_db_funcmem);
void __coral__IConnectionService_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::IConnectionService"), typeid(::coral::IConnectionService), sizeof(::coral::IConnectionService), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::IConnectionService")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10261, type_10419), Reflex::Literal("operator="), operator_8928, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandFunctionMemberBuilder(&__coral__IConnectionService_funcmem_bld);
}

//------Delayed data member builder for class IConnectionService -------------------
void __coral__IConnectionService_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IConnectionService -------------------
void __coral__IConnectionService_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10420, type_4135, type_2443), Reflex::Literal("connect"), method_8931, 0, "connectionName;accessMode=Update", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10420, type_4135, type_4135, type_2443), Reflex::Literal("connect"), method_8932, 0, "connectionName;asRole;accessMode=Update", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10367), Reflex::Literal("configuration"), method_8933, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("purgeConnectionPool"), method_8934, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10421), Reflex::Literal("monitoringReporter"), method_8935, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10409), Reflex::Literal("webCacheControl"), method_8936, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class const_iterator -------------------------------
static void destructor_10354(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeListSpecification::const_iterator*)o)->::coral::AttributeListSpecification::const_iterator::~const_iterator();
}
static void constructor_10355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeListSpecification::const_iterator(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
  else ::new(mem) ::coral::AttributeListSpecification::const_iterator(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

static  void operator_10356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeListSpecification::const_iterator*)o)->operator=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
  else   (((::coral::AttributeListSpecification::const_iterator*)o)->operator=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

static  void operator_10358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::AttributeListSpecification::const_iterator*)o)->operator->)());
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator->)();
}

static  void operator_10359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeListSpecification::const_iterator*)o)->operator*)();
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator*)();
}

static  void operator_10360( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::AttributeListSpecification::const_iterator*)o)->operator++)();
}

static  void operator_10361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification::const_iterator*)o)->operator==)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]));
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator==)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

static  void operator_10362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeListSpecification::const_iterator*)o)->operator!=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]));
  else   (((const ::coral::AttributeListSpecification::const_iterator*)o)->operator!=)(*(const ::coral::AttributeListSpecification::const_iterator*)arg[0]);
}

//------Dictionary for class const_iterator -------------------------------
void __coral__AttributeListSpecification__const_iterator_db_datamem(Reflex::Class*);
void __coral__AttributeListSpecification__const_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification__const_iterator_datamem_bld(&__coral__AttributeListSpecification__const_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeListSpecification__const_iterator_funcmem_bld(&__coral__AttributeListSpecification__const_iterator_db_funcmem);
void __coral__AttributeListSpecification__const_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeListSpecification::const_iterator"), typeid(::coral::AttributeListSpecification::const_iterator), sizeof(::coral::AttributeListSpecification::const_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~const_iterator"), destructor_10354, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11439), Reflex::Literal("const_iterator"), constructor_10355, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__coral__AttributeListSpecification__const_iterator_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeListSpecification__const_iterator_funcmem_bld);
}

//------Delayed data member builder for class const_iterator -------------------
void __coral__AttributeListSpecification__const_iterator_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2141, Reflex::Literal("m_iterator"), OffsetOf(__shadow__::__coral__AttributeListSpecification__const_iterator, m_iterator), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class const_iterator -------------------
void __coral__AttributeListSpecification__const_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11440, type_11439), Reflex::Literal("operator="), operator_10356, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10375), Reflex::Literal("operator->"), operator_10358, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10364), Reflex::Literal("operator*"), operator_10359, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("operator++"), operator_10360, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_11439), Reflex::Literal("operator=="), operator_10361, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_11439), Reflex::Literal("operator!="), operator_10362, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class iterator_base -------------------------------
static  void operator_10387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList::iterator_base*)o)->operator==)(*(const ::coral::AttributeList::iterator_base*)arg[0]));
  else   (((const ::coral::AttributeList::iterator_base*)o)->operator==)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::coral::AttributeList::iterator_base*)o)->operator!=)(*(const ::coral::AttributeList::iterator_base*)arg[0]));
  else   (((const ::coral::AttributeList::iterator_base*)o)->operator!=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10389( void*, void* o, const std::vector<void*>&, void*)
{
  (((::coral::AttributeList::iterator_base*)o)->operator++)();
}

//------Dictionary for class iterator_base -------------------------------
void __coral__AttributeList__iterator_base_db_datamem(Reflex::Class*);
void __coral__AttributeList__iterator_base_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_base_datamem_bld(&__coral__AttributeList__iterator_base_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_base_funcmem_bld(&__coral__AttributeList__iterator_base_db_funcmem);
void __coral__AttributeList__iterator_base_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList::iterator_base"), typeid(::coral::AttributeList::iterator_base), sizeof(::coral::AttributeList::iterator_base), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddOnDemandDataMemberBuilder(&__coral__AttributeList__iterator_base_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList__iterator_base_funcmem_bld);
}

//------Delayed data member builder for class iterator_base -------------------
void __coral__AttributeList__iterator_base_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2144, Reflex::Literal("m_iterator"), OffsetOf(__shadow__::__coral__AttributeList__iterator_base, m_iterator), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class iterator_base -------------------
void __coral__AttributeList__iterator_base_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_11446), Reflex::Literal("operator=="), operator_10387, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_11446), Reflex::Literal("operator!="), operator_10388, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("operator++"), operator_10389, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class iterator -------------------------------
static  void operator_10390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator*)arg[0]);
  else   (((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator*)arg[0]);
}

static void constructor_10391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator*)arg[0]);
  else ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator*)arg[0]);
}

static void destructor_10392(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeList::iterator*)o)->::coral::AttributeList::iterator::~iterator();
}
static void constructor_10393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else ::new(mem) ::coral::AttributeList::iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else   (((::coral::AttributeList::iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::coral::AttributeList::iterator*)o)->operator->)());
  else   (((::coral::AttributeList::iterator*)o)->operator->)();
}

static  void operator_10397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::iterator*)o)->operator*)();
  else   (((::coral::AttributeList::iterator*)o)->operator*)();
}

static void method_x192( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator_base")), ::Reflex::BaseOffset< ::coral::AttributeList::iterator,::coral::AttributeList::iterator_base >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class iterator -------------------------------
void __coral__AttributeList__iterator_db_datamem(Reflex::Class*);
void __coral__AttributeList__iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_datamem_bld(&__coral__AttributeList__iterator_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList__iterator_funcmem_bld(&__coral__AttributeList__iterator_db_funcmem);
void __coral__AttributeList__iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList::iterator"), typeid(::coral::AttributeList::iterator), sizeof(::coral::AttributeList::iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_8868, ::Reflex::BaseOffset< ::coral::AttributeList::iterator, ::coral::AttributeList::iterator_base >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11448, type_11449), Reflex::Literal("operator="), operator_10390, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11449), Reflex::Literal("iterator"), constructor_10391, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_10392, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11446), Reflex::Literal("iterator"), constructor_10393, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x192, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList__iterator_funcmem_bld);
}

//------Delayed data member builder for class iterator -------------------
void __coral__AttributeList__iterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator -------------------
void __coral__AttributeList__iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11448, type_11446), Reflex::Literal("operator="), operator_10394, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3161), Reflex::Literal("operator->"), operator_10396, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10377), Reflex::Literal("operator*"), operator_10397, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class const_iterator -------------------------------
static  void operator_10398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::const_iterator*)arg[0]);
  else   (((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::const_iterator*)arg[0]);
}

static void constructor_10399( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::const_iterator*)arg[0]);
  else ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::const_iterator*)arg[0]);
}

static void destructor_10400(void*, void * o, const std::vector<void*>&, void *) {
((::coral::AttributeList::const_iterator*)o)->::coral::AttributeList::const_iterator::~const_iterator();
}
static void constructor_10401( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else ::new(mem) ::coral::AttributeList::const_iterator(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
  else   (((::coral::AttributeList::const_iterator*)o)->operator=)(*(const ::coral::AttributeList::iterator_base*)arg[0]);
}

static  void operator_10404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::coral::AttributeList::const_iterator*)o)->operator->)());
  else   (((const ::coral::AttributeList::const_iterator*)o)->operator->)();
}

static  void operator_10405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::coral::AttributeList::const_iterator*)o)->operator*)();
  else   (((const ::coral::AttributeList::const_iterator*)o)->operator*)();
}

static void method_x193( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("coral::AttributeList::iterator_base")), ::Reflex::BaseOffset< ::coral::AttributeList::const_iterator,::coral::AttributeList::iterator_base >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class const_iterator -------------------------------
void __coral__AttributeList__const_iterator_db_datamem(Reflex::Class*);
void __coral__AttributeList__const_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __coral__AttributeList__const_iterator_datamem_bld(&__coral__AttributeList__const_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __coral__AttributeList__const_iterator_funcmem_bld(&__coral__AttributeList__const_iterator_db_funcmem);
void __coral__AttributeList__const_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("coral::AttributeList::const_iterator"), typeid(::coral::AttributeList::const_iterator), sizeof(::coral::AttributeList::const_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "coral::*Attribute*")
  .AddBase(type_8868, ::Reflex::BaseOffset< ::coral::AttributeList::const_iterator, ::coral::AttributeList::iterator_base >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11450, type_11451), Reflex::Literal("operator="), operator_10398, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11451), Reflex::Literal("const_iterator"), constructor_10399, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~const_iterator"), destructor_10400, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11446), Reflex::Literal("const_iterator"), constructor_10401, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x193, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__coral__AttributeList__const_iterator_funcmem_bld);
}

//------Delayed data member builder for class const_iterator -------------------
void __coral__AttributeList__const_iterator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class const_iterator -------------------
void __coral__AttributeList__const_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11450, type_11446), Reflex::Literal("operator="), operator_10402, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11452), Reflex::Literal("operator->"), operator_10404, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8914), Reflex::Literal("operator*"), operator_10405, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class shared_count -------------------------------
static void constructor_10628( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count();
  else ::new(mem) ::boost::detail::shared_count();
}

static void destructor_10629(void*, void * o, const std::vector<void*>&, void *) {
((::boost::detail::shared_count*)o)->::boost::detail::shared_count::~shared_count();
}
static void constructor_10630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::shared_count*)arg[0]);
  else ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::shared_count*)arg[0]);
}

static void constructor_10631( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0]);
  else ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0]);
}

static void constructor_10632( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0],
      *(::boost::detail::sp_nothrow_tag*)arg[1]);
  else ::new(mem) ::boost::detail::shared_count(*(const ::boost::detail::weak_count*)arg[0],
      *(::boost::detail::sp_nothrow_tag*)arg[1]);
}

static  void operator_10633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::boost::detail::shared_count*)o)->operator=)(*(const ::boost::detail::shared_count*)arg[0]);
  else   (((::boost::detail::shared_count*)o)->operator=)(*(const ::boost::detail::shared_count*)arg[0]);
}

static  void method_10634( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::boost::detail::shared_count*)o)->swap)(*(::boost::detail::shared_count*)arg[0]);
}

static  void method_10635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::boost::detail::shared_count*)o)->use_count)());
  else   (((const ::boost::detail::shared_count*)o)->use_count)();
}

static  void method_10636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::detail::shared_count*)o)->unique)());
  else   (((const ::boost::detail::shared_count*)o)->unique)();
}

static  void method_10637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::boost::detail::shared_count*)o)->empty)());
  else   (((const ::boost::detail::shared_count*)o)->empty)();
}

static  void method_10638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::detail::shared_count*)o)->get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]));
  else   (((const ::boost::detail::shared_count*)o)->get_deleter)(*(const ::boost::detail::sp_typeinfo*)arg[0]);
}

static  void method_10639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::boost::detail::shared_count*)o)->get_untyped_deleter)());
  else   (((const ::boost::detail::shared_count*)o)->get_untyped_deleter)();
}

static void method_newdel_9031( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::boost::detail::shared_count >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class shared_count -------------------------------
void __boost__detail__shared_count_db_datamem(Reflex::Class*);
void __boost__detail__shared_count_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __boost__detail__shared_count_datamem_bld(&__boost__detail__shared_count_db_datamem);
Reflex::GenreflexMemberBuilder __boost__detail__shared_count_funcmem_bld(&__boost__detail__shared_count_db_funcmem);
void __boost__detail__shared_count_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("boost::detail::shared_count"), typeid(::boost::detail::shared_count), sizeof(::boost::detail::shared_count), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("shared_count"), constructor_10628, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~shared_count"), destructor_10629, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10641), Reflex::Literal("shared_count"), constructor_10630, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10640), Reflex::Literal("shared_count"), constructor_10631, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10640, type_9025), Reflex::Literal("shared_count"), constructor_10632, 0, "r;", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9031, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__boost__detail__shared_count_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__boost__detail__shared_count_funcmem_bld);
}

//------Delayed data member builder for class shared_count -------------------
void __boost__detail__shared_count_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5255, Reflex::Literal("pi_"), OffsetOf(__shadow__::__boost__detail__shared_count, pi_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class shared_count -------------------
void __boost__detail__shared_count_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11549, type_10641), Reflex::Literal("operator="), operator_10633, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969, type_11549), Reflex::Literal("swap"), method_10634, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_124), Reflex::Literal("use_count"), method_10635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("unique"), method_10636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("empty"), method_10637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185, type_10153), Reflex::Literal("get_deleter"), method_10638, 0, "ti", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_185), Reflex::Literal("get_untyped_deleter"), method_10639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Typedefs -------------------------------
static void destructor_11328(void*, void * o, const std::vector<void*>&, void *) {
((::cool::PyCool::Helpers::Typedefs*)o)->::cool::PyCool::Helpers::Typedefs::~Typedefs();
}
static  void operator_11329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cool::PyCool::Helpers::Typedefs*)o)->operator=)(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
  else   (((::cool::PyCool::Helpers::Typedefs*)o)->operator=)(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
}

static void constructor_11330( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PyCool::Helpers::Typedefs(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
  else ::new(mem) ::cool::PyCool::Helpers::Typedefs(*(const ::cool::PyCool::Helpers::Typedefs*)arg[0]);
}

static void constructor_11331( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cool::PyCool::Helpers::Typedefs();
  else ::new(mem) ::cool::PyCool::Helpers::Typedefs();
}

static  void method_11332( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_a__Bool)();
}

static  void method_11334( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_b__UChar)();
}

static  void method_11336( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_d__Int16)();
}

static  void method_11338( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_e__UInt16)();
}

static  void method_11340( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_f__Int32)();
}

static  void method_11342( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_g__UInt32)();
}

static  void method_11344( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_h__UInt63)();
}

static  void method_11346( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_i__Int64)();
}

static  void method_11348( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_j__UInt64)();
}

static  void method_11350( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_k__Float)();
}

static  void method_11352( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_l__Double)();
}

static  void method_11354( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_m__String255)();
}

static  void method_11356( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_n__String4k)();
}

static  void method_11358( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_o__String64k)();
}

static  void method_11360( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_p__String16M)();
}

static  void method_11362( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_q__Blob64k)();
}

static  void method_11364( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_r__Blob16M)();
}

static  void method_11366( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_s__ValidityKey)();
}

static  void method_11368( void*, void* o, const std::vector<void*>&, void*)
{
  (((::cool::PyCool::Helpers::Typedefs*)o)->type_id_t__ChannelId)();
}

static  void method_11333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiona<bool>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiona<bool>)();
}

static  void method_11335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned char)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionb<unsigned char>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionb<unsigned char>)();
}

static  void method_11337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiond<short>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiond<short>)();
}

static  void method_11339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functione<unsigned short>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functione<unsigned short>)();
}

static  void method_11341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionf<int>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionf<int>)();
}

static  void method_11343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiong<unsigned int>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiong<unsigned int>)();
}

static  void method_11345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionh<unsigned long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionh<unsigned long long>)();
}

static  void method_11347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functioni<long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functioni<long long>)();
}

static  void method_11349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionj<unsigned long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionj<unsigned long long>)();
}

static  void method_11351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionk<float>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionk<float>)();
}

static  void method_11353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionl<double>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionl<double>)();
}

static  void method_11355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionm<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionm<std::string>)();
}

static  void method_11357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionn<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionn<std::string>)();
}

static  void method_11359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiono<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiono<std::string>)();
}

static  void method_11361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionp<std::string>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionp<std::string>)();
}

static  void method_11363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::Blob)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionq<coral::Blob>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionq<coral::Blob>)();
}

static  void method_11365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (coral::Blob)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functionr<coral::Blob>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functionr<coral::Blob>)();
}

static  void method_11367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functions<unsigned long long>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functions<unsigned long long>)();
}

static  void method_11369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::cool::PyCool::Helpers::Typedefs*)o)->functiont<unsigned int>)());
  else   (((const ::cool::PyCool::Helpers::Typedefs*)o)->functiont<unsigned int>)();
}

static void method_newdel_10172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cool::PyCool::Helpers::Typedefs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Typedefs -------------------------------
void __cool__PyCool__Helpers__Typedefs_db_datamem(Reflex::Class*);
void __cool__PyCool__Helpers__Typedefs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cool__PyCool__Helpers__Typedefs_datamem_bld(&__cool__PyCool__Helpers__Typedefs_db_datamem);
Reflex::GenreflexMemberBuilder __cool__PyCool__Helpers__Typedefs_funcmem_bld(&__cool__PyCool__Helpers__Typedefs_db_funcmem);
void __cool__PyCool__Helpers__Typedefs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cool::PyCool::Helpers::Typedefs"), typeid(::cool::PyCool::Helpers::Typedefs), sizeof(::cool::PyCool::Helpers::Typedefs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "cool::*")
  .AddTypedef(type_2398, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Bool"))
  .AddTypedef(type_2279, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UChar"))
  .AddTypedef(type_2330, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Int16"))
  .AddTypedef(type_2332, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt16"))
  .AddTypedef(type_2350, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Int32"))
  .AddTypedef(type_2367, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt32"))
  .AddTypedef(type_2294, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt63"))
  .AddTypedef(type_2276, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Int64"))
  .AddTypedef(type_2372, Reflex::Literal("cool::PyCool::Helpers::Typedefs::UInt64"))
  .AddTypedef(type_2377, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Float"))
  .AddTypedef(type_2345, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Double"))
  .AddTypedef(type_2407, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String255"))
  .AddTypedef(type_2351, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String4k"))
  .AddTypedef(type_2311, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String64k"))
  .AddTypedef(type_2369, Reflex::Literal("cool::PyCool::Helpers::Typedefs::String16M"))
  .AddTypedef(type_2401, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob64k"))
  .AddTypedef(type_2343, Reflex::Literal("cool::PyCool::Helpers::Typedefs::Blob16M"))
  .AddTypedef(type_2348, Reflex::Literal("cool::PyCool::Helpers::Typedefs::ValidityKey"))
  .AddTypedef(type_2314, Reflex::Literal("cool::PyCool::Helpers::Typedefs::ChannelId"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Typedefs"), destructor_11328, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11689, type_11690), Reflex::Literal("operator="), operator_11329, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11690), Reflex::Literal("Typedefs"), constructor_11330, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Typedefs"), constructor_11331, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_10172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__cool__PyCool__Helpers__Typedefs_funcmem_bld);
}

//------Delayed data member builder for class Typedefs -------------------
void __cool__PyCool__Helpers__Typedefs_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Typedefs -------------------
void __cool__PyCool__Helpers__Typedefs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_a__Bool"), method_11332, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_b__UChar"), method_11334, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_d__Int16"), method_11336, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_e__UInt16"), method_11338, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_f__Int32"), method_11340, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_g__UInt32"), method_11342, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_h__UInt63"), method_11344, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_i__Int64"), method_11346, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_j__UInt64"), method_11348, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_k__Float"), method_11350, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_l__Double"), method_11352, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_m__String255"), method_11354, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_n__String4k"), method_11356, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_o__String64k"), method_11358, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_p__String16M"), method_11360, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_q__Blob64k"), method_11362, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_r__Blob16M"), method_11364, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_s__ValidityKey"), method_11366, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1969), Reflex::Literal("type_id_t__ChannelId"), method_11368, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("functiona<bool>"), method_11333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_140), Reflex::Literal("functionb<unsigned char>"), method_11335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_679), Reflex::Literal("functiond<short>"), method_11337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_269), Reflex::Literal("functione<unsigned short>"), method_11339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31), Reflex::Literal("functionf<int>"), method_11341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_80), Reflex::Literal("functiong<unsigned int>"), method_11343, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_114), Reflex::Literal("functionh<unsigned long long>"), method_11345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96), Reflex::Literal("functioni<long long>"), method_11347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_114), Reflex::Literal("functionj<unsigned long long>"), method_11349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1847), Reflex::Literal("functionk<float>"), method_11351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1840), Reflex::Literal("functionl<double>"), method_11353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1443), Reflex::Literal("functionm<std::string>"), method_11355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1443), Reflex::Literal("functionn<std::string>"), method_11357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1443), Reflex::Literal("functiono<std::string>"), method_11359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1443), Reflex::Literal("functionp<std::string>"), method_11361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2342), Reflex::Literal("functionq<coral::Blob>"), method_11363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2342), Reflex::Literal("functionr<coral::Blob>"), method_11365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_114), Reflex::Literal("functions<unsigned long long>"), method_11367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_80), Reflex::Literal("functiont<unsigned int>"), method_11369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void destructor_4388(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::~_Rb_tree_iterator();
}
static  void operator_4389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_4390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_4391( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
  else ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
}

static void constructor_4392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >((::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >((::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void operator_4393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
}

static  void operator_4394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)());
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)();
}

static  void operator_4395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
}

static  void operator_4396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_4397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
}

static  void operator_4398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_4399( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void operator_4400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void method_newdel_1477( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem);
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >"), typeid(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >), sizeof(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddTypedef(type_1428, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_4379, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::reference"))
  .AddTypedef(type_4381, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_1767, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::iterator_category"))
  .AddTypedef(type_1581, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_3982, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Base_ptr"))
  .AddTypedef(type_4386, Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Link_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Rb_tree_iterator"), destructor_4388, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9519, type_9520), Reflex::Literal("operator="), operator_4389, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9520), Reflex::Literal("_Rb_tree_iterator"), constructor_4390, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Rb_tree_iterator"), constructor_4391, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4386), Reflex::Literal("_Rb_tree_iterator"), constructor_4392, 0, "__x", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1477, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3982, Reflex::Literal("_M_node"), OffsetOf(__shadow__::__std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_, _M_node), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Rb_tree_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4379), Reflex::Literal("operator*"), operator_4393, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4381), Reflex::Literal("operator->"), operator_4394, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9519), Reflex::Literal("operator++"), operator_4395, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477, type_31), Reflex::Literal("operator++"), operator_4396, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9519), Reflex::Literal("operator--"), operator_4397, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477, type_31), Reflex::Literal("operator--"), operator_4398, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9520), Reflex::Literal("operator=="), operator_4399, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9520), Reflex::Literal("operator!="), operator_4400, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void destructor_5574(void*, void * o, const std::vector<void*>&, void *) {
((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::~_Rb_tree_const_iterator();
}
static  void operator_5575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_5576( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_5577( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >();
}

static void constructor_5578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >((const ::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >((const ::std::_Rb_tree_node<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void constructor_5579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void method_5580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->_M_const_cast)());
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->_M_const_cast)();
}

static  void operator_5581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator*)();
}

static  void operator_5582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)());
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator->)();
}

static  void operator_5583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)();
}

static  void operator_5584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_5585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)();
}

static  void operator_5586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_5587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator==)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void operator_5588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]));
  else   (((const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)o)->operator!=)(*(const ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static void method_newdel_1695( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem);
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >"), typeid(::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >), sizeof(::std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("rootmap"), "false")
  .AddTypedef(type_1428, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_4693, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::reference"))
  .AddTypedef(type_4690, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_1477, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_1767, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::iterator_category"))
  .AddTypedef(type_1581, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_4660, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Base_ptr"))
  .AddTypedef(type_4703, Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >::_Link_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Rb_tree_const_iterator"), destructor_5574, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9782, type_9783), Reflex::Literal("operator="), operator_5575, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9783), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5576, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5577, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4703), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5578, 0, "__x", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9520), Reflex::Literal("_Rb_tree_const_iterator"), constructor_5579, 0, "__it", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1695, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4660, Reflex::Literal("_M_node"), OffsetOf(__shadow__::__std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s_, _M_node), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class _Rb_tree_const_iterator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1477), Reflex::Literal("_M_const_cast"), method_5580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4693), Reflex::Literal("operator*"), operator_5581, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4690), Reflex::Literal("operator->"), operator_5582, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9782), Reflex::Literal("operator++"), operator_5583, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1695, type_31), Reflex::Literal("operator++"), operator_5584, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9782), Reflex::Literal("operator--"), operator_5585, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1695, type_31), Reflex::Literal("operator--"), operator_5586, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9783), Reflex::Literal("operator=="), operator_5587, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881, type_9783), Reflex::Literal("operator!="), operator_5588, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
static void function_10171( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned char)(cool::PyCool::Helpers::getBlobByte(*(::coral::Blob*)arg[0],
    *(long*)arg[1]));
  else cool::PyCool::Helpers::getBlobByte(*(::coral::Blob*)arg[0],
    *(long*)arg[1]);
}
static void function_10173( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IObjectPtr)(cool::PyCool::Helpers::IObjectPtr((::cool::IObject*)arg[0]));
  else cool::PyCool::Helpers::IObjectPtr((::cool::IObject*)arg[0]);
}
static void function_10174( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    cool::PyCool::Helpers::refreshDatabaseFromDbSvc((::cool::IDatabaseSvc*)arg[0],
      *(const ::cool::DatabaseId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    cool::PyCool::Helpers::refreshDatabaseFromDbSvc((::cool::IDatabaseSvc*)arg[0],
      *(const ::cool::DatabaseId*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_10175( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&cool::PyCool::Helpers::coolMinMax();
  else cool::PyCool::Helpers::coolMinMax();
}
static void function_10176( void*, void*, const std::vector<void*>& arg, void*)
{
  cool::PyCool::Helpers::setBlobByte(*(::coral::Blob*)arg[0],
    *(long*)arg[1],
    *(unsigned char*)arg[2]);
}
static void function_10177( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IRecordPtr)(cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecord*)arg[0]));
  else cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecord*)arg[0]);
}
static void function_10178( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (cool::IRecordPtr)(cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecordSpecification*)arg[0]));
  else cool::PyCool::Helpers::IRecordPtr(*(const ::cool::IRecordSpecification*)arg[0]);
}
static void function_10179( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    cool::PyCool::Helpers::refreshDatabaseFromDb((::cool::IDatabase*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    cool::PyCool::Helpers::refreshDatabaseFromDb((::cool::IDatabase*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_10180( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)(cool::PyCool::Helpers::toString(*(::cool::IRecord*)arg[0]));
  else cool::PyCool::Helpers::toString(*(::cool::IRecord*)arg[0]);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __cool__IRecord_dict(); 
      __std__iterator_traits_boost__shared_ptr_cool__IRecord_p__dict(); 
      __cool__IObject_dict(); 
      __std__iterator_traits_boost__shared_ptr_cool__IObject_p__dict(); 
      __std__iterator_traits_coral__AttributeSpecificationpsconstp__dict(); 
      __std__iterator_traits_coral__Attributepp__dict(); 
      __std__iterator_traits_coral__Attributepsconstp__dict(); 
      __std__basic_string_char__dict(); 
      __std__vector_std__basic_string_char_s__dict(); 
      __std__vector_unsignedsint__dict(); 
      __boost__shared_ptr_cool__IRecord__dict(); 
      __std__vector_boost__shared_ptr_cool__IRecord_s__dict(); 
      __boost__shared_ptr_cool__IObject__dict(); 
      __std__vector_boost__shared_ptr_cool__IObject_s__dict(); 
      __std__vector_cool__IFieldp__dict(); 
      __std__vector_cool__IRecordSelectionp__dict(); 
      __std__vector_cool__IFieldSpecificationp__dict(); 
      __cool__ChannelSelection_dict(); 
      __cool__ChannelSelection__ChannelRange_dict(); 
      __std__vector_cool__ChannelSelection__ChannelRange__dict(); 
      __std__vector_coral__AttributeSpecificationp__dict(); 
      __std__vector_coral__Attributep__dict(); 
      __std__allocator_boost__shared_ptr_cool__IRecord_s__dict(); 
      __std__allocator_boost__shared_ptr_cool__IObject_s__dict(); 
      __std__allocator_cool__IFieldp__dict(); 
      __std__allocator_cool__IRecordSelectionp__dict(); 
      __std__allocator_cool__IFieldSpecificationp__dict(); 
      __std__allocator_cool__ChannelSelection__ChannelRange__dict(); 
      __std__allocator_coral__AttributeSpecificationp__dict(); 
      __std__allocator_coral__Attributep__dict(); 
      __std__allocator_boost__shared_ptr_cool__IRecord_s___rebind_boost__shared_ptr_cool__IRecord_s__dict(); 
      __std__allocator_boost__shared_ptr_cool__IObject_s___rebind_boost__shared_ptr_cool__IObject_s__dict(); 
      __std__allocator_cool__IRecordSelectionp___rebind_cool__IRecordSelectionp__dict(); 
      __std__allocator_cool__IFieldp___rebind_cool__IFieldp__dict(); 
      __std__allocator_cool__IFieldSpecificationp___rebind_cool__IFieldSpecificationp__dict(); 
      __std__allocator_cool__ChannelSelection__ChannelRange___rebind_cool__ChannelSelection__ChannelRange__dict(); 
      __std__allocator_coral__AttributeSpecificationp___rebind_coral__AttributeSpecificationp__dict(); 
      __std__allocator_coral__Attributep___rebind_coral__Attributep__dict(); 
      __std__map_unsignedsint_std__basic_string_char_s__dict(); 
      __std___Vector_base_boost__shared_ptr_cool__IRecord__std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      __std___Vector_base_boost__shared_ptr_cool__IObject__std__allocator_boost__shared_ptr_cool__IObject_s_s__dict(); 
      __std___Vector_base_cool__IRecordSelectionp_std__allocator_cool__IRecordSelectionp_s__dict(); 
      __std___Vector_base_cool__IFieldp_std__allocator_cool__IFieldp_s__dict(); 
      __std___Vector_base_cool__IFieldSpecificationp_std__allocator_cool__IFieldSpecificationp_s__dict(); 
      __std___Vector_base_cool__ChannelSelection__ChannelRange_std__allocator_cool__ChannelSelection__ChannelRange_s__dict(); 
      __std___Vector_base_coral__AttributeSpecificationp_std__allocator_coral__AttributeSpecificationp_s__dict(); 
      __std___Vector_base_coral__Attributep_std__allocator_coral__Attributep_s__dict(); 
      __std__type_info_dict(); 
      __std____are_same_coral__AttributeSpecificationpsconstp_coral__AttributeSpecificationpp__dict(); 
      __std____are_same_coral__Attributepsconstp_coral__Attributepp__dict(); 
      __std____are_same_coral__Attributepp_coral__Attributepp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IRecord_s_s___rebind_boost__shared_ptr_cool__IRecord_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_boost__shared_ptr_cool__IObject_s_s___rebind_boost__shared_ptr_cool__IObject_s__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IRecordSelectionp_s___rebind_cool__IRecordSelectionp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldp_s___rebind_cool__IFieldp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__IFieldSpecificationp_s___rebind_cool__IFieldSpecificationp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_cool__ChannelSelection__ChannelRange_s___rebind_cool__ChannelSelection__ChannelRange__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__AttributeSpecificationp_s___rebind_coral__AttributeSpecificationp__dict(); 
      ____gnu_cxx____alloc_traits_std__allocator_coral__Attributep_s___rebind_coral__Attributep__dict(); 
      ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IRecord_s__dict(); 
      ____gnu_cxx__new_allocator_boost__shared_ptr_cool__IObject_s__dict(); 
      ____gnu_cxx__new_allocator_cool__IRecordSelectionp__dict(); 
      ____gnu_cxx__new_allocator_cool__IFieldp__dict(); 
      ____gnu_cxx__new_allocator_cool__IFieldSpecificationp__dict(); 
      ____gnu_cxx__new_allocator_cool__ChannelSelection__ChannelRange__dict(); 
      ____gnu_cxx__new_allocator_coral__AttributeSpecificationp__dict(); 
      ____gnu_cxx__new_allocator_coral__Attributep__dict(); 
      ____gnu_cxx____enable_if_false_std__vector_coral__AttributeSpecificationp_s__dict(); 
      ____gnu_cxx____enable_if_false_std__vector_coral__Attributep_s__dict(); 
      ____gnu_cxx____enable_if_true_std__vector_coral__Attributep_s__dict(); 
      ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IRecord_p_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      ____gnu_cxx____normal_iterator_boost__shared_ptr_cool__IObject_p_std__vector_boost__shared_ptr_cool__IObject_s_s__dict(); 
      ____gnu_cxx____normal_iterator_coral__AttributeSpecificationpsconstp_std__vector_coral__AttributeSpecificationp_s__dict(); 
      ____gnu_cxx____normal_iterator_coral__Attributepp_std__vector_coral__Attributep_s__dict(); 
      ____gnu_cxx____normal_iterator_coral__Attributepsconstp_std__vector_coral__Attributep_s__dict(); 
      __cool__IObjectIterator_dict(); 
      __cool__FieldSelection_dict(); 
      __cool__FieldSpecificationWrongStorageType_dict(); 
      __cool__TagNotFound_dict(); 
      __cool__PayloadSpecificationTooManyFields_dict(); 
      __cool__ChannelExists_dict(); 
      __cool__IField_dict(); 
      __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IRecord_s_s__dict(); 
      __cool__InvalidChannelRange_dict(); 
      __cool__StorageTypeStringTooLong_dict(); 
      __cool__IFolderSet_dict(); 
      __cool__CompositeSelection_dict(); 
      __cool__StorageType_dict(); 
      __cool__IRecordSpecification_dict(); 
      __boost__shared_ptr_cool__IObjectIterator__dict(); 
      __cool__RecordSpecificationUnknownField_dict(); 
      __cool__TagRelationNotFound_dict(); 
      __cool__FolderSetNotFound_dict(); 
      __cool__FieldWrongCppType_dict(); 
      __boost__shared_ptr_cool__IFolderSet__dict(); 
      __cool__FieldSpecificationWrongName_dict(); 
      __cool__RecordSpecification_dict(); 
      __cool__ObjectNotFound_dict(); 
      __cool__ChannelNotFound_dict(); 
      __cool__StorageTypeException_dict(); 
      __cool__StorageTypeWrongCppType_dict(); 
      __cool__Record_dict(); 
      __cool__ValidityKeyException_dict(); 
      __cool__FieldIsNull_dict(); 
      __cool__InvalidPayloadSpecification_dict(); 
      __cool__IFieldSpecification_dict(); 
      __cool__FolderIsSingleVersion_dict(); 
      __cool__ITime_dict(); 
      __cool__ConstRecordAdapter_dict(); 
      __cool__InvalidTagRelation_dict(); 
      __cool__DatabaseNotOpen_dict(); 
      __cool__DatabaseDoesNotExist_dict(); 
      __cool__IFolder_dict(); 
      __boost__shared_ptr_cool__IFolder__dict(); 
      __cool__ValidityIntervalBackwards_dict(); 
      __cool__Time_dict(); 
      __boost__shared_ptr_std__vector_boost__shared_ptr_cool__IObject_s_s__dict(); 
      __cool__IRecordSelection_dict(); 
      __cool__IDatabase_dict(); 
      __boost__shared_ptr_cool__IDatabase__dict(); 
      __cool__IHvsNode_dict(); 
      __cool__RecordSpecificationCannotExtend_dict(); 
      __coral__Blob_dict(); 
      __cool__IApplication_dict(); 
      __cool__IHvsNodeRecord_dict(); 
      __cool__TagExists_dict(); 
      __cool__IDatabaseSvc_dict(); 
      __cool__FieldSpecification_dict(); 
      __cool__RecordException_dict(); 
      __cool__ReservedHeadTag_dict(); 
      __cool__ValidityKeyOutOfBoundaries_dict(); 
      __cool__FieldSpecificationInvalidName_dict(); 
      __cool__StorageTypeDoubleIsNaN_dict(); 
      __cool__TagRelationExists_dict(); 
      __cool__InvalidFolderSpecification_dict(); 
      __cool__StorageTypeStringContainsNullChar_dict(); 
      __cool__StorageTypeInvalidUInt63_dict(); 
      __cool__DatabaseSvcFactory_dict(); 
      __cool__InvalidChannelName_dict(); 
      __cool__StorageTypeBlobTooLong_dict(); 
      __cool__PayloadSpecificationInvalidFieldName_dict(); 
      __cool__DatabaseOpenInReadOnlyMode_dict(); 
      __cool__StorageTypeFloatIsNaN_dict(); 
      __cool__NodeNotFound_dict(); 
      __cool__Application_dict(); 
      __cool__NodeIsSingleVersion_dict(); 
      __cool__NodeExists_dict(); 
      __cool__StorageTypeInvalidValue_dict(); 
      __cool__TagIsLocked_dict(); 
      __cool__IRecordIterator_dict(); 
      __cool__NodeRelationNotFound_dict(); 
      __cool__FolderNotFound_dict(); 
      __cool__RecordSpecificationWrongSize_dict(); 
      __cool__IFolderSpecification_dict(); 
      __cool__Exception_dict(); 
      __cool__PayloadSpecificationTooManyBlobFields_dict(); 
      __cool__FolderSpecification_dict(); 
      __cool__PayloadSpecificationTooManyString255Fields_dict(); 
      __coral__AttributeListSpecification_dict(); 
      __coral__AttributeSpecification_dict(); 
      __coral__IConnectionServiceConfiguration_dict(); 
      __coral__Attribute_dict(); 
      __coral__AttributeList_dict(); 
      __coral__IWebCacheInfo_dict(); 
      __coral__IWebCacheControl_dict(); 
      __coral__AttributeListException_dict(); 
      __coral__AttributeException_dict(); 
      __coral__IConnectionService_dict(); 
      __coral__AttributeListSpecification__const_iterator_dict(); 
      __coral__AttributeList__iterator_base_dict(); 
      __coral__AttributeList__iterator_dict(); 
      __coral__AttributeList__const_iterator_dict(); 
      __boost__detail__shared_count_dict(); 
      __cool__PyCool__Helpers__Typedefs_dict(); 
      __std___Rb_tree_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict(); 
      __std___Rb_tree_const_iterator_std__pair_constsunsignedsint_std__basic_string_char_s_s__dict(); 
      ::Reflex::Type t0 = ::Reflex::FunctionTypeBuilder(type_140, type_10257, type_124);      ::Reflex::FunctionBuilder(t0, Reflex::Literal("cool::PyCool::Helpers::getBlobByte"), function_10171, 0, Reflex::Literal("b;pos"), ::Reflex::PUBLIC);
      ::Reflex::Type t1 = ::Reflex::FunctionTypeBuilder(type_2291, type_10185);      ::Reflex::FunctionBuilder(t1, Reflex::Literal("cool::PyCool::Helpers::IObjectPtr"), function_10173, 0, Reflex::Literal("obj"), ::Reflex::PUBLIC);
      ::Reflex::Type t2 = ::Reflex::FunctionTypeBuilder(type_1969, type_11370, type_10268, type_1881);      ::Reflex::FunctionBuilder(t2, Reflex::Literal("cool::PyCool::Helpers::refreshDatabaseFromDbSvc"), function_10174, 0, Reflex::Literal("dbSvc;dbId;keepNodes=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t3 = ::Reflex::FunctionTypeBuilder(type_10209);      ::Reflex::FunctionBuilder(t3, Reflex::Literal("cool::PyCool::Helpers::coolMinMax"), function_10175, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t4 = ::Reflex::FunctionTypeBuilder(type_1969, type_10257, type_124, type_140);      ::Reflex::FunctionBuilder(t4, Reflex::Literal("cool::PyCool::Helpers::setBlobByte"), function_10176, 0, Reflex::Literal("b;pos;val"), ::Reflex::PUBLIC);
      ::Reflex::Type t5 = ::Reflex::FunctionTypeBuilder(type_2400, type_8529);      ::Reflex::FunctionBuilder(t5, Reflex::Literal("cool::PyCool::Helpers::IRecordPtr"), function_10177, 0, Reflex::Literal("rec"), ::Reflex::PUBLIC);
      ::Reflex::Type t6 = ::Reflex::FunctionTypeBuilder(type_2400, type_10133);      ::Reflex::FunctionBuilder(t6, Reflex::Literal("cool::PyCool::Helpers::IRecordPtr"), function_10178, 0, Reflex::Literal("spec"), ::Reflex::PUBLIC);
      ::Reflex::Type t7 = ::Reflex::FunctionTypeBuilder(type_1969, type_10246, type_1881);      ::Reflex::FunctionBuilder(t7, Reflex::Literal("cool::PyCool::Helpers::refreshDatabaseFromDb"), function_10179, 0, Reflex::Literal("db;keepNodes=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t8 = ::Reflex::FunctionTypeBuilder(type_1450, type_10196);      ::Reflex::FunctionBuilder(t8, Reflex::Literal("cool::PyCool::Helpers::toString"), function_10180, 0, Reflex::Literal("r"), ::Reflex::PUBLIC);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::StorageType::TypeId"),typeid(::cool::StorageType::TypeId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("Bool"),0)
        .AddItem(Reflex::Literal("UChar"),1)
        .AddItem(Reflex::Literal("Int16"),2)
        .AddItem(Reflex::Literal("UInt16"),3)
        .AddItem(Reflex::Literal("Int32"),4)
        .AddItem(Reflex::Literal("UInt32"),5)
        .AddItem(Reflex::Literal("UInt63"),6)
        .AddItem(Reflex::Literal("Int64"),7)
        .AddItem(Reflex::Literal("Float"),8)
        .AddItem(Reflex::Literal("Double"),9)
        .AddItem(Reflex::Literal("String255"),10)
        .AddItem(Reflex::Literal("String4k"),11)
        .AddItem(Reflex::Literal("String64k"),12)
        .AddItem(Reflex::Literal("String16M"),13)
        .AddItem(Reflex::Literal("Blob64k"),14)
        .AddItem(Reflex::Literal("Blob16M"),15);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::HvsTagLock::Status"),typeid(::cool::HvsTagLock::Status), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("UNLOCKED"),0)
        .AddItem(Reflex::Literal("LOCKED"),1)
        .AddItem(Reflex::Literal("PARTIALLYLOCKED"),2);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::MSG::Level"),typeid(::cool::MSG::Level), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("NIL"),0)
        .AddItem(Reflex::Literal("VERBOSE"),1)
        .AddItem(Reflex::Literal("DEBUG"),2)
        .AddItem(Reflex::Literal("INFO"),3)
        .AddItem(Reflex::Literal("WARNING"),4)
        .AddItem(Reflex::Literal("ERROR"),5)
        .AddItem(Reflex::Literal("FATAL"),6)
        .AddItem(Reflex::Literal("ALWAYS"),7)
        .AddItem(Reflex::Literal("NUM_LEVELS"),8);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::PayloadMode::Mode"),typeid(::cool::PayloadMode::Mode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("INLINEPAYLOAD"),0)
        .AddItem(Reflex::Literal("SEPARATEPAYLOAD"),1)
        .AddItem(Reflex::Literal("VECTORPAYLOAD"),2);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::IHvsNode::Type"),typeid(::cool::IHvsNode::Type), ::Reflex::PUBLIC)
        .AddItem(Reflex::Literal("INNER_NODE"),0)
        .AddItem(Reflex::Literal("LEAF_NODE"),1);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::ChannelSelection::Order"),typeid(::cool::ChannelSelection::Order), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("channelBeforeSince"),0)
        .AddItem(Reflex::Literal("sinceBeforeChannel"),1)
        .AddItem(Reflex::Literal("channelBeforeSinceDesc"),2)
        .AddItem(Reflex::Literal("sinceDescBeforeChannel"),3);
      ::Reflex::EnumBuilder(Reflex::Literal("cool::FolderVersioning::Mode"),typeid(::cool::FolderVersioning::Mode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("NONE"),-1)
        .AddItem(Reflex::Literal("SINGLE_VERSION"),0)
        .AddItem(Reflex::Literal("MULTI_VERSION"),1);
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt16Min"), type_2332c, (size_t)&cool::UInt16Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int32Min"), type_2350c, (size_t)&cool::Int32Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UCharMax"), type_2279c, (size_t)&cool::UCharMax, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UCharMin"), type_2279c, (size_t)&cool::UCharMin, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt32Max"), type_2367c, (size_t)&cool::UInt32Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::ValidityKeyMax"), type_2348c, (size_t)&cool::ValidityKeyMax, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt32Min"), type_2367c, (size_t)&cool::UInt32Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int32Max"), type_2350c, (size_t)&cool::Int32Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt63Max"), type_2294c, (size_t)&cool::UInt63Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::ValidityKeyMin"), type_2348c, (size_t)&cool::ValidityKeyMin, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt63Min"), type_2294c, (size_t)&cool::UInt63Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt64Max"), type_2372c, (size_t)&cool::UInt64Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int64Max"), type_2276c, (size_t)&cool::Int64Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int16Max"), type_2330c, (size_t)&cool::Int16Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int16Min"), type_2330c, (size_t)&cool::Int16Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt64Min"), type_2372c, (size_t)&cool::UInt64Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::Int64Min"), type_2276c, (size_t)&cool::Int64Min, ::Reflex::PUBLIC | ::Reflex::STATIC );
      ::Reflex::VariableBuilder(Reflex::Literal("cool::UInt16Max"), type_2332c, (size_t)&cool::UInt16Max, ::Reflex::PUBLIC | ::Reflex::STATIC );
    }
    ~Dictionaries() {
      type_2302.Unload(); // class cool::IRecord 
      type_1389.Unload(); // class std::iterator_traits<boost::shared_ptr<cool::IRecord>*> 
      type_2321.Unload(); // class cool::IObject 
      type_1390.Unload(); // class std::iterator_traits<boost::shared_ptr<cool::IObject>*> 
      type_1392.Unload(); // class std::iterator_traits<coral::AttributeSpecification* const*> 
      type_1393.Unload(); // class std::iterator_traits<coral::Attribute**> 
      type_1394.Unload(); // class std::iterator_traits<coral::Attribute* const*> 
      type_1443.Unload(); // class std::basic_string<char> 
      type_1397.Unload(); // class std::vector<std::basic_string<char> > 
      type_1398.Unload(); // class std::vector<unsigned int> 
      type_2399.Unload(); // class boost::shared_ptr<cool::IRecord> 
      type_1399.Unload(); // class std::vector<boost::shared_ptr<cool::IRecord> > 
      type_2290.Unload(); // class boost::shared_ptr<cool::IObject> 
      type_1400.Unload(); // class std::vector<boost::shared_ptr<cool::IObject> > 
      type_1401.Unload(); // class std::vector<cool::IField*> 
      type_1402.Unload(); // class std::vector<cool::IRecordSelection*> 
      type_1404.Unload(); // class std::vector<cool::IFieldSpecification*> 
      type_2389.Unload(); // class cool::ChannelSelection 
      type_3676.Unload(); // class cool::ChannelSelection::ChannelRange 
      type_1405.Unload(); // class std::vector<cool::ChannelSelection::ChannelRange> 
      type_1406.Unload(); // class std::vector<coral::AttributeSpecification*> 
      type_1407.Unload(); // class std::vector<coral::Attribute*> 
      type_1540.Unload(); // class std::allocator<boost::shared_ptr<cool::IRecord> > 
      type_1541.Unload(); // class std::allocator<boost::shared_ptr<cool::IObject> > 
      type_1542.Unload(); // class std::allocator<cool::IField*> 
      type_1543.Unload(); // class std::allocator<cool::IRecordSelection*> 
      type_1545.Unload(); // class std::allocator<cool::IFieldSpecification*> 
      type_1546.Unload(); // class std::allocator<cool::ChannelSelection::ChannelRange> 
      type_1547.Unload(); // class std::allocator<coral::AttributeSpecification*> 
      type_1550.Unload(); // class std::allocator<coral::Attribute*> 
      type_1557.Unload(); // class std::allocator<boost::shared_ptr<cool::IRecord> >::rebind<boost::shared_ptr<cool::IRecord> > 
      type_1558.Unload(); // class std::allocator<boost::shared_ptr<cool::IObject> >::rebind<boost::shared_ptr<cool::IObject> > 
      type_1559.Unload(); // class std::allocator<cool::IRecordSelection*>::rebind<cool::IRecordSelection*> 
      type_1560.Unload(); // class std::allocator<cool::IField*>::rebind<cool::IField*> 
      type_1561.Unload(); // class std::allocator<cool::IFieldSpecification*>::rebind<cool::IFieldSpecification*> 
      type_1562.Unload(); // class std::allocator<cool::ChannelSelection::ChannelRange>::rebind<cool::ChannelSelection::ChannelRange> 
      type_1565.Unload(); // class std::allocator<coral::AttributeSpecification*>::rebind<coral::AttributeSpecification*> 
      type_1566.Unload(); // class std::allocator<coral::Attribute*>::rebind<coral::Attribute*> 
      type_1624.Unload(); // class std::map<unsigned int,std::basic_string<char> > 
      type_1677.Unload(); // class std::_Vector_base<boost::shared_ptr<cool::IRecord>,std::allocator<boost::shared_ptr<cool::IRecord> > > 
      type_1678.Unload(); // class std::_Vector_base<boost::shared_ptr<cool::IObject>,std::allocator<boost::shared_ptr<cool::IObject> > > 
      type_1679.Unload(); // class std::_Vector_base<cool::IRecordSelection*,std::allocator<cool::IRecordSelection*> > 
      type_1680.Unload(); // class std::_Vector_base<cool::IField*,std::allocator<cool::IField*> > 
      type_1681.Unload(); // class std::_Vector_base<cool::IFieldSpecification*,std::allocator<cool::IFieldSpecification*> > 
      type_1682.Unload(); // class std::_Vector_base<cool::ChannelSelection::ChannelRange,std::allocator<cool::ChannelSelection::ChannelRange> > 
      type_1683.Unload(); // class std::_Vector_base<coral::AttributeSpecification*,std::allocator<coral::AttributeSpecification*> > 
      type_1684.Unload(); // class std::_Vector_base<coral::Attribute*,std::allocator<coral::Attribute*> > 
      type_1701.Unload(); // class std::type_info 
      type_1821.Unload(); // class std::__are_same<coral::AttributeSpecification* const*,coral::AttributeSpecification**> 
      type_1822.Unload(); // class std::__are_same<coral::Attribute* const*,coral::Attribute**> 
      type_1823.Unload(); // class std::__are_same<coral::Attribute**,coral::Attribute**> 
      type_2039.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > > 
      type_2040.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > > 
      type_2041.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> > 
      type_2042.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IField*> > 
      type_2043.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> > 
      type_2044.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> > 
      type_2047.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> > 
      type_2048.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> > 
      type_2053.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IRecord> > >::rebind<boost::shared_ptr<cool::IRecord> > 
      type_2054.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<boost::shared_ptr<cool::IObject> > >::rebind<boost::shared_ptr<cool::IObject> > 
      type_2055.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IRecordSelection*> >::rebind<cool::IRecordSelection*> 
      type_2056.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IField*> >::rebind<cool::IField*> 
      type_2057.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::IFieldSpecification*> >::rebind<cool::IFieldSpecification*> 
      type_2058.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<cool::ChannelSelection::ChannelRange> >::rebind<cool::ChannelSelection::ChannelRange> 
      type_2061.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::AttributeSpecification*> >::rebind<coral::AttributeSpecification*> 
      type_2062.Unload(); // class __gnu_cxx::__alloc_traits<std::allocator<coral::Attribute*> >::rebind<coral::Attribute*> 
      type_2067.Unload(); // class __gnu_cxx::new_allocator<boost::shared_ptr<cool::IRecord> > 
      type_2068.Unload(); // class __gnu_cxx::new_allocator<boost::shared_ptr<cool::IObject> > 
      type_2069.Unload(); // class __gnu_cxx::new_allocator<cool::IRecordSelection*> 
      type_2070.Unload(); // class __gnu_cxx::new_allocator<cool::IField*> 
      type_2071.Unload(); // class __gnu_cxx::new_allocator<cool::IFieldSpecification*> 
      type_2072.Unload(); // class __gnu_cxx::new_allocator<cool::ChannelSelection::ChannelRange> 
      type_2075.Unload(); // class __gnu_cxx::new_allocator<coral::AttributeSpecification*> 
      type_2076.Unload(); // class __gnu_cxx::new_allocator<coral::Attribute*> 
      type_2112.Unload(); // class __gnu_cxx::__enable_if<false,std::vector<coral::AttributeSpecification*> > 
      type_2113.Unload(); // class __gnu_cxx::__enable_if<false,std::vector<coral::Attribute*> > 
      type_2114.Unload(); // class __gnu_cxx::__enable_if<true,std::vector<coral::Attribute*> > 
      type_2128.Unload(); // class __gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IRecord>*,std::vector<boost::shared_ptr<cool::IRecord> > > 
      type_2130.Unload(); // class __gnu_cxx::__normal_iterator<boost::shared_ptr<cool::IObject>*,std::vector<boost::shared_ptr<cool::IObject> > > 
      type_2141.Unload(); // class __gnu_cxx::__normal_iterator<coral::AttributeSpecification* const*,std::vector<coral::AttributeSpecification*> > 
      type_2143.Unload(); // class __gnu_cxx::__normal_iterator<coral::Attribute**,std::vector<coral::Attribute*> > 
      type_2144.Unload(); // class __gnu_cxx::__normal_iterator<coral::Attribute* const*,std::vector<coral::Attribute*> > 
      type_2263.Unload(); // class cool::IObjectIterator 
      type_2264.Unload(); // class cool::FieldSelection 
      type_2265.Unload(); // class cool::FieldSpecificationWrongStorageType 
      type_2267.Unload(); // class cool::TagNotFound 
      type_2268.Unload(); // class cool::PayloadSpecificationTooManyFields 
      type_2269.Unload(); // class cool::ChannelExists 
      type_2270.Unload(); // class cool::IField 
      type_2271.Unload(); // class boost::shared_ptr<std::vector<boost::shared_ptr<cool::IRecord> > > 
      type_2274.Unload(); // class cool::InvalidChannelRange 
      type_2275.Unload(); // class cool::StorageTypeStringTooLong 
      type_2277.Unload(); // class cool::IFolderSet 
      type_2278.Unload(); // class cool::CompositeSelection 
      type_2280.Unload(); // class cool::StorageType 
      type_2281.Unload(); // class cool::IRecordSpecification 
      type_2282.Unload(); // class boost::shared_ptr<cool::IObjectIterator> 
      type_2287.Unload(); // class cool::RecordSpecificationUnknownField 
      type_2289.Unload(); // class cool::TagRelationNotFound 
      type_2292.Unload(); // class cool::FolderSetNotFound 
      type_2297.Unload(); // class cool::FieldWrongCppType 
      type_2298.Unload(); // class boost::shared_ptr<cool::IFolderSet> 
      type_2303.Unload(); // class cool::FieldSpecificationWrongName 
      type_2304.Unload(); // class cool::RecordSpecification 
      type_2305.Unload(); // class cool::ObjectNotFound 
      type_2307.Unload(); // class cool::ChannelNotFound 
      type_2308.Unload(); // class cool::StorageTypeException 
      type_2309.Unload(); // class cool::StorageTypeWrongCppType 
      type_2310.Unload(); // class cool::Record 
      type_2312.Unload(); // class cool::ValidityKeyException 
      type_2313.Unload(); // class cool::FieldIsNull 
      type_2315.Unload(); // class cool::InvalidPayloadSpecification 
      type_2316.Unload(); // class cool::IFieldSpecification 
      type_2318.Unload(); // class cool::FolderIsSingleVersion 
      type_2319.Unload(); // class cool::ITime 
      type_2320.Unload(); // class cool::ConstRecordAdapter 
      type_2322.Unload(); // class cool::InvalidTagRelation 
      type_2323.Unload(); // class cool::DatabaseNotOpen 
      type_2324.Unload(); // class cool::DatabaseDoesNotExist 
      type_2410.Unload(); // class cool::IFolder 
      type_2325.Unload(); // class boost::shared_ptr<cool::IFolder> 
      type_2329.Unload(); // class cool::ValidityIntervalBackwards 
      type_2331.Unload(); // class cool::Time 
      type_2334.Unload(); // class boost::shared_ptr<std::vector<boost::shared_ptr<cool::IObject> > > 
      type_2336.Unload(); // class cool::IRecordSelection 
      type_2361.Unload(); // class cool::IDatabase 
      type_2337.Unload(); // class boost::shared_ptr<cool::IDatabase> 
      type_2339.Unload(); // class cool::IHvsNode 
      type_2341.Unload(); // class cool::RecordSpecificationCannotExtend 
      type_2342.Unload(); // class coral::Blob 
      type_2344.Unload(); // class cool::IApplication 
      type_2346.Unload(); // class cool::IHvsNodeRecord 
      type_2353.Unload(); // class cool::TagExists 
      type_2354.Unload(); // class cool::IDatabaseSvc 
      type_2355.Unload(); // class cool::FieldSpecification 
      type_2356.Unload(); // class cool::RecordException 
      type_2357.Unload(); // class cool::ReservedHeadTag 
      type_2358.Unload(); // class cool::ValidityKeyOutOfBoundaries 
      type_2359.Unload(); // class cool::FieldSpecificationInvalidName 
      type_2360.Unload(); // class cool::StorageTypeDoubleIsNaN 
      type_2362.Unload(); // class cool::TagRelationExists 
      type_2363.Unload(); // class cool::InvalidFolderSpecification 
      type_2364.Unload(); // class cool::StorageTypeStringContainsNullChar 
      type_2365.Unload(); // class cool::StorageTypeInvalidUInt63 
      type_2366.Unload(); // class cool::DatabaseSvcFactory 
      type_2370.Unload(); // class cool::InvalidChannelName 
      type_2373.Unload(); // class cool::StorageTypeBlobTooLong 
      type_2374.Unload(); // class cool::PayloadSpecificationInvalidFieldName 
      type_2376.Unload(); // class cool::DatabaseOpenInReadOnlyMode 
      type_2378.Unload(); // class cool::StorageTypeFloatIsNaN 
      type_2379.Unload(); // class cool::NodeNotFound 
      type_2380.Unload(); // class cool::Application 
      type_2381.Unload(); // class cool::NodeIsSingleVersion 
      type_2387.Unload(); // class cool::NodeExists 
      type_2388.Unload(); // class cool::StorageTypeInvalidValue 
      type_2391.Unload(); // class cool::TagIsLocked 
      type_2392.Unload(); // class cool::IRecordIterator 
      type_2393.Unload(); // class cool::NodeRelationNotFound 
      type_2394.Unload(); // class cool::FolderNotFound 
      type_2395.Unload(); // class cool::RecordSpecificationWrongSize 
      type_2397.Unload(); // class cool::IFolderSpecification 
      type_2402.Unload(); // class cool::Exception 
      type_2405.Unload(); // class cool::PayloadSpecificationTooManyBlobFields 
      type_2409.Unload(); // class cool::FolderSpecification 
      type_2412.Unload(); // class cool::PayloadSpecificationTooManyString255Fields 
      type_2442.Unload(); // class coral::AttributeListSpecification 
      type_2445.Unload(); // class coral::AttributeSpecification 
      type_2446.Unload(); // class coral::IConnectionServiceConfiguration 
      type_2449.Unload(); // class coral::Attribute 
      type_2452.Unload(); // class coral::AttributeList 
      type_2455.Unload(); // class coral::IWebCacheInfo 
      type_2456.Unload(); // class coral::IWebCacheControl 
      type_2457.Unload(); // class coral::AttributeListException 
      type_2461.Unload(); // class coral::AttributeException 
      type_2463.Unload(); // class coral::IConnectionService 
      type_8711.Unload(); // class coral::AttributeListSpecification::const_iterator 
      type_8868.Unload(); // class coral::AttributeList::iterator_base 
      type_8864.Unload(); // class coral::AttributeList::iterator 
      type_8863.Unload(); // class coral::AttributeList::const_iterator 
      type_9031.Unload(); // class boost::detail::shared_count 
      type_10172.Unload(); // class cool::PyCool::Helpers::Typedefs 
      type_1477.Unload(); // class std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > 
      type_1695.Unload(); // class std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
