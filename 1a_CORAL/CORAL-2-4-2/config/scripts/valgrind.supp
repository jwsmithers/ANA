#============================================================================
#
# Valgrind suppression file for the Oracle 11.2 client library libclntsh
# (and a few other libraries commonly used in CORAL and COOL)
# Each section was auto-generated using "valgrind --gen-suppressions=all"
#
#============================================================================
# *** ORACLE CLIENT *** OCIEnvCreate/OCIHandleFree only
#============================================================================
#
# Invalid read of size 4 [32bit only?!]
# [from "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# NB: This leak happens even only with OCIEnv/OCIError
#
{
   <oracle112030_OCIEnvCreate_32bit_slts_tls_getaddr_INVALIDREAD_addr4>
   Memcheck:Addr4
   fun:slts_tls_getaddr
   fun:sltsqKeyAdd
   fun:sltskys
   fun:kpummTLSGET1
   fun:kpeDbgProcessInit
   fun:kpummpin
   fun:kpuenvcr
   fun:OCIEnvCreate
}
#----------------------------------------------------------------------------
#
# Bytes are _definitely lost_ in loss record
# [from "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# NB: This leak happens even only with OCIEnv/OCIError
#
#{
#   <oracle112030_OCIEnvCreate_lfvLoadPkg_malloc_definiteLEAK>
#   Memcheck:Leak
#   fun:malloc
#   fun:slzsetevar
#   fun:lfvSetOHome
#   fun:slpmloclfv
#   fun:slpmloc
#   fun:lpmloadpkg
#   fun:lfvLoadPkg
#   fun:lfvSetShlMode
#   fun:lfvini1
#   fun:lfvini2
#   fun:lxlinit
#   fun:nleminz
#   fun:nlstdggo
#   fun:nlstdgg
#   fun:nigini2
#   fun:kpeDbgGetNPDGlobal
#   fun:kpeDbgTLSInit
#   fun:kpummTLSGET1
#   fun:kpeDbgProcessInit
#   fun:kpummpin
#   fun:kpuenvcr
#   fun:OCIEnvCreate
#}
#----------------------------------------------------------------------------
#
# Bytes are _possibly lost_ in loss record
# [from "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# NB: This leak happens even only with OCIEnv/OCIError
#
#{
#   <oracle112030_OCIEnvCreate_lfvLoadPkg_malloc_possiblyLEAK1>
#   Memcheck:Leak
#   fun:malloc
#   fun:sltsmxi
#   fun:lmmhpinit
#   fun:lmmcis
#   fun:lpmpali
#   fun:lpminitm
#   fun:lpminit
#   fun:lfvLoadPkg
#   fun:lfvSetShlMode
#   fun:lfvini1
#   fun:lfvini2
#   fun:lxlinit
#   fun:nleminz
#   fun:nlstdggo
#   fun:nlstdgg
#   fun:nigini2
#   fun:kpeDbgGetNPDGlobal
#   fun:kpeDbgTLSInit
#   fun:kpummTLSGET1
#   fun:kpeDbgProcessInit
#   fun:kpummpin
#   fun:kpuenvcr
#   fun:OCIEnvCreate
#}
#----------------------------------------------------------------------------
#
# Bytes are _possibly lost_ in loss record
# [from "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# NB: This leak happens even only with OCIEnv/OCIError
#
#{
#   <oracle112030_OCIEnvCreate_lfvLoadPkg_malloc_possiblyLEAK2>
#   Memcheck:Leak
#   fun:malloc
#   fun:sltsmxi
#   fun:lmmhpinit
#   fun:lmmcis
#   fun:lpmpali
#   fun:lpmloadpkg
#   fun:lfvLoadPkg
#   fun:lfvSetShlMode
#   fun:lfvini1
#   fun:lfvini2
#   fun:lxlinit
#   fun:nleminz
#   fun:nlstdggo
#   fun:nlstdgg
#   fun:nigini2
#   fun:kpeDbgGetNPDGlobal
#   fun:kpeDbgTLSInit
#   fun:kpummTLSGET1
#   fun:kpeDbgProcessInit
#   fun:kpummpin
#   fun:kpuenvcr
#   fun:OCIEnvCreate
#}
#----------------------------------------------------------------------------
#
# Bytes are _possibly lost_ in loss record
# [from "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# NB: This leak happens even only with OCIEnv/OCIError
#
#{
#   <oracle112030_OCIEnvCreate_lfvLoadPkg_calloc_possiblyLEAK>
#   Memcheck:Leak
#   fun:calloc
#   fun:slwmmgetmem
#   fun:lmmstvrt
#   fun:lmmstchnk
#   fun:lmmstsml
#   fun:lmmstmalloc
#   fun:lmmmalloc
#   fun:lmmcis
#   fun:lpmpali
#   fun:lpminitm
#   fun:lpminit
#   fun:lfvLoadPkg
#   fun:lfvSetShlMode
#   fun:lfvini1
#   fun:lfvini2
#   fun:lxlinit
#   fun:nleminz
#   fun:nlstdggo
#   fun:nlstdgg
#   fun:nigini2
#   fun:kpeDbgGetNPDGlobal
#   fun:kpeDbgTLSInit
#   fun:kpummTLSGET1
#   fun:kpeDbgProcessInit
#   fun:kpummpin
#   fun:kpuenvcr
#   fun:OCIEnvCreate
#}
#----------------------------------------------------------------------------
#
# Bytes are still reachable in loss record 
# From a simple program with OCIEnvCreate but no OCIError
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
# *** GENERIC SUPPRESSION FOR FAKE LEAKS IN OCIEnvCreate ***
# These suppress fake leaks reported even from a simple program with
# just OCIEnvCreate followed by OCIHandleFree( OCIEnv* ), but it does
# NOT suppress real leaks from OCIEnvCreate without OCIHandleFree.
# The first suppression will catch all 'Bytes are still reachable' leaks
# (except dlsym below) but also the four 'Bytes are definitely/possibly 
# lost' above (which are hence commented out and only kept for reference); 
# in particular it catches also the many leaks including 'fun:lfvLoadPkg'.
# The other two suppressions only catch six+one dlopen+dlsym related leaks.
#
{
   <oracle112030_OCIEnvCreate_kpummpin_alloc_FAKE_LEAK>
   Memcheck:Leak
   fun:*alloc
   ...
   fun:kpummpin
   fun:kpuenvcr
   fun:OCIEnvCreate
}
{
   <oracle112030_OCIEnvCreate_dlopen_alloc_FAKE_LEAK>
   Memcheck:Leak
   fun:*alloc
   ...
   fun:_dl_open
   fun:dlopen_doit
   fun:_dl_catch_error
   fun:_dlerror_run
   fun:dlopen@@GLIBC*
   fun:ssOswDlopen
   fun:skgsn_setup_numa_lib
   ...
   fun:skgminit
   fun:kpuiniPG
   fun:kpuinit0
   fun:kpuenvcr
   fun:OCIEnvCreate
}
{
   <oracle112030_OCIEnvCreate_dlsym_malloc_FAKE_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:_dl_signal_error
   fun:_dl_signal_cerror
   fun:_dl_lookup_symbol_x
   fun:do_sym
   fun:dlsym_doit
   fun:_dl_catch_error
   fun:_dlerror_run
   fun:dlsym
   fun:skgsn_setup_numa_lib
   fun:skgsninit
   fun:skgminit
   fun:kpuiniPG
   fun:kpuinit0
   fun:kpuenvcr
   fun:OCIEnvCreate
}
#----------------------------------------------------------------------------
#
# Bytes are still reachable in loss record 
# From a simple program with OCIEnvCreate but no OCIError
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
# DO NOT ENABLE! THIS IS THE SIGNATURE OF A REAL LEAK (OCIEnv not freed)!
#
#{
#   <oracle112030_OCIEnvCreate_kpuinit0_alloc_REAL_LEAK>
#   Memcheck:Leak
#   fun:*alloc
#   ...
#   fun:*ts*
#   ...
#   fun:kpuinit0
#   fun:kpuenvcr
#   fun:OCIEnvCreate
#}
#============================================================================
# *** ORACLE CLIENT *** OCIServerAttach and cleanup
#============================================================================
#
# Invalid read of size 4 [32bit only?!]
# [from "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# NB: This leak happens even only with OCIEnv/OCIError
#
{
   <oracle112030_OCIServerAttach_32bit_INVALIDREAD_addr8>
   Memcheck:Addr8
   ...
   fun:nsdo
   fun:nsbasic_sd
   fun:nssend
   fun:nscall2
   fun:nscall
   fun:niotns
   fun:nigcall
   fun:osncon
   fun:kpuadef
   fun:upiini
   fun:upiah0
   fun:kpuatch
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Bytes are still reachable in loss record
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
# *** GENERIC SUPPRESSION FOR FAKE LEAKS IN OCIServerAttach ***
# These suppress fake leaks reported even from a simple program with
# OCIServerDetach followed by all relevant OCIServerDetach and OCIHandleFree,
# but it does NOT suppress real leaks from OCIServerAttach with no cleanup.
# Note that the ONLY relevant cleanup seems to be OCIHandleFree( OCIEnv )!
#
{
   <oracle112030_OCIServerAttach_kpuatch_alloc_FAKE_LEAK>
   Memcheck:Leak
   fun:*alloc
   ...
   fun:kpuatch
   fun:OCIServerAttach
}
{
   <oracle112030_OCIServerVersion_kpuvers_ttcpro_alloc_FAKE_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:lxldalc
   fun:lxldLoadObject
   fun:lxldlod
   fun:lxdlobj
   fun:lxdgetobj
   fun:lxhci2h
   fun:ttc*
   fun:ttcpro
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:upirtr
   fun:upiver
   fun:kpuvers
   fun:OCIServerVersion
}
{
   <oracle112030_OCIServerVersion_kpuvers_ttcdty_alloc_FAKE_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:lxldalc
   fun:lxldLoadObject
   fun:lxldlod
   fun:lxdlobj
   fun:lxdgetobj
   fun:lxpcset
   fun:lxhLaToId
   fun:ttclxx
   fun:ttclxp
   fun:ttcdty
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:upirtr
   fun:upiver
   fun:kpuvers
   fun:OCIServerVersion
}
#
# Bytes are still reachable in loss record 
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# [NB: this only appears for password authentication on devdb11!]
#
{
   <oracle112030_OCISessionBegin_nlrnini_FAKE_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:nlrnini
   fun:nlrngr
   fun:snluicrt
   fun:snlui
   fun:nluicrt
   fun:kokidgen
   fun:kpuslsid
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Bytes are still reachable in loss record 
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
# DO NOT ENABLE! THIS IS THE SIGNATURE OF A REAL LEAK (OCIServer related)!
# [NB The leak seems to depend on freeing OCIEnv, not on freeing OCIServer!]
#
#{
#   <oracle112030_OCIHandleAlloc_alloc_REAL_LEAK>
#   Memcheck:Leak
#   fun:malloc
#   ...
#   fun:OCIHandleAlloc
#}
#----------------------------------------------------------------------------
#
# Syscall param write(buf) points to uninitialised byte(s)
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
{
   <oracle112030_OCIServerAttach_nttwr_writenocancel_param>
   Memcheck:Param
   write(buf)
   ...
   fun:nttwr
   fun:nsntwrn
   fun:nspsend
   fun:nsdofls
   fun:nsdoacts
   fun:nsdo
   fun:nsbasic_sd
   fun:nssend
   fun:nsnasend
   fun:nacomsn
   fun:na_client
   fun:naconnect
   fun:nsnadoconn
   fun:nsnaconn
   fun:nscall
   fun:niotns
   fun:nigcall
   fun:osncon
   fun:kpuadef
   fun:upiini
   fun:upiah0
   fun:kpuatch
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Syscall param write(buf) points to uninitialised byte(s)
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
{
   <oracle112030_OCIServerVersion_snttwrite_writenocancel_param>
   Memcheck:Param
   write(buf)
   fun:__write_nocancel
   fun:snttwrite
   fun:ntt*
   ...
   fun:ns*_bsd
   fun:nsbsend
   fun:nioqrc
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:upirtr
   fun:upiver
   fun:kpuvers
   fun:OCIServerVersion
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# [Note: Kerberos/test2 uses ztcr2seed, password/devdb11 uses ztcr2rnd]
#
{
   <oracle112030_OCIServerAttach_ztced_einit_val4>
   Memcheck:Value4
   fun:ztced_einit
   fun:ztcedgks
   fun:ztcedi
   fun:ztcebi
   fun:ztcei
   fun:ztceenc
   fun:ztcrbm
   fun:ztcrbh
   fun:ztcrbp
   ...
   fun:OCIServerAttach
}
{
   <oracle112030_OCIServerAttach_ztced_einit_val8>
   Memcheck:Value8
   fun:ztced_einit
   fun:ztcedgks
   fun:ztcedi
   fun:ztcebi
   fun:ztcei
   fun:ztceenc
   fun:ztcrbm
   fun:ztcrbh
   fun:ztcrbp
   ...
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
{
   <oracle112030_OCIServerAttach_ztcedecb_val4>
   Memcheck:Value4
   fun:ztcedecb
   fun:ztcedencbk
   fun:ztceb_encblk
   ...
   fun:OCIServerAttach
}
{
   <oracle112030_OCIServerAttach_ztcedecb_val8>
   Memcheck:Value8
   fun:ztcedecb
   fun:ztcedencbk
   fun:ztceb_encblk
   ...
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
{
   <oracle112030_OCIServerAttach_ztceaencbk_val4>
   Memcheck:Value4
   fun:ztceaencbk
   fun:ztceb_encblk
   fun:ztcebn
   ...
   fun:OCIServerAttach
}
{
   <oracle112030_OCIServerAttach_ztceaencbk_val8>
   Memcheck:Value8
   fun:ztceaencbk
   fun:ztceb_encblk
   fun:ztcebn
   ...
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
{
   <oracle112030_OCIServerAttach_A_X931RandomGenerateBytes_CMP_cond>
   Memcheck:Cond
   fun:CMP_*
   ...
   fun:A_X931RandomGenerateBytes
   fun:ztcr2rnd
   ...
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From a simple program with OCIServerAttach but no OCISvcCtx
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
# [NB: this only appears for password authentication on devdb11!]
#
{
   <oracle112030_OCIServerAttach_naeccn_cond>
   Memcheck:Cond
   fun:naeb*
   ...
   fun:naeccn
   fun:na_csrd
   fun:na_client
   fun:naconnect
   fun:nsnadoconn
   fun:nsnaconn
   fun:nscall
   fun:niotns
   fun:nigcall
   fun:osncon
   fun:kpuadef
   fun:upiini
   fun:upiah0
   fun:kpuatch
   fun:OCIServerAttach
}
#============================================================================
# *** ORACLE CLIENT *** OCISessionBegin and cleanup
#============================================================================
#
# Bytes are still reachable in loss record 
# From a simple program with OCISessionBegin but no queries
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
# *** GENERIC SUPPRESSION FOR FAKE LEAKS IN OCISessionBegin ***
# These suppress fake leaks reported even from a simple program with
# OCISessionBegin followed by all relevant OCISessionEnd and OCIHandleFree,
# but it does NOT suppress real leaks from OCISessionBegin with no cleanup.
# Note that the ONLY relevant cleanup seems to be OCIHandleFree( OCIEnv )!
#
{
   <oracle112030_OCISessionBegin_kpuauth_calloc_FAKE_LEAK>
   Memcheck:Leak
   fun:calloc
   fun:snlui
   fun:nluicrt
   fun:kokidgen
   fun:kpuslsid
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Bytes are still reachable in loss record
# From a simple program with OCISessionBegin but no queries
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
# DO NOT ENABLE! THIS IS THE SIGNATURE OF A REAL LEAK (OCISession related)!
# [NB The leak seems to depend on freeing OCIEnv, not on freeing OCISession!]
#
#{
#   <oracle112030_OCISessionBegin_alloc_REAL_LEAK>
#   Memcheck:Leak
#   fun:malloc
#   fun:ssMemMalloc
#   fun:sktsfMalloc
#   fun:kpummapg
#   ###fun:kghgex ### TOO MANY CALLERS!
#   ###fun:kghfnd ### TOO MANY CALLERS!
#   ...
#   fun:kghalo
#   fun:kghgex
#   fun:kghfnd
#   fun:kghalo
#   fun:kghgex
#   fun:kghfnd
#   fun:kghalo
#   fun:kpuhhalo
#   fun:ttcrbur
#   fun:ttcbur
#   fun:ttcdrv
#   fun:nioqwa
#   fun:upirtrc
#   fun:upirtr
#   fun:kpurcs
#   fun:kpu8lgn
#   fun:kpuauthxa
#   fun:kpuauth
#   fun:OCISessionBegin
#}
#============================================================================
# *** ORACLE CLIENT *** OCIStmtExecute and cleanup
#============================================================================
#
# Bytes are still reachable in loss record 
# From a simple program with OCIDefineByPos but no transactions
# [See "./koracle test2" in COOL ExternalTests/Kerberos/koracle]
#
# DO NOT ENABLE! THIS IS THE SIGNATURE OF A REAL LEAK (OCIStmt related)!
# [NB The leak seems to depend on freeing OCIEnv, not on freeing OCIStmt!]
#
#{
#   <oracle112030_OCIDefineByPos_malloc_REAL_LEAK>
#   Memcheck:Leak
#   fun:malloc
#   fun:ssMemMalloc
#   fun:sktsfMalloc
#   fun:kpummapg
#   fun:kghgex
#   fun:kghfnd
#   fun:kghalo
#   fun:kghgex
#   fun:kghfnd
#   fun:kghalo
#   fun:kghgex
#   fun:kghfnd
#   fun:kghalo
#   fun:kpuhhalo
#   fun:kpuertb_reallocTempBuf
#   fun:kpuex_reallocTempBuf
#   fun:kpudefn
#   fun:kpudfn
#   fun:OCIDefineByPos
#}
#============================================================================
# *** ORACLE CLIENT *** More complex OCI, CORAL, COOL tests
#============================================================================
#
# Bytes are still reachable in loss record 
# From 'coralServer' through 'CoralAccess server' test
# NB Checked that there are as many OCIEnvCreate as OCIHandleFree(OCIEnv)
#
{
   <oracle112030_OCIEnvCreate_lxldalc_FAKE_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:lxldalc
   fun:lxldLoadObject
   fun:lxldlod
   fun:lxdlobj
   fun:lxdgetobj
   fun:lxhchtoid
   fun:lmsaicmt
   fun:kgefaa2
   fun:kgefaa
   fun:kouogini
   fun:kouoini
   fun:kpuinit0
   fun:kpuenvcr
   fun:OCIEnvCreate
}
#----------------------------------------------------------------------------
#
# Bytes are still reachable in loss record 
# From 'test_Integration_ObjectConsistency oracle test_threads'
# *** TO BE CHECKED: FAKE OR REAL LEAK?... ***
#
{
   <oracle112030_OCIEnvCreate_lxldalc_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:lxldalc
   fun:lxldlod
   fun:lxdlobj
   fun:lxdgetobj
   fun:lxhchtoid
   fun:lmsaicmt
   fun:kgefaa2
   fun:kgefaa
   fun:kouogini
   fun:kouoini
   fun:kpuinit0
   fun:kpuenvcr
   fun:OCIEnvCreate
}
{
   <oracle112030_OCIServerVersion_lxldalc_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:lxldalc
   fun:lxldlod
   fun:lxdlobj
   fun:lxdgetobj
   fun:lxhci2h
   fun:ttcfdor
   fun:ttcpro
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:upirtr
   fun:upiver
   fun:kpuvers
   fun:OCIServerVersion
}
{
   <oracle112030_OCIAttrSet_AX931_CMP_malloc_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:T_malloc
   fun:CMP_reallocNoCopy
   fun:CMP_OctetStringToCMPInt
   fun:A_X931RandomInit
   fun:ztcriv
   fun:ztcrbp
   fun:ztcr2seed
   fun:ztcrseed3
   fun:ztcsh
   fun:kpusattr
   fun:OCIAttrSet
}
{
   <oracle112030_OCIAttrSet_AX931_malloc_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:T_malloc
   fun:A_X931RandomInit
   fun:ztcriv
   fun:ztcrbp
   fun:ztcr2seed
   fun:ztcrseed3
   fun:ztcsh
   fun:kpusattr
   fun:OCIAttrSet
}
{
   <oracle112030_OCIAttrSet_sltsmxi_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:sltsmxi
   fun:ztcriv
   fun:ztcrbp
   fun:ztcr2seed
   fun:ztcrseed3
   fun:ztcsh
   fun:kpusattr
   fun:OCIAttrSet
}
{
   <oracle112030_OCIDescribeAny_dlopen_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:_dl_signal_error
   fun:_dl_open
   fun:dlopen_doit
   fun:_dl_catch_error
   fun:_dlerror_run
   fun:dlopen@@GLIBC*
   fun:ssOswDlopen
   fun:skgsn_setup_numa_lib
   fun:skgsninit
   fun:skgminit
   fun:kpuiniPG
   fun:kpumin
   fun:kpumgs
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpudsany
   fun:OCIDescribeAny
}
{
   <oracle112030_OCIDescribeAny_dlsym_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:_dl_signal_error
   fun:_dl_signal_cerror
   fun:_dl_lookup_symbol_x
   fun:do_sym
   fun:dlsym_doit
   fun:_dl_catch_error
   fun:_dlerror_run
   fun:dlsym
   fun:skgsn_setup_numa_lib
   fun:skgsninit
   fun:skgminit
   fun:kpuiniPG
   fun:kpumin
   fun:kpumgs
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpudsany
   fun:OCIDescribeAny
}
{
   <oracle112030_OCIDescribeAny_kpummapg_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:ssMemMalloc
   fun:sktsfMalloc
   fun:kpummapg
   fun:kghgex
   fun:kghalf
   fun:kpumgs
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpudsany
   fun:OCIDescribeAny
}
{
   <oracle112030_OCIDescribeAny_kpummealloc_TOBECHECKED_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:ssMemMalloc
   fun:sktsfMalloc
   fun:kpummealloc
   fun:kpumin
   fun:kpumgs
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpudsany
   fun:OCIDescribeAny
}
#----------------------------------------------------------------------------
#
# Invalid read of size 8
# From 'coralServer' through 'CoralAccess server' test
# NB This has been filed as bug #98791
#
{
   <oracle112030_OCIStmtPrepare2_intelnewmemcpy_bug98791_INVALIDREAD_addr4>
   Memcheck:Addr4
   fun:__intel_new_memcpy
   fun:kpurclientparse
   fun:kpureq
   fun:kpuStmtPrep2New
   fun:kpureq2
   fun:OCIStmtPrepare2
}
{
   <oracle112030_OCIStmtPrepare2_intelnewmemcpy_bug98791_INVALIDREAD_addr8>
   Memcheck:Addr8
   fun:__intel_new_memcpy
   fun:kpurclientparse
   fun:kpureq
   fun:kpuStmtPrep2New
   fun:kpureq2
   fun:OCIStmtPrepare2
}
#
# Invalid read of size 8 [32bit only?!]
# From 'test_Integration_WriteRead oracle' within CORAL_ATLAS_HLT (61f) setup
#
{
   <oracle112030_OCIServerAttach_32bit_INVALIDREAD_bug100874_addr8>
   Memcheck:Addr8
   ...
   fun:nnfun2a
   fun:nnfsn2a
   fun:niqname
   fun:kpplcSetServerPooled
   fun:kpuatch
   fun:OCIServerAttach
}
#
# Invalid read of size 8 [32bit only?!]
# From 'test_Integration_WriteRead oracle' within CORAL_ATLAS_HLT (61f) setup
#
{
   <oracle112030_OCIStmtPrepare2_32bit_INVALIDREAD_bug100874_addr8>
   Memcheck:Addr8
   ...
   fun:kpurclientparse
   fun:kpureq
   fun:kpuStmtPrep2New
   fun:kpureq2
   fun:OCIStmtPrepare2
}
#----------------------------------------------------------------------------
#
# Invalid read of size 8
# From 'coralServer' through 'CoolRegression server' test
# NB This has been filed as bug #98791
#
{
   <oracle112030_OCILobRead_intelnewmemcpy_bug98791_INVALIDREAD_addr4>
   Memcheck:Addr4
   fun:__intel_new_memcpy
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpulfrdarr
   fun:kpulfrd
   fun:OCILobRead
}
{
   <oracle112030_OCILobRead_intelnewmemcpy_bug98791_INVALIDREAD_addr8>
   Memcheck:Addr8
   fun:__intel_new_memcpy
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpulfrdarr
   fun:kpulfrd
   fun:OCILobRead
}
#----------------------------------------------------------------------------
#
# Invalid read of size 8
# From 'coralServer' through 'HLT server' test
# NB This has been filed as bug #98791
#
{
   <oracle112030_OCIStmtExecute_intelnewmemcpy_bug98791_INVALIDREAD_addr4>
   Memcheck:Addr4
   fun:__intel_new_memcpy
   fun:ttcc2u
   fun:ttcpip
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpuexec
   fun:OCIStmtExecute
}
{
   <oracle112030_OCIStmtExecute_intelnewmemcpy_bug98791_INVALIDREAD_addr8>
   Memcheck:Addr8
   fun:__intel_new_memcpy
   fun:ttcc2u
   fun:ttcpip
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpuexec
   fun:OCIStmtExecute
}
#----------------------------------------------------------------------------
#
# Invalid read of size 8
# From CORAL_2_3_25 qmtest/valgrind suite
# NB This has been filed as bug #98791
#
{
   <oracle112030_OCIServerAttach_intelnewmemcpy_bug98791_INVALIDREAD_addr4>
   Memcheck:Addr4
   fun:__intel_new_memcpy
   fun:nacomap
   fun:nacomsn
   fun:na_client
   fun:naconnect
   fun:nsnadoconn
   fun:nsnaconn
   fun:nscall
   fun:niotns
   fun:nigcall
   fun:osncon
   fun:kpuadef
   fun:upiini
   fun:upiah0
   fun:kpuatch
   fun:OCIServerAttach
}
{
   <oracle112030_OCIServerAttach_intelnewmemcpy_bug98791_INVALIDREAD_addr8>
   Memcheck:Addr8
   fun:__intel_new_memcpy
   fun:nacomap
   fun:nacomsn
   fun:na_client
   fun:naconnect
   fun:nsnadoconn
   fun:nsnaconn
   fun:nscall
   fun:niotns
   fun:nigcall
   fun:osncon
   fun:kpuadef
   fun:upiini
   fun:upiah0
   fun:kpuatch
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Invalid read of size 8
# From CORAL_2_3_25 qmtest/valgrind suite
# NB This has been filed as bug #98791
#
{
   <oracle112030_OCIServerAttach_intelnewmemcpy_bug98791_INVALIDREAD_addr4>
   Memcheck:Addr4
   fun:__intel_new_memcpy
   fun:ttciovconv
   fun:kpulbcs
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpulfwrarr
   fun:kpulfwr
   fun:OCILobWriteAppend
}
{
   <oracle112030_OCIServerAttach_intelnewmemcpy_bug98791_INVALIDREAD_addr8>
   Memcheck:Addr8
   fun:__intel_new_memcpy
   fun:ttciovconv
   fun:kpulbcs
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:kpurcsc
   fun:kpulfwrarr
   fun:kpulfwr
   fun:OCILobWriteAppend
}
#----------------------------------------------------------------------------
#
# Syscall param write(buf) points to uninitialised byte(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCIServerVersion_snttwrite_libpthread_param>
   Memcheck:Param
   write(buf)
   obj:*/libpthread-*.so
   fun:snttwrite
   fun:nttfpwr
   fun:nsbasic_bsd
   fun:nsbsend
   fun:nioqrc
   fun:ttcdrv
   fun:nioqwa
   fun:upirtrc
   fun:upirtr
   fun:upiver
   fun:kpuvers
   fun:OCIServerVersion
}
#----------------------------------------------------------------------------
#
# Syscall param write(buf) points to uninitialised byte(s)
# From 'coralServer' through 'CoralAccess server' test
#
{
   <oracle112030_OCIServerAttach_snttwrite_libpthread_param>
   Memcheck:Param
   write(buf)
   obj:*/libpthread-*.so
   fun:snttwrite
   fun:nttwr
   fun:nsntwrn
   fun:nspsend
   fun:nsdofls
   fun:nsdoacts
   fun:nsdo
   fun:nsbasic_sd
   fun:nssend
   fun:nsnasend
   fun:nacomsn
   fun:na_client
   fun:naconnect
   fun:nsnadoconn
   fun:nsnaconn
   fun:nscall
   fun:niotns
   fun:nigcall
   fun:osncon
   fun:kpuadef
   fun:upiini
   ###fun:upiah0  ### TOO MANY CALLERS
   ###fun:kpuatch ### TOO MANY CALLERS
   ...
   fun:OCIServerAttach
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCIAttrSet_ztced_einit_val4>
   Memcheck:Value4
   fun:ztced_einit
   fun:ztcedgks
   fun:ztcedi
   fun:ztcebi
   fun:ztcei
   fun:ztceenc
   fun:ztcrbm
   fun:ztcrbh
   fun:ztcrbp
   fun:ztcr2seed
   fun:ztcrseed3
   ...
   fun:OCIAttrSet
}
{
   <oracle112030_OCIAttrSet_ztced_einit_val8>
   Memcheck:Value8
   fun:ztced_einit
   fun:ztcedgks
   fun:ztcedi
   fun:ztcebi
   fun:ztcei
   fun:ztceenc
   fun:ztcrbm
   fun:ztcrbh
   fun:ztcrbp
   fun:ztcr2seed
   fun:ztcrseed3
   ...
   fun:OCIAttrSet
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCIAttrSet_ztcedecb_val4>
   Memcheck:Value4
   fun:ztcedecb
   fun:ztcedencbk
   fun:ztceb*
   ...
   fun:OCIAttrSet
}
{
   <oracle112030_OCIAttrSet_ztcedecb_val8>
   Memcheck:Value8
   fun:ztcedecb
   fun:ztcedencbk
   fun:ztceb*
   ...
   fun:OCIAttrSet
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_ztceaencbk_val4>
   Memcheck:Value4
   fun:ztceaencbk
   fun:ztceb*
   ...
   fun:OCISessionBegin
}
{
   <oracle112030_OCISessionBegin_ztceaencbk_val8>
   Memcheck:Value8
   fun:ztceaencbk
   fun:ztceb*
   ...
   fun:OCISessionBegin
}
{
   <oracle112030_OCISessionBegin_ztceadecbk_val4>
   Memcheck:Value4
   fun:ztceadecbk
   fun:ztceb*
   ...
   fun:OCISessionBegin
}
{
   <oracle112030_OCISessionBegin_ztceadecbk_val8>
   Memcheck:Value8
   fun:ztceadecbk
   fun:ztceb*
   ...
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_ztceai_val4>
   Memcheck:Value4
   fun:ztceai
   fun:ztcebi
   fun:ztcei
   ...
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
{
   <oracle112030_OCISessionBegin_ztceai_val8>
   Memcheck:Value8
   fun:ztceai
   fun:ztcebi
   fun:ztcei
   ...
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_ztucbtx_val4>
   Memcheck:Value4
   fun:ztucbtx
   fun:ztvo5pe
   fun:kzsrepw
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
{
   <oracle112030_OCISessionBegin_ztucbtx_val8>
   Memcheck:Value8
   fun:ztucbtx
   fun:ztvo5pe
   fun:kzsrepw
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_intelnewmemcpy_val4>
   Memcheck:Value4
   fun:__intel_new_memcpy
   fun:ztcebf
   fun:ztcef
   fun:ztcedec
   fun:ztvo5ed
   fun:ztvo5ver
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
{
   <oracle112030_OCISessionBegin_intelnewmemcpy_val8>
   Memcheck:Value8
   fun:__intel_new_memcpy
   fun:ztcebf
   fun:ztcef
   fun:ztcedec
   fun:ztvo5ed
   fun:ztvo5ver
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Use of uninitialised value of size 4 or 8
# From 'coralServer' through 'CoralAccess server' test
#
{
   <oracle112030_OCISessionBegin_ztvo5ke_val4>
   Memcheck:Value4
   fun:ztvo5ke
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
{
   <oracle112030_OCISessionBegin_ztvo5ke_val8>
   Memcheck:Value8
   fun:ztvo5ke
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_A_X931RandomGenerateBytes_CMP_cond>
   Memcheck:Cond
   fun:CMP_*
   ...
   fun:A_X931RandomGenerateBytes
   fun:ztcr2rnd
   ...
   fun:OCISessionBegin
}
{
   <oracle112030_OCIAttrSet_A_X931RandomGenerateBytes_CMP_cond>
   Memcheck:Cond
   fun:CMP_*
   ...
   fun:A_X931RandomGenerateBytes
   fun:ztcr2rnd
   ...
   fun:OCIAttrSet
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_ztvo5ke_cond>
   Memcheck:Cond
   fun:ztvo5ke
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_kzsrepw_cond>
   Memcheck:Cond
   fun:kzsrepw
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_nassky_cond>
   Memcheck:Cond
   fun:nassky
   fun:nszssk
   fun:nszssk2
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_ztceb_unpadding_cond>
   Memcheck:Cond
   fun:ztceb_unpadding
   fun:ztcebf
   fun:ztcef
   fun:ztcedec
   fun:ztvo5ed
   fun:ztvo5ver
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#----------------------------------------------------------------------------
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_intelnewmemcpy_cond>
   Memcheck:Cond
   fun:__intel_new_memcpy
   fun:ztcebf
   fun:ztcef
   fun:ztcedec
   fun:ztvo5ed
   fun:ztvo5ver
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <oracle112030_OCISessionBegin_intelfastmemcpy_cond>
   Memcheck:Cond
   fun:_intel_fast_memcmp
   fun:ztvo5ver
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#
# Conditional jump or move depends on uninitialised value(s)
# From 'test_Integration_WriteRead oracle' within CORAL_ATLAS_HLT (61f) setup
#
{
   <oracle112030_OCISessionBegin_intelfastmemcpy_cond2>
   Memcheck:Cond
   fun:_intel_fast_memcmp
   fun:kpu8lgn
   fun:kpuauthxa
   fun:kpuauth
   fun:OCISessionBegin
}
#============================================================================
# *** PYTHON *** Python, PyCoral and PyCool tests
#============================================================================
#
# Invalid read of size 4
# [official svn.python.org/projects/python/trunk/Misc/valgrind-python.supp]
# From "python -c ''"
#
{
   <python26_PyObject_Free_addr4>
   Memcheck:Addr4
   fun:PyObject_Free
}
#
# Use of uninitialised value of size 4
# [official svn.python.org/projects/python/trunk/Misc/valgrind-python.supp]
# From "python -c ''" (for size 8)
#
{
   <python26_PyObject_Free_val4>
   Memcheck:Value4
   fun:PyObject_Free
}
#
# Use of uninitialised value of size 8
# [not in official valgrind-python.supp]
# From "python -c ''"
#
{
   <python26_PyObject_Free_val8>
   Memcheck:Value8
   fun:PyObject_Free
}
#
# Conditional jump or move depends on uninitialised value(s)
# [official svn.python.org/projects/python/trunk/Misc/valgrind-python.supp]
# From "python -c ''"
#
{
   <python26_PyObject_Free_cond>
   Memcheck:Cond
   fun:PyObject_Free
}
#----------------------------------------------------------------------------
#
# Invalid read of size 4
# [official svn.python.org/projects/python/trunk/Misc/valgrind-python.supp]
# From test_PyCoral_Basic.py oracle:oracle 
#
{
   <python26_PyObject_Realloc_addr4>
   Memcheck:Addr4
   fun:PyObject_Realloc
}
#
# Use of uninitialised value of size 4
# [official svn.python.org/projects/python/trunk/Misc/valgrind-python.supp]
# From test_PyCoral_Basic.py oracle:oracle 
#
{
   <python26_PyObject_Realloc_val4>
   Memcheck:Value4
   fun:PyObject_Realloc
}
#
# Use of uninitialised value of size 8
# [not in official valgrind-python.supp]
# From test_PyCoral_Basic.py oracle:oracle 
#
{
   <python26_PyObject_Realloc_val8>
   Memcheck:Value8
   fun:PyObject_Realloc
}
#
# Conditional jump or move depends on uninitialised value(s)
# [official svn.python.org/projects/python/trunk/Misc/valgrind-python.supp]
# From test_PyCoral_Basic.py oracle:oracle 
#
{
   <python26_PyObject_Realloc_cond>
   Memcheck:Cond
   fun:PyObject_Realloc
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are possibly lost)
# Memory leak (bytes are still reachable in loss record)
# From "python -c ''"
# From "python -c 'import coral'"
# From test_PyCoral_Basic.py oracle:oracle (very broad generalization)
#
{
   <python26_PyImport_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   ...
   fun:load_source_module
   fun:import_submodule
   fun:load_next
   fun:import_module*
   fun:PyImport_ImportModuleLevel
}
{
   <python26_PyImport_dlopen_LEAK>
   Memcheck:Leak
   fun:*alloc
   ...
   fun:dlopen@@GLIBC*
   fun:_PyImport_GetDynLoadFunc
   fun:_PyImport_LoadDynamicModule
   fun:import_submodule
   fun:load_next
   fun:import_module*
   fun:PyImport_ImportModuleLevel
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# From "python -c 'import coral'"
# From test_PyCoral_Basic.py oracle:oracle (very broad generalization)
#
{
   <python26_PyObject_GC_Malloc_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:_PyObject_GC_Malloc
}
{
   <python26_PyObject_GC_Resize_realloc_LEAK>
   Memcheck:Leak
   fun:realloc
   fun:_PyObject_GC_Resize
}
{
   <python26_Py_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:Py*
}
{
   <python26__Py_realloc_LEAK>
   Memcheck:Leak
   fun:realloc
   fun:_Py*
}
{
   <python26_Py_realloc_LEAK>
   Memcheck:Leak
   fun:realloc
   fun:Py*
}
{
   <python26_Py_realloc_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:realloc
   fun:Py*
}
{
   <python26_Py_calculatepath_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:calculate_path
   fun:Py*
}
{
   <python26_Py_dictresize_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:dictresize
   fun:Py*
}
{
   <python26_Py_strdup_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:strdup
   fun:Py*
}
{
   <python26_Py_PyInit_malloc_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:_Py*Init
   fun:Py*
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# From "python -c 'import ROOT'"
#
{
   <python26_PyStringResize_LEAK>
   Memcheck:Leak
   fun:realloc
   fun:_PyString_Resize
   fun:PyString_Format
   fun:binary_op1
   fun:PyNumber_Remainder
   fun:PyEval_EvalFrameEx
   fun:PyEval_EvalCodeEx
   fun:function_call
   fun:PyObject_Call
   fun:instancemethod_call
   fun:PyObject_Call
   fun:slot_tp_init
   fun:type_call
   fun:PyObject_Call
   fun:PyObject_CallFunctionObjArgs
   fun:PyEval_EvalFrameEx
   fun:PyEval_EvalCodeEx
   fun:PyEval_EvalCode
   fun:PyImport_ExecCodeModuleEx
   fun:load_source_module
   fun:import_submodule
   fun:load_next
   fun:import_module*
   fun:PyImport_ImportModuleLevel
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# From "python -c 'import ROOT'"
#
{
   <python26_add_subclass_LEAK>
   Memcheck:Leak
   fun:*alloc
   ...
   fun:PyList_Append
   fun:add_subclass*
   fun:PyType_Ready
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# From pycoolutilities.oracle.regression test
# [NB: _vgnU_freeres (vg_preloaded.c) is a valgrind method!]
#
{
   <python26_PyExit_dlclose_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:_dl_close_worker
   fun:_dl_close
   fun:_dl_catch_error
   fun:__libc_dlclose
   fun:free_mem
   fun:__libc_freeres
   fun:_vgnU_freeres
   fun:exit
   fun:Py_Exit
}
#============================================================================
# *** BOOST *** More complex OCI, CORAL, COOL tests
#============================================================================
#
# Memory leak (bytes are still reachable in loss record)
# [Ignore: http://stackoverflow.com/questions/6321602/boost-thread-leakage-c]
# [Ignore: http://boost.2283326.n4.nabble.com/thread-Memory-leak-in-Boost-Thread-td2648030.html]
# From 'test_Integration_ObjectConsistency oracle test_threads'
#
{
   <boost_detail_get_once_per_thread_epoch_malloc_FAKE_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:*boost*detail*get_once_per_thread_epoch*
   fun:*boost*call_once*
   fun:*boost*detail*get_current_thread_data*
}
#============================================================================
# *** CORAL *** More complex OCI, CORAL, COOL tests
#============================================================================
#
# Memory leak (bytes are still reachable in loss record)
# [NB This leak can be ignored: we do not unload dynamically loaded plugins]
# From 'test_Integration_ObjectConsistency oracle test_threads' ("alloc")
#
{
   <coral_PluginManager_loadLibrary_dlopen_alloc_FAKE_LEAK>
   Memcheck:Leak
   fun:*alloc
   ...
   fun:_dlerror_run
   fun:dlopen@@GLIBC*
   fun:*coral*PluginManager*loadLibrary*
   ...
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# [NB: TO BE CHECKED, IS THIS A REAL LEAK (bug #98958)?]
# From unit.coralkernel_pluginmanager test ("new" in XMLAuthenticationService)
#
#{
#   <coral_PluginManager_loadLibrary_dlopen_new_TOBECHECKED_LEAK>
#   Memcheck:Leak
#   fun:_Zn*m
#   ...
#   fun:_dlerror_run
#   fun:dlopen@@GLIBC*
#   fun:*coral*PluginManager*loadLibrary*
#   ...
#}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# [NB This leak can be ignored: we do not unload dynamically loaded plugins]
# From qmtest suite (e.g. unit.coralkernel_pluginmanager)
#
{
   <coral_PluginManager_loadLibrary_dlsym_alloc_FAKE_LEAK>
   Memcheck:Leak
   fun:*alloc
   ...
   fun:_dlerror_run
   fun:dlsym
   fun:*coral*PluginManager*loadLibrary*
   ...
}
#----------------------------------------------------------------------------
#
# Bytes are still reachable in loss record 
# From 'coralServer' through 'CoralAccess server' test
# NB This is a real leak and has been filed as bug #98792
#
{
   <coral_CoralMonitor23patches_coralRunCSVPlotter_bug98792_REAL_LEAK>
   Memcheck:Leak
   fun:malloc
   fun:_dl_map_object_deps
   fun:dl_open_worker
   fun:_dl_catch_error
   fun:_dl_open
   fun:do_dlopen
   fun:_dl_catch_error
   fun:__libc_dlopen_mode
   fun:pthread_cancel_init
   fun:_Unwind_ForcedUnwind
   fun:__pthread_unwind
   fun:pthread_exit
   fun:*coral*runCSVPlotter*
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# This seems to appear only in PyCoral and PyCool tests (bug #100599)
{
   <python_memalign_bug100599_LEAK>
   Memcheck:Leak
   fun:memalign
   fun:__tls_get_addr
   fun:__cxa_get_globals
   fun:__cxa_allocate_exception
   ...
   fun:PyEval_EvalFrameEx
}
#============================================================================
# *** PyCORAL *** Simple and more complex PyCoral tests
#============================================================================
#
# Memory leak (bytes are still reachable in loss record)
# From "python -c 'import coral'"
#
{
   <coral_PyCoral_import_LEAK>
   Memcheck:Leak
   fun:realloc
   fun:PyList_Append
   fun:PyType_Ready
   fun:type_new
   fun:type_call
   fun:PyObject_Call
   fun:PyObject_CallFunction
   fun:PyErr_NewException
   fun:*coral*PyCoral*Exception*
   fun:initliblcg_PyCoral
   fun:_PyImport_LoadDynamicModule
   fun:import_submodule
   fun:load_next
   fun:import_module*
   fun:PyImport_ImportModuleLevel
}
#============================================================================
# *** PyROOT *** PyROOT and PyCool tests
#============================================================================
#
# Memory leak (bytes are still reachable in loss record)
# From "python -c 'import ROOT'"
#
{
   <ROOT_PyImport_PyROOT_LEAK>
   Memcheck:Leak
   ...
   fun:*PyROOT*
   ...
   fun:import_submodule
   fun:load_next
   fun:import_module*
   fun:PyImport_ImportModuleLevel
}
{
   <ROOT_PyImport_readline_LEAK>
   Memcheck:Leak
   ...
   fun:initreadline
   fun:_PyImport_LoadDynamicModule
   fun:import_submodule
   fun:load_next
   fun:import_module*
   fun:PyImport_ImportModuleLevel
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# From "python -c 'import ROOT'"
# [official $ROOTSYS/etc/valgrind-root.supp]
#
{
   <ROOT_TClass_Init_Znam_LEAK>
   Memcheck:Leak
   fun:_Znam
   ...
   fun:_ZN6TClass4InitEPKcs*
}   
{
   <ROOT_TClass_Init_Znwm_LEAK>
   Memcheck:Leak
   fun:_Znwm
   ...
   fun:_ZN6TClass4InitEPKcs*
}
#----------------------------------------------------------------------------
#
# Memory leak (bytes are still reachable in loss record)
# From "python -c 'import ROOT'"
# From "python -c 'import PyCool'"
# From the PyCool coralattributelist test
# Brute force to remove errors from simple and complex PyCool tests
#
{
   <ROOT_libCore_new_LEAK>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libCore.so
}
{
   <ROOT_libCore_new_LEAK1>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libstdc++.so*
   obj:*libCore.so*
}
{
   <ROOT_libCore_new_LEAK2>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libCore.so*
}
{
   <ROOT_libCore_new_LEAK3>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libCore.so*
}
{
   <ROOT_libCore_alloc_LEAK>
   Memcheck:Leak
   fun:*alloc
   obj:*libCore.so
}
{
   <ROOT_libCint_new_LEAK>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libCint.so
}
{
   <ROOT_libCint_alloc_LEAK>
   Memcheck:Leak
   fun:*alloc
   obj:*libCint.so
}
{
   <ROOT_libPyROOT_new_LEAK>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libPyROOT.so
}
{
   <ROOT_libPyROOT_new_LEAK1>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libstdc++.so*
   obj:*libPyROOT.so
}
{
   <ROOT_libPyROOT_new_LEAK2>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libPyROOT.so
}
{
   <ROOT_libPyROOT_new_LEAK3>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libPyROOT.so
}
{
   <ROOT_libPyROOT_new_LEAK4>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libstdc++.so*
   obj:*libPyROOT.so
}
{
   <ROOT_libPyROOT_alloc_LEAK>
   Memcheck:Leak
   fun:*alloc
   obj:*libPyROOT.so
}
{
   <ROOT_libReflex_new_LEAK>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libReflex.so
}
{
   <ROOT_libReflex_alloc_LEAK>
   Memcheck:Leak
   fun:*alloc
   obj:*libReflex.so
}
{
   <ROOT_libCintex_new_LEAK>
   Memcheck:Leak
   fun:_Zn*m
   obj:*libCintex.so
}
{
   <ROOT_libCintex_alloc_LEAK>
   Memcheck:Leak
   fun:*alloc
   obj:*libCintex.so
}
#----------------------------------------------------------------------------
