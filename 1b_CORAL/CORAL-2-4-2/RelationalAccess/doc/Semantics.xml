<sect2>
<title>Description of the RelationalAccess API functionality</title>
<sect3><title>Design of the Interfaces</title>

<sect4><title>UML diagram of the abstract classes</title>
<para> The public interfaces of the CORAL API are depicted in the following UML class diagram.
<mediaobject>
<imageobject>
<imagedata fileref="RelationalAccess_pics/Interfaces.png" align="center" format="PNG"/> 
</imageobject>
</mediaobject>
</para>
</sect4>

<sect4><title>Exceptions</title>
<para>Most of the methods of the abstract interfaces return a void or a reference to
an object. In case of error conditions there is usually an error message in the form
of a SEAL message stream that is generated by the implementation plugin. In addition to
that a relevant C++ exception is thrown. All exceptions thrown by coral derive from the
base <emphasis role="bold">coral::Exception</emphasis> class, which in
turn is an extension of the SEAL Exception. Which specific exception is thrown in each
case is documented in the methods of the RelationalAccess interfaces and it is part
of the method semantics. The full exception hierarchy is shown in the following UML class diagram.
<mediaobject>
<imageobject>
<imagedata fileref="RelationalAccess_pics/Exceptions.png" align="center" format="PNG"/> 
</imageobject>
</mediaobject>
</para>
</sect4>
</sect3>

<sect3><title>Accessing a database</title>

<sect4><title>The Relational Service and Technology Domains</title>
<para>The software entry point for accessing a relational database through the RelationalAccess package is the <emphasis role="bold">IRelationalService</emphasis>
interface. CORAL provides a default implementation as a SEAL component with the label "CORAL/Services/RelationalService". For more details refer to the
documentation of the <emphasis role="bold">RelationalService</emphasis> package.</para>
<para>
The IRelationalService interface provides access to <emphasis role="bold">IRelationalDomain</emphasis> objects for the various different technology types.
The IRelationalDomain interface provides information about the technology type, the implementation of the corresponding plugin module and its version.</para>
<para>
An IRelationalDomain object is retrieved by the IRelationalService specifying either the technology type, or a connection string (which contains the technology type).
The IRelationalDomain is the base class for the corresponding SEAL component of a technology plugin. The component should be named according to the technology name
with the following convention: If the technology type is "MyRDBMS", then the IRelationalService will be searching for a plugin labeled as
"CORAL/RelationalPlugins/MyRDBMS". Optionally the implementation name can be specified.
In this case the plugin should be labeled as "CORAL/RelationalPlugins/MyRDBMS/MyImplementation".</para>
<para>
The Relational Service may handle several implementation plugins for a given RDBMS technology. By default a native implementation
(a plugin where the implementation name is not specified in its label) has a higher priority than all the others.
A user can at any moment change the default implementation for a given technology either through the IRelationalService API, or by setting accordingly the
corresponding property of the Relational Service implementation.
</para>
</sect4>

<sect4>
<title>Connection strings</title>
<para>
The IRelationalDomain interface acts as a factory for
<emphasis role="bold">IConnection</emphasis> objects which are
used for the physical connection to a relational database. Such an
object is obtained by specifying a connection string which has to have
the format
<programlisting>
technology_protocol://hostName:portNumber/databaseOrSchemaName
</programlisting>
where technology can be oracle, mysql, odbc, etc. (all small letters) and
refers to the actual plugin implementing the RelationalAccess abstract
interfaces. The protocol is optional and can be file, http, etc. It is
used for server-less, file-based databases, like SQLite.
The port number is optional as well.
</para>
<para>With a given IConnection object a user may start a session,
using the <emphasis role="bold">ISession</emphasis> interface, with
its associated transactional context. In case the back-end allows, for
the same connecion, several parallel and independent sessions may me started.</para>
</sect4>

<sect4>
<title>The authentication mechanism</title>
<para>The ISession interface allows a user authenticate to a
database specifying a user name and a password. Alternatively a
reference to an <emphasis role="bold">IAuthenticationService</emphasis>
object may be passed explicitly or implicitly looking for such a
registered service anywhere in the corresponding context tree.
</para>
<para>The IAuthenticationService is a simple interface which returns
for a given connection string the connection credentials (typically
user name and password) through an <emphasis role="bold">IAuthenticationCredentials</emphasis> object.
It has been introduced in the design of the
component so that authentication parameters need not appear in the
connection string, which may have to be shared by users with different
access rights. Refer to the relevant documentation for the semantics
of the existing implementations of this interface.
</para>
</sect4>


<sect4><title>Service Indirection</title>
<para>The CORAL API accomodates the use case where relational data may be distributed on a computing grid.
In this case a user addresses a database service not through its physical characteristics, but rather
using a logical name. The <emphasis role="bold">ILookupService</emphasis> class defines the interface
that a software module performing logical-to-physical name lookups for database services. A user, may
specify not only the logical name, but may also restrict the lookup with the access mode (database role)
and the authentication mechanism for the available replicas. The result of the lookup operation is an
<emphasis role="bold">IDatabaseServiceSet</emphasis> object, which is a container of
<emphasis role="bold">IDatabaseServiceDescription</emphasis> objects. An IDatabaseServiceDescription
describes a replica which fulfills the lookup criteria. The ILookupService returns the available replicas
in the order that they should be tried out.</para>
<para>The Lookup Service can be through of as the equivalent of the File Catalog in the POOL framework.</para>
<para>The ILookupService interface delivers the list of all the
available replicas corresponding to a logical name with an ordering
which is dependent on the back end. In grid applications accessing
databases in a distributed environment a re-ordering might be
desirable in order to pick up first the most proximate database
service. To this end the CORAL API defines an <emphasis role="bold">IReplicaSortingAlgorithm.h</emphasis> interface whose implementations can be used to
encode any ordering logic.</para>
</sect4>


<sect4><title>Client-side Monitoring</title>
<para>In a production environment it is important to monitor the activities in a database server. The monitoring
output gives hints not only on how to tune applications and optimize schemas. It also contributes towards the
definition of the most efficient deployment models and hardware configurations. Server-side monitoring is usually
a responsibility of the database administrators. It produces information such as the performance of the server
as a function of the number of concurrent clients running an application, or the most frequent or resource consuming
operations.</para>
<para>Client-side monitoring can be used to gather information which is specific to a particular application. Combined
with the information of the server-side monitoring it may reveal the contribution of the specific application to
the server load and/or the need for tuning of the application itself, or it may hint problems in the deployment
model.</para>
<para>CORAL facilitates client-side monitoring with the
<emphasis role="bold">IMonitoringService</emphasis> developer-level interface. It is an interface which is used
by the RDBMS-specific plugin implementations to register events that need to be monitored. Such events are the
connecting to and disconnecting from a database server, the starting and ending of a user session, the signaling of
transaction boundaries, and mostly important the issuing of SQL statements and the associated execution time.</para>
<para>In order for a RDBMS-specific plugin implementation to record monitoring data it is necessary that there is
an implementation of the IMonitoringService interface, defined as a SEAL component, reachable by the plugin through
its local context tree (like an IAuthenticationService implementation). Moreover, the user should explicitly enable the
monitoring, specifying also the verbosity level, through the <emphasis role="bold">IMonitoring</emphasis> interface
accessible through the ISession.</para>
<para>The reporting of the monitoring events is done through the <emphasis role="bold">IMonitoringReporter</emphasis>
interface accessible from the IMonitoringService object.
</para>
</sect4>


<sect4><title>Connecting to a database in the most generic way</title>
<para>In CORAL, connecting to a database, starting a user session and
authenticating are three separate operations.
The IConnection and ISession interfaces have been designed such that they can facilitate application-level connection pooling.
The <emphasis role="bold">IConnectionService</emphasis> is the interface for components that are responsible
for providing to the client components handles to physical connections that are re-used and probed for the
status of the physical connection before they are made available for use. In particular, the IConnectionService
is an abstract factory for <emphasis role="bold">ISessionProxy</emphasis> objects which make sure that a physical
connection to the underlying server is always valid.</para>
<para>The use of the IConnectionService is highly recommended in applications in a distributed environment, since
any implementation is responsible of provide a valid ISessionProxy object which corresponds to the best replica
of a logical database service. In that respect, the role of an IConnectionService implementation is the general
coordination of the various high-level CORAL components. Thus an IConnectionService has to:
<itemizedlist>
<listitem>Load if necessary an implementation of the IRelationalService interface and use it internally in subsequent calls.</listitem>
<listitem>Load if necessary an implementation of the IAuthenticationService and use it internally in subsequent calls.</listitem>
<listitem>Load if necessary an implementation of the IMonitoringService and issue calls to the IMonitoring interface of the ISession objects it manages.</listitem>
<listitem>Load if necessary an implementation of the ILookupService and use it whenever a logical database service name is specified in a request for an ISessionProxy.</listitem>
</itemizedlist>
</para>
<para>The Connection Service will also make sure that the number of
physical connections to a given database is minimized, by creating
several ISession objects under a single IConnection.</para>
<para>The IConnectionService interface can also be used for configuring a CORAL-based application. In particular, its
<emphasis role="bold">IConnectionServiceConfiguration</emphasis> interface can be used to select the particular implementations of
the various interfaces that should be loaded. Moreover, it can be used to override the default parameters that are related to
the connection re-attempting and replica failover mechanisms.</para>
<para>Finally, it provides access to IMonitoringReporter interface of
the loaded IMonitoringService, to allow a user trigger the reporting
of the monitoring events.</para>

<para>Given that the IConnectionService is the logical entry point for
CORAL, as of release 1.7.0, a ConnectionService facade object is
defined, which implements the IConnectionService interface and hides
all the underlying complexities related to the loading and looking up
of the various plugin libraries.</para>
</sect4>


<sect4>
<title>Transactional context</title>
<para>Every operation with a relational database using the
RelationalAccess component is executed within a transactional
context. There is a single transactional context for each session.
A reference to the <emphasis role="bold">ITransaction</emphasis>
interface can be retrieved by an ISession object once a
connection has been established.</para>
<para>A user can start a transaction in an update (default) or
read-only mode, commit and roll back the changes.
</para>
</sect4>


</sect3>



<sect3>
<title>Managing schemas</title>
<para>
Once connected to a relational database, the user works with the data
defined under the schema defined for the table collection (MySQL database, Oracle user schema,
SQLite file, etc.) specified in the connection string. The <emphasis role="bold">ISchema</emphasis>
interface which is retrieved by the ISession (or ISessionProxy) object allows the user to list,
create and drop tables in the working schema. This is the <emphasis>nominal working schema</emphasis>,
defined by the connection string itself. A user may also work with any other named schema for which
the necessary access rights have been granted, through the relevant call in ISession (or ISessionProxy).
The ISchema object which is obtained is completely independent from the nominal or other named ones.
The only things that are shared are the transaction sequence and the type converter.
</para>
<para>
The ISchema can be used to retrieve a reference to an
<emphasis role="bold">ITable</emphasis> object specifying
its name. This interface allows the user to
<itemizedlist>
<listitem><para>retrieve the description of the corresponding table
via the <emphasis role="bold">ITableDescription</emphasis>
interface</para></listitem>
<listitem><para>set the access privileges using the
<emphasis role="bold">ITablePrivilegeManager</emphasis> interface
</para></listitem>
<listitem><para>alter the table definition using the
<emphasis role="bold">ITableSchemaEditor</emphasis> interface
</para></listitem>
<listitem><para>perform data manipulation on the table through the
<emphasis role="bold">ITableDataEditor</emphasis> interface
</para></listitem>
<listitem><para>execute queries with the data of the corresponding table</para></listitem>
</itemizedlist>
</para>

<para>The ITableDescription object allows the user to retrieve the
following information from a table:
<itemizedlist>
<listitem>The column names and types (the C++ equivalents)</listitem>
<listitem>The NULLness and the UNIQUEness of a column</listitem>
<listitem>The definition (column names) of its primary key, in case there is one,
using the <emphasis role="bold">IPrimaryKey</emphasis> 
interface</listitem>
<listitem>The definitions (key name, column names, referenced table,
referenced columns) of its foreign keys using the 
<emphasis role="bold">IForeignKey</emphasis> interface</listitem>
<listitem>The definitions (column names, uniqueness) of its indices
using the <emphasis role="bold">IIndex</emphasis> interface</listitem>
<listitem>The definitions (column names) of its multi-column unique constraints
using the <emphasis role="bold">IUniqueConstraint</emphasis> interface</listitem>
</itemizedlist>
</para>

<para>
In order to create a new table in the schema the user has to construct
an ITableDescription object and pass it to the ISchema.
The component provides the <emphasis>TableDescription</emphasis> class which implements
the ITableDescription and ITableSchemaEditor interfaces for this purpose.
</para>

<para>
Views can be created using <emphasis role="bold">IViewFactory</emphasis> objects which can obtained
from the ISchema interface. They extend the <emphasis role="bold">IQueryDefinition</emphasis> interface
and are used to create <emphasis role="bold">IView</emphasis> objects, which can be used to retrieve the original
definition of the created views and to describe their columns.
</para>

<para>By default, for most technologies, a table or view is created without
any access right to anybody but the table owner. It is therefore a
good practice for tables that will be exposed to other database users
to use the ITablePrivilegeManager interface to grant the
relevant access rights immediatelly after the table creation.
</para>


<para>Note that the semantics of the interfaces assume that the names
of the tables, views, columns, keys, indices and constraints are case sensitive.
Given though that some databases do not preserve the case, it is highly
recommended to capitalize all such system names, especially if the CORAL
is expected to be used for cross-populating databases of different
technologies.</para>
</sect3>



<sect3>
<title>Performing data manipulation</title>
<para>
The ITableDataEditor allows the privileged user perform DML
operations on a table. In particular it is allowed to
<itemizedlist>
<listitem>Insert a new row. The input row is fed with an
AttributeList with an AttributeListSpecification that is compatible to
a subset of the table's columns and types.</listitem>
<listitem>Modify existing rows. In this case the SET and WHERE
clauses of the corresponding SQL statement have to be provided by the
user. The user is recommended to use bind variables for the WHERE and
SET clauses which can be passed through an AttributeList.</listitem>
<listitem>Delete existing rows. In this case the WHERE
clause of the corresponding SQL statement have to be provided by the
user. The user is recommended to use bind variables for the WHERE clause.</listitem>
<listitem>Insert query result sets (INSERT-SELECT statements) using an <emphasis role="bold">IOperationWithQuery</emphasis> object.</listitem>
<listitem>Perform bulk operations of the above using <emphasis role="bold">IBulkOperation</emphasis> and
<emphasis role="bold">IBulkOperationWithQuery</emphasis> objects. Such operations are highly recommmended in repetitive operations
where only the input data change. In this case the user specifies the row buffer to be bound and the number of rows to be cached
at the client side before the data are actually sent to the server.</listitem>
</itemizedlist>
</para>

</sect3>



<sect3>
<title>Issuing queries</title>
<para>Queries can by issued using the <emphasis role="bold">IQuery</emphasis> interface.
The ISchema and ITable interfaces acts as a factories of IQuery objects. The IQuery class
extends the <emphasis role="bold">IQueryDefinition</emphasis> class, which is the interface
for defining the query logic. A query is formed by
<itemizedlist>
<listitem><emphasis>Specifying the output variables</emphasis>. In case the IQuery object
has been constructed from an ITable, if no variable is specified a wildcard query is formed.
For each variable an alias can be specified.</listitem>

<listitem><emphasis>Specifying the table list</emphasis>. In case the IQuery object
has been constructed from an ITable this is not required. In case of a general query
the name of a table or a view can be specified, providing optionally an alias.</listitem>

<listitem><emphasis>Defining the query condition</emphasis>. The
user has to specify the WHERE clause of the corresponding SQL
statement. It is highly recommended to use bind variables passing the
corresponding AttributeList.</listitem>

<listitem><emphasis>Specifying order variables</emphasis>. By
doing so the user instructs the system to append to the SQL query an
ORDER BY clause.</listitem>

<listitem><emphasis>Limiting the number rows in the result
set</emphasis>. This is a very useful operation when the maximum number of
rows that will be retrieved at a query is known.</listitem>

<listitem><emphasis>Defining sub-queries</emphasis>. A user can define a sub-query by
retrieving a reference to an IQueryDefinition, whose result-set can be used as an input table
in the parent query.</listitem>

<listitem><emphasis>Apply set operations</emphasis>. A user can define a query by
retrieving a reference to an IQueryDefinition which appears as the RHS query in the resulting SQL statement.</listitem>

</itemizedlist>
</para>

<para>
The IQuery interface controls the actual execution of the query by:
<itemizedlist>
<listitem><emphasis>Defining the return type of the output variables</emphasis>
The return type of the output variables or expressions is internally deduced by the RDBMS client software.
However, the user may redefine the output types, either fully by specifying an AttributeList to be
used as the output buffer, or by partially by specifying the C++ type of a column in the result set.</listitem>

<listitem><emphasis>Defining the number of prefetched rows or
the size of the buffer on the client side for the rows if the result
set</emphasis>. This operation can be used to reduce the number of
roundtrips to the server for fetching the result of a query.</listitem>

<listitem><emphasis>Locking the rows of the result set</emphasis>.
This operation blocks other concurrent clients from updating the affected rows. This is a useful feature which
serves the use cases where the protection of data consistency from parallel write/update applications is required.</listitem>
</itemizedlist>

On execution the IQuery interface returns a reference to an <emphasis role="bold">ICursor</emphasis> object. It is simply
an iterator over the rows of the result set. The Attributes in the output buffer (AttributeList) have the values of the
underlying variables updated in every iteration. The associated boolean variables expressing the NULL-ness of the values
are updated as well.</para>
</sect3>

<sect3><title>Controlling the behaviour of web caches</title>
<para>
Some RDBMS implementations may use a web cache for fast retrieval and
efficient deployment of read-only data. This comes with the cost of
the risk that data may become stale from some moment and
onwards. Depending on the data model an application may be designed
that some tables should always be refreshed before they are accessed
for the first time within an application.
</para>
<para>CORAL allows an application to fully control of web caches
through the use of the <emphasis role="bold">IWebCacheControl</emphasis> interface,
that can be retrieved from an IConnectionService object. This
interface allows the client component to define policies related to a
particular schema, as this is defined by the logical or physical
connection string. The RDBMS plugins may use then the caching policies defined by the client
components, through calls to the
<emphasis role="bold">IWebCacheInfo</emphasis> objects corresponding
to the particular schema.
</para>
</sect3>

</sect2>


<sect2>
<title>Example of usage of the RelationalAccess API</title>
<para>
Examples of usage of the CORAL API can be found under the CORAL integration tests:

<variablelist>

<varlistentry><term>Schema creation and information retrieval</term>
<listitem><ulink url="http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/SchemaDefinition.cpp">http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/SchemaDefinition.cpp</ulink></listitem>
</varlistentry>

<varlistentry><term>Data manipulation</term>
<listitem><ulink url="http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/DmlOperations.cpp">http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/DmlOperations.cpp</ulink></listitem>
<listitem><ulink url="http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/InsertSelect.cpp">http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/InsertSelect.cpp</ulink></listitem>
</varlistentry>

<varlistentry><term>Queries</term>
<listitem><ulink url="http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/Queries.cpp">http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/Queries.cpp</ulink></listitem>
<listitem><ulink url="http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/SetOperations.cpp">http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Basic/src/SetOperations.cpp</ulink></listitem>
</varlistentry>

<varlistentry><term>Connecting using the Connection Service</term>
<listitem><ulink url="http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_ConnectionService/">http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_ConnectionService/</ulink></listitem>
</varlistentry>

<varlistentry><term>Enabling client-side monitoring</term>
<listitem><ulink url="http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Monitoring/">http://coral.cvs.cern.ch/cgi-bin/coral.cgi/coral/Tests/Integration_Monitoring/</ulink></listitem>
</varlistentry>

</variablelist>

</para>
</sect2>
