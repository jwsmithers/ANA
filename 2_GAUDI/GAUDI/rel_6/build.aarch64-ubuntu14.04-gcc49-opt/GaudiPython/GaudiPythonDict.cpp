// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME GaudiPythonDict

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;

// Header files passed as explicit arguments
#include "/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/GaudiPython/dict/kernel.h"

// Header files passed via #pragma extra_include

namespace ROOT {
   static TClass *__gnu_cxxcLcLdummy_Dictionary();
   static void __gnu_cxxcLcLdummy_TClassManip(TClass*);
   static void *new___gnu_cxxcLcLdummy(void *p = 0);
   static void *newArray___gnu_cxxcLcLdummy(Long_t size, void *p);
   static void delete___gnu_cxxcLcLdummy(void *p);
   static void deleteArray___gnu_cxxcLcLdummy(void *p);
   static void destruct___gnu_cxxcLcLdummy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::dummy*)
   {
      ::__gnu_cxx::dummy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::dummy));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::dummy", "invalid", 238,
                  typeid(::__gnu_cxx::dummy), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcLdummy_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::dummy) );
      instance.SetNew(&new___gnu_cxxcLcLdummy);
      instance.SetNewArray(&newArray___gnu_cxxcLcLdummy);
      instance.SetDelete(&delete___gnu_cxxcLcLdummy);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcLdummy);
      instance.SetDestructor(&destruct___gnu_cxxcLcLdummy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::dummy*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::dummy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::dummy*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcLdummy_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::dummy*)0x0)->GetClass();
      __gnu_cxxcLcLdummy_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcLdummy_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,SmartIF<IService> >,const string>*)
   {
      ::unary_function<pair<const string,SmartIF<IService> >,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,SmartIF<IService> >,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,SmartIF<IService> >,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,SmartIF<IService> >,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,SmartIF<IService> >,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,SmartIF<IService> >,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,SmartIF<IService> >,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>*)
   {
      ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,AIDA::IHistogram3D*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<GaudiAlg::ID,unsigned long>*)
   {
      ::unary_function<GaudiAlg::ID,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<GaudiAlg::ID,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<GaudiAlg::ID,unsigned long>", "string", 105,
                  typeid(::unary_function<GaudiAlg::ID,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<GaudiAlg::ID,unsigned long>) );
      instance.SetNew(&new_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<GaudiAlg::ID,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<GaudiAlg::ID,unsigned long>*)0x0)->GetClass();
      unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>*)
   {
      ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,AIDA::IHistogram1D*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>*)
   {
      ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,AIDA::IHistogram2D*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,AIDA::IProfile1D*>,const string>*)
   {
      ::unary_function<pair<const string,AIDA::IProfile1D*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,AIDA::IProfile1D*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,AIDA::IProfile1D*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,AIDA::IProfile1D*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,AIDA::IProfile1D*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IProfile1D*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IProfile1D*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,AIDA::IProfile2D*>,const string>*)
   {
      ::unary_function<pair<const string,AIDA::IProfile2D*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,AIDA::IProfile2D*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,AIDA::IProfile2D*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,AIDA::IProfile2D*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,AIDA::IProfile2D*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IProfile2D*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,AIDA::IProfile2D*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<bool>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<bool>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<bool>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<bool>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<bool>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<bool>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<bool>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<bool>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<char>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<char>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<char>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<char>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<char>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<char>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<char>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<char>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<short>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<short>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<short>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<short>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<short>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<short>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<short>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<short>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<int>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<int>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<int>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<int>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<int>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<int>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<int>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<int>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<float>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<float>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<float>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<float>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<float>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<float>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<float>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<float>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<double>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<double>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<double>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<double>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<double>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<double>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<double>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<double>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Array<float>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Array<float>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Array<float>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Array<float>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Array<float>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Array<float>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Array<float>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Array<float>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>*)
   {
      ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,NTuple::Matrix<float>*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,Tuples::TupleObj*>,const string>*)
   {
      ::unary_function<pair<const string,Tuples::TupleObj*>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,Tuples::TupleObj*>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,Tuples::TupleObj*>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,Tuples::TupleObj*>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,Tuples::TupleObj*>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,Tuples::TupleObj*>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,Tuples::TupleObj*>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEcharcOboolgR_Dictionary();
   static void unary_functionlEcharcOboolgR_TClassManip(TClass*);
   static void *new_unary_functionlEcharcOboolgR(void *p = 0);
   static void *newArray_unary_functionlEcharcOboolgR(Long_t size, void *p);
   static void delete_unary_functionlEcharcOboolgR(void *p);
   static void deleteArray_unary_functionlEcharcOboolgR(void *p);
   static void destruct_unary_functionlEcharcOboolgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<char,bool>*)
   {
      ::unary_function<char,bool> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<char,bool>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<char,bool>", "string", 105,
                  typeid(::unary_function<char,bool>), DefineBehavior(ptr, ptr),
                  &unary_functionlEcharcOboolgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<char,bool>) );
      instance.SetNew(&new_unary_functionlEcharcOboolgR);
      instance.SetNewArray(&newArray_unary_functionlEcharcOboolgR);
      instance.SetDelete(&delete_unary_functionlEcharcOboolgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEcharcOboolgR);
      instance.SetDestructor(&destruct_unary_functionlEcharcOboolgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<char,bool>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEcharcOboolgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<char,bool>*)0x0)->GetClass();
      unary_functionlEcharcOboolgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEcharcOboolgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR_Dictionary();
   static void unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR_TClassManip(TClass*);
   static void *new_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p = 0);
   static void *newArray_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(Long_t size, void *p);
   static void delete_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p);
   static void deleteArray_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p);
   static void destruct_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<pair<const string,string>,const string>*)
   {
      ::unary_function<pair<const string,string>,const string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<pair<const string,string>,const string>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<pair<const string,string>,const string>", "string", 105,
                  typeid(::unary_function<pair<const string,string>,const string>), DefineBehavior(ptr, ptr),
                  &unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<pair<const string,string>,const string>) );
      instance.SetNew(&new_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR);
      instance.SetNewArray(&newArray_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR);
      instance.SetDelete(&delete_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR);
      instance.SetDestructor(&destruct_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<pair<const string,string>,const string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<pair<const string,string>,const string>*)0x0)->GetClass();
      unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEconstsPcharmUcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEconstsPcharmUcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEconstsPcharmUcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<const char*,unsigned long>*)
   {
      ::unary_function<const char*,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<const char*,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<const char*,unsigned long>", "string", 105,
                  typeid(::unary_function<const char*,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEconstsPcharmUcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<const char*,unsigned long>) );
      instance.SetNew(&new_unary_functionlEconstsPcharmUcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEconstsPcharmUcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEconstsPcharmUcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEconstsPcharmUcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEconstsPcharmUcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<const char*,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEconstsPcharmUcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<const char*,unsigned long>*)0x0)->GetClass();
      unary_functionlEconstsPcharmUcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEconstsPcharmUcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEboolcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEboolcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEboolcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEboolcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEboolcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEboolcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEboolcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<bool,unsigned long>*)
   {
      ::unary_function<bool,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<bool,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<bool,unsigned long>", "string", 105,
                  typeid(::unary_function<bool,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEboolcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<bool,unsigned long>) );
      instance.SetNew(&new_unary_functionlEboolcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEboolcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEboolcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEboolcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEboolcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<bool,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEboolcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<bool,unsigned long>*)0x0)->GetClass();
      unary_functionlEboolcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEboolcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEcharcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEcharcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEcharcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEcharcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEcharcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEcharcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEcharcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<char,unsigned long>*)
   {
      ::unary_function<char,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<char,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<char,unsigned long>", "string", 105,
                  typeid(::unary_function<char,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEcharcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<char,unsigned long>) );
      instance.SetNew(&new_unary_functionlEcharcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEcharcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEcharcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEcharcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEcharcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<char,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEcharcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<char,unsigned long>*)0x0)->GetClass();
      unary_functionlEcharcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEcharcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEsignedsPcharcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEsignedsPcharcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEsignedsPcharcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<signed char,unsigned long>*)
   {
      ::unary_function<signed char,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<signed char,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<signed char,unsigned long>", "string", 105,
                  typeid(::unary_function<signed char,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEsignedsPcharcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<signed char,unsigned long>) );
      instance.SetNew(&new_unary_functionlEsignedsPcharcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEsignedsPcharcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEsignedsPcharcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEsignedsPcharcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEsignedsPcharcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<signed char,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEsignedsPcharcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<signed char,unsigned long>*)0x0)->GetClass();
      unary_functionlEsignedsPcharcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEsignedsPcharcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEunsignedsPcharcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEunsignedsPcharcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEunsignedsPcharcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<unsigned char,unsigned long>*)
   {
      ::unary_function<unsigned char,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<unsigned char,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<unsigned char,unsigned long>", "string", 105,
                  typeid(::unary_function<unsigned char,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEunsignedsPcharcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<unsigned char,unsigned long>) );
      instance.SetNew(&new_unary_functionlEunsignedsPcharcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEunsignedsPcharcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEunsignedsPcharcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEunsignedsPcharcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEunsignedsPcharcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<unsigned char,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEunsignedsPcharcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<unsigned char,unsigned long>*)0x0)->GetClass();
      unary_functionlEunsignedsPcharcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEunsignedsPcharcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEwchar_tcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEwchar_tcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEwchar_tcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEwchar_tcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEwchar_tcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEwchar_tcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEwchar_tcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<wchar_t,unsigned long>*)
   {
      ::unary_function<wchar_t,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<wchar_t,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<wchar_t,unsigned long>", "string", 105,
                  typeid(::unary_function<wchar_t,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEwchar_tcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<wchar_t,unsigned long>) );
      instance.SetNew(&new_unary_functionlEwchar_tcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEwchar_tcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEwchar_tcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEwchar_tcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEwchar_tcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<wchar_t,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEwchar_tcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<wchar_t,unsigned long>*)0x0)->GetClass();
      unary_functionlEwchar_tcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEwchar_tcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEshortcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEshortcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEshortcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEshortcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEshortcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEshortcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEshortcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<short,unsigned long>*)
   {
      ::unary_function<short,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<short,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<short,unsigned long>", "string", 105,
                  typeid(::unary_function<short,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEshortcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<short,unsigned long>) );
      instance.SetNew(&new_unary_functionlEshortcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEshortcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEshortcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEshortcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEshortcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<short,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEshortcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<short,unsigned long>*)0x0)->GetClass();
      unary_functionlEshortcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEshortcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEunsignedsPshortcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEunsignedsPshortcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEunsignedsPshortcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<unsigned short,unsigned long>*)
   {
      ::unary_function<unsigned short,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<unsigned short,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<unsigned short,unsigned long>", "string", 105,
                  typeid(::unary_function<unsigned short,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEunsignedsPshortcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<unsigned short,unsigned long>) );
      instance.SetNew(&new_unary_functionlEunsignedsPshortcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEunsignedsPshortcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEunsignedsPshortcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEunsignedsPshortcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEunsignedsPshortcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<unsigned short,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEunsignedsPshortcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<unsigned short,unsigned long>*)0x0)->GetClass();
      unary_functionlEunsignedsPshortcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEunsignedsPshortcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEintcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEintcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEintcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEintcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEintcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEintcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEintcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<int,unsigned long>*)
   {
      ::unary_function<int,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<int,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<int,unsigned long>", "string", 105,
                  typeid(::unary_function<int,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEintcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<int,unsigned long>) );
      instance.SetNew(&new_unary_functionlEintcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEintcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEintcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEintcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEintcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<int,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEintcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<int,unsigned long>*)0x0)->GetClass();
      unary_functionlEintcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEintcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEunsignedsPintcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEunsignedsPintcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEunsignedsPintcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<unsigned int,unsigned long>*)
   {
      ::unary_function<unsigned int,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<unsigned int,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<unsigned int,unsigned long>", "string", 105,
                  typeid(::unary_function<unsigned int,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEunsignedsPintcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<unsigned int,unsigned long>) );
      instance.SetNew(&new_unary_functionlEunsignedsPintcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEunsignedsPintcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEunsignedsPintcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEunsignedsPintcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEunsignedsPintcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<unsigned int,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEunsignedsPintcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<unsigned int,unsigned long>*)0x0)->GetClass();
      unary_functionlEunsignedsPintcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEunsignedsPintcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlElongcOunsignedsPlonggR_Dictionary();
   static void unary_functionlElongcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlElongcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlElongcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlElongcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlElongcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlElongcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<long,unsigned long>*)
   {
      ::unary_function<long,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<long,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<long,unsigned long>", "string", 105,
                  typeid(::unary_function<long,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlElongcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<long,unsigned long>) );
      instance.SetNew(&new_unary_functionlElongcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlElongcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlElongcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlElongcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlElongcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<long,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlElongcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<long,unsigned long>*)0x0)->GetClass();
      unary_functionlElongcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlElongcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEunsignedsPlongcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEunsignedsPlongcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEunsignedsPlongcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<unsigned long,unsigned long>*)
   {
      ::unary_function<unsigned long,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<unsigned long,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<unsigned long,unsigned long>", "string", 105,
                  typeid(::unary_function<unsigned long,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEunsignedsPlongcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<unsigned long,unsigned long>) );
      instance.SetNew(&new_unary_functionlEunsignedsPlongcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEunsignedsPlongcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEunsignedsPlongcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEunsignedsPlongcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEunsignedsPlongcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<unsigned long,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEunsignedsPlongcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<unsigned long,unsigned long>*)0x0)->GetClass();
      unary_functionlEunsignedsPlongcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEunsignedsPlongcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEdoublecOunsignedsPlonggR_Dictionary();
   static void unary_functionlEdoublecOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEdoublecOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEdoublecOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEdoublecOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEdoublecOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEdoublecOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<double,unsigned long>*)
   {
      ::unary_function<double,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<double,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<double,unsigned long>", "string", 105,
                  typeid(::unary_function<double,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEdoublecOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<double,unsigned long>) );
      instance.SetNew(&new_unary_functionlEdoublecOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEdoublecOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEdoublecOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEdoublecOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEdoublecOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<double,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEdoublecOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<double,unsigned long>*)0x0)->GetClass();
      unary_functionlEdoublecOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEdoublecOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlElongsPdoublecOunsignedsPlonggR_Dictionary();
   static void unary_functionlElongsPdoublecOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlElongsPdoublecOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<long double,unsigned long>*)
   {
      ::unary_function<long double,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<long double,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<long double,unsigned long>", "string", 105,
                  typeid(::unary_function<long double,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlElongsPdoublecOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<long double,unsigned long>) );
      instance.SetNew(&new_unary_functionlElongsPdoublecOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlElongsPdoublecOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlElongsPdoublecOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlElongsPdoublecOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlElongsPdoublecOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<long double,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlElongsPdoublecOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<long double,unsigned long>*)0x0)->GetClass();
      unary_functionlElongsPdoublecOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlElongsPdoublecOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEstringcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEstringcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEstringcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEstringcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEstringcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEstringcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEstringcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<string,unsigned long>*)
   {
      ::unary_function<string,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<string,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<string,unsigned long>", "string", 105,
                  typeid(::unary_function<string,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEstringcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<string,unsigned long>) );
      instance.SetNew(&new_unary_functionlEstringcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEstringcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEstringcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEstringcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEstringcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<string,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEstringcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<string,unsigned long>*)0x0)->GetClass();
      unary_functionlEstringcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEstringcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>*)
   {
      ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>", "string", 105,
                  typeid(::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>) );
      instance.SetNew(&new_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>*)0x0)->GetClass();
      unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlELong64_tcOunsignedsPlonggR_Dictionary();
   static void unary_functionlELong64_tcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlELong64_tcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlELong64_tcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlELong64_tcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlELong64_tcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlELong64_tcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<Long64_t,unsigned long>*)
   {
      ::unary_function<Long64_t,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<Long64_t,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<Long64_t,unsigned long>", "string", 105,
                  typeid(::unary_function<Long64_t,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlELong64_tcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<Long64_t,unsigned long>) );
      instance.SetNew(&new_unary_functionlELong64_tcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlELong64_tcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlELong64_tcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlELong64_tcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlELong64_tcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<Long64_t,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlELong64_tcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<Long64_t,unsigned long>*)0x0)->GetClass();
      unary_functionlELong64_tcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlELong64_tcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEfloatcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEfloatcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEfloatcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEfloatcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEfloatcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEfloatcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEfloatcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<float,unsigned long>*)
   {
      ::unary_function<float,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<float,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<float,unsigned long>", "string", 105,
                  typeid(::unary_function<float,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEfloatcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<float,unsigned long>) );
      instance.SetNew(&new_unary_functionlEfloatcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEfloatcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEfloatcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEfloatcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEfloatcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<float,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEfloatcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<float,unsigned long>*)0x0)->GetClass();
      unary_functionlEfloatcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEfloatcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEULong64_tcOunsignedsPlonggR_Dictionary();
   static void unary_functionlEULong64_tcOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEULong64_tcOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEULong64_tcOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEULong64_tcOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEULong64_tcOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEULong64_tcOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<ULong64_t,unsigned long>*)
   {
      ::unary_function<ULong64_t,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<ULong64_t,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<ULong64_t,unsigned long>", "string", 105,
                  typeid(::unary_function<ULong64_t,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEULong64_tcOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<ULong64_t,unsigned long>) );
      instance.SetNew(&new_unary_functionlEULong64_tcOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEULong64_tcOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEULong64_tcOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEULong64_tcOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEULong64_tcOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<ULong64_t,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEULong64_tcOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<ULong64_t,unsigned long>*)0x0)->GetClass();
      unary_functionlEULong64_tcOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEULong64_tcOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlE__int128cOunsignedsPlonggR_Dictionary();
   static void unary_functionlE__int128cOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlE__int128cOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlE__int128cOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlE__int128cOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlE__int128cOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlE__int128cOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<__int128,unsigned long>*)
   {
      ::unary_function<__int128,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<__int128,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<__int128,unsigned long>", "string", 105,
                  typeid(::unary_function<__int128,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlE__int128cOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<__int128,unsigned long>) );
      instance.SetNew(&new_unary_functionlE__int128cOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlE__int128cOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlE__int128cOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlE__int128cOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlE__int128cOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<__int128,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlE__int128cOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<__int128,unsigned long>*)0x0)->GetClass();
      unary_functionlE__int128cOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlE__int128cOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEunsignedsP__int128cOunsignedsPlonggR_Dictionary();
   static void unary_functionlEunsignedsP__int128cOunsignedsPlonggR_TClassManip(TClass*);
   static void *new_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p = 0);
   static void *newArray_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(Long_t size, void *p);
   static void delete_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p);
   static void deleteArray_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p);
   static void destruct_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<unsigned __int128,unsigned long>*)
   {
      ::unary_function<unsigned __int128,unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<unsigned __int128,unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<unsigned __int128,unsigned long>", "string", 105,
                  typeid(::unary_function<unsigned __int128,unsigned long>), DefineBehavior(ptr, ptr),
                  &unary_functionlEunsignedsP__int128cOunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<unsigned __int128,unsigned long>) );
      instance.SetNew(&new_unary_functionlEunsignedsP__int128cOunsignedsPlonggR);
      instance.SetNewArray(&newArray_unary_functionlEunsignedsP__int128cOunsignedsPlonggR);
      instance.SetDelete(&delete_unary_functionlEunsignedsP__int128cOunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEunsignedsP__int128cOunsignedsPlonggR);
      instance.SetDestructor(&destruct_unary_functionlEunsignedsP__int128cOunsignedsPlonggR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<unsigned __int128,unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEunsignedsP__int128cOunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<unsigned __int128,unsigned long>*)0x0)->GetClass();
      unary_functionlEunsignedsP__int128cOunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEunsignedsP__int128cOunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *unary_functionlEconstsPIInterfacemUcOIInterfacemUgR_Dictionary();
   static void unary_functionlEconstsPIInterfacemUcOIInterfacemUgR_TClassManip(TClass*);
   static void *new_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p = 0);
   static void *newArray_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(Long_t size, void *p);
   static void delete_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p);
   static void deleteArray_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p);
   static void destruct_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::unary_function<const IInterface*,IInterface*>*)
   {
      ::unary_function<const IInterface*,IInterface*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::unary_function<const IInterface*,IInterface*>));
      static ::ROOT::TGenericClassInfo 
         instance("unary_function<const IInterface*,IInterface*>", "string", 105,
                  typeid(::unary_function<const IInterface*,IInterface*>), DefineBehavior(ptr, ptr),
                  &unary_functionlEconstsPIInterfacemUcOIInterfacemUgR_Dictionary, isa_proxy, 0,
                  sizeof(::unary_function<const IInterface*,IInterface*>) );
      instance.SetNew(&new_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR);
      instance.SetNewArray(&newArray_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR);
      instance.SetDelete(&delete_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR);
      instance.SetDeleteArray(&deleteArray_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR);
      instance.SetDestructor(&destruct_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::unary_function<const IInterface*,IInterface*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *unary_functionlEconstsPIInterfacemUcOIInterfacemUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::unary_function<const IInterface*,IInterface*>*)0x0)->GetClass();
      unary_functionlEconstsPIInterfacemUcOIInterfacemUgR_TClassManip(theClass);
   return theClass;
   }

   static void unary_functionlEconstsPIInterfacemUcOIInterfacemUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLHelper_Dictionary();
   static void GaudiPythoncLcLHelper_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLHelper(void *p = 0);
   static void *newArray_GaudiPythoncLcLHelper(Long_t size, void *p);
   static void delete_GaudiPythoncLcLHelper(void *p);
   static void deleteArray_GaudiPythoncLcLHelper(void *p);
   static void destruct_GaudiPythoncLcLHelper(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::Helper*)
   {
      ::GaudiPython::Helper *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::Helper));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::Helper", "GaudiPython/Helpers.h", 47,
                  typeid(::GaudiPython::Helper), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLHelper_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::Helper) );
      instance.SetNew(&new_GaudiPythoncLcLHelper);
      instance.SetNewArray(&newArray_GaudiPythoncLcLHelper);
      instance.SetDelete(&delete_GaudiPythoncLcLHelper);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLHelper);
      instance.SetDestructor(&destruct_GaudiPythoncLcLHelper);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::Helper*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::Helper*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::Helper*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLHelper_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::Helper*)0x0)->GetClass();
      GaudiPythoncLcLHelper_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLHelper_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *basic_ostreamlEcharcOchar_traitslEchargRsPgR_Dictionary();
   static void basic_ostreamlEcharcOchar_traitslEchargRsPgR_TClassManip(TClass*);
   static void delete_basic_ostreamlEcharcOchar_traitslEchargRsPgR(void *p);
   static void deleteArray_basic_ostreamlEcharcOchar_traitslEchargRsPgR(void *p);
   static void destruct_basic_ostreamlEcharcOchar_traitslEchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::basic_ostream<char,char_traits<char> >*)
   {
      ::basic_ostream<char,char_traits<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::basic_ostream<char,char_traits<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("basic_ostream<char,char_traits<char> >", "ostream", 359,
                  typeid(::basic_ostream<char,char_traits<char> >), DefineBehavior(ptr, ptr),
                  &basic_ostreamlEcharcOchar_traitslEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::basic_ostream<char,char_traits<char> >) );
      instance.SetDelete(&delete_basic_ostreamlEcharcOchar_traitslEchargRsPgR);
      instance.SetDeleteArray(&deleteArray_basic_ostreamlEcharcOchar_traitslEchargRsPgR);
      instance.SetDestructor(&destruct_basic_ostreamlEcharcOchar_traitslEchargRsPgR);

      ROOT::AddClassAlternate("basic_ostream<char,char_traits<char> >","ostream");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::basic_ostream<char,char_traits<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *basic_ostreamlEcharcOchar_traitslEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::basic_ostream<char,char_traits<char> >*)0x0)->GetClass();
      basic_ostreamlEcharcOchar_traitslEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void basic_ostreamlEcharcOchar_traitslEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR_Dictionary();
   static void basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR_TClassManip(TClass*);
   static void *new_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p = 0);
   static void *newArray_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(Long_t size, void *p);
   static void delete_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p);
   static void deleteArray_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p);
   static void destruct_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::basic_stringbuf<char,char_traits<char>,allocator<char> >*)
   {
      ::basic_stringbuf<char,char_traits<char>,allocator<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::basic_stringbuf<char,char_traits<char>,allocator<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("basic_stringbuf<char,char_traits<char>,allocator<char> >", "sstream", 272,
                  typeid(::basic_stringbuf<char,char_traits<char>,allocator<char> >), DefineBehavior(ptr, ptr),
                  &basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::basic_stringbuf<char,char_traits<char>,allocator<char> >) );
      instance.SetNew(&new_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR);
      instance.SetNewArray(&newArray_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR);
      instance.SetDelete(&delete_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR);
      instance.SetDeleteArray(&deleteArray_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR);
      instance.SetDestructor(&destruct_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR);

      ROOT::AddClassAlternate("basic_stringbuf<char,char_traits<char>,allocator<char> >","basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >");
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::basic_stringbuf<char,char_traits<char>,allocator<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::basic_stringbuf<char,char_traits<char>,allocator<char> >*)0x0)->GetClass();
      basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *_Bit_reference_Dictionary();
   static void _Bit_reference_TClassManip(TClass*);
   static void *new__Bit_reference(void *p = 0);
   static void *newArray__Bit_reference(Long_t size, void *p);
   static void delete__Bit_reference(void *p);
   static void deleteArray__Bit_reference(void *p);
   static void destruct__Bit_reference(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::_Bit_reference*)
   {
      ::_Bit_reference *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::_Bit_reference));
      static ::ROOT::TGenericClassInfo 
         instance("_Bit_reference", "vector", 70,
                  typeid(::_Bit_reference), DefineBehavior(ptr, ptr),
                  &_Bit_reference_Dictionary, isa_proxy, 0,
                  sizeof(::_Bit_reference) );
      instance.SetNew(&new__Bit_reference);
      instance.SetNewArray(&newArray__Bit_reference);
      instance.SetDelete(&delete__Bit_reference);
      instance.SetDeleteArray(&deleteArray__Bit_reference);
      instance.SetDestructor(&destruct__Bit_reference);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::_Bit_reference*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *_Bit_reference_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::_Bit_reference*)0x0)->GetClass();
      _Bit_reference_TClassManip(theClass);
   return theClass;
   }

   static void _Bit_reference_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *allocatorlEIRegistrymUgR_Dictionary();
   static void allocatorlEIRegistrymUgR_TClassManip(TClass*);
   static void *new_allocatorlEIRegistrymUgR(void *p = 0);
   static void *newArray_allocatorlEIRegistrymUgR(Long_t size, void *p);
   static void delete_allocatorlEIRegistrymUgR(void *p);
   static void deleteArray_allocatorlEIRegistrymUgR(void *p);
   static void destruct_allocatorlEIRegistrymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const allocator<IRegistry*>*)
   {
      allocator<IRegistry*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(allocator<IRegistry*>));
      static ::ROOT::TGenericClassInfo 
         instance("allocator<IRegistry*>", "string", 92,
                  typeid(allocator<IRegistry*>), DefineBehavior(ptr, ptr),
                  &allocatorlEIRegistrymUgR_Dictionary, isa_proxy, 0,
                  sizeof(allocator<IRegistry*>) );
      instance.SetNew(&new_allocatorlEIRegistrymUgR);
      instance.SetNewArray(&newArray_allocatorlEIRegistrymUgR);
      instance.SetDelete(&delete_allocatorlEIRegistrymUgR);
      instance.SetDeleteArray(&deleteArray_allocatorlEIRegistrymUgR);
      instance.SetDestructor(&destruct_allocatorlEIRegistrymUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const allocator<IRegistry*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *allocatorlEIRegistrymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const allocator<IRegistry*>*)0x0)->GetClass();
      allocatorlEIRegistrymUgR_TClassManip(theClass);
   return theClass;
   }

   static void allocatorlEIRegistrymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *allocatorlEIAlgorithmmUgR_Dictionary();
   static void allocatorlEIAlgorithmmUgR_TClassManip(TClass*);
   static void *new_allocatorlEIAlgorithmmUgR(void *p = 0);
   static void *newArray_allocatorlEIAlgorithmmUgR(Long_t size, void *p);
   static void delete_allocatorlEIAlgorithmmUgR(void *p);
   static void deleteArray_allocatorlEIAlgorithmmUgR(void *p);
   static void destruct_allocatorlEIAlgorithmmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const allocator<IAlgorithm*>*)
   {
      allocator<IAlgorithm*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(allocator<IAlgorithm*>));
      static ::ROOT::TGenericClassInfo 
         instance("allocator<IAlgorithm*>", "string", 92,
                  typeid(allocator<IAlgorithm*>), DefineBehavior(ptr, ptr),
                  &allocatorlEIAlgorithmmUgR_Dictionary, isa_proxy, 0,
                  sizeof(allocator<IAlgorithm*>) );
      instance.SetNew(&new_allocatorlEIAlgorithmmUgR);
      instance.SetNewArray(&newArray_allocatorlEIAlgorithmmUgR);
      instance.SetDelete(&delete_allocatorlEIAlgorithmmUgR);
      instance.SetDeleteArray(&deleteArray_allocatorlEIAlgorithmmUgR);
      instance.SetDestructor(&destruct_allocatorlEIAlgorithmmUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const allocator<IAlgorithm*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *allocatorlEIAlgorithmmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const allocator<IAlgorithm*>*)0x0)->GetClass();
      allocatorlEIAlgorithmmUgR_TClassManip(theClass);
   return theClass;
   }

   static void allocatorlEIAlgorithmmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *allocatorlEIServicemUgR_Dictionary();
   static void allocatorlEIServicemUgR_TClassManip(TClass*);
   static void *new_allocatorlEIServicemUgR(void *p = 0);
   static void *newArray_allocatorlEIServicemUgR(Long_t size, void *p);
   static void delete_allocatorlEIServicemUgR(void *p);
   static void deleteArray_allocatorlEIServicemUgR(void *p);
   static void destruct_allocatorlEIServicemUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const allocator<IService*>*)
   {
      allocator<IService*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(allocator<IService*>));
      static ::ROOT::TGenericClassInfo 
         instance("allocator<IService*>", "string", 92,
                  typeid(allocator<IService*>), DefineBehavior(ptr, ptr),
                  &allocatorlEIServicemUgR_Dictionary, isa_proxy, 0,
                  sizeof(allocator<IService*>) );
      instance.SetNew(&new_allocatorlEIServicemUgR);
      instance.SetNewArray(&newArray_allocatorlEIServicemUgR);
      instance.SetDelete(&delete_allocatorlEIServicemUgR);
      instance.SetDeleteArray(&deleteArray_allocatorlEIServicemUgR);
      instance.SetDestructor(&destruct_allocatorlEIServicemUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const allocator<IService*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *allocatorlEIServicemUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const allocator<IService*>*)0x0)->GetClass();
      allocatorlEIServicemUgR_TClassManip(theClass);
   return theClass;
   }

   static void allocatorlEIServicemUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLUtilscLcLHistoscLcLHistoStrings_Dictionary();
   static void GaudicLcLUtilscLcLHistoscLcLHistoStrings_TClassManip(TClass*);
   static void *new_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p = 0);
   static void *newArray_GaudicLcLUtilscLcLHistoscLcLHistoStrings(Long_t size, void *p);
   static void delete_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p);
   static void deleteArray_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p);
   static void destruct_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::Utils::Histos::HistoStrings*)
   {
      ::Gaudi::Utils::Histos::HistoStrings *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::Utils::Histos::HistoStrings));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::Utils::Histos::HistoStrings", "GaudiUtils/HistoStrings.h", 52,
                  typeid(::Gaudi::Utils::Histos::HistoStrings), DefineBehavior(ptr, ptr),
                  &GaudicLcLUtilscLcLHistoscLcLHistoStrings_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::Utils::Histos::HistoStrings) );
      instance.SetNew(&new_GaudicLcLUtilscLcLHistoscLcLHistoStrings);
      instance.SetNewArray(&newArray_GaudicLcLUtilscLcLHistoscLcLHistoStrings);
      instance.SetDelete(&delete_GaudicLcLUtilscLcLHistoscLcLHistoStrings);
      instance.SetDeleteArray(&deleteArray_GaudicLcLUtilscLcLHistoscLcLHistoStrings);
      instance.SetDestructor(&destruct_GaudicLcLUtilscLcLHistoscLcLHistoStrings);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::Utils::Histos::HistoStrings*)
   {
      return GenerateInitInstanceLocal((::Gaudi::Utils::Histos::HistoStrings*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::Utils::Histos::HistoStrings*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLUtilscLcLHistoscLcLHistoStrings_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::Utils::Histos::HistoStrings*)0x0)->GetClass();
      GaudicLcLUtilscLcLHistoscLcLHistoStrings_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLUtilscLcLHistoscLcLHistoStrings_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)
   {
      ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)
   {
      ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >) );
      instance.SetNew(&new_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)0x0)->GetClass();
      SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >*)
   {
      ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >*)0x0)->GetClass();
      SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)
   {
      ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)
   {
      ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)0x0)->GetClass();
      SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)
   {
      ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >*)
   {
      ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >*)
   {
      ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >*)
   {
      ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >*)0x0)->GetClass();
      SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >*)
   {
      ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary();
   static void SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >*)
   {
      ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >) );
      instance.SetNew(&new_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >*)0x0)->GetClass();
      SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >*)
   {
      ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >) );
      instance.SetNew(&new_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >*)0x0)->GetClass();
      SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)
   {
      ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)0x0)->GetClass();
      SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)
   {
      ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)0x0)->GetClass();
      SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)
   {
      ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)0x0)->GetClass();
      SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >*)
   {
      ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >) );
      instance.SetNew(&new_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >*)0x0)->GetClass();
      SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary();
   static void SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >*)
   {
      ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >) );
      instance.SetNew(&new_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >*)0x0)->GetClass();
      SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary();
   static void SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >*)
   {
      ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >) );
      instance.SetNew(&new_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >*)0x0)->GetClass();
      SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >*)
   {
      ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >) );
      instance.SetNew(&new_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >*)0x0)->GetClass();
      SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)
   {
      ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >) );
      instance.SetNew(&new_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)0x0)->GetClass();
      SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)
   {
      ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >) );
      instance.SetNew(&new_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)0x0)->GetClass();
      SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR_Dictionary();
   static void SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p);
   static void deleteArray_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p);
   static void destruct_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<bool,BoundedVerifier<bool> >*)
   {
      ::SimpleProperty<bool,BoundedVerifier<bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<bool,BoundedVerifier<bool> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<bool,BoundedVerifier<bool> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<bool,BoundedVerifier<bool> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<bool,BoundedVerifier<bool> >) );
      instance.SetNew(&new_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<bool,BoundedVerifier<bool> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<bool,BoundedVerifier<bool> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<bool,BoundedVerifier<bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<bool,BoundedVerifier<bool> >*)0x0)->GetClass();
      SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_Dictionary();
   static void SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p);
   static void deleteArray_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p);
   static void destruct_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >*)
   {
      ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >) );
      instance.SetNew(&new_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >*)0x0)->GetClass();
      SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEcharcOBoundedVerifierlEchargRsPgR_Dictionary();
   static void SimplePropertylEcharcOBoundedVerifierlEchargRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p);
   static void deleteArray_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p);
   static void destruct_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<char,BoundedVerifier<char> >*)
   {
      ::SimpleProperty<char,BoundedVerifier<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<char,BoundedVerifier<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<char,BoundedVerifier<char> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<char,BoundedVerifier<char> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEcharcOBoundedVerifierlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<char,BoundedVerifier<char> >) );
      instance.SetNew(&new_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR);
      instance.SetDelete(&delete_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<char,BoundedVerifier<char> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<char,BoundedVerifier<char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<char,BoundedVerifier<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEcharcOBoundedVerifierlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<char,BoundedVerifier<char> >*)0x0)->GetClass();
      SimplePropertylEcharcOBoundedVerifierlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEcharcOBoundedVerifierlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_Dictionary();
   static void SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p);
   static void deleteArray_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p);
   static void destruct_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<signed char,BoundedVerifier<signed char> >*)
   {
      ::SimpleProperty<signed char,BoundedVerifier<signed char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<signed char,BoundedVerifier<signed char> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<signed char,BoundedVerifier<signed char> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<signed char,BoundedVerifier<signed char> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<signed char,BoundedVerifier<signed char> >) );
      instance.SetNew(&new_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR);
      instance.SetDelete(&delete_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<signed char,BoundedVerifier<signed char> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<signed char,BoundedVerifier<signed char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<signed char,BoundedVerifier<signed char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<signed char,BoundedVerifier<signed char> >*)0x0)->GetClass();
      SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_Dictionary();
   static void SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p);
   static void deleteArray_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p);
   static void destruct_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >*)
   {
      ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >) );
      instance.SetNew(&new_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR);
      instance.SetDelete(&delete_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >*)0x0)->GetClass();
      SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR_Dictionary();
   static void SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p);
   static void deleteArray_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p);
   static void destruct_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<short,BoundedVerifier<short> >*)
   {
      ::SimpleProperty<short,BoundedVerifier<short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<short,BoundedVerifier<short> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<short,BoundedVerifier<short> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<short,BoundedVerifier<short> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<short,BoundedVerifier<short> >) );
      instance.SetNew(&new_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<short,BoundedVerifier<short> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<short,BoundedVerifier<short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<short,BoundedVerifier<short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<short,BoundedVerifier<short> >*)0x0)->GetClass();
      SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_Dictionary();
   static void SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p);
   static void deleteArray_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p);
   static void destruct_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >*)
   {
      ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >) );
      instance.SetNew(&new_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >*)0x0)->GetClass();
      SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEintcOBoundedVerifierlEintgRsPgR_Dictionary();
   static void SimplePropertylEintcOBoundedVerifierlEintgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p);
   static void deleteArray_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p);
   static void destruct_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<int,BoundedVerifier<int> >*)
   {
      ::SimpleProperty<int,BoundedVerifier<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<int,BoundedVerifier<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<int,BoundedVerifier<int> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<int,BoundedVerifier<int> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEintcOBoundedVerifierlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<int,BoundedVerifier<int> >) );
      instance.SetNew(&new_SimplePropertylEintcOBoundedVerifierlEintgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEintcOBoundedVerifierlEintgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEintcOBoundedVerifierlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEintcOBoundedVerifierlEintgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEintcOBoundedVerifierlEintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<int,BoundedVerifier<int> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<int,BoundedVerifier<int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<int,BoundedVerifier<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEintcOBoundedVerifierlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<int,BoundedVerifier<int> >*)0x0)->GetClass();
      SimplePropertylEintcOBoundedVerifierlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEintcOBoundedVerifierlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_Dictionary();
   static void SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p);
   static void deleteArray_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p);
   static void destruct_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >*)
   {
      ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >) );
      instance.SetNew(&new_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >*)0x0)->GetClass();
      SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylElongcOBoundedVerifierlElonggRsPgR_Dictionary();
   static void SimplePropertylElongcOBoundedVerifierlElonggRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p = 0);
   static void *newArray_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p);
   static void deleteArray_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p);
   static void destruct_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<long,BoundedVerifier<long> >*)
   {
      ::SimpleProperty<long,BoundedVerifier<long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<long,BoundedVerifier<long> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<long,BoundedVerifier<long> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<long,BoundedVerifier<long> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylElongcOBoundedVerifierlElonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<long,BoundedVerifier<long> >) );
      instance.SetNew(&new_SimplePropertylElongcOBoundedVerifierlElonggRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylElongcOBoundedVerifierlElonggRsPgR);
      instance.SetDelete(&delete_SimplePropertylElongcOBoundedVerifierlElonggRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylElongcOBoundedVerifierlElonggRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylElongcOBoundedVerifierlElonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<long,BoundedVerifier<long> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<long,BoundedVerifier<long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<long,BoundedVerifier<long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylElongcOBoundedVerifierlElonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<long,BoundedVerifier<long> >*)0x0)->GetClass();
      SimplePropertylElongcOBoundedVerifierlElonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylElongcOBoundedVerifierlElonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_Dictionary();
   static void SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p);
   static void deleteArray_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p);
   static void destruct_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >*)
   {
      ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >) );
      instance.SetNew(&new_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR);
      instance.SetDelete(&delete_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >*)0x0)->GetClass();
      SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR_Dictionary();
   static void SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p);
   static void deleteArray_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p);
   static void destruct_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >*)
   {
      ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >) );
      instance.SetNew(&new_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR);
      instance.SetDelete(&delete_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >*)0x0)->GetClass();
      SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >*)
   {
      ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR_Dictionary();
   static void SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p);
   static void deleteArray_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p);
   static void destruct_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<float,BoundedVerifier<float> >*)
   {
      ::SimpleProperty<float,BoundedVerifier<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<float,BoundedVerifier<float> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<float,BoundedVerifier<float> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<float,BoundedVerifier<float> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<float,BoundedVerifier<float> >) );
      instance.SetNew(&new_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<float,BoundedVerifier<float> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<float,BoundedVerifier<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<float,BoundedVerifier<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<float,BoundedVerifier<float> >*)0x0)->GetClass();
      SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR_Dictionary();
   static void SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p);
   static void deleteArray_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p);
   static void destruct_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<double,BoundedVerifier<double> >*)
   {
      ::SimpleProperty<double,BoundedVerifier<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<double,BoundedVerifier<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<double,BoundedVerifier<double> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<double,BoundedVerifier<double> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<double,BoundedVerifier<double> >) );
      instance.SetNew(&new_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR);
      instance.SetDelete(&delete_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<double,BoundedVerifier<double> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<double,BoundedVerifier<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<double,BoundedVerifier<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<double,BoundedVerifier<double> >*)0x0)->GetClass();
      SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_Dictionary();
   static void SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p = 0);
   static void *newArray_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p);
   static void deleteArray_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p);
   static void destruct_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<long double,BoundedVerifier<long double> >*)
   {
      ::SimpleProperty<long double,BoundedVerifier<long double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<long double,BoundedVerifier<long double> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<long double,BoundedVerifier<long double> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<long double,BoundedVerifier<long double> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<long double,BoundedVerifier<long double> >) );
      instance.SetNew(&new_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR);
      instance.SetDelete(&delete_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<long double,BoundedVerifier<long double> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<long double,BoundedVerifier<long double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<long double,BoundedVerifier<long double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<long double,BoundedVerifier<long double> >*)0x0)->GetClass();
      SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR_Dictionary();
   static void SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p);
   static void deleteArray_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p);
   static void destruct_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<string,BoundedVerifier<string> >*)
   {
      ::SimpleProperty<string,BoundedVerifier<string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<string,BoundedVerifier<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<string,BoundedVerifier<string> >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<string,BoundedVerifier<string> >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<string,BoundedVerifier<string> >) );
      instance.SetNew(&new_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<string,BoundedVerifier<string> >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<string,BoundedVerifier<string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<string,BoundedVerifier<string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<string,BoundedVerifier<string> >*)0x0)->GetClass();
      SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >*)
   {
      ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >*)
   {
      ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >*)
   {
      ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)
   {
      ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >*)
   {
      ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary();
   static void SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass*);
   static void *new_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p = 0);
   static void *newArray_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(Long_t size, void *p);
   static void delete_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p);
   static void destruct_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)
   {
      ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >", "GaudiKernel/Property.h", 505,
                  typeid(::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >) );
      instance.SetNew(&new_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      instance.SetNewArray(&newArray_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      instance.SetDelete(&delete_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)
   {
      return GenerateInitInstanceLocal((::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)0x0)->GetClass();
      SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR_Dictionary();
   static void SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR(void *p);
   static void destruct_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >*)
   {
      ::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >) );
      instance.SetDelete(&delete_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >*)0x0)->GetClass();
      SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >*)
   {
      ::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)
   {
      ::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >*)
   {
      ::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >*)
   {
      ::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >*)
   {
      ::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEstringcONullVerifierlEstringgRsPgR_Dictionary();
   static void SimplePropertyReflEstringcONullVerifierlEstringgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR(void *p);
   static void destruct_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<string,NullVerifier<string> >*)
   {
      ::SimplePropertyRef<string,NullVerifier<string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<string,NullVerifier<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<string,NullVerifier<string> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<string,NullVerifier<string> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEstringcONullVerifierlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<string,NullVerifier<string> >) );
      instance.SetDelete(&delete_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<string,NullVerifier<string> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<string,NullVerifier<string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<string,NullVerifier<string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEstringcONullVerifierlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<string,NullVerifier<string> >*)0x0)->GetClass();
      SimplePropertyReflEstringcONullVerifierlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEstringcONullVerifierlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR_Dictionary();
   static void SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR(void *p);
   static void deleteArray_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR(void *p);
   static void destruct_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<long double,NullVerifier<long double> >*)
   {
      ::SimplePropertyRef<long double,NullVerifier<long double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<long double,NullVerifier<long double> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<long double,NullVerifier<long double> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<long double,NullVerifier<long double> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<long double,NullVerifier<long double> >) );
      instance.SetDelete(&delete_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<long double,NullVerifier<long double> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<long double,NullVerifier<long double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<long double,NullVerifier<long double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<long double,NullVerifier<long double> >*)0x0)->GetClass();
      SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR_Dictionary();
   static void SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR(void *p);
   static void destruct_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<double,NullVerifier<double> >*)
   {
      ::SimplePropertyRef<double,NullVerifier<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<double,NullVerifier<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<double,NullVerifier<double> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<double,NullVerifier<double> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<double,NullVerifier<double> >) );
      instance.SetDelete(&delete_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<double,NullVerifier<double> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<double,NullVerifier<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<double,NullVerifier<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<double,NullVerifier<double> >*)0x0)->GetClass();
      SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR_Dictionary();
   static void SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR(void *p);
   static void destruct_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<float,NullVerifier<float> >*)
   {
      ::SimplePropertyRef<float,NullVerifier<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<float,NullVerifier<float> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<float,NullVerifier<float> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<float,NullVerifier<float> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<float,NullVerifier<float> >) );
      instance.SetDelete(&delete_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<float,NullVerifier<float> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<float,NullVerifier<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<float,NullVerifier<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<float,NullVerifier<float> >*)0x0)->GetClass();
      SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR_Dictionary();
   static void SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR(void *p);
   static void destruct_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >*)
   {
      ::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >) );
      instance.SetDelete(&delete_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >*)0x0)->GetClass();
      SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)
   {
      ::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_Dictionary();
   static void SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR(void *p);
   static void destruct_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >*)
   {
      ::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >) );
      instance.SetDelete(&delete_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >*)0x0)->GetClass();
      SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflElongcONullVerifierlElonggRsPgR_Dictionary();
   static void SimplePropertyReflElongcONullVerifierlElonggRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflElongcONullVerifierlElonggRsPgR(void *p);
   static void deleteArray_SimplePropertyReflElongcONullVerifierlElonggRsPgR(void *p);
   static void destruct_SimplePropertyReflElongcONullVerifierlElonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<long,NullVerifier<long> >*)
   {
      ::SimplePropertyRef<long,NullVerifier<long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<long,NullVerifier<long> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<long,NullVerifier<long> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<long,NullVerifier<long> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflElongcONullVerifierlElonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<long,NullVerifier<long> >) );
      instance.SetDelete(&delete_SimplePropertyReflElongcONullVerifierlElonggRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflElongcONullVerifierlElonggRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflElongcONullVerifierlElonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<long,NullVerifier<long> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<long,NullVerifier<long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<long,NullVerifier<long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflElongcONullVerifierlElonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<long,NullVerifier<long> >*)0x0)->GetClass();
      SimplePropertyReflElongcONullVerifierlElonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflElongcONullVerifierlElonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_Dictionary();
   static void SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR(void *p);
   static void destruct_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >*)
   {
      ::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >) );
      instance.SetDelete(&delete_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >*)0x0)->GetClass();
      SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEintcONullVerifierlEintgRsPgR_Dictionary();
   static void SimplePropertyReflEintcONullVerifierlEintgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEintcONullVerifierlEintgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEintcONullVerifierlEintgRsPgR(void *p);
   static void destruct_SimplePropertyReflEintcONullVerifierlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<int,NullVerifier<int> >*)
   {
      ::SimplePropertyRef<int,NullVerifier<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<int,NullVerifier<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<int,NullVerifier<int> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<int,NullVerifier<int> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEintcONullVerifierlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<int,NullVerifier<int> >) );
      instance.SetDelete(&delete_SimplePropertyReflEintcONullVerifierlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEintcONullVerifierlEintgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEintcONullVerifierlEintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<int,NullVerifier<int> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<int,NullVerifier<int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<int,NullVerifier<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEintcONullVerifierlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<int,NullVerifier<int> >*)0x0)->GetClass();
      SimplePropertyReflEintcONullVerifierlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEintcONullVerifierlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_Dictionary();
   static void SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR(void *p);
   static void destruct_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >*)
   {
      ::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >) );
      instance.SetDelete(&delete_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >*)0x0)->GetClass();
      SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEshortcONullVerifierlEshortgRsPgR_Dictionary();
   static void SimplePropertyReflEshortcONullVerifierlEshortgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR(void *p);
   static void destruct_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<short,NullVerifier<short> >*)
   {
      ::SimplePropertyRef<short,NullVerifier<short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<short,NullVerifier<short> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<short,NullVerifier<short> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<short,NullVerifier<short> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEshortcONullVerifierlEshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<short,NullVerifier<short> >) );
      instance.SetDelete(&delete_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<short,NullVerifier<short> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<short,NullVerifier<short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<short,NullVerifier<short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEshortcONullVerifierlEshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<short,NullVerifier<short> >*)0x0)->GetClass();
      SimplePropertyReflEshortcONullVerifierlEshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEshortcONullVerifierlEshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_Dictionary();
   static void SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR(void *p);
   static void destruct_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >*)
   {
      ::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >) );
      instance.SetDelete(&delete_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >*)0x0)->GetClass();
      SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_Dictionary();
   static void SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR(void *p);
   static void destruct_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<signed char,NullVerifier<signed char> >*)
   {
      ::SimplePropertyRef<signed char,NullVerifier<signed char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<signed char,NullVerifier<signed char> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<signed char,NullVerifier<signed char> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<signed char,NullVerifier<signed char> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<signed char,NullVerifier<signed char> >) );
      instance.SetDelete(&delete_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<signed char,NullVerifier<signed char> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<signed char,NullVerifier<signed char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<signed char,NullVerifier<signed char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<signed char,NullVerifier<signed char> >*)0x0)->GetClass();
      SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEcharcONullVerifierlEchargRsPgR_Dictionary();
   static void SimplePropertyReflEcharcONullVerifierlEchargRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEcharcONullVerifierlEchargRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEcharcONullVerifierlEchargRsPgR(void *p);
   static void destruct_SimplePropertyReflEcharcONullVerifierlEchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<char,NullVerifier<char> >*)
   {
      ::SimplePropertyRef<char,NullVerifier<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<char,NullVerifier<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<char,NullVerifier<char> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<char,NullVerifier<char> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEcharcONullVerifierlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<char,NullVerifier<char> >) );
      instance.SetDelete(&delete_SimplePropertyReflEcharcONullVerifierlEchargRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEcharcONullVerifierlEchargRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEcharcONullVerifierlEchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<char,NullVerifier<char> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<char,NullVerifier<char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<char,NullVerifier<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEcharcONullVerifierlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<char,NullVerifier<char> >*)0x0)->GetClass();
      SimplePropertyReflEcharcONullVerifierlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEcharcONullVerifierlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEboolcONullVerifierlEboolgRsPgR_Dictionary();
   static void SimplePropertyReflEboolcONullVerifierlEboolgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR(void *p);
   static void destruct_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<bool,NullVerifier<bool> >*)
   {
      ::SimplePropertyRef<bool,NullVerifier<bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<bool,NullVerifier<bool> >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<bool,NullVerifier<bool> >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<bool,NullVerifier<bool> >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEboolcONullVerifierlEboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<bool,NullVerifier<bool> >) );
      instance.SetDelete(&delete_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<bool,NullVerifier<bool> >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<bool,NullVerifier<bool> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<bool,NullVerifier<bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEboolcONullVerifierlEboolgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<bool,NullVerifier<bool> >*)0x0)->GetClass();
      SimplePropertyReflEboolcONullVerifierlEboolgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEboolcONullVerifierlEboolgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >*)
   {
      ::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >*)0x0)->GetClass();
      SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)
   {
      ::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >) );
      instance.SetDelete(&delete_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)0x0)->GetClass();
      SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)
   {
      ::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >) );
      instance.SetDelete(&delete_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)0x0)->GetClass();
      SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)
   {
      ::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >) );
      instance.SetDelete(&delete_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)0x0)->GetClass();
      SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >*)
   {
      ::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >*)0x0)->GetClass();
      SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >*)
   {
      ::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >*)0x0)->GetClass();
      SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >*)
   {
      ::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >*)0x0)->GetClass();
      SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >*)
   {
      ::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >*)0x0)->GetClass();
      SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)
   {
      ::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)
   {
      ::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)
   {
      ::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >*)
   {
      ::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >*)
   {
      ::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >*)0x0)->GetClass();
      SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >*)
   {
      ::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >*)
   {
      ::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >*)
   {
      ::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >*)
   {
      ::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)
   {
      ::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)
   {
      ::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)
   {
      ::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >*)
   {
      ::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary();
   static void SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass*);
   static void delete_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p);
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p);
   static void destruct_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)
   {
      ::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >", "GaudiKernel/Property.h", 641,
                  typeid(::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >), DefineBehavior(ptr, ptr),
                  &SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >) );
      instance.SetDelete(&delete_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      instance.SetDestructor(&destruct_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)
   {
      return GenerateInitInstanceLocal((::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)0x0)->GetClass();
      SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEboolgR_Dictionary();
   static void BoundedVerifierlEboolgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEboolgR(void *p = 0);
   static void *newArray_BoundedVerifierlEboolgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEboolgR(void *p);
   static void deleteArray_BoundedVerifierlEboolgR(void *p);
   static void destruct_BoundedVerifierlEboolgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<bool>*)
   {
      ::BoundedVerifier<bool> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<bool>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<bool>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<bool>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEboolgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<bool>) );
      instance.SetNew(&new_BoundedVerifierlEboolgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEboolgR);
      instance.SetDelete(&delete_BoundedVerifierlEboolgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEboolgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEboolgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<bool>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<bool>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<bool>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEboolgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<bool>*)0x0)->GetClass();
      BoundedVerifierlEboolgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEboolgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEsignedsPchargR_Dictionary();
   static void BoundedVerifierlEsignedsPchargR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEsignedsPchargR(void *p = 0);
   static void *newArray_BoundedVerifierlEsignedsPchargR(Long_t size, void *p);
   static void delete_BoundedVerifierlEsignedsPchargR(void *p);
   static void deleteArray_BoundedVerifierlEsignedsPchargR(void *p);
   static void destruct_BoundedVerifierlEsignedsPchargR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<signed char>*)
   {
      ::BoundedVerifier<signed char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<signed char>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<signed char>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<signed char>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEsignedsPchargR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<signed char>) );
      instance.SetNew(&new_BoundedVerifierlEsignedsPchargR);
      instance.SetNewArray(&newArray_BoundedVerifierlEsignedsPchargR);
      instance.SetDelete(&delete_BoundedVerifierlEsignedsPchargR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEsignedsPchargR);
      instance.SetDestructor(&destruct_BoundedVerifierlEsignedsPchargR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<signed char>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<signed char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<signed char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEsignedsPchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<signed char>*)0x0)->GetClass();
      BoundedVerifierlEsignedsPchargR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEsignedsPchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEfloatgR_Dictionary();
   static void BoundedVerifierlEfloatgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEfloatgR(void *p = 0);
   static void *newArray_BoundedVerifierlEfloatgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEfloatgR(void *p);
   static void deleteArray_BoundedVerifierlEfloatgR(void *p);
   static void destruct_BoundedVerifierlEfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<float>*)
   {
      ::BoundedVerifier<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<float>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<float>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<float>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEfloatgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<float>) );
      instance.SetNew(&new_BoundedVerifierlEfloatgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEfloatgR);
      instance.SetDelete(&delete_BoundedVerifierlEfloatgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEfloatgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<float>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<float>*)0x0)->GetClass();
      BoundedVerifierlEfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEintgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEintgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEintgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEintgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEintgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEintgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<int> >*)
   {
      ::BoundedVerifier<vector<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<int> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<int> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<int> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEintgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEintgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEintgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<int> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<int> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEunsignedsPshortgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEunsignedsPshortgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<unsigned short> >*)
   {
      ::BoundedVerifier<vector<unsigned short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<unsigned short> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<unsigned short> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<unsigned short> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEunsignedsPshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<unsigned short> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<unsigned short> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<unsigned short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEunsignedsPshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned short> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEunsignedsPshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEunsignedsPshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEshortgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEshortgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEshortgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEshortgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEshortgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEshortgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<short> >*)
   {
      ::BoundedVerifier<vector<short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<short> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<short> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<short> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<short> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEshortgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEshortgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEshortgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<short> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<short> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEunsignedsPchargRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEunsignedsPchargRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<unsigned char> >*)
   {
      ::BoundedVerifier<vector<unsigned char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<unsigned char> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<unsigned char> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<unsigned char> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEunsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<unsigned char> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEunsignedsPchargRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEunsignedsPchargRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEunsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEunsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEunsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<unsigned char> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<unsigned char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEunsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned char> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEunsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEunsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEsignedsPchargRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEsignedsPchargRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEsignedsPchargRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<signed char> >*)
   {
      ::BoundedVerifier<vector<signed char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<signed char> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<signed char> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<signed char> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<signed char> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEsignedsPchargRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEsignedsPchargRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<signed char> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<signed char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<signed char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<signed char> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEchargRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEchargRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEchargRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEchargRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEchargRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEchargRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<char> >*)
   {
      ::BoundedVerifier<vector<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<char> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<char> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<char> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEchargRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEchargRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEchargRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEchargRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<char> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<char> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEboolgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEboolgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEboolgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEboolgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEboolgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEboolgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEboolgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<bool> >*)
   {
      ::BoundedVerifier<vector<bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<bool> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<bool> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<bool> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<bool> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEboolgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEboolgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEboolgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEboolgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEboolgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<bool> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<bool> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEboolgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<bool> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEboolgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEboolgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEstringgR_Dictionary();
   static void BoundedVerifierlEstringgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEstringgR(void *p = 0);
   static void *newArray_BoundedVerifierlEstringgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEstringgR(void *p);
   static void deleteArray_BoundedVerifierlEstringgR(void *p);
   static void destruct_BoundedVerifierlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<string>*)
   {
      ::BoundedVerifier<string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<string>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<string>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<string>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<string>) );
      instance.SetNew(&new_BoundedVerifierlEstringgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEstringgR);
      instance.SetDelete(&delete_BoundedVerifierlEstringgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEstringgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEstringgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<string>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<string>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<string>*)0x0)->GetClass();
      BoundedVerifierlEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlElongsPdoublegR_Dictionary();
   static void BoundedVerifierlElongsPdoublegR_TClassManip(TClass*);
   static void *new_BoundedVerifierlElongsPdoublegR(void *p = 0);
   static void *newArray_BoundedVerifierlElongsPdoublegR(Long_t size, void *p);
   static void delete_BoundedVerifierlElongsPdoublegR(void *p);
   static void deleteArray_BoundedVerifierlElongsPdoublegR(void *p);
   static void destruct_BoundedVerifierlElongsPdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<long double>*)
   {
      ::BoundedVerifier<long double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<long double>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<long double>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<long double>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlElongsPdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<long double>) );
      instance.SetNew(&new_BoundedVerifierlElongsPdoublegR);
      instance.SetNewArray(&newArray_BoundedVerifierlElongsPdoublegR);
      instance.SetDelete(&delete_BoundedVerifierlElongsPdoublegR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlElongsPdoublegR);
      instance.SetDestructor(&destruct_BoundedVerifierlElongsPdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<long double>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<long double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<long double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlElongsPdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<long double>*)0x0)->GetClass();
      BoundedVerifierlElongsPdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlElongsPdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEdoublegR_Dictionary();
   static void BoundedVerifierlEdoublegR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEdoublegR(void *p = 0);
   static void *newArray_BoundedVerifierlEdoublegR(Long_t size, void *p);
   static void delete_BoundedVerifierlEdoublegR(void *p);
   static void deleteArray_BoundedVerifierlEdoublegR(void *p);
   static void destruct_BoundedVerifierlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<double>*)
   {
      ::BoundedVerifier<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<double>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<double>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<double>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<double>) );
      instance.SetNew(&new_BoundedVerifierlEdoublegR);
      instance.SetNewArray(&newArray_BoundedVerifierlEdoublegR);
      instance.SetDelete(&delete_BoundedVerifierlEdoublegR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEdoublegR);
      instance.SetDestructor(&destruct_BoundedVerifierlEdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<double>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<double>*)0x0)->GetClass();
      BoundedVerifierlEdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary();
   static void BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p);
   static void destruct_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<map<string,vector<int> > >*)
   {
      ::BoundedVerifier<map<string,vector<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<map<string,vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<map<string,vector<int> > >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<map<string,vector<int> > >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<map<string,vector<int> > >) );
      instance.SetNew(&new_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<map<string,vector<int> > >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<map<string,vector<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,vector<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,vector<int> > >*)0x0)->GetClass();
      BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEULong64_tgR_Dictionary();
   static void BoundedVerifierlEULong64_tgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEULong64_tgR(void *p = 0);
   static void *newArray_BoundedVerifierlEULong64_tgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEULong64_tgR(void *p);
   static void deleteArray_BoundedVerifierlEULong64_tgR(void *p);
   static void destruct_BoundedVerifierlEULong64_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<ULong64_t>*)
   {
      ::BoundedVerifier<ULong64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<ULong64_t>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<ULong64_t>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<ULong64_t>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEULong64_tgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<ULong64_t>) );
      instance.SetNew(&new_BoundedVerifierlEULong64_tgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEULong64_tgR);
      instance.SetDelete(&delete_BoundedVerifierlEULong64_tgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEULong64_tgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEULong64_tgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<ULong64_t>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<ULong64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<ULong64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEULong64_tgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<ULong64_t>*)0x0)->GetClass();
      BoundedVerifierlEULong64_tgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEULong64_tgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlELong64_tgR_Dictionary();
   static void BoundedVerifierlELong64_tgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlELong64_tgR(void *p = 0);
   static void *newArray_BoundedVerifierlELong64_tgR(Long_t size, void *p);
   static void delete_BoundedVerifierlELong64_tgR(void *p);
   static void deleteArray_BoundedVerifierlELong64_tgR(void *p);
   static void destruct_BoundedVerifierlELong64_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<Long64_t>*)
   {
      ::BoundedVerifier<Long64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<Long64_t>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<Long64_t>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<Long64_t>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlELong64_tgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<Long64_t>) );
      instance.SetNew(&new_BoundedVerifierlELong64_tgR);
      instance.SetNewArray(&newArray_BoundedVerifierlELong64_tgR);
      instance.SetDelete(&delete_BoundedVerifierlELong64_tgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlELong64_tgR);
      instance.SetDestructor(&destruct_BoundedVerifierlELong64_tgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<Long64_t>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<Long64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<Long64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlELong64_tgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<Long64_t>*)0x0)->GetClass();
      BoundedVerifierlELong64_tgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlELong64_tgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEunsignedsPlonggR_Dictionary();
   static void BoundedVerifierlEunsignedsPlonggR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEunsignedsPlonggR(void *p = 0);
   static void *newArray_BoundedVerifierlEunsignedsPlonggR(Long_t size, void *p);
   static void delete_BoundedVerifierlEunsignedsPlonggR(void *p);
   static void deleteArray_BoundedVerifierlEunsignedsPlonggR(void *p);
   static void destruct_BoundedVerifierlEunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<unsigned long>*)
   {
      ::BoundedVerifier<unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<unsigned long>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<unsigned long>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<unsigned long>) );
      instance.SetNew(&new_BoundedVerifierlEunsignedsPlonggR);
      instance.SetNewArray(&newArray_BoundedVerifierlEunsignedsPlonggR);
      instance.SetDelete(&delete_BoundedVerifierlEunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEunsignedsPlonggR);
      instance.SetDestructor(&destruct_BoundedVerifierlEunsignedsPlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<unsigned long>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<unsigned long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned long>*)0x0)->GetClass();
      BoundedVerifierlEunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlElonggR_Dictionary();
   static void BoundedVerifierlElonggR_TClassManip(TClass*);
   static void *new_BoundedVerifierlElonggR(void *p = 0);
   static void *newArray_BoundedVerifierlElonggR(Long_t size, void *p);
   static void delete_BoundedVerifierlElonggR(void *p);
   static void deleteArray_BoundedVerifierlElonggR(void *p);
   static void destruct_BoundedVerifierlElonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<long>*)
   {
      ::BoundedVerifier<long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<long>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<long>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<long>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlElonggR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<long>) );
      instance.SetNew(&new_BoundedVerifierlElonggR);
      instance.SetNewArray(&newArray_BoundedVerifierlElonggR);
      instance.SetDelete(&delete_BoundedVerifierlElonggR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlElonggR);
      instance.SetDestructor(&destruct_BoundedVerifierlElonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<long>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlElonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<long>*)0x0)->GetClass();
      BoundedVerifierlElonggR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlElonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEunsignedsPintgR_Dictionary();
   static void BoundedVerifierlEunsignedsPintgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEunsignedsPintgR(void *p = 0);
   static void *newArray_BoundedVerifierlEunsignedsPintgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEunsignedsPintgR(void *p);
   static void deleteArray_BoundedVerifierlEunsignedsPintgR(void *p);
   static void destruct_BoundedVerifierlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<unsigned int>*)
   {
      ::BoundedVerifier<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<unsigned int>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<unsigned int>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<unsigned int>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<unsigned int>) );
      instance.SetNew(&new_BoundedVerifierlEunsignedsPintgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEunsignedsPintgR);
      instance.SetDelete(&delete_BoundedVerifierlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEunsignedsPintgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEunsignedsPintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<unsigned int>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<unsigned int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEunsignedsPintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned int>*)0x0)->GetClass();
      BoundedVerifierlEunsignedsPintgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEunsignedsPintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEintgR_Dictionary();
   static void BoundedVerifierlEintgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEintgR(void *p = 0);
   static void *newArray_BoundedVerifierlEintgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEintgR(void *p);
   static void deleteArray_BoundedVerifierlEintgR(void *p);
   static void destruct_BoundedVerifierlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<int>*)
   {
      ::BoundedVerifier<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<int>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<int>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<int>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<int>) );
      instance.SetNew(&new_BoundedVerifierlEintgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEintgR);
      instance.SetDelete(&delete_BoundedVerifierlEintgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEintgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<int>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<int>*)0x0)->GetClass();
      BoundedVerifierlEintgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEunsignedsPshortgR_Dictionary();
   static void BoundedVerifierlEunsignedsPshortgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEunsignedsPshortgR(void *p = 0);
   static void *newArray_BoundedVerifierlEunsignedsPshortgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEunsignedsPshortgR(void *p);
   static void deleteArray_BoundedVerifierlEunsignedsPshortgR(void *p);
   static void destruct_BoundedVerifierlEunsignedsPshortgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<unsigned short>*)
   {
      ::BoundedVerifier<unsigned short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<unsigned short>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<unsigned short>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<unsigned short>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEunsignedsPshortgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<unsigned short>) );
      instance.SetNew(&new_BoundedVerifierlEunsignedsPshortgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEunsignedsPshortgR);
      instance.SetDelete(&delete_BoundedVerifierlEunsignedsPshortgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEunsignedsPshortgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEunsignedsPshortgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<unsigned short>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<unsigned short>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEunsignedsPshortgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned short>*)0x0)->GetClass();
      BoundedVerifierlEunsignedsPshortgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEunsignedsPshortgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEshortgR_Dictionary();
   static void BoundedVerifierlEshortgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEshortgR(void *p = 0);
   static void *newArray_BoundedVerifierlEshortgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEshortgR(void *p);
   static void deleteArray_BoundedVerifierlEshortgR(void *p);
   static void destruct_BoundedVerifierlEshortgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<short>*)
   {
      ::BoundedVerifier<short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<short>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<short>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<short>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEshortgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<short>) );
      instance.SetNew(&new_BoundedVerifierlEshortgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEshortgR);
      instance.SetDelete(&delete_BoundedVerifierlEshortgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEshortgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEshortgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<short>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<short>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEshortgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<short>*)0x0)->GetClass();
      BoundedVerifierlEshortgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEshortgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEunsignedsPchargR_Dictionary();
   static void BoundedVerifierlEunsignedsPchargR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEunsignedsPchargR(void *p = 0);
   static void *newArray_BoundedVerifierlEunsignedsPchargR(Long_t size, void *p);
   static void delete_BoundedVerifierlEunsignedsPchargR(void *p);
   static void deleteArray_BoundedVerifierlEunsignedsPchargR(void *p);
   static void destruct_BoundedVerifierlEunsignedsPchargR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<unsigned char>*)
   {
      ::BoundedVerifier<unsigned char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<unsigned char>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<unsigned char>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<unsigned char>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEunsignedsPchargR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<unsigned char>) );
      instance.SetNew(&new_BoundedVerifierlEunsignedsPchargR);
      instance.SetNewArray(&newArray_BoundedVerifierlEunsignedsPchargR);
      instance.SetDelete(&delete_BoundedVerifierlEunsignedsPchargR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEunsignedsPchargR);
      instance.SetDestructor(&destruct_BoundedVerifierlEunsignedsPchargR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<unsigned char>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<unsigned char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEunsignedsPchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<unsigned char>*)0x0)->GetClass();
      BoundedVerifierlEunsignedsPchargR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEunsignedsPchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEchargR_Dictionary();
   static void BoundedVerifierlEchargR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEchargR(void *p = 0);
   static void *newArray_BoundedVerifierlEchargR(Long_t size, void *p);
   static void delete_BoundedVerifierlEchargR(void *p);
   static void deleteArray_BoundedVerifierlEchargR(void *p);
   static void destruct_BoundedVerifierlEchargR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<char>*)
   {
      ::BoundedVerifier<char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<char>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<char>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<char>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEchargR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<char>) );
      instance.SetNew(&new_BoundedVerifierlEchargR);
      instance.SetNewArray(&newArray_BoundedVerifierlEchargR);
      instance.SetDelete(&delete_BoundedVerifierlEchargR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEchargR);
      instance.SetDestructor(&destruct_BoundedVerifierlEchargR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<char>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<char>*)0x0)->GetClass();
      BoundedVerifierlEchargR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlElonggRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlElonggRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlElonggRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlElonggRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlElonggRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlElonggRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlElonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<long> >*)
   {
      ::BoundedVerifier<vector<long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<long> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<long> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<long> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlElonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<long> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlElonggRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlElonggRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlElonggRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlElonggRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlElonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<long> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlElonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<long> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlElonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlElonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary();
   static void BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p);
   static void destruct_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<map<string,vector<double> > >*)
   {
      ::BoundedVerifier<map<string,vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<map<string,vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<map<string,vector<double> > >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<map<string,vector<double> > >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<map<string,vector<double> > >) );
      instance.SetNew(&new_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<map<string,vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<map<string,vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,vector<double> > >*)0x0)->GetClass();
      BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary();
   static void BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p);
   static void destruct_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<map<string,vector<string> > >*)
   {
      ::BoundedVerifier<map<string,vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<map<string,vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<map<string,vector<string> > >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<map<string,vector<string> > >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<map<string,vector<string> > >) );
      instance.SetNew(&new_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<map<string,vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<map<string,vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,vector<string> > >*)0x0)->GetClass();
      BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEmaplEstringcOdoublegRsPgR_Dictionary();
   static void BoundedVerifierlEmaplEstringcOdoublegRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEmaplEstringcOdoublegRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p);
   static void destruct_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<map<string,double> >*)
   {
      ::BoundedVerifier<map<string,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<map<string,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<map<string,double> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<map<string,double> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEmaplEstringcOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<map<string,double> >) );
      instance.SetNew(&new_BoundedVerifierlEmaplEstringcOdoublegRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEmaplEstringcOdoublegRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEmaplEstringcOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEmaplEstringcOdoublegRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEmaplEstringcOdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<map<string,double> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<map<string,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEmaplEstringcOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,double> >*)0x0)->GetClass();
      BoundedVerifierlEmaplEstringcOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEmaplEstringcOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEmaplEstringcOintgRsPgR_Dictionary();
   static void BoundedVerifierlEmaplEstringcOintgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEmaplEstringcOintgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p);
   static void destruct_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<map<string,int> >*)
   {
      ::BoundedVerifier<map<string,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<map<string,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<map<string,int> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<map<string,int> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEmaplEstringcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<map<string,int> >) );
      instance.SetNew(&new_BoundedVerifierlEmaplEstringcOintgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEmaplEstringcOintgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEmaplEstringcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEmaplEstringcOintgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEmaplEstringcOintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<map<string,int> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<map<string,int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEmaplEstringcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,int> >*)0x0)->GetClass();
      BoundedVerifierlEmaplEstringcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEmaplEstringcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEmaplEstringcOstringgRsPgR_Dictionary();
   static void BoundedVerifierlEmaplEstringcOstringgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEmaplEstringcOstringgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p);
   static void destruct_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<map<string,string> >*)
   {
      ::BoundedVerifier<map<string,string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<map<string,string> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<map<string,string> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<map<string,string> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEmaplEstringcOstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<map<string,string> >) );
      instance.SetNew(&new_BoundedVerifierlEmaplEstringcOstringgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEmaplEstringcOstringgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEmaplEstringcOstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEmaplEstringcOstringgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEmaplEstringcOstringgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<map<string,string> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<map<string,string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEmaplEstringcOstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<map<string,string> >*)0x0)->GetClass();
      BoundedVerifierlEmaplEstringcOstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEmaplEstringcOstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEmaplEintcOdoublegRsPgR_Dictionary();
   static void BoundedVerifierlEmaplEintcOdoublegRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEmaplEintcOdoublegRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p);
   static void destruct_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<map<int,double> >*)
   {
      ::BoundedVerifier<map<int,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<map<int,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<map<int,double> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<map<int,double> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEmaplEintcOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<map<int,double> >) );
      instance.SetNew(&new_BoundedVerifierlEmaplEintcOdoublegRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEmaplEintcOdoublegRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEmaplEintcOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEmaplEintcOdoublegRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEmaplEintcOdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<map<int,double> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<map<int,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<map<int,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEmaplEintcOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<map<int,double> >*)0x0)->GetClass();
      BoundedVerifierlEmaplEintcOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEmaplEintcOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<vector<double> > >*)
   {
      ::BoundedVerifier<vector<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<vector<double> > >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<vector<double> > >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<vector<double> > >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<vector<double> > >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<vector<string> > >*)
   {
      ::BoundedVerifier<vector<vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<vector<string> > >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<vector<string> > >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<vector<string> > >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<vector<string> > >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<pair<double,double> > >*)
   {
      ::BoundedVerifier<vector<pair<double,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<pair<double,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<pair<double,double> > >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<pair<double,double> > >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<pair<double,double> > >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<pair<double,double> > >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<pair<double,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<pair<double,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<pair<double,double> > >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEpairlEdoublecOdoublegRsPgR_Dictionary();
   static void BoundedVerifierlEpairlEdoublecOdoublegRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p);
   static void destruct_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<pair<double,double> >*)
   {
      ::BoundedVerifier<pair<double,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<pair<double,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<pair<double,double> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<pair<double,double> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEpairlEdoublecOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<pair<double,double> >) );
      instance.SetNew(&new_BoundedVerifierlEpairlEdoublecOdoublegRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEpairlEdoublecOdoublegRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEpairlEdoublecOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEpairlEdoublecOdoublegRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEpairlEdoublecOdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<pair<double,double> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<pair<double,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<pair<double,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEpairlEdoublecOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<pair<double,double> >*)0x0)->GetClass();
      BoundedVerifierlEpairlEdoublecOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEpairlEdoublecOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEpairlEintcOintgRsPgR_Dictionary();
   static void BoundedVerifierlEpairlEintcOintgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEpairlEintcOintgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEpairlEintcOintgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEpairlEintcOintgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEpairlEintcOintgRsPgR(void *p);
   static void destruct_BoundedVerifierlEpairlEintcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<pair<int,int> >*)
   {
      ::BoundedVerifier<pair<int,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<pair<int,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<pair<int,int> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<pair<int,int> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEpairlEintcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<pair<int,int> >) );
      instance.SetNew(&new_BoundedVerifierlEpairlEintcOintgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEpairlEintcOintgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEpairlEintcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEpairlEintcOintgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEpairlEintcOintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<pair<int,int> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<pair<int,int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<pair<int,int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEpairlEintcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<pair<int,int> >*)0x0)->GetClass();
      BoundedVerifierlEpairlEintcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEpairlEintcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEGaudicLcLHisto1DDefgR_Dictionary();
   static void BoundedVerifierlEGaudicLcLHisto1DDefgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p = 0);
   static void *newArray_BoundedVerifierlEGaudicLcLHisto1DDefgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p);
   static void deleteArray_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p);
   static void destruct_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<Gaudi::Histo1DDef>*)
   {
      ::BoundedVerifier<Gaudi::Histo1DDef> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<Gaudi::Histo1DDef>));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<Gaudi::Histo1DDef>", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<Gaudi::Histo1DDef>), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEGaudicLcLHisto1DDefgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<Gaudi::Histo1DDef>) );
      instance.SetNew(&new_BoundedVerifierlEGaudicLcLHisto1DDefgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEGaudicLcLHisto1DDefgR);
      instance.SetDelete(&delete_BoundedVerifierlEGaudicLcLHisto1DDefgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEGaudicLcLHisto1DDefgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEGaudicLcLHisto1DDefgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<Gaudi::Histo1DDef>*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<Gaudi::Histo1DDef>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<Gaudi::Histo1DDef>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEGaudicLcLHisto1DDefgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<Gaudi::Histo1DDef>*)0x0)->GetClass();
      BoundedVerifierlEGaudicLcLHisto1DDefgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEGaudicLcLHisto1DDefgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEstringgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEstringgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEstringgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEstringgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEstringgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEstringgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<string> >*)
   {
      ::BoundedVerifier<vector<string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<string> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<string> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<string> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEstringgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEstringgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEstringgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEstringgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<string> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<string> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlElongsPdoublegRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlElongsPdoublegRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlElongsPdoublegRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<long double> >*)
   {
      ::BoundedVerifier<vector<long double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<long double> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<long double> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<long double> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlElongsPdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<long double> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlElongsPdoublegRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlElongsPdoublegRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlElongsPdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlElongsPdoublegRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlElongsPdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<long double> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<long double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<long double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlElongsPdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<long double> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlElongsPdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlElongsPdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEdoublegRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEdoublegRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEdoublegRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEdoublegRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEdoublegRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<double> >*)
   {
      ::BoundedVerifier<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<double> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<double> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<double> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEdoublegRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEdoublegRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<double> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<double> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEfloatgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEfloatgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEfloatgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEfloatgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEfloatgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEfloatgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<float> >*)
   {
      ::BoundedVerifier<vector<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<float> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<float> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<float> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<float> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEfloatgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEfloatgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEfloatgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEfloatgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<float> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<float> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEULong64_tgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEULong64_tgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEULong64_tgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<ULong64_t> >*)
   {
      ::BoundedVerifier<vector<ULong64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<ULong64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<ULong64_t> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<ULong64_t> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEULong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<ULong64_t> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEULong64_tgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEULong64_tgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEULong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEULong64_tgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEULong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<ULong64_t> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<ULong64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<ULong64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEULong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<ULong64_t> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEULong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEULong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlELong64_tgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlELong64_tgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlELong64_tgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<Long64_t> >*)
   {
      ::BoundedVerifier<vector<Long64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<Long64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<Long64_t> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<Long64_t> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlELong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<Long64_t> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlELong64_tgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlELong64_tgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlELong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlELong64_tgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlELong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<Long64_t> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<Long64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<Long64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlELong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<Long64_t> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlELong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlELong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEunsignedsPlonggRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<unsigned long> >*)
   {
      ::BoundedVerifier<vector<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<unsigned long> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<unsigned long> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<unsigned long> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<unsigned long> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<unsigned long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned long> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *BoundedVerifierlEvectorlEunsignedsPintgRsPgR_Dictionary();
   static void BoundedVerifierlEvectorlEunsignedsPintgRsPgR_TClassManip(TClass*);
   static void *new_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p = 0);
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(Long_t size, void *p);
   static void delete_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p);
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p);
   static void destruct_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::BoundedVerifier<vector<unsigned int> >*)
   {
      ::BoundedVerifier<vector<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::BoundedVerifier<vector<unsigned int> >));
      static ::ROOT::TGenericClassInfo 
         instance("BoundedVerifier<vector<unsigned int> >", "GaudiKernel/PropertyVerifier.h", 70,
                  typeid(::BoundedVerifier<vector<unsigned int> >), DefineBehavior(ptr, ptr),
                  &BoundedVerifierlEvectorlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::BoundedVerifier<vector<unsigned int> >) );
      instance.SetNew(&new_BoundedVerifierlEvectorlEunsignedsPintgRsPgR);
      instance.SetNewArray(&newArray_BoundedVerifierlEvectorlEunsignedsPintgRsPgR);
      instance.SetDelete(&delete_BoundedVerifierlEvectorlEunsignedsPintgRsPgR);
      instance.SetDeleteArray(&deleteArray_BoundedVerifierlEvectorlEunsignedsPintgRsPgR);
      instance.SetDestructor(&destruct_BoundedVerifierlEvectorlEunsignedsPintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::BoundedVerifier<vector<unsigned int> >*)
   {
      return GenerateInitInstanceLocal((::BoundedVerifier<vector<unsigned int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *BoundedVerifierlEvectorlEunsignedsPintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::BoundedVerifier<vector<unsigned int> >*)0x0)->GetClass();
      BoundedVerifierlEvectorlEunsignedsPintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void BoundedVerifierlEvectorlEunsignedsPintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEboolgR_Dictionary();
   static void PropertyVerifierlEboolgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEboolgR(void *p);
   static void deleteArray_PropertyVerifierlEboolgR(void *p);
   static void destruct_PropertyVerifierlEboolgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<bool>*)
   {
      ::PropertyVerifier<bool> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<bool>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<bool>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<bool>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEboolgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<bool>) );
      instance.SetDelete(&delete_PropertyVerifierlEboolgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEboolgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEboolgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<bool>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<bool>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<bool>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEboolgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<bool>*)0x0)->GetClass();
      PropertyVerifierlEboolgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEboolgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEstringgR_Dictionary();
   static void PropertyVerifierlEstringgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEstringgR(void *p);
   static void deleteArray_PropertyVerifierlEstringgR(void *p);
   static void destruct_PropertyVerifierlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<string>*)
   {
      ::PropertyVerifier<string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<string>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<string>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<string>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<string>) );
      instance.SetDelete(&delete_PropertyVerifierlEstringgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEstringgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEstringgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<string>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<string>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<string>*)0x0)->GetClass();
      PropertyVerifierlEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlElonggRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlElonggRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlElonggRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlElonggRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlElonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<long> >*)
   {
      ::PropertyVerifier<vector<long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<long> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<long> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlElonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<long> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlElonggRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlElonggRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlElonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlElonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<long> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlElonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlElonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEunsignedsPintgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEunsignedsPintgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEunsignedsPintgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPintgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEunsignedsPintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<unsigned int> >*)
   {
      ::PropertyVerifier<vector<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<unsigned int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<unsigned int> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<unsigned int> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<unsigned int> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEunsignedsPintgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEunsignedsPintgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEunsignedsPintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<unsigned int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<unsigned int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEunsignedsPintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned int> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEunsignedsPintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEunsignedsPintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEintgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEintgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEintgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEintgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<int> >*)
   {
      ::PropertyVerifier<vector<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<int> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<int> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<int> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEintgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<int> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEunsignedsPshortgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEunsignedsPshortgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<unsigned short> >*)
   {
      ::PropertyVerifier<vector<unsigned short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<unsigned short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<unsigned short> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<unsigned short> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEunsignedsPshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<unsigned short> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<unsigned short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<unsigned short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEunsignedsPshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned short> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEunsignedsPshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEunsignedsPshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEshortgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEshortgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEshortgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEshortgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEshortgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<short> >*)
   {
      ::PropertyVerifier<vector<short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<short> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<short> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<short> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEshortgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEshortgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEshortgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<short> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEunsignedsPchargRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEunsignedsPchargRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEunsignedsPchargRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPchargRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEunsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<unsigned char> >*)
   {
      ::PropertyVerifier<vector<unsigned char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<unsigned char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<unsigned char> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<unsigned char> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEunsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<unsigned char> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEunsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEunsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEunsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<unsigned char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<unsigned char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEunsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned char> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEunsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEunsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEsignedsPchargRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEsignedsPchargRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEsignedsPchargRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEsignedsPchargRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEsignedsPchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<signed char> >*)
   {
      ::PropertyVerifier<vector<signed char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<signed char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<signed char> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<signed char> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<signed char> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEsignedsPchargRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEsignedsPchargRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEsignedsPchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<signed char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<signed char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<signed char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<signed char> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEchargRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEchargRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEchargRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEchargRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEchargRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<char> >*)
   {
      ::PropertyVerifier<vector<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<char> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<char> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<char> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEchargRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEchargRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEchargRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<char> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEboolgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEboolgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEboolgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEboolgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEboolgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<bool> >*)
   {
      ::PropertyVerifier<vector<bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<bool> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<bool> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<bool> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<bool> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEboolgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEboolgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEboolgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<bool> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<bool> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEboolgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<bool> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEboolgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEboolgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEunsignedsPlonggRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<unsigned long> >*)
   {
      ::PropertyVerifier<vector<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<unsigned long> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<unsigned long> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<unsigned long> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<unsigned long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<unsigned long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<unsigned long> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlElongsPdoublegR_Dictionary();
   static void PropertyVerifierlElongsPdoublegR_TClassManip(TClass*);
   static void delete_PropertyVerifierlElongsPdoublegR(void *p);
   static void deleteArray_PropertyVerifierlElongsPdoublegR(void *p);
   static void destruct_PropertyVerifierlElongsPdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<long double>*)
   {
      ::PropertyVerifier<long double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<long double>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<long double>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<long double>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlElongsPdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<long double>) );
      instance.SetDelete(&delete_PropertyVerifierlElongsPdoublegR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlElongsPdoublegR);
      instance.SetDestructor(&destruct_PropertyVerifierlElongsPdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<long double>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<long double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<long double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlElongsPdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<long double>*)0x0)->GetClass();
      PropertyVerifierlElongsPdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlElongsPdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEdoublegR_Dictionary();
   static void PropertyVerifierlEdoublegR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEdoublegR(void *p);
   static void deleteArray_PropertyVerifierlEdoublegR(void *p);
   static void destruct_PropertyVerifierlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<double>*)
   {
      ::PropertyVerifier<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<double>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<double>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<double>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<double>) );
      instance.SetDelete(&delete_PropertyVerifierlEdoublegR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEdoublegR);
      instance.SetDestructor(&destruct_PropertyVerifierlEdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<double>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<double>*)0x0)->GetClass();
      PropertyVerifierlEdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEfloatgR_Dictionary();
   static void PropertyVerifierlEfloatgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEfloatgR(void *p);
   static void deleteArray_PropertyVerifierlEfloatgR(void *p);
   static void destruct_PropertyVerifierlEfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<float>*)
   {
      ::PropertyVerifier<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<float>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<float>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<float>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEfloatgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<float>) );
      instance.SetDelete(&delete_PropertyVerifierlEfloatgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEfloatgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<float>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<float>*)0x0)->GetClass();
      PropertyVerifierlEfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEULong64_tgR_Dictionary();
   static void PropertyVerifierlEULong64_tgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEULong64_tgR(void *p);
   static void deleteArray_PropertyVerifierlEULong64_tgR(void *p);
   static void destruct_PropertyVerifierlEULong64_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<ULong64_t>*)
   {
      ::PropertyVerifier<ULong64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<ULong64_t>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<ULong64_t>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<ULong64_t>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEULong64_tgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<ULong64_t>) );
      instance.SetDelete(&delete_PropertyVerifierlEULong64_tgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEULong64_tgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEULong64_tgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<ULong64_t>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<ULong64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<ULong64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEULong64_tgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<ULong64_t>*)0x0)->GetClass();
      PropertyVerifierlEULong64_tgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEULong64_tgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlELong64_tgR_Dictionary();
   static void PropertyVerifierlELong64_tgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlELong64_tgR(void *p);
   static void deleteArray_PropertyVerifierlELong64_tgR(void *p);
   static void destruct_PropertyVerifierlELong64_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<Long64_t>*)
   {
      ::PropertyVerifier<Long64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<Long64_t>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<Long64_t>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<Long64_t>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlELong64_tgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<Long64_t>) );
      instance.SetDelete(&delete_PropertyVerifierlELong64_tgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlELong64_tgR);
      instance.SetDestructor(&destruct_PropertyVerifierlELong64_tgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<Long64_t>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<Long64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<Long64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlELong64_tgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<Long64_t>*)0x0)->GetClass();
      PropertyVerifierlELong64_tgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlELong64_tgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEunsignedsPlonggR_Dictionary();
   static void PropertyVerifierlEunsignedsPlonggR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEunsignedsPlonggR(void *p);
   static void deleteArray_PropertyVerifierlEunsignedsPlonggR(void *p);
   static void destruct_PropertyVerifierlEunsignedsPlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<unsigned long>*)
   {
      ::PropertyVerifier<unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<unsigned long>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<unsigned long>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<unsigned long>) );
      instance.SetDelete(&delete_PropertyVerifierlEunsignedsPlonggR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEunsignedsPlonggR);
      instance.SetDestructor(&destruct_PropertyVerifierlEunsignedsPlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<unsigned long>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<unsigned long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned long>*)0x0)->GetClass();
      PropertyVerifierlEunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlElonggR_Dictionary();
   static void PropertyVerifierlElonggR_TClassManip(TClass*);
   static void delete_PropertyVerifierlElonggR(void *p);
   static void deleteArray_PropertyVerifierlElonggR(void *p);
   static void destruct_PropertyVerifierlElonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<long>*)
   {
      ::PropertyVerifier<long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<long>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<long>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<long>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlElonggR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<long>) );
      instance.SetDelete(&delete_PropertyVerifierlElonggR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlElonggR);
      instance.SetDestructor(&destruct_PropertyVerifierlElonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<long>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlElonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<long>*)0x0)->GetClass();
      PropertyVerifierlElonggR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlElonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEunsignedsPintgR_Dictionary();
   static void PropertyVerifierlEunsignedsPintgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEunsignedsPintgR(void *p);
   static void deleteArray_PropertyVerifierlEunsignedsPintgR(void *p);
   static void destruct_PropertyVerifierlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<unsigned int>*)
   {
      ::PropertyVerifier<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<unsigned int>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<unsigned int>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<unsigned int>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<unsigned int>) );
      instance.SetDelete(&delete_PropertyVerifierlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEunsignedsPintgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEunsignedsPintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<unsigned int>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<unsigned int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEunsignedsPintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned int>*)0x0)->GetClass();
      PropertyVerifierlEunsignedsPintgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEunsignedsPintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEunsignedsPshortgR_Dictionary();
   static void PropertyVerifierlEunsignedsPshortgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEunsignedsPshortgR(void *p);
   static void deleteArray_PropertyVerifierlEunsignedsPshortgR(void *p);
   static void destruct_PropertyVerifierlEunsignedsPshortgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<unsigned short>*)
   {
      ::PropertyVerifier<unsigned short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<unsigned short>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<unsigned short>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<unsigned short>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEunsignedsPshortgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<unsigned short>) );
      instance.SetDelete(&delete_PropertyVerifierlEunsignedsPshortgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEunsignedsPshortgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEunsignedsPshortgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<unsigned short>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<unsigned short>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEunsignedsPshortgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned short>*)0x0)->GetClass();
      PropertyVerifierlEunsignedsPshortgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEunsignedsPshortgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<pair<double,double> > >*)
   {
      ::PropertyVerifier<vector<pair<double,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<pair<double,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<pair<double,double> > >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<pair<double,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<pair<double,double> > >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<pair<double,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<pair<double,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<pair<double,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<pair<double,double> > >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary();
   static void PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p);
   static void destruct_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<map<string,vector<double> > >*)
   {
      ::PropertyVerifier<map<string,vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<map<string,vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<map<string,vector<double> > >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<map<string,vector<double> > >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<map<string,vector<double> > >) );
      instance.SetDelete(&delete_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<map<string,vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<map<string,vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,vector<double> > >*)0x0)->GetClass();
      PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary();
   static void PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p);
   static void destruct_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<map<string,vector<int> > >*)
   {
      ::PropertyVerifier<map<string,vector<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<map<string,vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<map<string,vector<int> > >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<map<string,vector<int> > >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<map<string,vector<int> > >) );
      instance.SetDelete(&delete_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<map<string,vector<int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<map<string,vector<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,vector<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,vector<int> > >*)0x0)->GetClass();
      PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary();
   static void PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p);
   static void destruct_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<map<string,vector<string> > >*)
   {
      ::PropertyVerifier<map<string,vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<map<string,vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<map<string,vector<string> > >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<map<string,vector<string> > >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<map<string,vector<string> > >) );
      instance.SetDelete(&delete_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<map<string,vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<map<string,vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,vector<string> > >*)0x0)->GetClass();
      PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEmaplEstringcOdoublegRsPgR_Dictionary();
   static void PropertyVerifierlEmaplEstringcOdoublegRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEmaplEstringcOdoublegRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEmaplEstringcOdoublegRsPgR(void *p);
   static void destruct_PropertyVerifierlEmaplEstringcOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<map<string,double> >*)
   {
      ::PropertyVerifier<map<string,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<map<string,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<map<string,double> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<map<string,double> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEmaplEstringcOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<map<string,double> >) );
      instance.SetDelete(&delete_PropertyVerifierlEmaplEstringcOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEmaplEstringcOdoublegRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEmaplEstringcOdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<map<string,double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<map<string,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEmaplEstringcOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,double> >*)0x0)->GetClass();
      PropertyVerifierlEmaplEstringcOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEmaplEstringcOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEmaplEstringcOintgRsPgR_Dictionary();
   static void PropertyVerifierlEmaplEstringcOintgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEmaplEstringcOintgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEmaplEstringcOintgRsPgR(void *p);
   static void destruct_PropertyVerifierlEmaplEstringcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<map<string,int> >*)
   {
      ::PropertyVerifier<map<string,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<map<string,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<map<string,int> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<map<string,int> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEmaplEstringcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<map<string,int> >) );
      instance.SetDelete(&delete_PropertyVerifierlEmaplEstringcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEmaplEstringcOintgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEmaplEstringcOintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<map<string,int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<map<string,int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEmaplEstringcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,int> >*)0x0)->GetClass();
      PropertyVerifierlEmaplEstringcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEmaplEstringcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEmaplEstringcOstringgRsPgR_Dictionary();
   static void PropertyVerifierlEmaplEstringcOstringgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEmaplEstringcOstringgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEmaplEstringcOstringgRsPgR(void *p);
   static void destruct_PropertyVerifierlEmaplEstringcOstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<map<string,string> >*)
   {
      ::PropertyVerifier<map<string,string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<map<string,string> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<map<string,string> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<map<string,string> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEmaplEstringcOstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<map<string,string> >) );
      instance.SetDelete(&delete_PropertyVerifierlEmaplEstringcOstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEmaplEstringcOstringgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEmaplEstringcOstringgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<map<string,string> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<map<string,string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEmaplEstringcOstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<map<string,string> >*)0x0)->GetClass();
      PropertyVerifierlEmaplEstringcOstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEmaplEstringcOstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEmaplEintcOdoublegRsPgR_Dictionary();
   static void PropertyVerifierlEmaplEintcOdoublegRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEmaplEintcOdoublegRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEmaplEintcOdoublegRsPgR(void *p);
   static void destruct_PropertyVerifierlEmaplEintcOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<map<int,double> >*)
   {
      ::PropertyVerifier<map<int,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<map<int,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<map<int,double> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<map<int,double> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEmaplEintcOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<map<int,double> >) );
      instance.SetDelete(&delete_PropertyVerifierlEmaplEintcOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEmaplEintcOdoublegRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEmaplEintcOdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<map<int,double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<map<int,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<map<int,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEmaplEintcOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<map<int,double> >*)0x0)->GetClass();
      PropertyVerifierlEmaplEintcOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEmaplEintcOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<vector<double> > >*)
   {
      ::PropertyVerifier<vector<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<vector<double> > >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<vector<double> > >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<vector<double> > >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<vector<double> > >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<vector<string> > >*)
   {
      ::PropertyVerifier<vector<vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<vector<string> > >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<vector<string> > >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<vector<string> > >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<vector<string> > >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEintgR_Dictionary();
   static void PropertyVerifierlEintgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEintgR(void *p);
   static void deleteArray_PropertyVerifierlEintgR(void *p);
   static void destruct_PropertyVerifierlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<int>*)
   {
      ::PropertyVerifier<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<int>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<int>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<int>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<int>) );
      instance.SetDelete(&delete_PropertyVerifierlEintgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEintgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<int>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<int>*)0x0)->GetClass();
      PropertyVerifierlEintgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEpairlEdoublecOdoublegRsPgR_Dictionary();
   static void PropertyVerifierlEpairlEdoublecOdoublegRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEpairlEdoublecOdoublegRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEpairlEdoublecOdoublegRsPgR(void *p);
   static void destruct_PropertyVerifierlEpairlEdoublecOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<pair<double,double> >*)
   {
      ::PropertyVerifier<pair<double,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<pair<double,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<pair<double,double> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<pair<double,double> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEpairlEdoublecOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<pair<double,double> >) );
      instance.SetDelete(&delete_PropertyVerifierlEpairlEdoublecOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEpairlEdoublecOdoublegRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEpairlEdoublecOdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<pair<double,double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<pair<double,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<pair<double,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEpairlEdoublecOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<pair<double,double> >*)0x0)->GetClass();
      PropertyVerifierlEpairlEdoublecOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEpairlEdoublecOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEpairlEintcOintgRsPgR_Dictionary();
   static void PropertyVerifierlEpairlEintcOintgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEpairlEintcOintgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEpairlEintcOintgRsPgR(void *p);
   static void destruct_PropertyVerifierlEpairlEintcOintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<pair<int,int> >*)
   {
      ::PropertyVerifier<pair<int,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<pair<int,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<pair<int,int> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<pair<int,int> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEpairlEintcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<pair<int,int> >) );
      instance.SetDelete(&delete_PropertyVerifierlEpairlEintcOintgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEpairlEintcOintgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEpairlEintcOintgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<pair<int,int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<pair<int,int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<pair<int,int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEpairlEintcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<pair<int,int> >*)0x0)->GetClass();
      PropertyVerifierlEpairlEintcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEpairlEintcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEstringgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEstringgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEstringgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEstringgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEstringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<string> >*)
   {
      ::PropertyVerifier<vector<string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<string> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<string> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<string> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEstringgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEstringgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEstringgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<string> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<string> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlElongsPdoublegRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlElongsPdoublegRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlElongsPdoublegRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlElongsPdoublegRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlElongsPdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<long double> >*)
   {
      ::PropertyVerifier<vector<long double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<long double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<long double> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<long double> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlElongsPdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<long double> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlElongsPdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlElongsPdoublegRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlElongsPdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<long double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<long double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<long double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlElongsPdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<long double> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlElongsPdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlElongsPdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEdoublegRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEdoublegRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEdoublegRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<double> >*)
   {
      ::PropertyVerifier<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<double> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<double> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<double> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEdoublegRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<double> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEfloatgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEfloatgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEfloatgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEfloatgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<float> >*)
   {
      ::PropertyVerifier<vector<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<float> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<float> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<float> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<float> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEfloatgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEfloatgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<float> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<float> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlEULong64_tgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlEULong64_tgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlEULong64_tgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlEULong64_tgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlEULong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<ULong64_t> >*)
   {
      ::PropertyVerifier<vector<ULong64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<ULong64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<ULong64_t> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<ULong64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlEULong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<ULong64_t> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlEULong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlEULong64_tgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlEULong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<ULong64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<ULong64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<ULong64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlEULong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<ULong64_t> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlEULong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlEULong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEvectorlELong64_tgRsPgR_Dictionary();
   static void PropertyVerifierlEvectorlELong64_tgRsPgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEvectorlELong64_tgRsPgR(void *p);
   static void deleteArray_PropertyVerifierlEvectorlELong64_tgRsPgR(void *p);
   static void destruct_PropertyVerifierlEvectorlELong64_tgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<vector<Long64_t> >*)
   {
      ::PropertyVerifier<vector<Long64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<vector<Long64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<vector<Long64_t> >", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<vector<Long64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEvectorlELong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<vector<Long64_t> >) );
      instance.SetDelete(&delete_PropertyVerifierlEvectorlELong64_tgRsPgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEvectorlELong64_tgRsPgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEvectorlELong64_tgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<vector<Long64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<vector<Long64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<vector<Long64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEvectorlELong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<vector<Long64_t> >*)0x0)->GetClass();
      PropertyVerifierlEvectorlELong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEvectorlELong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEunsignedsPchargR_Dictionary();
   static void PropertyVerifierlEunsignedsPchargR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEunsignedsPchargR(void *p);
   static void deleteArray_PropertyVerifierlEunsignedsPchargR(void *p);
   static void destruct_PropertyVerifierlEunsignedsPchargR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<unsigned char>*)
   {
      ::PropertyVerifier<unsigned char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<unsigned char>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<unsigned char>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<unsigned char>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEunsignedsPchargR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<unsigned char>) );
      instance.SetDelete(&delete_PropertyVerifierlEunsignedsPchargR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEunsignedsPchargR);
      instance.SetDestructor(&destruct_PropertyVerifierlEunsignedsPchargR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<unsigned char>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<unsigned char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEunsignedsPchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<unsigned char>*)0x0)->GetClass();
      PropertyVerifierlEunsignedsPchargR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEunsignedsPchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEsignedsPchargR_Dictionary();
   static void PropertyVerifierlEsignedsPchargR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEsignedsPchargR(void *p);
   static void deleteArray_PropertyVerifierlEsignedsPchargR(void *p);
   static void destruct_PropertyVerifierlEsignedsPchargR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<signed char>*)
   {
      ::PropertyVerifier<signed char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<signed char>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<signed char>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<signed char>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEsignedsPchargR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<signed char>) );
      instance.SetDelete(&delete_PropertyVerifierlEsignedsPchargR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEsignedsPchargR);
      instance.SetDestructor(&destruct_PropertyVerifierlEsignedsPchargR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<signed char>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<signed char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<signed char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEsignedsPchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<signed char>*)0x0)->GetClass();
      PropertyVerifierlEsignedsPchargR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEsignedsPchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEchargR_Dictionary();
   static void PropertyVerifierlEchargR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEchargR(void *p);
   static void deleteArray_PropertyVerifierlEchargR(void *p);
   static void destruct_PropertyVerifierlEchargR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<char>*)
   {
      ::PropertyVerifier<char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<char>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<char>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<char>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEchargR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<char>) );
      instance.SetDelete(&delete_PropertyVerifierlEchargR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEchargR);
      instance.SetDestructor(&destruct_PropertyVerifierlEchargR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<char>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<char>*)0x0)->GetClass();
      PropertyVerifierlEchargR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEGaudicLcLHisto1DDefgR_Dictionary();
   static void PropertyVerifierlEGaudicLcLHisto1DDefgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEGaudicLcLHisto1DDefgR(void *p);
   static void deleteArray_PropertyVerifierlEGaudicLcLHisto1DDefgR(void *p);
   static void destruct_PropertyVerifierlEGaudicLcLHisto1DDefgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<Gaudi::Histo1DDef>*)
   {
      ::PropertyVerifier<Gaudi::Histo1DDef> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<Gaudi::Histo1DDef>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<Gaudi::Histo1DDef>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<Gaudi::Histo1DDef>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEGaudicLcLHisto1DDefgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<Gaudi::Histo1DDef>) );
      instance.SetDelete(&delete_PropertyVerifierlEGaudicLcLHisto1DDefgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEGaudicLcLHisto1DDefgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEGaudicLcLHisto1DDefgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<Gaudi::Histo1DDef>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<Gaudi::Histo1DDef>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<Gaudi::Histo1DDef>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEGaudicLcLHisto1DDefgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<Gaudi::Histo1DDef>*)0x0)->GetClass();
      PropertyVerifierlEGaudicLcLHisto1DDefgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEGaudicLcLHisto1DDefgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyVerifierlEshortgR_Dictionary();
   static void PropertyVerifierlEshortgR_TClassManip(TClass*);
   static void delete_PropertyVerifierlEshortgR(void *p);
   static void deleteArray_PropertyVerifierlEshortgR(void *p);
   static void destruct_PropertyVerifierlEshortgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyVerifier<short>*)
   {
      ::PropertyVerifier<short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyVerifier<short>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyVerifier<short>", "GaudiKernel/PropertyVerifier.h", 27,
                  typeid(::PropertyVerifier<short>), DefineBehavior(ptr, ptr),
                  &PropertyVerifierlEshortgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyVerifier<short>) );
      instance.SetDelete(&delete_PropertyVerifierlEshortgR);
      instance.SetDeleteArray(&deleteArray_PropertyVerifierlEshortgR);
      instance.SetDestructor(&destruct_PropertyVerifierlEshortgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyVerifier<short>*)
   {
      return GenerateInitInstanceLocal((::PropertyVerifier<short>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyVerifier<short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyVerifierlEshortgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyVerifier<short>*)0x0)->GetClass();
      PropertyVerifierlEshortgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyVerifierlEshortgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyCallbackFunctor_Dictionary();
   static void PropertyCallbackFunctor_TClassManip(TClass*);
   static void delete_PropertyCallbackFunctor(void *p);
   static void deleteArray_PropertyCallbackFunctor(void *p);
   static void destruct_PropertyCallbackFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyCallbackFunctor*)
   {
      ::PropertyCallbackFunctor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyCallbackFunctor));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyCallbackFunctor", "GaudiKernel/PropertyCallbackFunctor.h", 42,
                  typeid(::PropertyCallbackFunctor), DefineBehavior(ptr, ptr),
                  &PropertyCallbackFunctor_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyCallbackFunctor) );
      instance.SetDelete(&delete_PropertyCallbackFunctor);
      instance.SetDeleteArray(&deleteArray_PropertyCallbackFunctor);
      instance.SetDestructor(&destruct_PropertyCallbackFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyCallbackFunctor*)
   {
      return GenerateInitInstanceLocal((::PropertyCallbackFunctor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyCallbackFunctor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyCallbackFunctor_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyCallbackFunctor*)0x0)->GetClass();
      PropertyCallbackFunctor_TClassManip(theClass);
   return theClass;
   }

   static void PropertyCallbackFunctor_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrintStat_Dictionary();
   static void GaudiAlgcLcLPrintStat_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrintStat(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrintStat(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrintStat(void *p);
   static void deleteArray_GaudiAlgcLcLPrintStat(void *p);
   static void destruct_GaudiAlgcLcLPrintStat(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::PrintStat*)
   {
      ::GaudiAlg::PrintStat *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::PrintStat));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::PrintStat", "GaudiAlg/Print.h", 193,
                  typeid(::GaudiAlg::PrintStat), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrintStat_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::PrintStat) );
      instance.SetNew(&new_GaudiAlgcLcLPrintStat);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrintStat);
      instance.SetDelete(&delete_GaudiAlgcLcLPrintStat);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrintStat);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrintStat);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::PrintStat*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::PrintStat*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::PrintStat*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrintStat_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::PrintStat*)0x0)->GetClass();
      GaudiAlgcLcLPrintStat_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrintStat_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrintTuple_Dictionary();
   static void GaudiAlgcLcLPrintTuple_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrintTuple(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrintTuple(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrintTuple(void *p);
   static void deleteArray_GaudiAlgcLcLPrintTuple(void *p);
   static void destruct_GaudiAlgcLcLPrintTuple(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::PrintTuple*)
   {
      ::GaudiAlg::PrintTuple *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::PrintTuple));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::PrintTuple", "GaudiAlg/Print.h", 173,
                  typeid(::GaudiAlg::PrintTuple), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrintTuple_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::PrintTuple) );
      instance.SetNew(&new_GaudiAlgcLcLPrintTuple);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrintTuple);
      instance.SetDelete(&delete_GaudiAlgcLcLPrintTuple);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrintTuple);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrintTuple);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::PrintTuple*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::PrintTuple*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::PrintTuple*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrintTuple_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::PrintTuple*)0x0)->GetClass();
      GaudiAlgcLcLPrintTuple_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrintTuple_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrint_Dictionary();
   static void GaudiAlgcLcLPrint_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrint(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrint(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrint(void *p);
   static void deleteArray_GaudiAlgcLcLPrint(void *p);
   static void destruct_GaudiAlgcLcLPrint(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::Print*)
   {
      ::GaudiAlg::Print *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::Print));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::Print", "GaudiAlg/Print.h", 54,
                  typeid(::GaudiAlg::Print), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrint_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::Print) );
      instance.SetNew(&new_GaudiAlgcLcLPrint);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrint);
      instance.SetDelete(&delete_GaudiAlgcLcLPrint);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrint);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrint);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::Print*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::Print*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::Print*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrint_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::Print*)0x0)->GetClass();
      GaudiAlgcLcLPrint_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrint_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrint1D_Dictionary();
   static void GaudiAlgcLcLPrint1D_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrint1D(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrint1D(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrint1D(void *p);
   static void deleteArray_GaudiAlgcLcLPrint1D(void *p);
   static void destruct_GaudiAlgcLcLPrint1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::Print1D*)
   {
      ::GaudiAlg::Print1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::Print1D));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::Print1D", "GaudiAlg/Print.h", 68,
                  typeid(::GaudiAlg::Print1D), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrint1D_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::Print1D) );
      instance.SetNew(&new_GaudiAlgcLcLPrint1D);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrint1D);
      instance.SetDelete(&delete_GaudiAlgcLcLPrint1D);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrint1D);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrint1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::Print1D*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::Print1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::Print1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrint1D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::Print1D*)0x0)->GetClass();
      GaudiAlgcLcLPrint1D_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrint1D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrint2DProf_Dictionary();
   static void GaudiAlgcLcLPrint2DProf_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrint2DProf(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrint2DProf(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrint2DProf(void *p);
   static void deleteArray_GaudiAlgcLcLPrint2DProf(void *p);
   static void destruct_GaudiAlgcLcLPrint2DProf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::Print2DProf*)
   {
      ::GaudiAlg::Print2DProf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::Print2DProf));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::Print2DProf", "GaudiAlg/Print.h", 151,
                  typeid(::GaudiAlg::Print2DProf), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrint2DProf_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::Print2DProf) );
      instance.SetNew(&new_GaudiAlgcLcLPrint2DProf);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrint2DProf);
      instance.SetDelete(&delete_GaudiAlgcLcLPrint2DProf);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrint2DProf);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrint2DProf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::Print2DProf*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::Print2DProf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::Print2DProf*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrint2DProf_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::Print2DProf*)0x0)->GetClass();
      GaudiAlgcLcLPrint2DProf_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrint2DProf_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrint2D_Dictionary();
   static void GaudiAlgcLcLPrint2D_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrint2D(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrint2D(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrint2D(void *p);
   static void deleteArray_GaudiAlgcLcLPrint2D(void *p);
   static void destruct_GaudiAlgcLcLPrint2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::Print2D*)
   {
      ::GaudiAlg::Print2D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::Print2D));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::Print2D", "GaudiAlg/Print.h", 88,
                  typeid(::GaudiAlg::Print2D), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrint2D_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::Print2D) );
      instance.SetNew(&new_GaudiAlgcLcLPrint2D);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrint2D);
      instance.SetDelete(&delete_GaudiAlgcLcLPrint2D);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrint2D);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrint2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::Print2D*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::Print2D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::Print2D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrint2D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::Print2D*)0x0)->GetClass();
      GaudiAlgcLcLPrint2D_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrint2D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrint1DProf_Dictionary();
   static void GaudiAlgcLcLPrint1DProf_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrint1DProf(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrint1DProf(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrint1DProf(void *p);
   static void deleteArray_GaudiAlgcLcLPrint1DProf(void *p);
   static void destruct_GaudiAlgcLcLPrint1DProf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::Print1DProf*)
   {
      ::GaudiAlg::Print1DProf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::Print1DProf));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::Print1DProf", "GaudiAlg/Print.h", 130,
                  typeid(::GaudiAlg::Print1DProf), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrint1DProf_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::Print1DProf) );
      instance.SetNew(&new_GaudiAlgcLcLPrint1DProf);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrint1DProf);
      instance.SetDelete(&delete_GaudiAlgcLcLPrint1DProf);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrint1DProf);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrint1DProf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::Print1DProf*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::Print1DProf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::Print1DProf*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrint1DProf_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::Print1DProf*)0x0)->GetClass();
      GaudiAlgcLcLPrint1DProf_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrint1DProf_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLPrint3D_Dictionary();
   static void GaudiAlgcLcLPrint3D_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLPrint3D(void *p = 0);
   static void *newArray_GaudiAlgcLcLPrint3D(Long_t size, void *p);
   static void delete_GaudiAlgcLcLPrint3D(void *p);
   static void deleteArray_GaudiAlgcLcLPrint3D(void *p);
   static void destruct_GaudiAlgcLcLPrint3D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::Print3D*)
   {
      ::GaudiAlg::Print3D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::Print3D));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::Print3D", "GaudiAlg/Print.h", 109,
                  typeid(::GaudiAlg::Print3D), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLPrint3D_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::Print3D) );
      instance.SetNew(&new_GaudiAlgcLcLPrint3D);
      instance.SetNewArray(&newArray_GaudiAlgcLcLPrint3D);
      instance.SetDelete(&delete_GaudiAlgcLcLPrint3D);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLPrint3D);
      instance.SetDestructor(&destruct_GaudiAlgcLcLPrint3D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::Print3D*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::Print3D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::Print3D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLPrint3D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::Print3D*)0x0)->GetClass();
      GaudiAlgcLcLPrint3D_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLPrint3D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgcLcLID_Dictionary();
   static void GaudiAlgcLcLID_TClassManip(TClass*);
   static void *new_GaudiAlgcLcLID(void *p = 0);
   static void *newArray_GaudiAlgcLcLID(Long_t size, void *p);
   static void delete_GaudiAlgcLcLID(void *p);
   static void deleteArray_GaudiAlgcLcLID(void *p);
   static void destruct_GaudiAlgcLcLID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlg::ID*)
   {
      ::GaudiAlg::ID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlg::ID));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlg::ID", "GaudiAlg/GaudiHistoID.h", 46,
                  typeid(::GaudiAlg::ID), DefineBehavior(ptr, ptr),
                  &GaudiAlgcLcLID_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlg::ID) );
      instance.SetNew(&new_GaudiAlgcLcLID);
      instance.SetNewArray(&newArray_GaudiAlgcLcLID);
      instance.SetDelete(&delete_GaudiAlgcLcLID);
      instance.SetDeleteArray(&deleteArray_GaudiAlgcLcLID);
      instance.SetDestructor(&destruct_GaudiAlgcLcLID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlg::ID*)
   {
      return GenerateInitInstanceLocal((::GaudiAlg::ID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlg::ID*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgcLcLID_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlg::ID*)0x0)->GetClass();
      GaudiAlgcLcLID_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgcLcLID_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiAlgorithm_Dictionary();
   static void GaudiAlgorithm_TClassManip(TClass*);
   static void delete_GaudiAlgorithm(void *p);
   static void deleteArray_GaudiAlgorithm(void *p);
   static void destruct_GaudiAlgorithm(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiAlgorithm*)
   {
      ::GaudiAlgorithm *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiAlgorithm));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiAlgorithm", "GaudiAlg/GaudiAlgorithm.h", 94,
                  typeid(::GaudiAlgorithm), DefineBehavior(ptr, ptr),
                  &GaudiAlgorithm_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiAlgorithm) );
      instance.SetDelete(&delete_GaudiAlgorithm);
      instance.SetDeleteArray(&deleteArray_GaudiAlgorithm);
      instance.SetDestructor(&destruct_GaudiAlgorithm);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiAlgorithm*)
   {
      return GenerateInitInstanceLocal((::GaudiAlgorithm*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiAlgorithm*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiAlgorithm_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiAlgorithm*)0x0)->GetClass();
      GaudiAlgorithm_TClassManip(theClass);
   return theClass;
   }

   static void GaudiAlgorithm_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiHistoAlg_Dictionary();
   static void GaudiHistoAlg_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiHistoAlg*)
   {
      ::GaudiHistoAlg *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiHistoAlg));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiHistoAlg", "GaudiAlg/GaudiHistoAlg.h", 38,
                  typeid(::GaudiHistoAlg), DefineBehavior(ptr, ptr),
                  &GaudiHistoAlg_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiHistoAlg) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiHistoAlg*)
   {
      return GenerateInitInstanceLocal((::GaudiHistoAlg*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiHistoAlg*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiHistoAlg_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiHistoAlg*)0x0)->GetClass();
      GaudiHistoAlg_TClassManip(theClass);
   return theClass;
   }

   static void GaudiHistoAlg_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLPyAlglEGaudiTupleAlggR_Dictionary();
   static void GaudiPythoncLcLPyAlglEGaudiTupleAlggR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::PyAlg<GaudiTupleAlg>*)
   {
      ::GaudiPython::PyAlg<GaudiTupleAlg> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::PyAlg<GaudiTupleAlg>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::PyAlg<GaudiTupleAlg>", "GaudiPython/Algorithm.h", 65,
                  typeid(::GaudiPython::PyAlg<GaudiTupleAlg>), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLPyAlglEGaudiTupleAlggR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::PyAlg<GaudiTupleAlg>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::PyAlg<GaudiTupleAlg>*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::PyAlg<GaudiTupleAlg>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::PyAlg<GaudiTupleAlg>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLPyAlglEGaudiTupleAlggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::PyAlg<GaudiTupleAlg>*)0x0)->GetClass();
      GaudiPythoncLcLPyAlglEGaudiTupleAlggR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLPyAlglEGaudiTupleAlggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLPyAlglEGaudiHistoAlggR_Dictionary();
   static void GaudiPythoncLcLPyAlglEGaudiHistoAlggR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::PyAlg<GaudiHistoAlg>*)
   {
      ::GaudiPython::PyAlg<GaudiHistoAlg> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::PyAlg<GaudiHistoAlg>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::PyAlg<GaudiHistoAlg>", "GaudiPython/Algorithm.h", 65,
                  typeid(::GaudiPython::PyAlg<GaudiHistoAlg>), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLPyAlglEGaudiHistoAlggR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::PyAlg<GaudiHistoAlg>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::PyAlg<GaudiHistoAlg>*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::PyAlg<GaudiHistoAlg>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::PyAlg<GaudiHistoAlg>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLPyAlglEGaudiHistoAlggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::PyAlg<GaudiHistoAlg>*)0x0)->GetClass();
      GaudiPythoncLcLPyAlglEGaudiHistoAlggR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLPyAlglEGaudiHistoAlggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLPyAlglEGaudiAlgorithmgR_Dictionary();
   static void GaudiPythoncLcLPyAlglEGaudiAlgorithmgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::PyAlg<GaudiAlgorithm>*)
   {
      ::GaudiPython::PyAlg<GaudiAlgorithm> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::PyAlg<GaudiAlgorithm>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::PyAlg<GaudiAlgorithm>", "GaudiPython/Algorithm.h", 65,
                  typeid(::GaudiPython::PyAlg<GaudiAlgorithm>), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLPyAlglEGaudiAlgorithmgR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::PyAlg<GaudiAlgorithm>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::PyAlg<GaudiAlgorithm>*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::PyAlg<GaudiAlgorithm>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::PyAlg<GaudiAlgorithm>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLPyAlglEGaudiAlgorithmgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::PyAlg<GaudiAlgorithm>*)0x0)->GetClass();
      GaudiPythoncLcLPyAlglEGaudiAlgorithmgR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLPyAlglEGaudiAlgorithmgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiTupleAlg_Dictionary();
   static void GaudiTupleAlg_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiTupleAlg*)
   {
      ::GaudiTupleAlg *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiTupleAlg));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiTupleAlg", "GaudiAlg/GaudiTupleAlg.h", 42,
                  typeid(::GaudiTupleAlg), DefineBehavior(ptr, ptr),
                  &GaudiTupleAlg_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiTupleAlg) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiTupleAlg*)
   {
      return GenerateInitInstanceLocal((::GaudiTupleAlg*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiTupleAlg*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiTupleAlg_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiTupleAlg*)0x0)->GetClass();
      GaudiTupleAlg_TClassManip(theClass);
   return theClass;
   }

   static void GaudiTupleAlg_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *TuplescLcLTuple_Dictionary();
   static void TuplescLcLTuple_TClassManip(TClass*);
   static void delete_TuplescLcLTuple(void *p);
   static void deleteArray_TuplescLcLTuple(void *p);
   static void destruct_TuplescLcLTuple(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Tuples::Tuple*)
   {
      ::Tuples::Tuple *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Tuples::Tuple));
      static ::ROOT::TGenericClassInfo 
         instance("Tuples::Tuple", "GaudiAlg/Tuple.h", 115,
                  typeid(::Tuples::Tuple), DefineBehavior(ptr, ptr),
                  &TuplescLcLTuple_Dictionary, isa_proxy, 0,
                  sizeof(::Tuples::Tuple) );
      instance.SetDelete(&delete_TuplescLcLTuple);
      instance.SetDeleteArray(&deleteArray_TuplescLcLTuple);
      instance.SetDestructor(&destruct_TuplescLcLTuple);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Tuples::Tuple*)
   {
      return GenerateInitInstanceLocal((::Tuples::Tuple*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Tuples::Tuple*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *TuplescLcLTuple_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Tuples::Tuple*)0x0)->GetClass();
      TuplescLcLTuple_TClassManip(theClass);
   return theClass;
   }

   static void TuplescLcLTuple_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLTupleDecorator_Dictionary();
   static void GaudiPythoncLcLTupleDecorator_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLTupleDecorator(void *p = 0);
   static void *newArray_GaudiPythoncLcLTupleDecorator(Long_t size, void *p);
   static void delete_GaudiPythoncLcLTupleDecorator(void *p);
   static void deleteArray_GaudiPythoncLcLTupleDecorator(void *p);
   static void destruct_GaudiPythoncLcLTupleDecorator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::TupleDecorator*)
   {
      ::GaudiPython::TupleDecorator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::TupleDecorator));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::TupleDecorator", "GaudiPython/TupleDecorator.h", 48,
                  typeid(::GaudiPython::TupleDecorator), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLTupleDecorator_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::TupleDecorator) );
      instance.SetNew(&new_GaudiPythoncLcLTupleDecorator);
      instance.SetNewArray(&newArray_GaudiPythoncLcLTupleDecorator);
      instance.SetDelete(&delete_GaudiPythoncLcLTupleDecorator);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLTupleDecorator);
      instance.SetDestructor(&destruct_GaudiPythoncLcLTupleDecorator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::TupleDecorator*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::TupleDecorator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::TupleDecorator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLTupleDecorator_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::TupleDecorator*)0x0)->GetClass();
      GaudiPythoncLcLTupleDecorator_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLTupleDecorator_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLTupleToolDecorator_Dictionary();
   static void GaudiPythoncLcLTupleToolDecorator_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLTupleToolDecorator(void *p = 0);
   static void *newArray_GaudiPythoncLcLTupleToolDecorator(Long_t size, void *p);
   static void delete_GaudiPythoncLcLTupleToolDecorator(void *p);
   static void deleteArray_GaudiPythoncLcLTupleToolDecorator(void *p);
   static void destruct_GaudiPythoncLcLTupleToolDecorator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::TupleToolDecorator*)
   {
      ::GaudiPython::TupleToolDecorator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::TupleToolDecorator));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::TupleToolDecorator", "GaudiPython/TupleDecorator.h", 513,
                  typeid(::GaudiPython::TupleToolDecorator), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLTupleToolDecorator_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::TupleToolDecorator) );
      instance.SetNew(&new_GaudiPythoncLcLTupleToolDecorator);
      instance.SetNewArray(&newArray_GaudiPythoncLcLTupleToolDecorator);
      instance.SetDelete(&delete_GaudiPythoncLcLTupleToolDecorator);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLTupleToolDecorator);
      instance.SetDestructor(&destruct_GaudiPythoncLcLTupleToolDecorator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::TupleToolDecorator*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::TupleToolDecorator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::TupleToolDecorator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLTupleToolDecorator_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::TupleToolDecorator*)0x0)->GetClass();
      GaudiPythoncLcLTupleToolDecorator_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLTupleToolDecorator_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLHistoDecorator_Dictionary();
   static void GaudiPythoncLcLHistoDecorator_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLHistoDecorator(void *p = 0);
   static void *newArray_GaudiPythoncLcLHistoDecorator(Long_t size, void *p);
   static void delete_GaudiPythoncLcLHistoDecorator(void *p);
   static void deleteArray_GaudiPythoncLcLHistoDecorator(void *p);
   static void destruct_GaudiPythoncLcLHistoDecorator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::HistoDecorator*)
   {
      ::GaudiPython::HistoDecorator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::HistoDecorator));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::HistoDecorator", "GaudiPython/HistoDecorator.h", 27,
                  typeid(::GaudiPython::HistoDecorator), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLHistoDecorator_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::HistoDecorator) );
      instance.SetNew(&new_GaudiPythoncLcLHistoDecorator);
      instance.SetNewArray(&newArray_GaudiPythoncLcLHistoDecorator);
      instance.SetDelete(&delete_GaudiPythoncLcLHistoDecorator);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLHistoDecorator);
      instance.SetDestructor(&destruct_GaudiPythoncLcLHistoDecorator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::HistoDecorator*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::HistoDecorator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::HistoDecorator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLHistoDecorator_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::HistoDecorator*)0x0)->GetClass();
      GaudiPythoncLcLHistoDecorator_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLHistoDecorator_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLAlgDecorator_Dictionary();
   static void GaudiPythoncLcLAlgDecorator_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLAlgDecorator(void *p = 0);
   static void *newArray_GaudiPythoncLcLAlgDecorator(Long_t size, void *p);
   static void delete_GaudiPythoncLcLAlgDecorator(void *p);
   static void deleteArray_GaudiPythoncLcLAlgDecorator(void *p);
   static void destruct_GaudiPythoncLcLAlgDecorator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::AlgDecorator*)
   {
      ::GaudiPython::AlgDecorator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::AlgDecorator));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::AlgDecorator", "GaudiPython/AlgDecorators.h", 47,
                  typeid(::GaudiPython::AlgDecorator), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLAlgDecorator_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::AlgDecorator) );
      instance.SetNew(&new_GaudiPythoncLcLAlgDecorator);
      instance.SetNewArray(&newArray_GaudiPythoncLcLAlgDecorator);
      instance.SetDelete(&delete_GaudiPythoncLcLAlgDecorator);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLAlgDecorator);
      instance.SetDestructor(&destruct_GaudiPythoncLcLAlgDecorator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::AlgDecorator*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::AlgDecorator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::AlgDecorator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLAlgDecorator_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::AlgDecorator*)0x0)->GetClass();
      GaudiPythoncLcLAlgDecorator_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLAlgDecorator_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLTupleAlgDecorator_Dictionary();
   static void GaudiPythoncLcLTupleAlgDecorator_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLTupleAlgDecorator(void *p = 0);
   static void *newArray_GaudiPythoncLcLTupleAlgDecorator(Long_t size, void *p);
   static void delete_GaudiPythoncLcLTupleAlgDecorator(void *p);
   static void deleteArray_GaudiPythoncLcLTupleAlgDecorator(void *p);
   static void destruct_GaudiPythoncLcLTupleAlgDecorator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::TupleAlgDecorator*)
   {
      ::GaudiPython::TupleAlgDecorator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::TupleAlgDecorator));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::TupleAlgDecorator", "GaudiPython/TupleDecorator.h", 448,
                  typeid(::GaudiPython::TupleAlgDecorator), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLTupleAlgDecorator_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::TupleAlgDecorator) );
      instance.SetNew(&new_GaudiPythoncLcLTupleAlgDecorator);
      instance.SetNewArray(&newArray_GaudiPythoncLcLTupleAlgDecorator);
      instance.SetDelete(&delete_GaudiPythoncLcLTupleAlgDecorator);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLTupleAlgDecorator);
      instance.SetDestructor(&destruct_GaudiPythoncLcLTupleAlgDecorator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::TupleAlgDecorator*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::TupleAlgDecorator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::TupleAlgDecorator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLTupleAlgDecorator_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::TupleAlgDecorator*)0x0)->GetClass();
      GaudiPythoncLcLTupleAlgDecorator_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLTupleAlgDecorator_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *StatEntity_Dictionary();
   static void StatEntity_TClassManip(TClass*);
   static void *new_StatEntity(void *p = 0);
   static void *newArray_StatEntity(Long_t size, void *p);
   static void delete_StatEntity(void *p);
   static void deleteArray_StatEntity(void *p);
   static void destruct_StatEntity(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::StatEntity*)
   {
      ::StatEntity *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::StatEntity));
      static ::ROOT::TGenericClassInfo 
         instance("StatEntity", "GaudiKernel/StatEntity.h", 68,
                  typeid(::StatEntity), DefineBehavior(ptr, ptr),
                  &StatEntity_Dictionary, isa_proxy, 0,
                  sizeof(::StatEntity) );
      instance.SetNew(&new_StatEntity);
      instance.SetNewArray(&newArray_StatEntity);
      instance.SetDelete(&delete_StatEntity);
      instance.SetDeleteArray(&deleteArray_StatEntity);
      instance.SetDestructor(&destruct_StatEntity);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::StatEntity*)
   {
      return GenerateInitInstanceLocal((::StatEntity*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::StatEntity*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *StatEntity_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::StatEntity*)0x0)->GetClass();
      StatEntity_TClassManip(theClass);
   return theClass;
   }

   static void StatEntity_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLPrinterlEContainedObjectgR_Dictionary();
   static void GaudiPythoncLcLPrinterlEContainedObjectgR_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p = 0);
   static void *newArray_GaudiPythoncLcLPrinterlEContainedObjectgR(Long_t size, void *p);
   static void delete_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p);
   static void deleteArray_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p);
   static void destruct_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::Printer<ContainedObject>*)
   {
      ::GaudiPython::Printer<ContainedObject> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::Printer<ContainedObject>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::Printer<ContainedObject>", "GaudiPython/Printer.h", 39,
                  typeid(::GaudiPython::Printer<ContainedObject>), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLPrinterlEContainedObjectgR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::Printer<ContainedObject>) );
      instance.SetNew(&new_GaudiPythoncLcLPrinterlEContainedObjectgR);
      instance.SetNewArray(&newArray_GaudiPythoncLcLPrinterlEContainedObjectgR);
      instance.SetDelete(&delete_GaudiPythoncLcLPrinterlEContainedObjectgR);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLPrinterlEContainedObjectgR);
      instance.SetDestructor(&destruct_GaudiPythoncLcLPrinterlEContainedObjectgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::Printer<ContainedObject>*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::Printer<ContainedObject>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::Printer<ContainedObject>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLPrinterlEContainedObjectgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::Printer<ContainedObject>*)0x0)->GetClass();
      GaudiPythoncLcLPrinterlEContainedObjectgR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLPrinterlEContainedObjectgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLPrinterlEDataObjectgR_Dictionary();
   static void GaudiPythoncLcLPrinterlEDataObjectgR_TClassManip(TClass*);
   static void *new_GaudiPythoncLcLPrinterlEDataObjectgR(void *p = 0);
   static void *newArray_GaudiPythoncLcLPrinterlEDataObjectgR(Long_t size, void *p);
   static void delete_GaudiPythoncLcLPrinterlEDataObjectgR(void *p);
   static void deleteArray_GaudiPythoncLcLPrinterlEDataObjectgR(void *p);
   static void destruct_GaudiPythoncLcLPrinterlEDataObjectgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::Printer<DataObject>*)
   {
      ::GaudiPython::Printer<DataObject> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::Printer<DataObject>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::Printer<DataObject>", "GaudiPython/Printer.h", 50,
                  typeid(::GaudiPython::Printer<DataObject>), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLPrinterlEDataObjectgR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::Printer<DataObject>) );
      instance.SetNew(&new_GaudiPythoncLcLPrinterlEDataObjectgR);
      instance.SetNewArray(&newArray_GaudiPythoncLcLPrinterlEDataObjectgR);
      instance.SetDelete(&delete_GaudiPythoncLcLPrinterlEDataObjectgR);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLPrinterlEDataObjectgR);
      instance.SetDestructor(&destruct_GaudiPythoncLcLPrinterlEDataObjectgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::Printer<DataObject>*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::Printer<DataObject>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::Printer<DataObject>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLPrinterlEDataObjectgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::Printer<DataObject>*)0x0)->GetClass();
      GaudiPythoncLcLPrinterlEDataObjectgR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLPrinterlEDataObjectgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiCommonlEAlgorithmgR_Dictionary();
   static void GaudiCommonlEAlgorithmgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiCommon<Algorithm>*)
   {
      ::GaudiCommon<Algorithm> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiCommon<Algorithm>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiCommon<Algorithm>", "GaudiAlg/GaudiCommon.h", 59,
                  typeid(::GaudiCommon<Algorithm>), DefineBehavior(ptr, ptr),
                  &GaudiCommonlEAlgorithmgR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiCommon<Algorithm>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiCommon<Algorithm>*)
   {
      return GenerateInitInstanceLocal((::GaudiCommon<Algorithm>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiCommon<Algorithm>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiCommonlEAlgorithmgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiCommon<Algorithm>*)0x0)->GetClass();
      GaudiCommonlEAlgorithmgR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiCommonlEAlgorithmgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiHistoslEGaudiAlgorithmgR_Dictionary();
   static void GaudiHistoslEGaudiAlgorithmgR_TClassManip(TClass*);
   static void delete_GaudiHistoslEGaudiAlgorithmgR(void *p);
   static void deleteArray_GaudiHistoslEGaudiAlgorithmgR(void *p);
   static void destruct_GaudiHistoslEGaudiAlgorithmgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiHistos<GaudiAlgorithm>*)
   {
      ::GaudiHistos<GaudiAlgorithm> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiHistos<GaudiAlgorithm>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiHistos<GaudiAlgorithm>", "GaudiAlg/GaudiHistos.h", 50,
                  typeid(::GaudiHistos<GaudiAlgorithm>), DefineBehavior(ptr, ptr),
                  &GaudiHistoslEGaudiAlgorithmgR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiHistos<GaudiAlgorithm>) );
      instance.SetDelete(&delete_GaudiHistoslEGaudiAlgorithmgR);
      instance.SetDeleteArray(&deleteArray_GaudiHistoslEGaudiAlgorithmgR);
      instance.SetDestructor(&destruct_GaudiHistoslEGaudiAlgorithmgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiHistos<GaudiAlgorithm>*)
   {
      return GenerateInitInstanceLocal((::GaudiHistos<GaudiAlgorithm>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiHistos<GaudiAlgorithm>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiHistoslEGaudiAlgorithmgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiHistos<GaudiAlgorithm>*)0x0)->GetClass();
      GaudiHistoslEGaudiAlgorithmgR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiHistoslEGaudiAlgorithmgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiTupleslEGaudiHistoAlggR_Dictionary();
   static void GaudiTupleslEGaudiHistoAlggR_TClassManip(TClass*);
   static void delete_GaudiTupleslEGaudiHistoAlggR(void *p);
   static void deleteArray_GaudiTupleslEGaudiHistoAlggR(void *p);
   static void destruct_GaudiTupleslEGaudiHistoAlggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiTuples<GaudiHistoAlg>*)
   {
      ::GaudiTuples<GaudiHistoAlg> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiTuples<GaudiHistoAlg>));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiTuples<GaudiHistoAlg>", "GaudiAlg/GaudiTuples.h", 37,
                  typeid(::GaudiTuples<GaudiHistoAlg>), DefineBehavior(ptr, ptr),
                  &GaudiTupleslEGaudiHistoAlggR_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiTuples<GaudiHistoAlg>) );
      instance.SetDelete(&delete_GaudiTupleslEGaudiHistoAlggR);
      instance.SetDeleteArray(&deleteArray_GaudiTupleslEGaudiHistoAlggR);
      instance.SetDestructor(&destruct_GaudiTupleslEGaudiHistoAlggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiTuples<GaudiHistoAlg>*)
   {
      return GenerateInitInstanceLocal((::GaudiTuples<GaudiHistoAlg>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiTuples<GaudiHistoAlg>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiTupleslEGaudiHistoAlggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiTuples<GaudiHistoAlg>*)0x0)->GetClass();
      GaudiTupleslEGaudiHistoAlggR_TClassManip(theClass);
   return theClass;
   }

   static void GaudiTupleslEGaudiHistoAlggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLUtilscLcLAida2ROOT_Dictionary();
   static void GaudicLcLUtilscLcLAida2ROOT_TClassManip(TClass*);
   static void *new_GaudicLcLUtilscLcLAida2ROOT(void *p = 0);
   static void *newArray_GaudicLcLUtilscLcLAida2ROOT(Long_t size, void *p);
   static void delete_GaudicLcLUtilscLcLAida2ROOT(void *p);
   static void deleteArray_GaudicLcLUtilscLcLAida2ROOT(void *p);
   static void destruct_GaudicLcLUtilscLcLAida2ROOT(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::Utils::Aida2ROOT*)
   {
      ::Gaudi::Utils::Aida2ROOT *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::Utils::Aida2ROOT));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::Utils::Aida2ROOT", "GaudiUtils/Aida2ROOT.h", 61,
                  typeid(::Gaudi::Utils::Aida2ROOT), DefineBehavior(ptr, ptr),
                  &GaudicLcLUtilscLcLAida2ROOT_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::Utils::Aida2ROOT) );
      instance.SetNew(&new_GaudicLcLUtilscLcLAida2ROOT);
      instance.SetNewArray(&newArray_GaudicLcLUtilscLcLAida2ROOT);
      instance.SetDelete(&delete_GaudicLcLUtilscLcLAida2ROOT);
      instance.SetDeleteArray(&deleteArray_GaudicLcLUtilscLcLAida2ROOT);
      instance.SetDestructor(&destruct_GaudicLcLUtilscLcLAida2ROOT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::Utils::Aida2ROOT*)
   {
      return GenerateInitInstanceLocal((::Gaudi::Utils::Aida2ROOT*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::Utils::Aida2ROOT*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLUtilscLcLAida2ROOT_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::Utils::Aida2ROOT*)0x0)->GetClass();
      GaudicLcLUtilscLcLAida2ROOT_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLUtilscLcLAida2ROOT_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *Stat_Dictionary();
   static void Stat_TClassManip(TClass*);
   static void *new_Stat(void *p = 0);
   static void *newArray_Stat(Long_t size, void *p);
   static void delete_Stat(void *p);
   static void deleteArray_Stat(void *p);
   static void destruct_Stat(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Stat*)
   {
      ::Stat *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Stat));
      static ::ROOT::TGenericClassInfo 
         instance("Stat", "GaudiKernel/Stat.h", 50,
                  typeid(::Stat), DefineBehavior(ptr, ptr),
                  &Stat_Dictionary, isa_proxy, 0,
                  sizeof(::Stat) );
      instance.SetNew(&new_Stat);
      instance.SetNewArray(&newArray_Stat);
      instance.SetDelete(&delete_Stat);
      instance.SetDeleteArray(&deleteArray_Stat);
      instance.SetDestructor(&destruct_Stat);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Stat*)
   {
      return GenerateInitInstanceLocal((::Stat*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Stat*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *Stat_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Stat*)0x0)->GetClass();
      Stat_TClassManip(theClass);
   return theClass;
   }

   static void Stat_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *Chrono_Dictionary();
   static void Chrono_TClassManip(TClass*);
   static void *new_Chrono(void *p = 0);
   static void *newArray_Chrono(Long_t size, void *p);
   static void delete_Chrono(void *p);
   static void deleteArray_Chrono(void *p);
   static void destruct_Chrono(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Chrono*)
   {
      ::Chrono *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Chrono));
      static ::ROOT::TGenericClassInfo 
         instance("Chrono", "GaudiKernel/Chrono.h", 27,
                  typeid(::Chrono), DefineBehavior(ptr, ptr),
                  &Chrono_Dictionary, isa_proxy, 0,
                  sizeof(::Chrono) );
      instance.SetNew(&new_Chrono);
      instance.SetNewArray(&newArray_Chrono);
      instance.SetDelete(&delete_Chrono);
      instance.SetDeleteArray(&deleteArray_Chrono);
      instance.SetDestructor(&destruct_Chrono);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Chrono*)
   {
      return GenerateInitInstanceLocal((::Chrono*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Chrono*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *Chrono_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Chrono*)0x0)->GetClass();
      Chrono_TClassManip(theClass);
   return theClass;
   }

   static void Chrono_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *ChronoEntity_Dictionary();
   static void ChronoEntity_TClassManip(TClass*);
   static void *new_ChronoEntity(void *p = 0);
   static void *newArray_ChronoEntity(Long_t size, void *p);
   static void delete_ChronoEntity(void *p);
   static void deleteArray_ChronoEntity(void *p);
   static void destruct_ChronoEntity(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ChronoEntity*)
   {
      ::ChronoEntity *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ChronoEntity));
      static ::ROOT::TGenericClassInfo 
         instance("ChronoEntity", "GaudiKernel/ChronoEntity.h", 21,
                  typeid(::ChronoEntity), DefineBehavior(ptr, ptr),
                  &ChronoEntity_Dictionary, isa_proxy, 0,
                  sizeof(::ChronoEntity) );
      instance.SetNew(&new_ChronoEntity);
      instance.SetNewArray(&newArray_ChronoEntity);
      instance.SetDelete(&delete_ChronoEntity);
      instance.SetDeleteArray(&deleteArray_ChronoEntity);
      instance.SetDestructor(&destruct_ChronoEntity);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ChronoEntity*)
   {
      return GenerateInitInstanceLocal((::ChronoEntity*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ChronoEntity*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *ChronoEntity_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::ChronoEntity*)0x0)->GetClass();
      ChronoEntity_TClassManip(theClass);
   return theClass;
   }

   static void ChronoEntity_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyCallbackPointerFunctor_Dictionary();
   static void PropertyCallbackPointerFunctor_TClassManip(TClass*);
   static void delete_PropertyCallbackPointerFunctor(void *p);
   static void deleteArray_PropertyCallbackPointerFunctor(void *p);
   static void destruct_PropertyCallbackPointerFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyCallbackPointerFunctor*)
   {
      ::PropertyCallbackPointerFunctor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyCallbackPointerFunctor));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyCallbackPointerFunctor", "GaudiKernel/PropertyCallbackFunctor.h", 71,
                  typeid(::PropertyCallbackPointerFunctor), DefineBehavior(ptr, ptr),
                  &PropertyCallbackPointerFunctor_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyCallbackPointerFunctor) );
      instance.SetDelete(&delete_PropertyCallbackPointerFunctor);
      instance.SetDeleteArray(&deleteArray_PropertyCallbackPointerFunctor);
      instance.SetDestructor(&destruct_PropertyCallbackPointerFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyCallbackPointerFunctor*)
   {
      return GenerateInitInstanceLocal((::PropertyCallbackPointerFunctor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyCallbackPointerFunctor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyCallbackPointerFunctor_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyCallbackPointerFunctor*)0x0)->GetClass();
      PropertyCallbackPointerFunctor_TClassManip(theClass);
   return theClass;
   }

   static void PropertyCallbackPointerFunctor_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEintcOBoundedVerifierlEintgRsPgR_Dictionary();
   static void PropertyWithVerifierlEintcOBoundedVerifierlEintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<int,BoundedVerifier<int> >*)
   {
      ::PropertyWithVerifier<int,BoundedVerifier<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<int,BoundedVerifier<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<int,BoundedVerifier<int> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<int,BoundedVerifier<int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEintcOBoundedVerifierlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<int,BoundedVerifier<int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<int,BoundedVerifier<int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<int,BoundedVerifier<int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<int,BoundedVerifier<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEintcOBoundedVerifierlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<int,BoundedVerifier<int> >*)0x0)->GetClass();
      PropertyWithVerifierlEintcOBoundedVerifierlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEintcOBoundedVerifierlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)
   {
      ::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)
   {
      ::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)
   {
      ::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)
   {
      ::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)
   {
      ::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >*)
   {
      ::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >*)
   {
      ::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >*)
   {
      ::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >*)
   {
      ::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >*)
   {
      ::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >*)
   {
      ::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >*)
   {
      ::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >*)
   {
      ::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >*)
   {
      ::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >*)
   {
      ::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEstringcONullVerifierlEstringgRsPgR_Dictionary();
   static void PropertyWithVerifierlEstringcONullVerifierlEstringgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<string,NullVerifier<string> >*)
   {
      ::PropertyWithVerifier<string,NullVerifier<string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<string,NullVerifier<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<string,NullVerifier<string> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<string,NullVerifier<string> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEstringcONullVerifierlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<string,NullVerifier<string> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<string,NullVerifier<string> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<string,NullVerifier<string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<string,NullVerifier<string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEstringcONullVerifierlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<string,NullVerifier<string> >*)0x0)->GetClass();
      PropertyWithVerifierlEstringcONullVerifierlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEstringcONullVerifierlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >*)
   {
      ::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >*)
   {
      ::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)
   {
      ::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)
   {
      ::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)
   {
      ::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)
   {
      ::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)
   {
      ::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >*)
   {
      ::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >*)
   {
      ::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >*)
   {
      ::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >*)
   {
      ::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >*)
   {
      ::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >*)
   {
      ::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >*)
   {
      ::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlElongcOBoundedVerifierlElonggRsPgR_Dictionary();
   static void PropertyWithVerifierlElongcOBoundedVerifierlElonggRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<long,BoundedVerifier<long> >*)
   {
      ::PropertyWithVerifier<long,BoundedVerifier<long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<long,BoundedVerifier<long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<long,BoundedVerifier<long> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<long,BoundedVerifier<long> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlElongcOBoundedVerifierlElonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<long,BoundedVerifier<long> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<long,BoundedVerifier<long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<long,BoundedVerifier<long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<long,BoundedVerifier<long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlElongcOBoundedVerifierlElonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<long,BoundedVerifier<long> >*)0x0)->GetClass();
      PropertyWithVerifierlElongcOBoundedVerifierlElonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlElongcOBoundedVerifierlElonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEboolcOBoundedVerifierlEboolgRsPgR_Dictionary();
   static void PropertyWithVerifierlEboolcOBoundedVerifierlEboolgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<bool,BoundedVerifier<bool> >*)
   {
      ::PropertyWithVerifier<bool,BoundedVerifier<bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<bool,BoundedVerifier<bool> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<bool,BoundedVerifier<bool> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<bool,BoundedVerifier<bool> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEboolcOBoundedVerifierlEboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<bool,BoundedVerifier<bool> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<bool,BoundedVerifier<bool> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<bool,BoundedVerifier<bool> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<bool,BoundedVerifier<bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEboolcOBoundedVerifierlEboolgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<bool,BoundedVerifier<bool> >*)0x0)->GetClass();
      PropertyWithVerifierlEboolcOBoundedVerifierlEboolgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEboolcOBoundedVerifierlEboolgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEboolcONullVerifierlEboolgRsPgR_Dictionary();
   static void PropertyWithVerifierlEboolcONullVerifierlEboolgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<bool,NullVerifier<bool> >*)
   {
      ::PropertyWithVerifier<bool,NullVerifier<bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<bool,NullVerifier<bool> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<bool,NullVerifier<bool> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<bool,NullVerifier<bool> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEboolcONullVerifierlEboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<bool,NullVerifier<bool> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<bool,NullVerifier<bool> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<bool,NullVerifier<bool> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<bool,NullVerifier<bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEboolcONullVerifierlEboolgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<bool,NullVerifier<bool> >*)0x0)->GetClass();
      PropertyWithVerifierlEboolcONullVerifierlEboolgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEboolcONullVerifierlEboolgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEcharcOBoundedVerifierlEchargRsPgR_Dictionary();
   static void PropertyWithVerifierlEcharcOBoundedVerifierlEchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<char,BoundedVerifier<char> >*)
   {
      ::PropertyWithVerifier<char,BoundedVerifier<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<char,BoundedVerifier<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<char,BoundedVerifier<char> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<char,BoundedVerifier<char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEcharcOBoundedVerifierlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<char,BoundedVerifier<char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<char,BoundedVerifier<char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<char,BoundedVerifier<char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<char,BoundedVerifier<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEcharcOBoundedVerifierlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<char,BoundedVerifier<char> >*)0x0)->GetClass();
      PropertyWithVerifierlEcharcOBoundedVerifierlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEcharcOBoundedVerifierlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEcharcONullVerifierlEchargRsPgR_Dictionary();
   static void PropertyWithVerifierlEcharcONullVerifierlEchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<char,NullVerifier<char> >*)
   {
      ::PropertyWithVerifier<char,NullVerifier<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<char,NullVerifier<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<char,NullVerifier<char> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<char,NullVerifier<char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEcharcONullVerifierlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<char,NullVerifier<char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<char,NullVerifier<char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<char,NullVerifier<char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<char,NullVerifier<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEcharcONullVerifierlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<char,NullVerifier<char> >*)0x0)->GetClass();
      PropertyWithVerifierlEcharcONullVerifierlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEcharcONullVerifierlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_Dictionary();
   static void PropertyWithVerifierlEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >*)
   {
      ::PropertyWithVerifier<signed char,BoundedVerifier<signed char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<signed char,BoundedVerifier<signed char> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >*)0x0)->GetClass();
      PropertyWithVerifierlEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_Dictionary();
   static void PropertyWithVerifierlEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<signed char,NullVerifier<signed char> >*)
   {
      ::PropertyWithVerifier<signed char,NullVerifier<signed char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<signed char,NullVerifier<signed char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<signed char,NullVerifier<signed char> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<signed char,NullVerifier<signed char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<signed char,NullVerifier<signed char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<signed char,NullVerifier<signed char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<signed char,NullVerifier<signed char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<signed char,NullVerifier<signed char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<signed char,NullVerifier<signed char> >*)0x0)->GetClass();
      PropertyWithVerifierlEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEsignedsPcharcONullVerifierlEsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >*)
   {
      ::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >*)
   {
      ::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEshortcOBoundedVerifierlEshortgRsPgR_Dictionary();
   static void PropertyWithVerifierlEshortcOBoundedVerifierlEshortgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<short,BoundedVerifier<short> >*)
   {
      ::PropertyWithVerifier<short,BoundedVerifier<short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<short,BoundedVerifier<short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<short,BoundedVerifier<short> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<short,BoundedVerifier<short> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEshortcOBoundedVerifierlEshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<short,BoundedVerifier<short> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<short,BoundedVerifier<short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<short,BoundedVerifier<short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<short,BoundedVerifier<short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEshortcOBoundedVerifierlEshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<short,BoundedVerifier<short> >*)0x0)->GetClass();
      PropertyWithVerifierlEshortcOBoundedVerifierlEshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEshortcOBoundedVerifierlEshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEshortcONullVerifierlEshortgRsPgR_Dictionary();
   static void PropertyWithVerifierlEshortcONullVerifierlEshortgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<short,NullVerifier<short> >*)
   {
      ::PropertyWithVerifier<short,NullVerifier<short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<short,NullVerifier<short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<short,NullVerifier<short> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<short,NullVerifier<short> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEshortcONullVerifierlEshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<short,NullVerifier<short> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<short,NullVerifier<short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<short,NullVerifier<short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<short,NullVerifier<short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEshortcONullVerifierlEshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<short,NullVerifier<short> >*)0x0)->GetClass();
      PropertyWithVerifierlEshortcONullVerifierlEshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEshortcONullVerifierlEshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >*)
   {
      ::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >*)
   {
      ::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEintcONullVerifierlEintgRsPgR_Dictionary();
   static void PropertyWithVerifierlEintcONullVerifierlEintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<int,NullVerifier<int> >*)
   {
      ::PropertyWithVerifier<int,NullVerifier<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<int,NullVerifier<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<int,NullVerifier<int> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<int,NullVerifier<int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEintcONullVerifierlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<int,NullVerifier<int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<int,NullVerifier<int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<int,NullVerifier<int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<int,NullVerifier<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEintcONullVerifierlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<int,NullVerifier<int> >*)0x0)->GetClass();
      PropertyWithVerifierlEintcONullVerifierlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEintcONullVerifierlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >*)
   {
      ::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >*)
   {
      ::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >*)
   {
      ::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlElongcONullVerifierlElonggRsPgR_Dictionary();
   static void PropertyWithVerifierlElongcONullVerifierlElonggRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<long,NullVerifier<long> >*)
   {
      ::PropertyWithVerifier<long,NullVerifier<long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<long,NullVerifier<long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<long,NullVerifier<long> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<long,NullVerifier<long> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlElongcONullVerifierlElonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<long,NullVerifier<long> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<long,NullVerifier<long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<long,NullVerifier<long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<long,NullVerifier<long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlElongcONullVerifierlElonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<long,NullVerifier<long> >*)0x0)->GetClass();
      PropertyWithVerifierlElongcONullVerifierlElonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlElongcONullVerifierlElonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >*)
   {
      ::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_Dictionary();
   static void PropertyWithVerifierlEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >*)
   {
      ::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >*)0x0)->GetClass();
      PropertyWithVerifierlEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlELong64_tcOBoundedVerifierlELong64_tgRsPgR_Dictionary();
   static void PropertyWithVerifierlELong64_tcOBoundedVerifierlELong64_tgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >*)
   {
      ::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlELong64_tcOBoundedVerifierlELong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlELong64_tcOBoundedVerifierlELong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >*)0x0)->GetClass();
      PropertyWithVerifierlELong64_tcOBoundedVerifierlELong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlELong64_tcOBoundedVerifierlELong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlELong64_tcONullVerifierlELong64_tgRsPgR_Dictionary();
   static void PropertyWithVerifierlELong64_tcONullVerifierlELong64_tgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >*)
   {
      ::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlELong64_tcONullVerifierlELong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlELong64_tcONullVerifierlELong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >*)0x0)->GetClass();
      PropertyWithVerifierlELong64_tcONullVerifierlELong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlELong64_tcONullVerifierlELong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_Dictionary();
   static void PropertyWithVerifierlEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >*)
   {
      ::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >*)0x0)->GetClass();
      PropertyWithVerifierlEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEULong64_tcOBoundedVerifierlEULong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEULong64_tcONullVerifierlEULong64_tgRsPgR_Dictionary();
   static void PropertyWithVerifierlEULong64_tcONullVerifierlEULong64_tgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >*)
   {
      ::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEULong64_tcONullVerifierlEULong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEULong64_tcONullVerifierlEULong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >*)0x0)->GetClass();
      PropertyWithVerifierlEULong64_tcONullVerifierlEULong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEULong64_tcONullVerifierlEULong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEfloatcOBoundedVerifierlEfloatgRsPgR_Dictionary();
   static void PropertyWithVerifierlEfloatcOBoundedVerifierlEfloatgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<float,BoundedVerifier<float> >*)
   {
      ::PropertyWithVerifier<float,BoundedVerifier<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<float,BoundedVerifier<float> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<float,BoundedVerifier<float> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<float,BoundedVerifier<float> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEfloatcOBoundedVerifierlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<float,BoundedVerifier<float> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<float,BoundedVerifier<float> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<float,BoundedVerifier<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<float,BoundedVerifier<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEfloatcOBoundedVerifierlEfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<float,BoundedVerifier<float> >*)0x0)->GetClass();
      PropertyWithVerifierlEfloatcOBoundedVerifierlEfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEfloatcOBoundedVerifierlEfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEfloatcONullVerifierlEfloatgRsPgR_Dictionary();
   static void PropertyWithVerifierlEfloatcONullVerifierlEfloatgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<float,NullVerifier<float> >*)
   {
      ::PropertyWithVerifier<float,NullVerifier<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<float,NullVerifier<float> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<float,NullVerifier<float> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<float,NullVerifier<float> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEfloatcONullVerifierlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<float,NullVerifier<float> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<float,NullVerifier<float> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<float,NullVerifier<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<float,NullVerifier<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEfloatcONullVerifierlEfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<float,NullVerifier<float> >*)0x0)->GetClass();
      PropertyWithVerifierlEfloatcONullVerifierlEfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEfloatcONullVerifierlEfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEdoublecOBoundedVerifierlEdoublegRsPgR_Dictionary();
   static void PropertyWithVerifierlEdoublecOBoundedVerifierlEdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<double,BoundedVerifier<double> >*)
   {
      ::PropertyWithVerifier<double,BoundedVerifier<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<double,BoundedVerifier<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<double,BoundedVerifier<double> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<double,BoundedVerifier<double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEdoublecOBoundedVerifierlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<double,BoundedVerifier<double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<double,BoundedVerifier<double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<double,BoundedVerifier<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<double,BoundedVerifier<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEdoublecOBoundedVerifierlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<double,BoundedVerifier<double> >*)0x0)->GetClass();
      PropertyWithVerifierlEdoublecOBoundedVerifierlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEdoublecOBoundedVerifierlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEdoublecONullVerifierlEdoublegRsPgR_Dictionary();
   static void PropertyWithVerifierlEdoublecONullVerifierlEdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<double,NullVerifier<double> >*)
   {
      ::PropertyWithVerifier<double,NullVerifier<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<double,NullVerifier<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<double,NullVerifier<double> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<double,NullVerifier<double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEdoublecONullVerifierlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<double,NullVerifier<double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<double,NullVerifier<double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<double,NullVerifier<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<double,NullVerifier<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEdoublecONullVerifierlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<double,NullVerifier<double> >*)0x0)->GetClass();
      PropertyWithVerifierlEdoublecONullVerifierlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEdoublecONullVerifierlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_Dictionary();
   static void PropertyWithVerifierlElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<long double,BoundedVerifier<long double> >*)
   {
      ::PropertyWithVerifier<long double,BoundedVerifier<long double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<long double,BoundedVerifier<long double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<long double,BoundedVerifier<long double> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<long double,BoundedVerifier<long double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<long double,BoundedVerifier<long double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<long double,BoundedVerifier<long double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<long double,BoundedVerifier<long double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<long double,BoundedVerifier<long double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<long double,BoundedVerifier<long double> >*)0x0)->GetClass();
      PropertyWithVerifierlElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlElongsPdoublecONullVerifierlElongsPdoublegRsPgR_Dictionary();
   static void PropertyWithVerifierlElongsPdoublecONullVerifierlElongsPdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<long double,NullVerifier<long double> >*)
   {
      ::PropertyWithVerifier<long double,NullVerifier<long double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<long double,NullVerifier<long double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<long double,NullVerifier<long double> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<long double,NullVerifier<long double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlElongsPdoublecONullVerifierlElongsPdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<long double,NullVerifier<long double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<long double,NullVerifier<long double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<long double,NullVerifier<long double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<long double,NullVerifier<long double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlElongsPdoublecONullVerifierlElongsPdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<long double,NullVerifier<long double> >*)0x0)->GetClass();
      PropertyWithVerifierlElongsPdoublecONullVerifierlElongsPdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlElongsPdoublecONullVerifierlElongsPdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEstringcOBoundedVerifierlEstringgRsPgR_Dictionary();
   static void PropertyWithVerifierlEstringcOBoundedVerifierlEstringgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<string,BoundedVerifier<string> >*)
   {
      ::PropertyWithVerifier<string,BoundedVerifier<string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<string,BoundedVerifier<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<string,BoundedVerifier<string> >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<string,BoundedVerifier<string> >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEstringcOBoundedVerifierlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<string,BoundedVerifier<string> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<string,BoundedVerifier<string> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<string,BoundedVerifier<string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<string,BoundedVerifier<string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEstringcOBoundedVerifierlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<string,BoundedVerifier<string> >*)0x0)->GetClass();
      PropertyWithVerifierlEstringcOBoundedVerifierlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEstringcOBoundedVerifierlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >*)
   {
      ::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >*)
   {
      ::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >*)
   {
      ::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >*)
   {
      ::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)
   {
      ::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >*)
   {
      ::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >*)
   {
      ::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >*)
   {
      ::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >*)
   {
      ::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >*)
   {
      ::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)
   {
      ::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)
   {
      ::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)
   {
      ::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)
   {
      ::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)
   {
      ::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >*)
   {
      ::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >*)
   {
      ::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >*)0x0)->GetClass();
      PropertyWithVerifierlEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >*)
   {
      ::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >*)0x0)->GetClass();
      PropertyWithVerifierlEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)
   {
      ::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >", "GaudiKernel/Property.h", 396,
                  typeid(::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >), DefineBehavior(ptr, ptr),
                  &PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)0x0)->GetClass();
      PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithVerifierlEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEdoublegRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<double> >*)
   {
      ::PropertyWithValue<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<double> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<double> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEfloatgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEfloatgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<float> >*)
   {
      ::PropertyWithValue<vector<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<float> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<float> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<float> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<float> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<float> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEfloatgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<float> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEfloatgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEfloatgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEULong64_tgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEULong64_tgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<ULong64_t> >*)
   {
      ::PropertyWithValue<vector<ULong64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<ULong64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<ULong64_t> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<ULong64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEULong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<ULong64_t> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<ULong64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<ULong64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<ULong64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEULong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<ULong64_t> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEULong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEULong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlELong64_tgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlELong64_tgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<Long64_t> >*)
   {
      ::PropertyWithValue<vector<Long64_t> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<Long64_t> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<Long64_t> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<Long64_t> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlELong64_tgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<Long64_t> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<Long64_t> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<Long64_t> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<Long64_t> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlELong64_tgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<Long64_t> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlELong64_tgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlELong64_tgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEunsignedsPlonggRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<unsigned long> >*)
   {
      ::PropertyWithValue<vector<unsigned long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<unsigned long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<unsigned long> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<unsigned long> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEunsignedsPlonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<unsigned long> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<unsigned long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<unsigned long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEunsignedsPlonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned long> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEunsignedsPlonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEunsignedsPlonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlElonggRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlElonggRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<long> >*)
   {
      ::PropertyWithValue<vector<long> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<long> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<long> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<long> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlElonggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<long> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<long> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<long> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<long> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlElonggRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<long> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlElonggRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlElonggRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEunsignedsPintgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEunsignedsPintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<unsigned int> >*)
   {
      ::PropertyWithValue<vector<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<unsigned int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<unsigned int> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<unsigned int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<unsigned int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<unsigned int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<unsigned int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEunsignedsPintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned int> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEunsignedsPintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEunsignedsPintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEintgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<int> >*)
   {
      ::PropertyWithValue<vector<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<int> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<int> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEunsignedsPshortgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEunsignedsPshortgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<unsigned short> >*)
   {
      ::PropertyWithValue<vector<unsigned short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<unsigned short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<unsigned short> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<unsigned short> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEunsignedsPshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<unsigned short> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<unsigned short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<unsigned short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEunsignedsPshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned short> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEunsignedsPshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEunsignedsPshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEshortgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEshortgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<short> >*)
   {
      ::PropertyWithValue<vector<short> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<short> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<short> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<short> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEshortgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<short> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<short> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<short> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<short> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEshortgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<short> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEshortgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEshortgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEunsignedsPchargRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEunsignedsPchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<unsigned char> >*)
   {
      ::PropertyWithValue<vector<unsigned char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<unsigned char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<unsigned char> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<unsigned char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEunsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<unsigned char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<unsigned char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<unsigned char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEunsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<unsigned char> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEunsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEunsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithValuelEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<map<string,vector<double> > >*)
   {
      ::PropertyWithValue<map<string,vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<map<string,vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<map<string,vector<double> > >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<map<string,vector<double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<map<string,vector<double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<map<string,vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<map<string,vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEmaplEstringcOvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,vector<double> > >*)0x0)->GetClass();
      PropertyWithValuelEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEmaplEstringcOvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEsignedsPchargRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEsignedsPchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<signed char> >*)
   {
      ::PropertyWithValue<vector<signed char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<signed char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<signed char> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<signed char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEsignedsPchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<signed char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<signed char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<signed char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<signed char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEsignedsPchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<signed char> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEsignedsPchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEsignedsPchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlElongsPdoublegRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlElongsPdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<long double> >*)
   {
      ::PropertyWithValue<vector<long double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<long double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<long double> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<long double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlElongsPdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<long double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<long double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<long double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<long double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlElongsPdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<long double> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlElongsPdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlElongsPdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEstringgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEstringgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<string> >*)
   {
      ::PropertyWithValue<vector<string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<string> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<string> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<string> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<string> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<string> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<string> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEpairlEintcOintgRsPgR_Dictionary();
   static void PropertyWithValuelEpairlEintcOintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<pair<int,int> >*)
   {
      ::PropertyWithValue<pair<int,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<pair<int,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<pair<int,int> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<pair<int,int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEpairlEintcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<pair<int,int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<pair<int,int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<pair<int,int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<pair<int,int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEpairlEintcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<pair<int,int> >*)0x0)->GetClass();
      PropertyWithValuelEpairlEintcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEpairlEintcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEpairlEdoublecOdoublegRsPgR_Dictionary();
   static void PropertyWithValuelEpairlEdoublecOdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<pair<double,double> >*)
   {
      ::PropertyWithValue<pair<double,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<pair<double,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<pair<double,double> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<pair<double,double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEpairlEdoublecOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<pair<double,double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<pair<double,double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<pair<double,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<pair<double,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEpairlEdoublecOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<pair<double,double> >*)0x0)->GetClass();
      PropertyWithValuelEpairlEdoublecOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEpairlEdoublecOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<pair<double,double> > >*)
   {
      ::PropertyWithValue<vector<pair<double,double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<pair<double,double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<pair<double,double> > >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<pair<double,double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<pair<double,double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<pair<double,double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<pair<double,double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<pair<double,double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEpairlEdoublecOdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<pair<double,double> > >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEpairlEdoublecOdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEvectorlEstringgRsPgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<vector<string> > >*)
   {
      ::PropertyWithValue<vector<vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<vector<string> > >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<vector<string> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<vector<string> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<vector<string> > >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<vector<double> > >*)
   {
      ::PropertyWithValue<vector<vector<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<vector<double> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<vector<double> > >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<vector<double> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<vector<double> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<vector<double> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<vector<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<vector<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEvectorlEdoublegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<vector<double> > >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEvectorlEdoublegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEmaplEintcOdoublegRsPgR_Dictionary();
   static void PropertyWithValuelEmaplEintcOdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<map<int,double> >*)
   {
      ::PropertyWithValue<map<int,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<map<int,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<map<int,double> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<map<int,double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEmaplEintcOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<map<int,double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<map<int,double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<map<int,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<map<int,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEmaplEintcOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<map<int,double> >*)0x0)->GetClass();
      PropertyWithValuelEmaplEintcOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEmaplEintcOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEmaplEstringcOstringgRsPgR_Dictionary();
   static void PropertyWithValuelEmaplEstringcOstringgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<map<string,string> >*)
   {
      ::PropertyWithValue<map<string,string> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<map<string,string> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<map<string,string> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<map<string,string> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEmaplEstringcOstringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<map<string,string> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<map<string,string> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<map<string,string> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,string> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEmaplEstringcOstringgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,string> >*)0x0)->GetClass();
      PropertyWithValuelEmaplEstringcOstringgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEmaplEstringcOstringgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEmaplEstringcOintgRsPgR_Dictionary();
   static void PropertyWithValuelEmaplEstringcOintgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<map<string,int> >*)
   {
      ::PropertyWithValue<map<string,int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<map<string,int> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<map<string,int> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<map<string,int> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEmaplEstringcOintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<map<string,int> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<map<string,int> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<map<string,int> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEmaplEstringcOintgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,int> >*)0x0)->GetClass();
      PropertyWithValuelEmaplEstringcOintgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEmaplEstringcOintgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEmaplEstringcOdoublegRsPgR_Dictionary();
   static void PropertyWithValuelEmaplEstringcOdoublegRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<map<string,double> >*)
   {
      ::PropertyWithValue<map<string,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<map<string,double> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<map<string,double> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<map<string,double> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEmaplEstringcOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<map<string,double> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<map<string,double> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<map<string,double> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEmaplEstringcOdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,double> >*)0x0)->GetClass();
      PropertyWithValuelEmaplEstringcOdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEmaplEstringcOdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary();
   static void PropertyWithValuelEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<map<string,vector<string> > >*)
   {
      ::PropertyWithValue<map<string,vector<string> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<map<string,vector<string> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<map<string,vector<string> > >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<map<string,vector<string> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<map<string,vector<string> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<map<string,vector<string> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<map<string,vector<string> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,vector<string> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEmaplEstringcOvectorlEstringgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,vector<string> > >*)0x0)->GetClass();
      PropertyWithValuelEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEmaplEstringcOvectorlEstringgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary();
   static void PropertyWithValuelEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<map<string,vector<int> > >*)
   {
      ::PropertyWithValue<map<string,vector<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<map<string,vector<int> > >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<map<string,vector<int> > >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<map<string,vector<int> > >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<map<string,vector<int> > >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<map<string,vector<int> > >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<map<string,vector<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,vector<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEmaplEstringcOvectorlEintgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<map<string,vector<int> > >*)0x0)->GetClass();
      PropertyWithValuelEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEmaplEstringcOvectorlEintgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEintgR_Dictionary();
   static void PropertyWithValuelEintgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<int>*)
   {
      ::PropertyWithValue<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<int>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<int>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<int>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEintgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<int>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<int>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<int>*)0x0)->GetClass();
      PropertyWithValuelEintgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEsignedsPchargR_Dictionary();
   static void PropertyWithValuelEsignedsPchargR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<signed char>*)
   {
      ::PropertyWithValue<signed char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<signed char>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<signed char>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<signed char>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEsignedsPchargR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<signed char>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<signed char>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<signed char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<signed char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEsignedsPchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<signed char>*)0x0)->GetClass();
      PropertyWithValuelEsignedsPchargR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEsignedsPchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEunsignedsPchargR_Dictionary();
   static void PropertyWithValuelEunsignedsPchargR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<unsigned char>*)
   {
      ::PropertyWithValue<unsigned char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<unsigned char>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<unsigned char>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<unsigned char>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEunsignedsPchargR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<unsigned char>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<unsigned char>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<unsigned char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEunsignedsPchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned char>*)0x0)->GetClass();
      PropertyWithValuelEunsignedsPchargR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEunsignedsPchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEshortgR_Dictionary();
   static void PropertyWithValuelEshortgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<short>*)
   {
      ::PropertyWithValue<short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<short>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<short>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<short>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEshortgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<short>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<short>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<short>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEshortgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<short>*)0x0)->GetClass();
      PropertyWithValuelEshortgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEshortgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEunsignedsPshortgR_Dictionary();
   static void PropertyWithValuelEunsignedsPshortgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<unsigned short>*)
   {
      ::PropertyWithValue<unsigned short> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<unsigned short>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<unsigned short>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<unsigned short>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEunsignedsPshortgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<unsigned short>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<unsigned short>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<unsigned short>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEunsignedsPshortgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned short>*)0x0)->GetClass();
      PropertyWithValuelEunsignedsPshortgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEunsignedsPshortgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEunsignedsPintgR_Dictionary();
   static void PropertyWithValuelEunsignedsPintgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<unsigned int>*)
   {
      ::PropertyWithValue<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<unsigned int>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<unsigned int>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<unsigned int>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<unsigned int>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<unsigned int>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<unsigned int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEunsignedsPintgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned int>*)0x0)->GetClass();
      PropertyWithValuelEunsignedsPintgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEunsignedsPintgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelElonggR_Dictionary();
   static void PropertyWithValuelElonggR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<long>*)
   {
      ::PropertyWithValue<long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<long>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<long>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<long>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelElonggR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<long>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<long>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelElonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<long>*)0x0)->GetClass();
      PropertyWithValuelElonggR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelElonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEchargR_Dictionary();
   static void PropertyWithValuelEchargR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<char>*)
   {
      ::PropertyWithValue<char> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<char>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<char>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<char>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEchargR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<char>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<char>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<char>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<char>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEchargR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<char>*)0x0)->GetClass();
      PropertyWithValuelEchargR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEchargR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEunsignedsPlonggR_Dictionary();
   static void PropertyWithValuelEunsignedsPlonggR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<unsigned long>*)
   {
      ::PropertyWithValue<unsigned long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<unsigned long>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<unsigned long>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<unsigned long>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEunsignedsPlonggR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<unsigned long>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<unsigned long>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<unsigned long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEunsignedsPlonggR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<unsigned long>*)0x0)->GetClass();
      PropertyWithValuelEunsignedsPlonggR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEunsignedsPlonggR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelELong64_tgR_Dictionary();
   static void PropertyWithValuelELong64_tgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<Long64_t>*)
   {
      ::PropertyWithValue<Long64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<Long64_t>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<Long64_t>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<Long64_t>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelELong64_tgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<Long64_t>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<Long64_t>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<Long64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<Long64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelELong64_tgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<Long64_t>*)0x0)->GetClass();
      PropertyWithValuelELong64_tgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelELong64_tgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEULong64_tgR_Dictionary();
   static void PropertyWithValuelEULong64_tgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<ULong64_t>*)
   {
      ::PropertyWithValue<ULong64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<ULong64_t>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<ULong64_t>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<ULong64_t>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEULong64_tgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<ULong64_t>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<ULong64_t>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<ULong64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<ULong64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEULong64_tgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<ULong64_t>*)0x0)->GetClass();
      PropertyWithValuelEULong64_tgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEULong64_tgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEfloatgR_Dictionary();
   static void PropertyWithValuelEfloatgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<float>*)
   {
      ::PropertyWithValue<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<float>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<float>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<float>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEfloatgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<float>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<float>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEfloatgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<float>*)0x0)->GetClass();
      PropertyWithValuelEfloatgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEfloatgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEboolgR_Dictionary();
   static void PropertyWithValuelEboolgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<bool>*)
   {
      ::PropertyWithValue<bool> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<bool>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<bool>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<bool>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEboolgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<bool>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<bool>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<bool>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<bool>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEboolgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<bool>*)0x0)->GetClass();
      PropertyWithValuelEboolgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEboolgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEdoublegR_Dictionary();
   static void PropertyWithValuelEdoublegR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<double>*)
   {
      ::PropertyWithValue<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<double>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<double>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<double>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<double>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<double>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<double>*)0x0)->GetClass();
      PropertyWithValuelEdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelElongsPdoublegR_Dictionary();
   static void PropertyWithValuelElongsPdoublegR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<long double>*)
   {
      ::PropertyWithValue<long double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<long double>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<long double>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<long double>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelElongsPdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<long double>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<long double>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<long double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<long double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelElongsPdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<long double>*)0x0)->GetClass();
      PropertyWithValuelElongsPdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelElongsPdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEboolgRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEboolgRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<bool> >*)
   {
      ::PropertyWithValue<vector<bool> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<bool> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<bool> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<bool> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEboolgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<bool> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<bool> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<bool> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<bool> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEboolgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<bool> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEboolgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEboolgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEvectorlEchargRsPgR_Dictionary();
   static void PropertyWithValuelEvectorlEchargRsPgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<vector<char> >*)
   {
      ::PropertyWithValue<vector<char> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<vector<char> >));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<vector<char> >", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<vector<char> >), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEvectorlEchargRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<vector<char> >) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<vector<char> >*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<vector<char> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<vector<char> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEvectorlEchargRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<vector<char> >*)0x0)->GetClass();
      PropertyWithValuelEvectorlEchargRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEvectorlEchargRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *PropertyWithValuelEstringgR_Dictionary();
   static void PropertyWithValuelEstringgR_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PropertyWithValue<string>*)
   {
      ::PropertyWithValue<string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PropertyWithValue<string>));
      static ::ROOT::TGenericClassInfo 
         instance("PropertyWithValue<string>", "GaudiKernel/Property.h", 147,
                  typeid(::PropertyWithValue<string>), DefineBehavior(ptr, ptr),
                  &PropertyWithValuelEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(::PropertyWithValue<string>) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PropertyWithValue<string>*)
   {
      return GenerateInitInstanceLocal((::PropertyWithValue<string>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PropertyWithValue<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *PropertyWithValuelEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::PropertyWithValue<string>*)0x0)->GetClass();
      PropertyWithValuelEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void PropertyWithValuelEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIBaseHistogram_Dictionary();
   static void AIDAcLcLIBaseHistogram_TClassManip(TClass*);
   static void delete_AIDAcLcLIBaseHistogram(void *p);
   static void deleteArray_AIDAcLcLIBaseHistogram(void *p);
   static void destruct_AIDAcLcLIBaseHistogram(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IBaseHistogram*)
   {
      ::AIDA::IBaseHistogram *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IBaseHistogram));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IBaseHistogram", "AIDA/IBaseHistogram.h", 29,
                  typeid(::AIDA::IBaseHistogram), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIBaseHistogram_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IBaseHistogram) );
      instance.SetDelete(&delete_AIDAcLcLIBaseHistogram);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIBaseHistogram);
      instance.SetDestructor(&destruct_AIDAcLcLIBaseHistogram);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IBaseHistogram*)
   {
      return GenerateInitInstanceLocal((::AIDA::IBaseHistogram*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IBaseHistogram*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIBaseHistogram_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IBaseHistogram*)0x0)->GetClass();
      AIDAcLcLIBaseHistogram_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIBaseHistogram_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIHistogram_Dictionary();
   static void AIDAcLcLIHistogram_TClassManip(TClass*);
   static void delete_AIDAcLcLIHistogram(void *p);
   static void deleteArray_AIDAcLcLIHistogram(void *p);
   static void destruct_AIDAcLcLIHistogram(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IHistogram*)
   {
      ::AIDA::IHistogram *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IHistogram));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IHistogram", "AIDA/IHistogram.h", 26,
                  typeid(::AIDA::IHistogram), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIHistogram_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IHistogram) );
      instance.SetDelete(&delete_AIDAcLcLIHistogram);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIHistogram);
      instance.SetDestructor(&destruct_AIDAcLcLIHistogram);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IHistogram*)
   {
      return GenerateInitInstanceLocal((::AIDA::IHistogram*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IHistogram*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIHistogram_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IHistogram*)0x0)->GetClass();
      AIDAcLcLIHistogram_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIHistogram_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIHistogram1D_Dictionary();
   static void AIDAcLcLIHistogram1D_TClassManip(TClass*);
   static void delete_AIDAcLcLIHistogram1D(void *p);
   static void deleteArray_AIDAcLcLIHistogram1D(void *p);
   static void destruct_AIDAcLcLIHistogram1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IHistogram1D*)
   {
      ::AIDA::IHistogram1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IHistogram1D));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IHistogram1D", "AIDA/IHistogram1D.h", 28,
                  typeid(::AIDA::IHistogram1D), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIHistogram1D_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IHistogram1D) );
      instance.SetDelete(&delete_AIDAcLcLIHistogram1D);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIHistogram1D);
      instance.SetDestructor(&destruct_AIDAcLcLIHistogram1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IHistogram1D*)
   {
      return GenerateInitInstanceLocal((::AIDA::IHistogram1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IHistogram1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIHistogram1D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IHistogram1D*)0x0)->GetClass();
      AIDAcLcLIHistogram1D_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIHistogram1D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIHistogram2D_Dictionary();
   static void AIDAcLcLIHistogram2D_TClassManip(TClass*);
   static void delete_AIDAcLcLIHistogram2D(void *p);
   static void deleteArray_AIDAcLcLIHistogram2D(void *p);
   static void destruct_AIDAcLcLIHistogram2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IHistogram2D*)
   {
      ::AIDA::IHistogram2D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IHistogram2D));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IHistogram2D", "AIDA/IHistogram2D.h", 28,
                  typeid(::AIDA::IHistogram2D), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIHistogram2D_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IHistogram2D) );
      instance.SetDelete(&delete_AIDAcLcLIHistogram2D);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIHistogram2D);
      instance.SetDestructor(&destruct_AIDAcLcLIHistogram2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IHistogram2D*)
   {
      return GenerateInitInstanceLocal((::AIDA::IHistogram2D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IHistogram2D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIHistogram2D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IHistogram2D*)0x0)->GetClass();
      AIDAcLcLIHistogram2D_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIHistogram2D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIHistogram3D_Dictionary();
   static void AIDAcLcLIHistogram3D_TClassManip(TClass*);
   static void delete_AIDAcLcLIHistogram3D(void *p);
   static void deleteArray_AIDAcLcLIHistogram3D(void *p);
   static void destruct_AIDAcLcLIHistogram3D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IHistogram3D*)
   {
      ::AIDA::IHistogram3D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IHistogram3D));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IHistogram3D", "AIDA/IHistogram3D.h", 28,
                  typeid(::AIDA::IHistogram3D), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIHistogram3D_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IHistogram3D) );
      instance.SetDelete(&delete_AIDAcLcLIHistogram3D);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIHistogram3D);
      instance.SetDestructor(&destruct_AIDAcLcLIHistogram3D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IHistogram3D*)
   {
      return GenerateInitInstanceLocal((::AIDA::IHistogram3D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IHistogram3D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIHistogram3D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IHistogram3D*)0x0)->GetClass();
      AIDAcLcLIHistogram3D_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIHistogram3D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIProfile_Dictionary();
   static void AIDAcLcLIProfile_TClassManip(TClass*);
   static void delete_AIDAcLcLIProfile(void *p);
   static void deleteArray_AIDAcLcLIProfile(void *p);
   static void destruct_AIDAcLcLIProfile(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IProfile*)
   {
      ::AIDA::IProfile *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IProfile));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IProfile", "AIDA/IProfile.h", 26,
                  typeid(::AIDA::IProfile), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIProfile_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IProfile) );
      instance.SetDelete(&delete_AIDAcLcLIProfile);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIProfile);
      instance.SetDestructor(&destruct_AIDAcLcLIProfile);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IProfile*)
   {
      return GenerateInitInstanceLocal((::AIDA::IProfile*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IProfile*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIProfile_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IProfile*)0x0)->GetClass();
      AIDAcLcLIProfile_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIProfile_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIProfile1D_Dictionary();
   static void AIDAcLcLIProfile1D_TClassManip(TClass*);
   static void delete_AIDAcLcLIProfile1D(void *p);
   static void deleteArray_AIDAcLcLIProfile1D(void *p);
   static void destruct_AIDAcLcLIProfile1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IProfile1D*)
   {
      ::AIDA::IProfile1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IProfile1D));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IProfile1D", "AIDA/IProfile1D.h", 28,
                  typeid(::AIDA::IProfile1D), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIProfile1D_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IProfile1D) );
      instance.SetDelete(&delete_AIDAcLcLIProfile1D);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIProfile1D);
      instance.SetDestructor(&destruct_AIDAcLcLIProfile1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IProfile1D*)
   {
      return GenerateInitInstanceLocal((::AIDA::IProfile1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IProfile1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIProfile1D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IProfile1D*)0x0)->GetClass();
      AIDAcLcLIProfile1D_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIProfile1D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIProfile2D_Dictionary();
   static void AIDAcLcLIProfile2D_TClassManip(TClass*);
   static void delete_AIDAcLcLIProfile2D(void *p);
   static void deleteArray_AIDAcLcLIProfile2D(void *p);
   static void destruct_AIDAcLcLIProfile2D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IProfile2D*)
   {
      ::AIDA::IProfile2D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IProfile2D));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IProfile2D", "AIDA/IProfile2D.h", 28,
                  typeid(::AIDA::IProfile2D), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIProfile2D_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IProfile2D) );
      instance.SetDelete(&delete_AIDAcLcLIProfile2D);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIProfile2D);
      instance.SetDestructor(&destruct_AIDAcLcLIProfile2D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IProfile2D*)
   {
      return GenerateInitInstanceLocal((::AIDA::IProfile2D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IProfile2D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIProfile2D_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IProfile2D*)0x0)->GetClass();
      AIDAcLcLIProfile2D_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIProfile2D_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *AIDAcLcLIAxis_Dictionary();
   static void AIDAcLcLIAxis_TClassManip(TClass*);
   static void delete_AIDAcLcLIAxis(void *p);
   static void deleteArray_AIDAcLcLIAxis(void *p);
   static void destruct_AIDAcLcLIAxis(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::AIDA::IAxis*)
   {
      ::AIDA::IAxis *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AIDA::IAxis));
      static ::ROOT::TGenericClassInfo 
         instance("AIDA::IAxis", "AIDA/IAxis.h", 26,
                  typeid(::AIDA::IAxis), DefineBehavior(ptr, ptr),
                  &AIDAcLcLIAxis_Dictionary, isa_proxy, 0,
                  sizeof(::AIDA::IAxis) );
      instance.SetDelete(&delete_AIDAcLcLIAxis);
      instance.SetDeleteArray(&deleteArray_AIDAcLcLIAxis);
      instance.SetDestructor(&destruct_AIDAcLcLIAxis);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::AIDA::IAxis*)
   {
      return GenerateInitInstanceLocal((::AIDA::IAxis*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AIDA::IAxis*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *AIDAcLcLIAxis_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::AIDA::IAxis*)0x0)->GetClass();
      AIDAcLcLIAxis_TClassManip(theClass);
   return theClass;
   }

   static void AIDAcLcLIAxis_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLPyAlgorithm_Dictionary();
   static void GaudiPythoncLcLPyAlgorithm_TClassManip(TClass*);
   static void delete_GaudiPythoncLcLPyAlgorithm(void *p);
   static void deleteArray_GaudiPythoncLcLPyAlgorithm(void *p);
   static void destruct_GaudiPythoncLcLPyAlgorithm(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::PyAlgorithm*)
   {
      ::GaudiPython::PyAlgorithm *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::PyAlgorithm));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::PyAlgorithm", "GaudiPython/Algorithm.h", 35,
                  typeid(::GaudiPython::PyAlgorithm), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLPyAlgorithm_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::PyAlgorithm) );
      instance.SetDelete(&delete_GaudiPythoncLcLPyAlgorithm);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLPyAlgorithm);
      instance.SetDestructor(&destruct_GaudiPythoncLcLPyAlgorithm);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::PyAlgorithm*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::PyAlgorithm*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::PyAlgorithm*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLPyAlgorithm_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::PyAlgorithm*)0x0)->GetClass();
      GaudiPythoncLcLPyAlgorithm_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLPyAlgorithm_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudiPythoncLcLCallbackStreamBuf_Dictionary();
   static void GaudiPythoncLcLCallbackStreamBuf_TClassManip(TClass*);
   static void delete_GaudiPythoncLcLCallbackStreamBuf(void *p);
   static void deleteArray_GaudiPythoncLcLCallbackStreamBuf(void *p);
   static void destruct_GaudiPythoncLcLCallbackStreamBuf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GaudiPython::CallbackStreamBuf*)
   {
      ::GaudiPython::CallbackStreamBuf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GaudiPython::CallbackStreamBuf));
      static ::ROOT::TGenericClassInfo 
         instance("GaudiPython::CallbackStreamBuf", "GaudiPython/CallbackStreamBuf.h", 15,
                  typeid(::GaudiPython::CallbackStreamBuf), DefineBehavior(ptr, ptr),
                  &GaudiPythoncLcLCallbackStreamBuf_Dictionary, isa_proxy, 0,
                  sizeof(::GaudiPython::CallbackStreamBuf) );
      instance.SetDelete(&delete_GaudiPythoncLcLCallbackStreamBuf);
      instance.SetDeleteArray(&deleteArray_GaudiPythoncLcLCallbackStreamBuf);
      instance.SetDestructor(&destruct_GaudiPythoncLcLCallbackStreamBuf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GaudiPython::CallbackStreamBuf*)
   {
      return GenerateInitInstanceLocal((::GaudiPython::CallbackStreamBuf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GaudiPython::CallbackStreamBuf*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudiPythoncLcLCallbackStreamBuf_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::GaudiPython::CallbackStreamBuf*)0x0)->GetClass();
      GaudiPythoncLcLCallbackStreamBuf_TClassManip(theClass);
   return theClass;
   }

   static void GaudiPythoncLcLCallbackStreamBuf_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *ParticleProperty_Dictionary();
   static void ParticleProperty_TClassManip(TClass*);
   static void *new_ParticleProperty(void *p = 0);
   static void *newArray_ParticleProperty(Long_t size, void *p);
   static void delete_ParticleProperty(void *p);
   static void deleteArray_ParticleProperty(void *p);
   static void destruct_ParticleProperty(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ParticleProperty*)
   {
      ::ParticleProperty *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ParticleProperty));
      static ::ROOT::TGenericClassInfo 
         instance("ParticleProperty", "GaudiKernel/ParticleProperty.h", 19,
                  typeid(::ParticleProperty), DefineBehavior(ptr, ptr),
                  &ParticleProperty_Dictionary, isa_proxy, 0,
                  sizeof(::ParticleProperty) );
      instance.SetNew(&new_ParticleProperty);
      instance.SetNewArray(&newArray_ParticleProperty);
      instance.SetDelete(&delete_ParticleProperty);
      instance.SetDeleteArray(&deleteArray_ParticleProperty);
      instance.SetDestructor(&destruct_ParticleProperty);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ParticleProperty*)
   {
      return GenerateInitInstanceLocal((::ParticleProperty*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ParticleProperty*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *ParticleProperty_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::ParticleProperty*)0x0)->GetClass();
      ParticleProperty_TClassManip(theClass);
   return theClass;
   }

   static void ParticleProperty_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLStringKey_Dictionary();
   static void GaudicLcLStringKey_TClassManip(TClass*);
   static void *new_GaudicLcLStringKey(void *p = 0);
   static void *newArray_GaudicLcLStringKey(Long_t size, void *p);
   static void delete_GaudicLcLStringKey(void *p);
   static void deleteArray_GaudicLcLStringKey(void *p);
   static void destruct_GaudicLcLStringKey(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::StringKey*)
   {
      ::Gaudi::StringKey *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::StringKey));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::StringKey", "GaudiKernel/StringKey.h", 35,
                  typeid(::Gaudi::StringKey), DefineBehavior(ptr, ptr),
                  &GaudicLcLStringKey_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::StringKey) );
      instance.SetNew(&new_GaudicLcLStringKey);
      instance.SetNewArray(&newArray_GaudicLcLStringKey);
      instance.SetDelete(&delete_GaudicLcLStringKey);
      instance.SetDeleteArray(&deleteArray_GaudicLcLStringKey);
      instance.SetDestructor(&destruct_GaudicLcLStringKey);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::StringKey*)
   {
      return GenerateInitInstanceLocal((::Gaudi::StringKey*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::StringKey*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLStringKey_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::StringKey*)0x0)->GetClass();
      GaudicLcLStringKey_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLStringKey_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLUtilscLcLMapBase_Dictionary();
   static void GaudicLcLUtilscLcLMapBase_TClassManip(TClass*);
   static void *new_GaudicLcLUtilscLcLMapBase(void *p = 0);
   static void *newArray_GaudicLcLUtilscLcLMapBase(Long_t size, void *p);
   static void delete_GaudicLcLUtilscLcLMapBase(void *p);
   static void deleteArray_GaudicLcLUtilscLcLMapBase(void *p);
   static void destruct_GaudicLcLUtilscLcLMapBase(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::Utils::MapBase*)
   {
      ::Gaudi::Utils::MapBase *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::Utils::MapBase));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::Utils::MapBase", "GaudiKernel/MapBase.h", 46,
                  typeid(::Gaudi::Utils::MapBase), DefineBehavior(ptr, ptr),
                  &GaudicLcLUtilscLcLMapBase_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::Utils::MapBase) );
      instance.SetNew(&new_GaudicLcLUtilscLcLMapBase);
      instance.SetNewArray(&newArray_GaudicLcLUtilscLcLMapBase);
      instance.SetDelete(&delete_GaudicLcLUtilscLcLMapBase);
      instance.SetDeleteArray(&deleteArray_GaudicLcLUtilscLcLMapBase);
      instance.SetDestructor(&destruct_GaudicLcLUtilscLcLMapBase);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::Utils::MapBase*)
   {
      return GenerateInitInstanceLocal((::Gaudi::Utils::MapBase*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::Utils::MapBase*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLUtilscLcLMapBase_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::Utils::MapBase*)0x0)->GetClass();
      GaudicLcLUtilscLcLMapBase_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLUtilscLcLMapBase_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *IErrorTool_Dictionary();
   static void IErrorTool_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::IErrorTool*)
   {
      ::IErrorTool *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::IErrorTool));
      static ::ROOT::TGenericClassInfo 
         instance("IErrorTool", "GaudiAlg/IErrorTool.h", 26,
                  typeid(::IErrorTool), DefineBehavior(ptr, ptr),
                  &IErrorTool_Dictionary, isa_proxy, 0,
                  sizeof(::IErrorTool) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::IErrorTool*)
   {
      return GenerateInitInstanceLocal((::IErrorTool*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::IErrorTool*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *IErrorTool_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::IErrorTool*)0x0)->GetClass();
      IErrorTool_TClassManip(theClass);
   return theClass;
   }

   static void IErrorTool_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *IGenericTool_Dictionary();
   static void IGenericTool_TClassManip(TClass*);
   static void delete_IGenericTool(void *p);
   static void deleteArray_IGenericTool(void *p);
   static void destruct_IGenericTool(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::IGenericTool*)
   {
      ::IGenericTool *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::IGenericTool));
      static ::ROOT::TGenericClassInfo 
         instance("IGenericTool", "GaudiAlg/IGenericTool.h", 14,
                  typeid(::IGenericTool), DefineBehavior(ptr, ptr),
                  &IGenericTool_Dictionary, isa_proxy, 0,
                  sizeof(::IGenericTool) );
      instance.SetDelete(&delete_IGenericTool);
      instance.SetDeleteArray(&deleteArray_IGenericTool);
      instance.SetDestructor(&destruct_IGenericTool);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::IGenericTool*)
   {
      return GenerateInitInstanceLocal((::IGenericTool*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::IGenericTool*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *IGenericTool_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::IGenericTool*)0x0)->GetClass();
      IGenericTool_TClassManip(theClass);
   return theClass;
   }

   static void IGenericTool_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *IHistoTool_Dictionary();
   static void IHistoTool_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::IHistoTool*)
   {
      ::IHistoTool *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::IHistoTool));
      static ::ROOT::TGenericClassInfo 
         instance("IHistoTool", "GaudiAlg/IHistoTool.h", 33,
                  typeid(::IHistoTool), DefineBehavior(ptr, ptr),
                  &IHistoTool_Dictionary, isa_proxy, 0,
                  sizeof(::IHistoTool) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::IHistoTool*)
   {
      return GenerateInitInstanceLocal((::IHistoTool*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::IHistoTool*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *IHistoTool_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::IHistoTool*)0x0)->GetClass();
      IHistoTool_TClassManip(theClass);
   return theClass;
   }

   static void IHistoTool_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *ITupleTool_Dictionary();
   static void ITupleTool_TClassManip(TClass*);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ITupleTool*)
   {
      ::ITupleTool *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ITupleTool));
      static ::ROOT::TGenericClassInfo 
         instance("ITupleTool", "GaudiAlg/ITupleTool.h", 33,
                  typeid(::ITupleTool), DefineBehavior(ptr, ptr),
                  &ITupleTool_Dictionary, isa_proxy, 0,
                  sizeof(::ITupleTool) );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ITupleTool*)
   {
      return GenerateInitInstanceLocal((::ITupleTool*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ITupleTool*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *ITupleTool_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::ITupleTool*)0x0)->GetClass();
      ITupleTool_TClassManip(theClass);
   return theClass;
   }

   static void ITupleTool_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *ISequencerTimerTool_Dictionary();
   static void ISequencerTimerTool_TClassManip(TClass*);
   static void delete_ISequencerTimerTool(void *p);
   static void deleteArray_ISequencerTimerTool(void *p);
   static void destruct_ISequencerTimerTool(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ISequencerTimerTool*)
   {
      ::ISequencerTimerTool *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ISequencerTimerTool));
      static ::ROOT::TGenericClassInfo 
         instance("ISequencerTimerTool", "GaudiAlg/ISequencerTimerTool.h", 14,
                  typeid(::ISequencerTimerTool), DefineBehavior(ptr, ptr),
                  &ISequencerTimerTool_Dictionary, isa_proxy, 0,
                  sizeof(::ISequencerTimerTool) );
      instance.SetDelete(&delete_ISequencerTimerTool);
      instance.SetDeleteArray(&deleteArray_ISequencerTimerTool);
      instance.SetDestructor(&destruct_ISequencerTimerTool);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ISequencerTimerTool*)
   {
      return GenerateInitInstanceLocal((::ISequencerTimerTool*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ISequencerTimerTool*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *ISequencerTimerTool_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::ISequencerTimerTool*)0x0)->GetClass();
      ISequencerTimerTool_TClassManip(theClass);
   return theClass;
   }

   static void ISequencerTimerTool_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLIFileCatalog_Dictionary();
   static void GaudicLcLIFileCatalog_TClassManip(TClass*);
   static void delete_GaudicLcLIFileCatalog(void *p);
   static void deleteArray_GaudicLcLIFileCatalog(void *p);
   static void destruct_GaudicLcLIFileCatalog(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::IFileCatalog*)
   {
      ::Gaudi::IFileCatalog *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::IFileCatalog));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::IFileCatalog", "GaudiUtils/IFileCatalog.h", 24,
                  typeid(::Gaudi::IFileCatalog), DefineBehavior(ptr, ptr),
                  &GaudicLcLIFileCatalog_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::IFileCatalog) );
      instance.SetDelete(&delete_GaudicLcLIFileCatalog);
      instance.SetDeleteArray(&deleteArray_GaudicLcLIFileCatalog);
      instance.SetDestructor(&destruct_GaudicLcLIFileCatalog);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::IFileCatalog*)
   {
      return GenerateInitInstanceLocal((::Gaudi::IFileCatalog*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::IFileCatalog*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLIFileCatalog_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::IFileCatalog*)0x0)->GetClass();
      GaudicLcLIFileCatalog_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLIFileCatalog_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLIFileCatalogMgr_Dictionary();
   static void GaudicLcLIFileCatalogMgr_TClassManip(TClass*);
   static void delete_GaudicLcLIFileCatalogMgr(void *p);
   static void deleteArray_GaudicLcLIFileCatalogMgr(void *p);
   static void destruct_GaudicLcLIFileCatalogMgr(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::IFileCatalogMgr*)
   {
      ::Gaudi::IFileCatalogMgr *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::IFileCatalogMgr));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::IFileCatalogMgr", "GaudiUtils/IFileCatalogMgr.h", 26,
                  typeid(::Gaudi::IFileCatalogMgr), DefineBehavior(ptr, ptr),
                  &GaudicLcLIFileCatalogMgr_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::IFileCatalogMgr) );
      instance.SetDelete(&delete_GaudicLcLIFileCatalogMgr);
      instance.SetDeleteArray(&deleteArray_GaudicLcLIFileCatalogMgr);
      instance.SetDestructor(&destruct_GaudicLcLIFileCatalogMgr);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::IFileCatalogMgr*)
   {
      return GenerateInitInstanceLocal((::Gaudi::IFileCatalogMgr*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::IFileCatalogMgr*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLIFileCatalogMgr_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::IFileCatalogMgr*)0x0)->GetClass();
      GaudicLcLIFileCatalogMgr_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLIFileCatalogMgr_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLIDataConnection_Dictionary();
   static void GaudicLcLIDataConnection_TClassManip(TClass*);
   static void delete_GaudicLcLIDataConnection(void *p);
   static void deleteArray_GaudicLcLIDataConnection(void *p);
   static void destruct_GaudicLcLIDataConnection(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::IDataConnection*)
   {
      ::Gaudi::IDataConnection *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::IDataConnection));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::IDataConnection", "GaudiUtils/IIODataManager.h", 25,
                  typeid(::Gaudi::IDataConnection), DefineBehavior(ptr, ptr),
                  &GaudicLcLIDataConnection_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::IDataConnection) );
      instance.SetDelete(&delete_GaudicLcLIDataConnection);
      instance.SetDeleteArray(&deleteArray_GaudicLcLIDataConnection);
      instance.SetDestructor(&destruct_GaudicLcLIDataConnection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::IDataConnection*)
   {
      return GenerateInitInstanceLocal((::Gaudi::IDataConnection*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::IDataConnection*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLIDataConnection_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::IDataConnection*)0x0)->GetClass();
      GaudicLcLIDataConnection_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLIDataConnection_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLIIODataManager_Dictionary();
   static void GaudicLcLIIODataManager_TClassManip(TClass*);
   static void delete_GaudicLcLIIODataManager(void *p);
   static void deleteArray_GaudicLcLIIODataManager(void *p);
   static void destruct_GaudicLcLIIODataManager(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::IIODataManager*)
   {
      ::Gaudi::IIODataManager *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::IIODataManager));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::IIODataManager", "GaudiUtils/IIODataManager.h", 88,
                  typeid(::Gaudi::IIODataManager), DefineBehavior(ptr, ptr),
                  &GaudicLcLIIODataManager_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::IIODataManager) );
      instance.SetDelete(&delete_GaudicLcLIIODataManager);
      instance.SetDeleteArray(&deleteArray_GaudicLcLIIODataManager);
      instance.SetDestructor(&destruct_GaudicLcLIIODataManager);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::IIODataManager*)
   {
      return GenerateInitInstanceLocal((::Gaudi::IIODataManager*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::IIODataManager*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLIIODataManager_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::IIODataManager*)0x0)->GetClass();
      GaudicLcLIIODataManager_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLIIODataManager_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLUtilscLcLHistoscLcLTable_Dictionary();
   static void GaudicLcLUtilscLcLHistoscLcLTable_TClassManip(TClass*);
   static void *new_GaudicLcLUtilscLcLHistoscLcLTable(void *p = 0);
   static void *newArray_GaudicLcLUtilscLcLHistoscLcLTable(Long_t size, void *p);
   static void delete_GaudicLcLUtilscLcLHistoscLcLTable(void *p);
   static void deleteArray_GaudicLcLUtilscLcLHistoscLcLTable(void *p);
   static void destruct_GaudicLcLUtilscLcLHistoscLcLTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::Utils::Histos::Table*)
   {
      ::Gaudi::Utils::Histos::Table *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::Utils::Histos::Table));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::Utils::Histos::Table", "GaudiUtils/HistoTableFormat.h", 411,
                  typeid(::Gaudi::Utils::Histos::Table), DefineBehavior(ptr, ptr),
                  &GaudicLcLUtilscLcLHistoscLcLTable_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::Utils::Histos::Table) );
      instance.SetNew(&new_GaudicLcLUtilscLcLHistoscLcLTable);
      instance.SetNewArray(&newArray_GaudicLcLUtilscLcLHistoscLcLTable);
      instance.SetDelete(&delete_GaudicLcLUtilscLcLHistoscLcLTable);
      instance.SetDeleteArray(&deleteArray_GaudicLcLUtilscLcLHistoscLcLTable);
      instance.SetDestructor(&destruct_GaudicLcLUtilscLcLHistoscLcLTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::Utils::Histos::Table*)
   {
      return GenerateInitInstanceLocal((::Gaudi::Utils::Histos::Table*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::Utils::Histos::Table*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLUtilscLcLHistoscLcLTable_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::Utils::Histos::Table*)0x0)->GetClass();
      GaudicLcLUtilscLcLHistoscLcLTable_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLUtilscLcLHistoscLcLTable_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLUtilscLcLHistoStats_Dictionary();
   static void GaudicLcLUtilscLcLHistoStats_TClassManip(TClass*);
   static void *new_GaudicLcLUtilscLcLHistoStats(void *p = 0);
   static void *newArray_GaudicLcLUtilscLcLHistoStats(Long_t size, void *p);
   static void delete_GaudicLcLUtilscLcLHistoStats(void *p);
   static void deleteArray_GaudicLcLUtilscLcLHistoStats(void *p);
   static void destruct_GaudicLcLUtilscLcLHistoStats(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::Utils::HistoStats*)
   {
      ::Gaudi::Utils::HistoStats *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::Utils::HistoStats));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::Utils::HistoStats", "GaudiUtils/HistoStats.h", 31,
                  typeid(::Gaudi::Utils::HistoStats), DefineBehavior(ptr, ptr),
                  &GaudicLcLUtilscLcLHistoStats_Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::Utils::HistoStats) );
      instance.SetNew(&new_GaudicLcLUtilscLcLHistoStats);
      instance.SetNewArray(&newArray_GaudicLcLUtilscLcLHistoStats);
      instance.SetDelete(&delete_GaudicLcLUtilscLcLHistoStats);
      instance.SetDeleteArray(&deleteArray_GaudicLcLUtilscLcLHistoStats);
      instance.SetDestructor(&destruct_GaudicLcLUtilscLcLHistoStats);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::Utils::HistoStats*)
   {
      return GenerateInitInstanceLocal((::Gaudi::Utils::HistoStats*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::Utils::HistoStats*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLUtilscLcLHistoStats_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::Utils::HistoStats*)0x0)->GetClass();
      GaudicLcLUtilscLcLHistoStats_TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLUtilscLcLHistoStats_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *GaudicLcLRangeBase__Dictionary();
   static void GaudicLcLRangeBase__TClassManip(TClass*);
   static void *new_GaudicLcLRangeBase_(void *p = 0);
   static void *newArray_GaudicLcLRangeBase_(Long_t size, void *p);
   static void delete_GaudicLcLRangeBase_(void *p);
   static void deleteArray_GaudicLcLRangeBase_(void *p);
   static void destruct_GaudicLcLRangeBase_(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Gaudi::RangeBase_*)
   {
      ::Gaudi::RangeBase_ *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Gaudi::RangeBase_));
      static ::ROOT::TGenericClassInfo 
         instance("Gaudi::RangeBase_", "GaudiKernel/Range.h", 52,
                  typeid(::Gaudi::RangeBase_), DefineBehavior(ptr, ptr),
                  &GaudicLcLRangeBase__Dictionary, isa_proxy, 0,
                  sizeof(::Gaudi::RangeBase_) );
      instance.SetNew(&new_GaudicLcLRangeBase_);
      instance.SetNewArray(&newArray_GaudicLcLRangeBase_);
      instance.SetDelete(&delete_GaudicLcLRangeBase_);
      instance.SetDeleteArray(&deleteArray_GaudicLcLRangeBase_);
      instance.SetDestructor(&destruct_GaudicLcLRangeBase_);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Gaudi::RangeBase_*)
   {
      return GenerateInitInstanceLocal((::Gaudi::RangeBase_*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Gaudi::RangeBase_*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *GaudicLcLRangeBase__Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::Gaudi::RangeBase_*)0x0)->GetClass();
      GaudicLcLRangeBase__TClassManip(theClass);
   return theClass;
   }

   static void GaudicLcLRangeBase__TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcLdummy(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::dummy : new ::__gnu_cxx::dummy;
   }
   static void *newArray___gnu_cxxcLcLdummy(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::dummy[nElements] : new ::__gnu_cxx::dummy[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcLdummy(void *p) {
      delete ((::__gnu_cxx::dummy*)p);
   }
   static void deleteArray___gnu_cxxcLcLdummy(void *p) {
      delete [] ((::__gnu_cxx::dummy*)p);
   }
   static void destruct___gnu_cxxcLcLdummy(void *p) {
      typedef ::__gnu_cxx::dummy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::dummy

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,SmartIF<IService> >,const string> : new ::unary_function<pair<const string,SmartIF<IService> >,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,SmartIF<IService> >,const string>[nElements] : new ::unary_function<pair<const string,SmartIF<IService> >,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,SmartIF<IService> >,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,SmartIF<IService> >,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOSmartIFlEIServicegRsPgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,SmartIF<IService> >,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,SmartIF<IService> >,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string> : new ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>[nElements] : new ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram3DmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,AIDA::IHistogram3D*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<GaudiAlg::ID,unsigned long> : new ::unary_function<GaudiAlg::ID,unsigned long>;
   }
   static void *newArray_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<GaudiAlg::ID,unsigned long>[nElements] : new ::unary_function<GaudiAlg::ID,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<GaudiAlg::ID,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<GaudiAlg::ID,unsigned long>*)p);
   }
   static void destruct_unary_functionlEGaudiAlgcLcLIDcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<GaudiAlg::ID,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<GaudiAlg::ID,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string> : new ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>[nElements] : new ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram1DmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,AIDA::IHistogram1D*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string> : new ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>[nElements] : new ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIHistogram2DmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,AIDA::IHistogram2D*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IProfile1D*>,const string> : new ::unary_function<pair<const string,AIDA::IProfile1D*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IProfile1D*>,const string>[nElements] : new ::unary_function<pair<const string,AIDA::IProfile1D*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,AIDA::IProfile1D*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,AIDA::IProfile1D*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile1DmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,AIDA::IProfile1D*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,AIDA::IProfile1D*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IProfile2D*>,const string> : new ::unary_function<pair<const string,AIDA::IProfile2D*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,AIDA::IProfile2D*>,const string>[nElements] : new ::unary_function<pair<const string,AIDA::IProfile2D*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,AIDA::IProfile2D*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,AIDA::IProfile2D*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOAIDAcLcLIProfile2DmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,AIDA::IProfile2D*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,AIDA::IProfile2D*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<bool>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<bool>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<bool>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<bool>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<bool>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<bool>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEboolgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<bool>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<bool>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<char>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<char>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<char>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<char>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<char>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<char>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEchargRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<char>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<char>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPchargRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<short>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<short>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<short>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<short>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<short>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<short>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEshortgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<short>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<short>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPshortgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<int>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<int>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<int>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<int>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<int>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<int>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEintgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<int>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<int>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEunsignedsPintgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlELong64_tgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEULong64_tgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<float>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<float>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<float>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<float>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<float>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<float>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEfloatgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<float>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<float>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<double>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<double>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<double>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<double>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<double>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<double>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEdoublegRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<double>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<double>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string> : new ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLItemlEIOpaqueAddressmUgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Array<float>*>,const string> : new ::unary_function<pair<const string,NTuple::Array<float>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Array<float>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Array<float>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Array<float>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Array<float>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLArraylEfloatgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Array<float>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Array<float>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string> : new ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>[nElements] : new ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcONTuplecLcLMatrixlEfloatgRmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,NTuple::Matrix<float>*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,Tuples::TupleObj*>,const string> : new ::unary_function<pair<const string,Tuples::TupleObj*>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,Tuples::TupleObj*>,const string>[nElements] : new ::unary_function<pair<const string,Tuples::TupleObj*>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,Tuples::TupleObj*>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,Tuples::TupleObj*>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOTuplescLcLTupleObjmUgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,Tuples::TupleObj*>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,Tuples::TupleObj*>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEcharcOboolgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<char,bool> : new ::unary_function<char,bool>;
   }
   static void *newArray_unary_functionlEcharcOboolgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<char,bool>[nElements] : new ::unary_function<char,bool>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEcharcOboolgR(void *p) {
      delete ((::unary_function<char,bool>*)p);
   }
   static void deleteArray_unary_functionlEcharcOboolgR(void *p) {
      delete [] ((::unary_function<char,bool>*)p);
   }
   static void destruct_unary_functionlEcharcOboolgR(void *p) {
      typedef ::unary_function<char,bool> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<char,bool>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,string>,const string> : new ::unary_function<pair<const string,string>,const string>;
   }
   static void *newArray_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<pair<const string,string>,const string>[nElements] : new ::unary_function<pair<const string,string>,const string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p) {
      delete ((::unary_function<pair<const string,string>,const string>*)p);
   }
   static void deleteArray_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p) {
      delete [] ((::unary_function<pair<const string,string>,const string>*)p);
   }
   static void destruct_unary_functionlEpairlEconstsPstringcOstringgRcOconstsPstringgR(void *p) {
      typedef ::unary_function<pair<const string,string>,const string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<pair<const string,string>,const string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<const char*,unsigned long> : new ::unary_function<const char*,unsigned long>;
   }
   static void *newArray_unary_functionlEconstsPcharmUcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<const char*,unsigned long>[nElements] : new ::unary_function<const char*,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<const char*,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<const char*,unsigned long>*)p);
   }
   static void destruct_unary_functionlEconstsPcharmUcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<const char*,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<const char*,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEboolcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<bool,unsigned long> : new ::unary_function<bool,unsigned long>;
   }
   static void *newArray_unary_functionlEboolcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<bool,unsigned long>[nElements] : new ::unary_function<bool,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEboolcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<bool,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEboolcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<bool,unsigned long>*)p);
   }
   static void destruct_unary_functionlEboolcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<bool,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<bool,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEcharcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<char,unsigned long> : new ::unary_function<char,unsigned long>;
   }
   static void *newArray_unary_functionlEcharcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<char,unsigned long>[nElements] : new ::unary_function<char,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEcharcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<char,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEcharcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<char,unsigned long>*)p);
   }
   static void destruct_unary_functionlEcharcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<char,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<char,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<signed char,unsigned long> : new ::unary_function<signed char,unsigned long>;
   }
   static void *newArray_unary_functionlEsignedsPcharcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<signed char,unsigned long>[nElements] : new ::unary_function<signed char,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<signed char,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<signed char,unsigned long>*)p);
   }
   static void destruct_unary_functionlEsignedsPcharcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<signed char,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<signed char,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned char,unsigned long> : new ::unary_function<unsigned char,unsigned long>;
   }
   static void *newArray_unary_functionlEunsignedsPcharcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned char,unsigned long>[nElements] : new ::unary_function<unsigned char,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<unsigned char,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<unsigned char,unsigned long>*)p);
   }
   static void destruct_unary_functionlEunsignedsPcharcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<unsigned char,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<unsigned char,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEwchar_tcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<wchar_t,unsigned long> : new ::unary_function<wchar_t,unsigned long>;
   }
   static void *newArray_unary_functionlEwchar_tcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<wchar_t,unsigned long>[nElements] : new ::unary_function<wchar_t,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEwchar_tcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<wchar_t,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEwchar_tcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<wchar_t,unsigned long>*)p);
   }
   static void destruct_unary_functionlEwchar_tcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<wchar_t,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<wchar_t,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEshortcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<short,unsigned long> : new ::unary_function<short,unsigned long>;
   }
   static void *newArray_unary_functionlEshortcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<short,unsigned long>[nElements] : new ::unary_function<short,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEshortcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<short,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEshortcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<short,unsigned long>*)p);
   }
   static void destruct_unary_functionlEshortcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<short,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<short,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned short,unsigned long> : new ::unary_function<unsigned short,unsigned long>;
   }
   static void *newArray_unary_functionlEunsignedsPshortcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned short,unsigned long>[nElements] : new ::unary_function<unsigned short,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<unsigned short,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<unsigned short,unsigned long>*)p);
   }
   static void destruct_unary_functionlEunsignedsPshortcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<unsigned short,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<unsigned short,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEintcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<int,unsigned long> : new ::unary_function<int,unsigned long>;
   }
   static void *newArray_unary_functionlEintcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<int,unsigned long>[nElements] : new ::unary_function<int,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEintcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<int,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEintcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<int,unsigned long>*)p);
   }
   static void destruct_unary_functionlEintcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<int,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<int,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned int,unsigned long> : new ::unary_function<unsigned int,unsigned long>;
   }
   static void *newArray_unary_functionlEunsignedsPintcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned int,unsigned long>[nElements] : new ::unary_function<unsigned int,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<unsigned int,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<unsigned int,unsigned long>*)p);
   }
   static void destruct_unary_functionlEunsignedsPintcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<unsigned int,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<unsigned int,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlElongcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<long,unsigned long> : new ::unary_function<long,unsigned long>;
   }
   static void *newArray_unary_functionlElongcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<long,unsigned long>[nElements] : new ::unary_function<long,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlElongcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<long,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlElongcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<long,unsigned long>*)p);
   }
   static void destruct_unary_functionlElongcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<long,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<long,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned long,unsigned long> : new ::unary_function<unsigned long,unsigned long>;
   }
   static void *newArray_unary_functionlEunsignedsPlongcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned long,unsigned long>[nElements] : new ::unary_function<unsigned long,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<unsigned long,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<unsigned long,unsigned long>*)p);
   }
   static void destruct_unary_functionlEunsignedsPlongcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<unsigned long,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<unsigned long,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEdoublecOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<double,unsigned long> : new ::unary_function<double,unsigned long>;
   }
   static void *newArray_unary_functionlEdoublecOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<double,unsigned long>[nElements] : new ::unary_function<double,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEdoublecOunsignedsPlonggR(void *p) {
      delete ((::unary_function<double,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEdoublecOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<double,unsigned long>*)p);
   }
   static void destruct_unary_functionlEdoublecOunsignedsPlonggR(void *p) {
      typedef ::unary_function<double,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<double,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<long double,unsigned long> : new ::unary_function<long double,unsigned long>;
   }
   static void *newArray_unary_functionlElongsPdoublecOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<long double,unsigned long>[nElements] : new ::unary_function<long double,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p) {
      delete ((::unary_function<long double,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<long double,unsigned long>*)p);
   }
   static void destruct_unary_functionlElongsPdoublecOunsignedsPlonggR(void *p) {
      typedef ::unary_function<long double,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<long double,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEstringcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<string,unsigned long> : new ::unary_function<string,unsigned long>;
   }
   static void *newArray_unary_functionlEstringcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<string,unsigned long>[nElements] : new ::unary_function<string,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEstringcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<string,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEstringcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<string,unsigned long>*)p);
   }
   static void destruct_unary_functionlEstringcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<string,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<string,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long> : new ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>;
   }
   static void *newArray_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>[nElements] : new ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>*)p);
   }
   static void destruct_unary_functionlEbasic_stringlEwchar_tcOchar_traitslEwchar_tgRcOallocatorlEwchar_tgRsPgRcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlELong64_tcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<Long64_t,unsigned long> : new ::unary_function<Long64_t,unsigned long>;
   }
   static void *newArray_unary_functionlELong64_tcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<Long64_t,unsigned long>[nElements] : new ::unary_function<Long64_t,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlELong64_tcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<Long64_t,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlELong64_tcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<Long64_t,unsigned long>*)p);
   }
   static void destruct_unary_functionlELong64_tcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<Long64_t,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<Long64_t,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEfloatcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<float,unsigned long> : new ::unary_function<float,unsigned long>;
   }
   static void *newArray_unary_functionlEfloatcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<float,unsigned long>[nElements] : new ::unary_function<float,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEfloatcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<float,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEfloatcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<float,unsigned long>*)p);
   }
   static void destruct_unary_functionlEfloatcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<float,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<float,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEULong64_tcOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<ULong64_t,unsigned long> : new ::unary_function<ULong64_t,unsigned long>;
   }
   static void *newArray_unary_functionlEULong64_tcOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<ULong64_t,unsigned long>[nElements] : new ::unary_function<ULong64_t,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEULong64_tcOunsignedsPlonggR(void *p) {
      delete ((::unary_function<ULong64_t,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEULong64_tcOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<ULong64_t,unsigned long>*)p);
   }
   static void destruct_unary_functionlEULong64_tcOunsignedsPlonggR(void *p) {
      typedef ::unary_function<ULong64_t,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<ULong64_t,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlE__int128cOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<__int128,unsigned long> : new ::unary_function<__int128,unsigned long>;
   }
   static void *newArray_unary_functionlE__int128cOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<__int128,unsigned long>[nElements] : new ::unary_function<__int128,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlE__int128cOunsignedsPlonggR(void *p) {
      delete ((::unary_function<__int128,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlE__int128cOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<__int128,unsigned long>*)p);
   }
   static void destruct_unary_functionlE__int128cOunsignedsPlonggR(void *p) {
      typedef ::unary_function<__int128,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<__int128,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned __int128,unsigned long> : new ::unary_function<unsigned __int128,unsigned long>;
   }
   static void *newArray_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<unsigned __int128,unsigned long>[nElements] : new ::unary_function<unsigned __int128,unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p) {
      delete ((::unary_function<unsigned __int128,unsigned long>*)p);
   }
   static void deleteArray_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p) {
      delete [] ((::unary_function<unsigned __int128,unsigned long>*)p);
   }
   static void destruct_unary_functionlEunsignedsP__int128cOunsignedsPlonggR(void *p) {
      typedef ::unary_function<unsigned __int128,unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<unsigned __int128,unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<const IInterface*,IInterface*> : new ::unary_function<const IInterface*,IInterface*>;
   }
   static void *newArray_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::unary_function<const IInterface*,IInterface*>[nElements] : new ::unary_function<const IInterface*,IInterface*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p) {
      delete ((::unary_function<const IInterface*,IInterface*>*)p);
   }
   static void deleteArray_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p) {
      delete [] ((::unary_function<const IInterface*,IInterface*>*)p);
   }
   static void destruct_unary_functionlEconstsPIInterfacemUcOIInterfacemUgR(void *p) {
      typedef ::unary_function<const IInterface*,IInterface*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::unary_function<const IInterface*,IInterface*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLHelper(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::Helper : new ::GaudiPython::Helper;
   }
   static void *newArray_GaudiPythoncLcLHelper(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::Helper[nElements] : new ::GaudiPython::Helper[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLHelper(void *p) {
      delete ((::GaudiPython::Helper*)p);
   }
   static void deleteArray_GaudiPythoncLcLHelper(void *p) {
      delete [] ((::GaudiPython::Helper*)p);
   }
   static void destruct_GaudiPythoncLcLHelper(void *p) {
      typedef ::GaudiPython::Helper current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::Helper

namespace ROOT {
   // Wrapper around operator delete
   static void delete_basic_ostreamlEcharcOchar_traitslEchargRsPgR(void *p) {
      delete ((::basic_ostream<char,char_traits<char> >*)p);
   }
   static void deleteArray_basic_ostreamlEcharcOchar_traitslEchargRsPgR(void *p) {
      delete [] ((::basic_ostream<char,char_traits<char> >*)p);
   }
   static void destruct_basic_ostreamlEcharcOchar_traitslEchargRsPgR(void *p) {
      typedef ::basic_ostream<char,char_traits<char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::basic_ostream<char,char_traits<char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::basic_stringbuf<char,char_traits<char>,allocator<char> > : new ::basic_stringbuf<char,char_traits<char>,allocator<char> >;
   }
   static void *newArray_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::basic_stringbuf<char,char_traits<char>,allocator<char> >[nElements] : new ::basic_stringbuf<char,char_traits<char>,allocator<char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p) {
      delete ((::basic_stringbuf<char,char_traits<char>,allocator<char> >*)p);
   }
   static void deleteArray_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p) {
      delete [] ((::basic_stringbuf<char,char_traits<char>,allocator<char> >*)p);
   }
   static void destruct_basic_stringbuflEcharcOchar_traitslEchargRcOallocatorlEchargRsPgR(void *p) {
      typedef ::basic_stringbuf<char,char_traits<char>,allocator<char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::basic_stringbuf<char,char_traits<char>,allocator<char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new__Bit_reference(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::_Bit_reference : new ::_Bit_reference;
   }
   static void *newArray__Bit_reference(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::_Bit_reference[nElements] : new ::_Bit_reference[nElements];
   }
   // Wrapper around operator delete
   static void delete__Bit_reference(void *p) {
      delete ((::_Bit_reference*)p);
   }
   static void deleteArray__Bit_reference(void *p) {
      delete [] ((::_Bit_reference*)p);
   }
   static void destruct__Bit_reference(void *p) {
      typedef ::_Bit_reference current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::_Bit_reference

namespace ROOT {
   // Wrappers around operator new
   static void *new_allocatorlEIRegistrymUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<IRegistry*> : new allocator<IRegistry*>;
   }
   static void *newArray_allocatorlEIRegistrymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<IRegistry*>[nElements] : new allocator<IRegistry*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_allocatorlEIRegistrymUgR(void *p) {
      delete ((allocator<IRegistry*>*)p);
   }
   static void deleteArray_allocatorlEIRegistrymUgR(void *p) {
      delete [] ((allocator<IRegistry*>*)p);
   }
   static void destruct_allocatorlEIRegistrymUgR(void *p) {
      typedef allocator<IRegistry*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class allocator<IRegistry*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_allocatorlEIAlgorithmmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<IAlgorithm*> : new allocator<IAlgorithm*>;
   }
   static void *newArray_allocatorlEIAlgorithmmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<IAlgorithm*>[nElements] : new allocator<IAlgorithm*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_allocatorlEIAlgorithmmUgR(void *p) {
      delete ((allocator<IAlgorithm*>*)p);
   }
   static void deleteArray_allocatorlEIAlgorithmmUgR(void *p) {
      delete [] ((allocator<IAlgorithm*>*)p);
   }
   static void destruct_allocatorlEIAlgorithmmUgR(void *p) {
      typedef allocator<IAlgorithm*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class allocator<IAlgorithm*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_allocatorlEIServicemUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<IService*> : new allocator<IService*>;
   }
   static void *newArray_allocatorlEIServicemUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) allocator<IService*>[nElements] : new allocator<IService*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_allocatorlEIServicemUgR(void *p) {
      delete ((allocator<IService*>*)p);
   }
   static void deleteArray_allocatorlEIServicemUgR(void *p) {
      delete [] ((allocator<IService*>*)p);
   }
   static void destruct_allocatorlEIServicemUgR(void *p) {
      typedef allocator<IService*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class allocator<IService*>

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::Histos::HistoStrings : new ::Gaudi::Utils::Histos::HistoStrings;
   }
   static void *newArray_GaudicLcLUtilscLcLHistoscLcLHistoStrings(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::Histos::HistoStrings[nElements] : new ::Gaudi::Utils::Histos::HistoStrings[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p) {
      delete ((::Gaudi::Utils::Histos::HistoStrings*)p);
   }
   static void deleteArray_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p) {
      delete [] ((::Gaudi::Utils::Histos::HistoStrings*)p);
   }
   static void destruct_GaudicLcLUtilscLcLHistoscLcLHistoStrings(void *p) {
      typedef ::Gaudi::Utils::Histos::HistoStrings current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::Utils::Histos::HistoStrings

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > > : new ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >;
   }
   static void *newArray_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >[nElements] : new ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEunsignedsPintgRcOBoundedVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > > : new ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >;
   }
   static void *newArray_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >[nElements] : new ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)p);
   }
   static void deleteArray_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >*)p);
   }
   static void destruct_SimplePropertylEmaplEstringcOvectorlEdoublegRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > > : new ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >;
   }
   static void *newArray_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >[nElements] : new ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlElonggRcOBoundedVerifierlEvectorlElonggRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > > : new ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >;
   }
   static void *newArray_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >[nElements] : new ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEunsignedsPlonggRcOBoundedVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > > : new ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >;
   }
   static void *newArray_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >[nElements] : new ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlELong64_tgRcOBoundedVerifierlEvectorlELong64_tgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > > : new ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >;
   }
   static void *newArray_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >[nElements] : new ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEULong64_tgRcOBoundedVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > > : new ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >;
   }
   static void *newArray_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >[nElements] : new ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEfloatgRcOBoundedVerifierlEvectorlEfloatgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > > : new ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >;
   }
   static void *newArray_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >[nElements] : new ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEdoublegRcOBoundedVerifierlEvectorlEdoublegRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > > : new ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >;
   }
   static void *newArray_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >[nElements] : new ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlElongsPdoublegRcOBoundedVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > > : new ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >;
   }
   static void *newArray_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >[nElements] : new ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEstringgRcOBoundedVerifierlEvectorlEstringgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > > : new ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >;
   }
   static void *newArray_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >[nElements] : new ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >*)p);
   }
   static void deleteArray_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >*)p);
   }
   static void destruct_SimplePropertylEpairlEintcOintgRcOBoundedVerifierlEpairlEintcOintgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > > : new ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >;
   }
   static void *newArray_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >[nElements] : new ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >*)p);
   }
   static void deleteArray_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >*)p);
   }
   static void destruct_SimplePropertylEpairlEdoublecOdoublegRcOBoundedVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > > : new ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >;
   }
   static void *newArray_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >[nElements] : new ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEpairlEdoublecOdoublegRsPgRcOBoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > > : new ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >;
   }
   static void *newArray_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >[nElements] : new ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEvectorlEstringgRsPgRcOBoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > > : new ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >;
   }
   static void *newArray_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >[nElements] : new ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEvectorlEdoublegRsPgRcOBoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > > : new ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >;
   }
   static void *newArray_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >[nElements] : new ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >*)p);
   }
   static void deleteArray_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >*)p);
   }
   static void destruct_SimplePropertylEmaplEintcOdoublegRcOBoundedVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > > : new ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >;
   }
   static void *newArray_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >[nElements] : new ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >*)p);
   }
   static void deleteArray_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >*)p);
   }
   static void destruct_SimplePropertylEmaplEstringcOstringgRcOBoundedVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > > : new ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >;
   }
   static void *newArray_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >[nElements] : new ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >*)p);
   }
   static void deleteArray_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >*)p);
   }
   static void destruct_SimplePropertylEmaplEstringcOintgRcOBoundedVerifierlEmaplEstringcOintgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > > : new ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >;
   }
   static void *newArray_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >[nElements] : new ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >*)p);
   }
   static void deleteArray_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >*)p);
   }
   static void destruct_SimplePropertylEmaplEstringcOdoublegRcOBoundedVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > > : new ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >;
   }
   static void *newArray_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >[nElements] : new ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)p);
   }
   static void deleteArray_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >*)p);
   }
   static void destruct_SimplePropertylEmaplEstringcOvectorlEstringgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > > : new ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >;
   }
   static void *newArray_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >[nElements] : new ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)p);
   }
   static void deleteArray_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >*)p);
   }
   static void destruct_SimplePropertylEmaplEstringcOvectorlEintgRsPgRcOBoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<bool,BoundedVerifier<bool> > : new ::SimpleProperty<bool,BoundedVerifier<bool> >;
   }
   static void *newArray_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<bool,BoundedVerifier<bool> >[nElements] : new ::SimpleProperty<bool,BoundedVerifier<bool> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p) {
      delete ((::SimpleProperty<bool,BoundedVerifier<bool> >*)p);
   }
   static void deleteArray_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p) {
      delete [] ((::SimpleProperty<bool,BoundedVerifier<bool> >*)p);
   }
   static void destruct_SimplePropertylEboolcOBoundedVerifierlEboolgRsPgR(void *p) {
      typedef ::SimpleProperty<bool,BoundedVerifier<bool> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<bool,BoundedVerifier<bool> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> > : new ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >;
   }
   static void *newArray_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >[nElements] : new ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p) {
      delete ((::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >*)p);
   }
   static void deleteArray_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p) {
      delete [] ((::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >*)p);
   }
   static void destruct_SimplePropertylEULong64_tcOBoundedVerifierlEULong64_tgRsPgR(void *p) {
      typedef ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<char,BoundedVerifier<char> > : new ::SimpleProperty<char,BoundedVerifier<char> >;
   }
   static void *newArray_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<char,BoundedVerifier<char> >[nElements] : new ::SimpleProperty<char,BoundedVerifier<char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p) {
      delete ((::SimpleProperty<char,BoundedVerifier<char> >*)p);
   }
   static void deleteArray_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p) {
      delete [] ((::SimpleProperty<char,BoundedVerifier<char> >*)p);
   }
   static void destruct_SimplePropertylEcharcOBoundedVerifierlEchargRsPgR(void *p) {
      typedef ::SimpleProperty<char,BoundedVerifier<char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<char,BoundedVerifier<char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<signed char,BoundedVerifier<signed char> > : new ::SimpleProperty<signed char,BoundedVerifier<signed char> >;
   }
   static void *newArray_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<signed char,BoundedVerifier<signed char> >[nElements] : new ::SimpleProperty<signed char,BoundedVerifier<signed char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p) {
      delete ((::SimpleProperty<signed char,BoundedVerifier<signed char> >*)p);
   }
   static void deleteArray_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p) {
      delete [] ((::SimpleProperty<signed char,BoundedVerifier<signed char> >*)p);
   }
   static void destruct_SimplePropertylEsignedsPcharcOBoundedVerifierlEsignedsPchargRsPgR(void *p) {
      typedef ::SimpleProperty<signed char,BoundedVerifier<signed char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<signed char,BoundedVerifier<signed char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> > : new ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >;
   }
   static void *newArray_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >[nElements] : new ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p) {
      delete ((::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >*)p);
   }
   static void deleteArray_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p) {
      delete [] ((::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >*)p);
   }
   static void destruct_SimplePropertylEunsignedsPcharcOBoundedVerifierlEunsignedsPchargRsPgR(void *p) {
      typedef ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<short,BoundedVerifier<short> > : new ::SimpleProperty<short,BoundedVerifier<short> >;
   }
   static void *newArray_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<short,BoundedVerifier<short> >[nElements] : new ::SimpleProperty<short,BoundedVerifier<short> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p) {
      delete ((::SimpleProperty<short,BoundedVerifier<short> >*)p);
   }
   static void deleteArray_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p) {
      delete [] ((::SimpleProperty<short,BoundedVerifier<short> >*)p);
   }
   static void destruct_SimplePropertylEshortcOBoundedVerifierlEshortgRsPgR(void *p) {
      typedef ::SimpleProperty<short,BoundedVerifier<short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<short,BoundedVerifier<short> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> > : new ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >;
   }
   static void *newArray_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >[nElements] : new ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p) {
      delete ((::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >*)p);
   }
   static void deleteArray_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p) {
      delete [] ((::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >*)p);
   }
   static void destruct_SimplePropertylEunsignedsPshortcOBoundedVerifierlEunsignedsPshortgRsPgR(void *p) {
      typedef ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<int,BoundedVerifier<int> > : new ::SimpleProperty<int,BoundedVerifier<int> >;
   }
   static void *newArray_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<int,BoundedVerifier<int> >[nElements] : new ::SimpleProperty<int,BoundedVerifier<int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p) {
      delete ((::SimpleProperty<int,BoundedVerifier<int> >*)p);
   }
   static void deleteArray_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p) {
      delete [] ((::SimpleProperty<int,BoundedVerifier<int> >*)p);
   }
   static void destruct_SimplePropertylEintcOBoundedVerifierlEintgRsPgR(void *p) {
      typedef ::SimpleProperty<int,BoundedVerifier<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<int,BoundedVerifier<int> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> > : new ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >;
   }
   static void *newArray_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >[nElements] : new ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p) {
      delete ((::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >*)p);
   }
   static void deleteArray_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p) {
      delete [] ((::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >*)p);
   }
   static void destruct_SimplePropertylEunsignedsPintcOBoundedVerifierlEunsignedsPintgRsPgR(void *p) {
      typedef ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<long,BoundedVerifier<long> > : new ::SimpleProperty<long,BoundedVerifier<long> >;
   }
   static void *newArray_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<long,BoundedVerifier<long> >[nElements] : new ::SimpleProperty<long,BoundedVerifier<long> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p) {
      delete ((::SimpleProperty<long,BoundedVerifier<long> >*)p);
   }
   static void deleteArray_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p) {
      delete [] ((::SimpleProperty<long,BoundedVerifier<long> >*)p);
   }
   static void destruct_SimplePropertylElongcOBoundedVerifierlElonggRsPgR(void *p) {
      typedef ::SimpleProperty<long,BoundedVerifier<long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<long,BoundedVerifier<long> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> > : new ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >;
   }
   static void *newArray_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >[nElements] : new ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p) {
      delete ((::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >*)p);
   }
   static void deleteArray_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p) {
      delete [] ((::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >*)p);
   }
   static void destruct_SimplePropertylEunsignedsPlongcOBoundedVerifierlEunsignedsPlonggRsPgR(void *p) {
      typedef ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> > : new ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >;
   }
   static void *newArray_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >[nElements] : new ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p) {
      delete ((::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >*)p);
   }
   static void deleteArray_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p) {
      delete [] ((::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >*)p);
   }
   static void destruct_SimplePropertylELong64_tcOBoundedVerifierlELong64_tgRsPgR(void *p) {
      typedef ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > > : new ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >;
   }
   static void *newArray_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >[nElements] : new ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEintgRcOBoundedVerifierlEvectorlEintgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<float,BoundedVerifier<float> > : new ::SimpleProperty<float,BoundedVerifier<float> >;
   }
   static void *newArray_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<float,BoundedVerifier<float> >[nElements] : new ::SimpleProperty<float,BoundedVerifier<float> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p) {
      delete ((::SimpleProperty<float,BoundedVerifier<float> >*)p);
   }
   static void deleteArray_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p) {
      delete [] ((::SimpleProperty<float,BoundedVerifier<float> >*)p);
   }
   static void destruct_SimplePropertylEfloatcOBoundedVerifierlEfloatgRsPgR(void *p) {
      typedef ::SimpleProperty<float,BoundedVerifier<float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<float,BoundedVerifier<float> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<double,BoundedVerifier<double> > : new ::SimpleProperty<double,BoundedVerifier<double> >;
   }
   static void *newArray_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<double,BoundedVerifier<double> >[nElements] : new ::SimpleProperty<double,BoundedVerifier<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p) {
      delete ((::SimpleProperty<double,BoundedVerifier<double> >*)p);
   }
   static void deleteArray_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p) {
      delete [] ((::SimpleProperty<double,BoundedVerifier<double> >*)p);
   }
   static void destruct_SimplePropertylEdoublecOBoundedVerifierlEdoublegRsPgR(void *p) {
      typedef ::SimpleProperty<double,BoundedVerifier<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<double,BoundedVerifier<double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<long double,BoundedVerifier<long double> > : new ::SimpleProperty<long double,BoundedVerifier<long double> >;
   }
   static void *newArray_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<long double,BoundedVerifier<long double> >[nElements] : new ::SimpleProperty<long double,BoundedVerifier<long double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p) {
      delete ((::SimpleProperty<long double,BoundedVerifier<long double> >*)p);
   }
   static void deleteArray_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p) {
      delete [] ((::SimpleProperty<long double,BoundedVerifier<long double> >*)p);
   }
   static void destruct_SimplePropertylElongsPdoublecOBoundedVerifierlElongsPdoublegRsPgR(void *p) {
      typedef ::SimpleProperty<long double,BoundedVerifier<long double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<long double,BoundedVerifier<long double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<string,BoundedVerifier<string> > : new ::SimpleProperty<string,BoundedVerifier<string> >;
   }
   static void *newArray_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<string,BoundedVerifier<string> >[nElements] : new ::SimpleProperty<string,BoundedVerifier<string> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p) {
      delete ((::SimpleProperty<string,BoundedVerifier<string> >*)p);
   }
   static void deleteArray_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p) {
      delete [] ((::SimpleProperty<string,BoundedVerifier<string> >*)p);
   }
   static void destruct_SimplePropertylEstringcOBoundedVerifierlEstringgRsPgR(void *p) {
      typedef ::SimpleProperty<string,BoundedVerifier<string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<string,BoundedVerifier<string> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > > : new ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >;
   }
   static void *newArray_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >[nElements] : new ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEboolgRcOBoundedVerifierlEvectorlEboolgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > > : new ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >;
   }
   static void *newArray_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >[nElements] : new ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEchargRcOBoundedVerifierlEvectorlEchargRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > > : new ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >;
   }
   static void *newArray_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >[nElements] : new ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEsignedsPchargRcOBoundedVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > > : new ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >;
   }
   static void *newArray_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >[nElements] : new ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEunsignedsPchargRcOBoundedVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > > : new ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >;
   }
   static void *newArray_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >[nElements] : new ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEshortgRcOBoundedVerifierlEvectorlEshortgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p) {
      return  p ? new(p) ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > > : new ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >;
   }
   static void *newArray_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >[nElements] : new ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p) {
      delete ((::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)p);
   }
   static void deleteArray_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p) {
      delete [] ((::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >*)p);
   }
   static void destruct_SimplePropertylEvectorlEunsignedsPshortgRcOBoundedVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p) {
      typedef ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR(void *p) {
      delete ((::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >*)p);
   }
   static void deleteArray_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >*)p);
   }
   static void destruct_SimplePropertyReflELong64_tcONullVerifierlELong64_tgRsPgR(void *p) {
      typedef ::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEshortgRcONullVerifierlEvectorlEshortgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEunsignedsPchargRcONullVerifierlEvectorlEunsignedsPchargRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEsignedsPchargRcONullVerifierlEvectorlEsignedsPchargRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEchargRcONullVerifierlEvectorlEchargRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEboolgRcONullVerifierlEvectorlEboolgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR(void *p) {
      delete ((::SimplePropertyRef<string,NullVerifier<string> >*)p);
   }
   static void deleteArray_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<string,NullVerifier<string> >*)p);
   }
   static void destruct_SimplePropertyReflEstringcONullVerifierlEstringgRsPgR(void *p) {
      typedef ::SimplePropertyRef<string,NullVerifier<string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<string,NullVerifier<string> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR(void *p) {
      delete ((::SimplePropertyRef<long double,NullVerifier<long double> >*)p);
   }
   static void deleteArray_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<long double,NullVerifier<long double> >*)p);
   }
   static void destruct_SimplePropertyReflElongsPdoublecONullVerifierlElongsPdoublegRsPgR(void *p) {
      typedef ::SimplePropertyRef<long double,NullVerifier<long double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<long double,NullVerifier<long double> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR(void *p) {
      delete ((::SimplePropertyRef<double,NullVerifier<double> >*)p);
   }
   static void deleteArray_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<double,NullVerifier<double> >*)p);
   }
   static void destruct_SimplePropertyReflEdoublecONullVerifierlEdoublegRsPgR(void *p) {
      typedef ::SimplePropertyRef<double,NullVerifier<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<double,NullVerifier<double> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR(void *p) {
      delete ((::SimplePropertyRef<float,NullVerifier<float> >*)p);
   }
   static void deleteArray_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<float,NullVerifier<float> >*)p);
   }
   static void destruct_SimplePropertyReflEfloatcONullVerifierlEfloatgRsPgR(void *p) {
      typedef ::SimplePropertyRef<float,NullVerifier<float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<float,NullVerifier<float> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR(void *p) {
      delete ((::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >*)p);
   }
   static void deleteArray_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >*)p);
   }
   static void destruct_SimplePropertyReflEULong64_tcONullVerifierlEULong64_tgRsPgR(void *p) {
      typedef ::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEunsignedsPshortgRcONullVerifierlEvectorlEunsignedsPshortgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR(void *p) {
      delete ((::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >*)p);
   }
   static void deleteArray_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >*)p);
   }
   static void destruct_SimplePropertyReflEunsignedsPlongcONullVerifierlEunsignedsPlonggRsPgR(void *p) {
      typedef ::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflElongcONullVerifierlElonggRsPgR(void *p) {
      delete ((::SimplePropertyRef<long,NullVerifier<long> >*)p);
   }
   static void deleteArray_SimplePropertyReflElongcONullVerifierlElonggRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<long,NullVerifier<long> >*)p);
   }
   static void destruct_SimplePropertyReflElongcONullVerifierlElonggRsPgR(void *p) {
      typedef ::SimplePropertyRef<long,NullVerifier<long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<long,NullVerifier<long> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR(void *p) {
      delete ((::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >*)p);
   }
   static void deleteArray_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >*)p);
   }
   static void destruct_SimplePropertyReflEunsignedsPintcONullVerifierlEunsignedsPintgRsPgR(void *p) {
      typedef ::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEintcONullVerifierlEintgRsPgR(void *p) {
      delete ((::SimplePropertyRef<int,NullVerifier<int> >*)p);
   }
   static void deleteArray_SimplePropertyReflEintcONullVerifierlEintgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<int,NullVerifier<int> >*)p);
   }
   static void destruct_SimplePropertyReflEintcONullVerifierlEintgRsPgR(void *p) {
      typedef ::SimplePropertyRef<int,NullVerifier<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<int,NullVerifier<int> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR(void *p) {
      delete ((::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >*)p);
   }
   static void deleteArray_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >*)p);
   }
   static void destruct_SimplePropertyReflEunsignedsPshortcONullVerifierlEunsignedsPshortgRsPgR(void *p) {
      typedef ::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR(void *p) {
      delete ((::SimplePropertyRef<short,NullVerifier<short> >*)p);
   }
   static void deleteArray_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<short,NullVerifier<short> >*)p);
   }
   static void destruct_SimplePropertyReflEshortcONullVerifierlEshortgRsPgR(void *p) {
      typedef ::SimplePropertyRef<short,NullVerifier<short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<short,NullVerifier<short> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR(void *p) {
      delete ((::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >*)p);
   }
   static void deleteArray_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >*)p);
   }
   static void destruct_SimplePropertyReflEunsignedsPcharcONullVerifierlEunsignedsPchargRsPgR(void *p) {
      typedef ::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR(void *p) {
      delete ((::SimplePropertyRef<signed char,NullVerifier<signed char> >*)p);
   }
   static void deleteArray_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<signed char,NullVerifier<signed char> >*)p);
   }
   static void destruct_SimplePropertyReflEsignedsPcharcONullVerifierlEsignedsPchargRsPgR(void *p) {
      typedef ::SimplePropertyRef<signed char,NullVerifier<signed char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<signed char,NullVerifier<signed char> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEcharcONullVerifierlEchargRsPgR(void *p) {
      delete ((::SimplePropertyRef<char,NullVerifier<char> >*)p);
   }
   static void deleteArray_SimplePropertyReflEcharcONullVerifierlEchargRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<char,NullVerifier<char> >*)p);
   }
   static void destruct_SimplePropertyReflEcharcONullVerifierlEchargRsPgR(void *p) {
      typedef ::SimplePropertyRef<char,NullVerifier<char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<char,NullVerifier<char> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR(void *p) {
      delete ((::SimplePropertyRef<bool,NullVerifier<bool> >*)p);
   }
   static void deleteArray_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<bool,NullVerifier<bool> >*)p);
   }
   static void destruct_SimplePropertyReflEboolcONullVerifierlEboolgRsPgR(void *p) {
      typedef ::SimplePropertyRef<bool,NullVerifier<bool> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<bool,NullVerifier<bool> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >*)p);
   }
   static void destruct_SimplePropertyReflEpairlEdoublecOdoublegRcONullVerifierlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)p);
   }
   static void deleteArray_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >*)p);
   }
   static void destruct_SimplePropertyReflEmaplEstringcOvectorlEdoublegRsPgRcONullVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)p);
   }
   static void deleteArray_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >*)p);
   }
   static void destruct_SimplePropertyReflEmaplEstringcOvectorlEintgRsPgRcONullVerifierlEmaplEstringcOvectorlEintgRsPgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)p);
   }
   static void deleteArray_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >*)p);
   }
   static void destruct_SimplePropertyReflEmaplEstringcOvectorlEstringgRsPgRcONullVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >*)p);
   }
   static void destruct_SimplePropertyReflEmaplEstringcOdoublegRcONullVerifierlEmaplEstringcOdoublegRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >*)p);
   }
   static void destruct_SimplePropertyReflEmaplEstringcOintgRcONullVerifierlEmaplEstringcOintgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >*)p);
   }
   static void destruct_SimplePropertyReflEmaplEstringcOstringgRcONullVerifierlEmaplEstringcOstringgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >*)p);
   }
   static void destruct_SimplePropertyReflEmaplEintcOdoublegRcONullVerifierlEmaplEintcOdoublegRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEvectorlEdoublegRsPgRcONullVerifierlEvectorlEvectorlEdoublegRsPgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEvectorlEstringgRsPgRcONullVerifierlEvectorlEvectorlEstringgRsPgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEpairlEdoublecOdoublegRsPgRcONullVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEintgRcONullVerifierlEvectorlEintgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >*)p);
   }
   static void destruct_SimplePropertyReflEpairlEintcOintgRcONullVerifierlEpairlEintcOintgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEstringgRcONullVerifierlEvectorlEstringgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlElongsPdoublegRcONullVerifierlEvectorlElongsPdoublegRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEdoublegRcONullVerifierlEvectorlEdoublegRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEfloatgRcONullVerifierlEvectorlEfloatgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEULong64_tgRcONullVerifierlEvectorlEULong64_tgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlELong64_tgRcONullVerifierlEvectorlELong64_tgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEunsignedsPlonggRcONullVerifierlEvectorlEunsignedsPlonggRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlElonggRcONullVerifierlEvectorlElonggRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete ((::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)p);
   }
   static void deleteArray_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete [] ((::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >*)p);
   }
   static void destruct_SimplePropertyReflEvectorlEunsignedsPintgRcONullVerifierlEvectorlEunsignedsPintgRsPgRsPgR(void *p) {
      typedef ::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEboolgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<bool> : new ::BoundedVerifier<bool>;
   }
   static void *newArray_BoundedVerifierlEboolgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<bool>[nElements] : new ::BoundedVerifier<bool>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEboolgR(void *p) {
      delete ((::BoundedVerifier<bool>*)p);
   }
   static void deleteArray_BoundedVerifierlEboolgR(void *p) {
      delete [] ((::BoundedVerifier<bool>*)p);
   }
   static void destruct_BoundedVerifierlEboolgR(void *p) {
      typedef ::BoundedVerifier<bool> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<bool>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEsignedsPchargR(void *p) {
      return  p ? new(p) ::BoundedVerifier<signed char> : new ::BoundedVerifier<signed char>;
   }
   static void *newArray_BoundedVerifierlEsignedsPchargR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<signed char>[nElements] : new ::BoundedVerifier<signed char>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEsignedsPchargR(void *p) {
      delete ((::BoundedVerifier<signed char>*)p);
   }
   static void deleteArray_BoundedVerifierlEsignedsPchargR(void *p) {
      delete [] ((::BoundedVerifier<signed char>*)p);
   }
   static void destruct_BoundedVerifierlEsignedsPchargR(void *p) {
      typedef ::BoundedVerifier<signed char> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<signed char>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEfloatgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<float> : new ::BoundedVerifier<float>;
   }
   static void *newArray_BoundedVerifierlEfloatgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<float>[nElements] : new ::BoundedVerifier<float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEfloatgR(void *p) {
      delete ((::BoundedVerifier<float>*)p);
   }
   static void deleteArray_BoundedVerifierlEfloatgR(void *p) {
      delete [] ((::BoundedVerifier<float>*)p);
   }
   static void destruct_BoundedVerifierlEfloatgR(void *p) {
      typedef ::BoundedVerifier<float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<float>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEintgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<int> > : new ::BoundedVerifier<vector<int> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEintgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<int> >[nElements] : new ::BoundedVerifier<vector<int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEintgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<int> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEintgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<int> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEintgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<int> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<unsigned short> > : new ::BoundedVerifier<vector<unsigned short> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<unsigned short> >[nElements] : new ::BoundedVerifier<vector<unsigned short> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<unsigned short> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<unsigned short> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEunsignedsPshortgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<unsigned short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<unsigned short> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEshortgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<short> > : new ::BoundedVerifier<vector<short> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEshortgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<short> >[nElements] : new ::BoundedVerifier<vector<short> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEshortgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<short> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEshortgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<short> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEshortgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<short> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<unsigned char> > : new ::BoundedVerifier<vector<unsigned char> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<unsigned char> >[nElements] : new ::BoundedVerifier<vector<unsigned char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<unsigned char> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<unsigned char> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEunsignedsPchargRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<unsigned char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<unsigned char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<signed char> > : new ::BoundedVerifier<vector<signed char> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEsignedsPchargRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<signed char> >[nElements] : new ::BoundedVerifier<vector<signed char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<signed char> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<signed char> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEsignedsPchargRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<signed char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<signed char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEchargRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<char> > : new ::BoundedVerifier<vector<char> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEchargRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<char> >[nElements] : new ::BoundedVerifier<vector<char> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEchargRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<char> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEchargRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<char> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEchargRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<char> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEboolgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<bool> > : new ::BoundedVerifier<vector<bool> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEboolgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<bool> >[nElements] : new ::BoundedVerifier<vector<bool> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEboolgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<bool> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEboolgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<bool> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEboolgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<bool> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<bool> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEstringgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<string> : new ::BoundedVerifier<string>;
   }
   static void *newArray_BoundedVerifierlEstringgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<string>[nElements] : new ::BoundedVerifier<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEstringgR(void *p) {
      delete ((::BoundedVerifier<string>*)p);
   }
   static void deleteArray_BoundedVerifierlEstringgR(void *p) {
      delete [] ((::BoundedVerifier<string>*)p);
   }
   static void destruct_BoundedVerifierlEstringgR(void *p) {
      typedef ::BoundedVerifier<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<string>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlElongsPdoublegR(void *p) {
      return  p ? new(p) ::BoundedVerifier<long double> : new ::BoundedVerifier<long double>;
   }
   static void *newArray_BoundedVerifierlElongsPdoublegR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<long double>[nElements] : new ::BoundedVerifier<long double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlElongsPdoublegR(void *p) {
      delete ((::BoundedVerifier<long double>*)p);
   }
   static void deleteArray_BoundedVerifierlElongsPdoublegR(void *p) {
      delete [] ((::BoundedVerifier<long double>*)p);
   }
   static void destruct_BoundedVerifierlElongsPdoublegR(void *p) {
      typedef ::BoundedVerifier<long double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<long double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEdoublegR(void *p) {
      return  p ? new(p) ::BoundedVerifier<double> : new ::BoundedVerifier<double>;
   }
   static void *newArray_BoundedVerifierlEdoublegR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<double>[nElements] : new ::BoundedVerifier<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEdoublegR(void *p) {
      delete ((::BoundedVerifier<double>*)p);
   }
   static void deleteArray_BoundedVerifierlEdoublegR(void *p) {
      delete [] ((::BoundedVerifier<double>*)p);
   }
   static void destruct_BoundedVerifierlEdoublegR(void *p) {
      typedef ::BoundedVerifier<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<double>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<map<string,vector<int> > > : new ::BoundedVerifier<map<string,vector<int> > >;
   }
   static void *newArray_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<map<string,vector<int> > >[nElements] : new ::BoundedVerifier<map<string,vector<int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p) {
      delete ((::BoundedVerifier<map<string,vector<int> > >*)p);
   }
   static void deleteArray_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<map<string,vector<int> > >*)p);
   }
   static void destruct_BoundedVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p) {
      typedef ::BoundedVerifier<map<string,vector<int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<map<string,vector<int> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEULong64_tgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<ULong64_t> : new ::BoundedVerifier<ULong64_t>;
   }
   static void *newArray_BoundedVerifierlEULong64_tgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<ULong64_t>[nElements] : new ::BoundedVerifier<ULong64_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEULong64_tgR(void *p) {
      delete ((::BoundedVerifier<ULong64_t>*)p);
   }
   static void deleteArray_BoundedVerifierlEULong64_tgR(void *p) {
      delete [] ((::BoundedVerifier<ULong64_t>*)p);
   }
   static void destruct_BoundedVerifierlEULong64_tgR(void *p) {
      typedef ::BoundedVerifier<ULong64_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<ULong64_t>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlELong64_tgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<Long64_t> : new ::BoundedVerifier<Long64_t>;
   }
   static void *newArray_BoundedVerifierlELong64_tgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<Long64_t>[nElements] : new ::BoundedVerifier<Long64_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlELong64_tgR(void *p) {
      delete ((::BoundedVerifier<Long64_t>*)p);
   }
   static void deleteArray_BoundedVerifierlELong64_tgR(void *p) {
      delete [] ((::BoundedVerifier<Long64_t>*)p);
   }
   static void destruct_BoundedVerifierlELong64_tgR(void *p) {
      typedef ::BoundedVerifier<Long64_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<Long64_t>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEunsignedsPlonggR(void *p) {
      return  p ? new(p) ::BoundedVerifier<unsigned long> : new ::BoundedVerifier<unsigned long>;
   }
   static void *newArray_BoundedVerifierlEunsignedsPlonggR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<unsigned long>[nElements] : new ::BoundedVerifier<unsigned long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEunsignedsPlonggR(void *p) {
      delete ((::BoundedVerifier<unsigned long>*)p);
   }
   static void deleteArray_BoundedVerifierlEunsignedsPlonggR(void *p) {
      delete [] ((::BoundedVerifier<unsigned long>*)p);
   }
   static void destruct_BoundedVerifierlEunsignedsPlonggR(void *p) {
      typedef ::BoundedVerifier<unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<unsigned long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlElonggR(void *p) {
      return  p ? new(p) ::BoundedVerifier<long> : new ::BoundedVerifier<long>;
   }
   static void *newArray_BoundedVerifierlElonggR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<long>[nElements] : new ::BoundedVerifier<long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlElonggR(void *p) {
      delete ((::BoundedVerifier<long>*)p);
   }
   static void deleteArray_BoundedVerifierlElonggR(void *p) {
      delete [] ((::BoundedVerifier<long>*)p);
   }
   static void destruct_BoundedVerifierlElonggR(void *p) {
      typedef ::BoundedVerifier<long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<long>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEunsignedsPintgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<unsigned int> : new ::BoundedVerifier<unsigned int>;
   }
   static void *newArray_BoundedVerifierlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<unsigned int>[nElements] : new ::BoundedVerifier<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEunsignedsPintgR(void *p) {
      delete ((::BoundedVerifier<unsigned int>*)p);
   }
   static void deleteArray_BoundedVerifierlEunsignedsPintgR(void *p) {
      delete [] ((::BoundedVerifier<unsigned int>*)p);
   }
   static void destruct_BoundedVerifierlEunsignedsPintgR(void *p) {
      typedef ::BoundedVerifier<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<unsigned int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEintgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<int> : new ::BoundedVerifier<int>;
   }
   static void *newArray_BoundedVerifierlEintgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<int>[nElements] : new ::BoundedVerifier<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEintgR(void *p) {
      delete ((::BoundedVerifier<int>*)p);
   }
   static void deleteArray_BoundedVerifierlEintgR(void *p) {
      delete [] ((::BoundedVerifier<int>*)p);
   }
   static void destruct_BoundedVerifierlEintgR(void *p) {
      typedef ::BoundedVerifier<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<int>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEunsignedsPshortgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<unsigned short> : new ::BoundedVerifier<unsigned short>;
   }
   static void *newArray_BoundedVerifierlEunsignedsPshortgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<unsigned short>[nElements] : new ::BoundedVerifier<unsigned short>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEunsignedsPshortgR(void *p) {
      delete ((::BoundedVerifier<unsigned short>*)p);
   }
   static void deleteArray_BoundedVerifierlEunsignedsPshortgR(void *p) {
      delete [] ((::BoundedVerifier<unsigned short>*)p);
   }
   static void destruct_BoundedVerifierlEunsignedsPshortgR(void *p) {
      typedef ::BoundedVerifier<unsigned short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<unsigned short>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEshortgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<short> : new ::BoundedVerifier<short>;
   }
   static void *newArray_BoundedVerifierlEshortgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<short>[nElements] : new ::BoundedVerifier<short>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEshortgR(void *p) {
      delete ((::BoundedVerifier<short>*)p);
   }
   static void deleteArray_BoundedVerifierlEshortgR(void *p) {
      delete [] ((::BoundedVerifier<short>*)p);
   }
   static void destruct_BoundedVerifierlEshortgR(void *p) {
      typedef ::BoundedVerifier<short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<short>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEunsignedsPchargR(void *p) {
      return  p ? new(p) ::BoundedVerifier<unsigned char> : new ::BoundedVerifier<unsigned char>;
   }
   static void *newArray_BoundedVerifierlEunsignedsPchargR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<unsigned char>[nElements] : new ::BoundedVerifier<unsigned char>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEunsignedsPchargR(void *p) {
      delete ((::BoundedVerifier<unsigned char>*)p);
   }
   static void deleteArray_BoundedVerifierlEunsignedsPchargR(void *p) {
      delete [] ((::BoundedVerifier<unsigned char>*)p);
   }
   static void destruct_BoundedVerifierlEunsignedsPchargR(void *p) {
      typedef ::BoundedVerifier<unsigned char> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<unsigned char>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEchargR(void *p) {
      return  p ? new(p) ::BoundedVerifier<char> : new ::BoundedVerifier<char>;
   }
   static void *newArray_BoundedVerifierlEchargR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<char>[nElements] : new ::BoundedVerifier<char>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEchargR(void *p) {
      delete ((::BoundedVerifier<char>*)p);
   }
   static void deleteArray_BoundedVerifierlEchargR(void *p) {
      delete [] ((::BoundedVerifier<char>*)p);
   }
   static void destruct_BoundedVerifierlEchargR(void *p) {
      typedef ::BoundedVerifier<char> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<char>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlElonggRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<long> > : new ::BoundedVerifier<vector<long> >;
   }
   static void *newArray_BoundedVerifierlEvectorlElonggRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<long> >[nElements] : new ::BoundedVerifier<vector<long> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlElonggRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<long> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlElonggRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<long> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlElonggRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<long> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<map<string,vector<double> > > : new ::BoundedVerifier<map<string,vector<double> > >;
   }
   static void *newArray_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<map<string,vector<double> > >[nElements] : new ::BoundedVerifier<map<string,vector<double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p) {
      delete ((::BoundedVerifier<map<string,vector<double> > >*)p);
   }
   static void deleteArray_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<map<string,vector<double> > >*)p);
   }
   static void destruct_BoundedVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p) {
      typedef ::BoundedVerifier<map<string,vector<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<map<string,vector<double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<map<string,vector<string> > > : new ::BoundedVerifier<map<string,vector<string> > >;
   }
   static void *newArray_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<map<string,vector<string> > >[nElements] : new ::BoundedVerifier<map<string,vector<string> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p) {
      delete ((::BoundedVerifier<map<string,vector<string> > >*)p);
   }
   static void deleteArray_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<map<string,vector<string> > >*)p);
   }
   static void destruct_BoundedVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p) {
      typedef ::BoundedVerifier<map<string,vector<string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<map<string,vector<string> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<map<string,double> > : new ::BoundedVerifier<map<string,double> >;
   }
   static void *newArray_BoundedVerifierlEmaplEstringcOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<map<string,double> >[nElements] : new ::BoundedVerifier<map<string,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p) {
      delete ((::BoundedVerifier<map<string,double> >*)p);
   }
   static void deleteArray_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p) {
      delete [] ((::BoundedVerifier<map<string,double> >*)p);
   }
   static void destruct_BoundedVerifierlEmaplEstringcOdoublegRsPgR(void *p) {
      typedef ::BoundedVerifier<map<string,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<map<string,double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<map<string,int> > : new ::BoundedVerifier<map<string,int> >;
   }
   static void *newArray_BoundedVerifierlEmaplEstringcOintgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<map<string,int> >[nElements] : new ::BoundedVerifier<map<string,int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p) {
      delete ((::BoundedVerifier<map<string,int> >*)p);
   }
   static void deleteArray_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<map<string,int> >*)p);
   }
   static void destruct_BoundedVerifierlEmaplEstringcOintgRsPgR(void *p) {
      typedef ::BoundedVerifier<map<string,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<map<string,int> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<map<string,string> > : new ::BoundedVerifier<map<string,string> >;
   }
   static void *newArray_BoundedVerifierlEmaplEstringcOstringgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<map<string,string> >[nElements] : new ::BoundedVerifier<map<string,string> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p) {
      delete ((::BoundedVerifier<map<string,string> >*)p);
   }
   static void deleteArray_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<map<string,string> >*)p);
   }
   static void destruct_BoundedVerifierlEmaplEstringcOstringgRsPgR(void *p) {
      typedef ::BoundedVerifier<map<string,string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<map<string,string> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<map<int,double> > : new ::BoundedVerifier<map<int,double> >;
   }
   static void *newArray_BoundedVerifierlEmaplEintcOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<map<int,double> >[nElements] : new ::BoundedVerifier<map<int,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p) {
      delete ((::BoundedVerifier<map<int,double> >*)p);
   }
   static void deleteArray_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p) {
      delete [] ((::BoundedVerifier<map<int,double> >*)p);
   }
   static void destruct_BoundedVerifierlEmaplEintcOdoublegRsPgR(void *p) {
      typedef ::BoundedVerifier<map<int,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<map<int,double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<vector<double> > > : new ::BoundedVerifier<vector<vector<double> > >;
   }
   static void *newArray_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<vector<double> > >[nElements] : new ::BoundedVerifier<vector<vector<double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<vector<double> > >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<vector<double> > >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<vector<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<vector<double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<vector<string> > > : new ::BoundedVerifier<vector<vector<string> > >;
   }
   static void *newArray_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<vector<string> > >[nElements] : new ::BoundedVerifier<vector<vector<string> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<vector<string> > >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<vector<string> > >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<vector<string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<vector<string> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<pair<double,double> > > : new ::BoundedVerifier<vector<pair<double,double> > >;
   }
   static void *newArray_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<pair<double,double> > >[nElements] : new ::BoundedVerifier<vector<pair<double,double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<pair<double,double> > >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<pair<double,double> > >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<pair<double,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<pair<double,double> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<pair<double,double> > : new ::BoundedVerifier<pair<double,double> >;
   }
   static void *newArray_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<pair<double,double> >[nElements] : new ::BoundedVerifier<pair<double,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete ((::BoundedVerifier<pair<double,double> >*)p);
   }
   static void deleteArray_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete [] ((::BoundedVerifier<pair<double,double> >*)p);
   }
   static void destruct_BoundedVerifierlEpairlEdoublecOdoublegRsPgR(void *p) {
      typedef ::BoundedVerifier<pair<double,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<pair<double,double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEpairlEintcOintgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<pair<int,int> > : new ::BoundedVerifier<pair<int,int> >;
   }
   static void *newArray_BoundedVerifierlEpairlEintcOintgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<pair<int,int> >[nElements] : new ::BoundedVerifier<pair<int,int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEpairlEintcOintgRsPgR(void *p) {
      delete ((::BoundedVerifier<pair<int,int> >*)p);
   }
   static void deleteArray_BoundedVerifierlEpairlEintcOintgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<pair<int,int> >*)p);
   }
   static void destruct_BoundedVerifierlEpairlEintcOintgRsPgR(void *p) {
      typedef ::BoundedVerifier<pair<int,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<pair<int,int> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<Gaudi::Histo1DDef> : new ::BoundedVerifier<Gaudi::Histo1DDef>;
   }
   static void *newArray_BoundedVerifierlEGaudicLcLHisto1DDefgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<Gaudi::Histo1DDef>[nElements] : new ::BoundedVerifier<Gaudi::Histo1DDef>[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p) {
      delete ((::BoundedVerifier<Gaudi::Histo1DDef>*)p);
   }
   static void deleteArray_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p) {
      delete [] ((::BoundedVerifier<Gaudi::Histo1DDef>*)p);
   }
   static void destruct_BoundedVerifierlEGaudicLcLHisto1DDefgR(void *p) {
      typedef ::BoundedVerifier<Gaudi::Histo1DDef> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<Gaudi::Histo1DDef>

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEstringgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<string> > : new ::BoundedVerifier<vector<string> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEstringgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<string> >[nElements] : new ::BoundedVerifier<vector<string> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEstringgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<string> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEstringgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<string> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEstringgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<string> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<long double> > : new ::BoundedVerifier<vector<long double> >;
   }
   static void *newArray_BoundedVerifierlEvectorlElongsPdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<long double> >[nElements] : new ::BoundedVerifier<vector<long double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<long double> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<long double> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlElongsPdoublegRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<long double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<long double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEdoublegRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<double> > : new ::BoundedVerifier<vector<double> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<double> >[nElements] : new ::BoundedVerifier<vector<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEdoublegRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<double> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<double> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEdoublegRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<double> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEfloatgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<float> > : new ::BoundedVerifier<vector<float> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEfloatgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<float> >[nElements] : new ::BoundedVerifier<vector<float> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEfloatgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<float> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEfloatgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<float> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEfloatgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<float> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<ULong64_t> > : new ::BoundedVerifier<vector<ULong64_t> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEULong64_tgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<ULong64_t> >[nElements] : new ::BoundedVerifier<vector<ULong64_t> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<ULong64_t> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<ULong64_t> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEULong64_tgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<ULong64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<ULong64_t> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<Long64_t> > : new ::BoundedVerifier<vector<Long64_t> >;
   }
   static void *newArray_BoundedVerifierlEvectorlELong64_tgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<Long64_t> >[nElements] : new ::BoundedVerifier<vector<Long64_t> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<Long64_t> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<Long64_t> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlELong64_tgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<Long64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<Long64_t> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<unsigned long> > : new ::BoundedVerifier<vector<unsigned long> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<unsigned long> >[nElements] : new ::BoundedVerifier<vector<unsigned long> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<unsigned long> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<unsigned long> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEunsignedsPlonggRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<unsigned long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<unsigned long> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p) {
      return  p ? new(p) ::BoundedVerifier<vector<unsigned int> > : new ::BoundedVerifier<vector<unsigned int> >;
   }
   static void *newArray_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(Long_t nElements, void *p) {
      return p ? new(p) ::BoundedVerifier<vector<unsigned int> >[nElements] : new ::BoundedVerifier<vector<unsigned int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p) {
      delete ((::BoundedVerifier<vector<unsigned int> >*)p);
   }
   static void deleteArray_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p) {
      delete [] ((::BoundedVerifier<vector<unsigned int> >*)p);
   }
   static void destruct_BoundedVerifierlEvectorlEunsignedsPintgRsPgR(void *p) {
      typedef ::BoundedVerifier<vector<unsigned int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BoundedVerifier<vector<unsigned int> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEboolgR(void *p) {
      delete ((::PropertyVerifier<bool>*)p);
   }
   static void deleteArray_PropertyVerifierlEboolgR(void *p) {
      delete [] ((::PropertyVerifier<bool>*)p);
   }
   static void destruct_PropertyVerifierlEboolgR(void *p) {
      typedef ::PropertyVerifier<bool> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<bool>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEstringgR(void *p) {
      delete ((::PropertyVerifier<string>*)p);
   }
   static void deleteArray_PropertyVerifierlEstringgR(void *p) {
      delete [] ((::PropertyVerifier<string>*)p);
   }
   static void destruct_PropertyVerifierlEstringgR(void *p) {
      typedef ::PropertyVerifier<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<string>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlElonggRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<long> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlElonggRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<long> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlElonggRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<long> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEunsignedsPintgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<unsigned int> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPintgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<unsigned int> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEunsignedsPintgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<unsigned int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<unsigned int> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEintgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<int> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEintgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<int> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEintgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<int> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<unsigned short> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<unsigned short> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEunsignedsPshortgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<unsigned short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<unsigned short> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEshortgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<short> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEshortgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<short> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEshortgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<short> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<short> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEunsignedsPchargRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<unsigned char> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPchargRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<unsigned char> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEunsignedsPchargRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<unsigned char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<unsigned char> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEsignedsPchargRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<signed char> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEsignedsPchargRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<signed char> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEsignedsPchargRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<signed char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<signed char> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEchargRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<char> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEchargRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<char> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEchargRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<char> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<char> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEboolgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<bool> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEboolgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<bool> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEboolgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<bool> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<bool> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<unsigned long> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<unsigned long> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEunsignedsPlonggRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<unsigned long> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<unsigned long> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlElongsPdoublegR(void *p) {
      delete ((::PropertyVerifier<long double>*)p);
   }
   static void deleteArray_PropertyVerifierlElongsPdoublegR(void *p) {
      delete [] ((::PropertyVerifier<long double>*)p);
   }
   static void destruct_PropertyVerifierlElongsPdoublegR(void *p) {
      typedef ::PropertyVerifier<long double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<long double>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEdoublegR(void *p) {
      delete ((::PropertyVerifier<double>*)p);
   }
   static void deleteArray_PropertyVerifierlEdoublegR(void *p) {
      delete [] ((::PropertyVerifier<double>*)p);
   }
   static void destruct_PropertyVerifierlEdoublegR(void *p) {
      typedef ::PropertyVerifier<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<double>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEfloatgR(void *p) {
      delete ((::PropertyVerifier<float>*)p);
   }
   static void deleteArray_PropertyVerifierlEfloatgR(void *p) {
      delete [] ((::PropertyVerifier<float>*)p);
   }
   static void destruct_PropertyVerifierlEfloatgR(void *p) {
      typedef ::PropertyVerifier<float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<float>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEULong64_tgR(void *p) {
      delete ((::PropertyVerifier<ULong64_t>*)p);
   }
   static void deleteArray_PropertyVerifierlEULong64_tgR(void *p) {
      delete [] ((::PropertyVerifier<ULong64_t>*)p);
   }
   static void destruct_PropertyVerifierlEULong64_tgR(void *p) {
      typedef ::PropertyVerifier<ULong64_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<ULong64_t>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlELong64_tgR(void *p) {
      delete ((::PropertyVerifier<Long64_t>*)p);
   }
   static void deleteArray_PropertyVerifierlELong64_tgR(void *p) {
      delete [] ((::PropertyVerifier<Long64_t>*)p);
   }
   static void destruct_PropertyVerifierlELong64_tgR(void *p) {
      typedef ::PropertyVerifier<Long64_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<Long64_t>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEunsignedsPlonggR(void *p) {
      delete ((::PropertyVerifier<unsigned long>*)p);
   }
   static void deleteArray_PropertyVerifierlEunsignedsPlonggR(void *p) {
      delete [] ((::PropertyVerifier<unsigned long>*)p);
   }
   static void destruct_PropertyVerifierlEunsignedsPlonggR(void *p) {
      typedef ::PropertyVerifier<unsigned long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<unsigned long>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlElonggR(void *p) {
      delete ((::PropertyVerifier<long>*)p);
   }
   static void deleteArray_PropertyVerifierlElonggR(void *p) {
      delete [] ((::PropertyVerifier<long>*)p);
   }
   static void destruct_PropertyVerifierlElonggR(void *p) {
      typedef ::PropertyVerifier<long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<long>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEunsignedsPintgR(void *p) {
      delete ((::PropertyVerifier<unsigned int>*)p);
   }
   static void deleteArray_PropertyVerifierlEunsignedsPintgR(void *p) {
      delete [] ((::PropertyVerifier<unsigned int>*)p);
   }
   static void destruct_PropertyVerifierlEunsignedsPintgR(void *p) {
      typedef ::PropertyVerifier<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<unsigned int>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEunsignedsPshortgR(void *p) {
      delete ((::PropertyVerifier<unsigned short>*)p);
   }
   static void deleteArray_PropertyVerifierlEunsignedsPshortgR(void *p) {
      delete [] ((::PropertyVerifier<unsigned short>*)p);
   }
   static void destruct_PropertyVerifierlEunsignedsPshortgR(void *p) {
      typedef ::PropertyVerifier<unsigned short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<unsigned short>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<pair<double,double> > >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<pair<double,double> > >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEpairlEdoublecOdoublegRsPgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<pair<double,double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<pair<double,double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p) {
      delete ((::PropertyVerifier<map<string,vector<double> > >*)p);
   }
   static void deleteArray_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<map<string,vector<double> > >*)p);
   }
   static void destruct_PropertyVerifierlEmaplEstringcOvectorlEdoublegRsPgRsPgR(void *p) {
      typedef ::PropertyVerifier<map<string,vector<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<map<string,vector<double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p) {
      delete ((::PropertyVerifier<map<string,vector<int> > >*)p);
   }
   static void deleteArray_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<map<string,vector<int> > >*)p);
   }
   static void destruct_PropertyVerifierlEmaplEstringcOvectorlEintgRsPgRsPgR(void *p) {
      typedef ::PropertyVerifier<map<string,vector<int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<map<string,vector<int> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p) {
      delete ((::PropertyVerifier<map<string,vector<string> > >*)p);
   }
   static void deleteArray_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<map<string,vector<string> > >*)p);
   }
   static void destruct_PropertyVerifierlEmaplEstringcOvectorlEstringgRsPgRsPgR(void *p) {
      typedef ::PropertyVerifier<map<string,vector<string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<map<string,vector<string> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEmaplEstringcOdoublegRsPgR(void *p) {
      delete ((::PropertyVerifier<map<string,double> >*)p);
   }
   static void deleteArray_PropertyVerifierlEmaplEstringcOdoublegRsPgR(void *p) {
      delete [] ((::PropertyVerifier<map<string,double> >*)p);
   }
   static void destruct_PropertyVerifierlEmaplEstringcOdoublegRsPgR(void *p) {
      typedef ::PropertyVerifier<map<string,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<map<string,double> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEmaplEstringcOintgRsPgR(void *p) {
      delete ((::PropertyVerifier<map<string,int> >*)p);
   }
   static void deleteArray_PropertyVerifierlEmaplEstringcOintgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<map<string,int> >*)p);
   }
   static void destruct_PropertyVerifierlEmaplEstringcOintgRsPgR(void *p) {
      typedef ::PropertyVerifier<map<string,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<map<string,int> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEmaplEstringcOstringgRsPgR(void *p) {
      delete ((::PropertyVerifier<map<string,string> >*)p);
   }
   static void deleteArray_PropertyVerifierlEmaplEstringcOstringgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<map<string,string> >*)p);
   }
   static void destruct_PropertyVerifierlEmaplEstringcOstringgRsPgR(void *p) {
      typedef ::PropertyVerifier<map<string,string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<map<string,string> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEmaplEintcOdoublegRsPgR(void *p) {
      delete ((::PropertyVerifier<map<int,double> >*)p);
   }
   static void deleteArray_PropertyVerifierlEmaplEintcOdoublegRsPgR(void *p) {
      delete [] ((::PropertyVerifier<map<int,double> >*)p);
   }
   static void destruct_PropertyVerifierlEmaplEintcOdoublegRsPgR(void *p) {
      typedef ::PropertyVerifier<map<int,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<map<int,double> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<vector<double> > >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<vector<double> > >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEvectorlEdoublegRsPgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<vector<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<vector<double> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<vector<string> > >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<vector<string> > >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEvectorlEstringgRsPgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<vector<string> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<vector<string> > >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEintgR(void *p) {
      delete ((::PropertyVerifier<int>*)p);
   }
   static void deleteArray_PropertyVerifierlEintgR(void *p) {
      delete [] ((::PropertyVerifier<int>*)p);
   }
   static void destruct_PropertyVerifierlEintgR(void *p) {
      typedef ::PropertyVerifier<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<int>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete ((::PropertyVerifier<pair<double,double> >*)p);
   }
   static void deleteArray_PropertyVerifierlEpairlEdoublecOdoublegRsPgR(void *p) {
      delete [] ((::PropertyVerifier<pair<double,double> >*)p);
   }
   static void destruct_PropertyVerifierlEpairlEdoublecOdoublegRsPgR(void *p) {
      typedef ::PropertyVerifier<pair<double,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<pair<double,double> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEpairlEintcOintgRsPgR(void *p) {
      delete ((::PropertyVerifier<pair<int,int> >*)p);
   }
   static void deleteArray_PropertyVerifierlEpairlEintcOintgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<pair<int,int> >*)p);
   }
   static void destruct_PropertyVerifierlEpairlEintcOintgRsPgR(void *p) {
      typedef ::PropertyVerifier<pair<int,int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<pair<int,int> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEstringgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<string> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEstringgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<string> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEstringgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<string> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<string> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlElongsPdoublegRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<long double> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlElongsPdoublegRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<long double> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlElongsPdoublegRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<long double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<long double> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEdoublegRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<double> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<double> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEdoublegRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<double> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEfloatgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<float> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEfloatgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<float> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEfloatgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<float> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlEULong64_tgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<ULong64_t> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlEULong64_tgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<ULong64_t> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlEULong64_tgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<ULong64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<ULong64_t> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEvectorlELong64_tgRsPgR(void *p) {
      delete ((::PropertyVerifier<vector<Long64_t> >*)p);
   }
   static void deleteArray_PropertyVerifierlEvectorlELong64_tgRsPgR(void *p) {
      delete [] ((::PropertyVerifier<vector<Long64_t> >*)p);
   }
   static void destruct_PropertyVerifierlEvectorlELong64_tgRsPgR(void *p) {
      typedef ::PropertyVerifier<vector<Long64_t> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<vector<Long64_t> >

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEunsignedsPchargR(void *p) {
      delete ((::PropertyVerifier<unsigned char>*)p);
   }
   static void deleteArray_PropertyVerifierlEunsignedsPchargR(void *p) {
      delete [] ((::PropertyVerifier<unsigned char>*)p);
   }
   static void destruct_PropertyVerifierlEunsignedsPchargR(void *p) {
      typedef ::PropertyVerifier<unsigned char> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<unsigned char>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEsignedsPchargR(void *p) {
      delete ((::PropertyVerifier<signed char>*)p);
   }
   static void deleteArray_PropertyVerifierlEsignedsPchargR(void *p) {
      delete [] ((::PropertyVerifier<signed char>*)p);
   }
   static void destruct_PropertyVerifierlEsignedsPchargR(void *p) {
      typedef ::PropertyVerifier<signed char> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<signed char>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEchargR(void *p) {
      delete ((::PropertyVerifier<char>*)p);
   }
   static void deleteArray_PropertyVerifierlEchargR(void *p) {
      delete [] ((::PropertyVerifier<char>*)p);
   }
   static void destruct_PropertyVerifierlEchargR(void *p) {
      typedef ::PropertyVerifier<char> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<char>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEGaudicLcLHisto1DDefgR(void *p) {
      delete ((::PropertyVerifier<Gaudi::Histo1DDef>*)p);
   }
   static void deleteArray_PropertyVerifierlEGaudicLcLHisto1DDefgR(void *p) {
      delete [] ((::PropertyVerifier<Gaudi::Histo1DDef>*)p);
   }
   static void destruct_PropertyVerifierlEGaudicLcLHisto1DDefgR(void *p) {
      typedef ::PropertyVerifier<Gaudi::Histo1DDef> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<Gaudi::Histo1DDef>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyVerifierlEshortgR(void *p) {
      delete ((::PropertyVerifier<short>*)p);
   }
   static void deleteArray_PropertyVerifierlEshortgR(void *p) {
      delete [] ((::PropertyVerifier<short>*)p);
   }
   static void destruct_PropertyVerifierlEshortgR(void *p) {
      typedef ::PropertyVerifier<short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyVerifier<short>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyCallbackFunctor(void *p) {
      delete ((::PropertyCallbackFunctor*)p);
   }
   static void deleteArray_PropertyCallbackFunctor(void *p) {
      delete [] ((::PropertyCallbackFunctor*)p);
   }
   static void destruct_PropertyCallbackFunctor(void *p) {
      typedef ::PropertyCallbackFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyCallbackFunctor

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrintStat(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::PrintStat : new ::GaudiAlg::PrintStat;
   }
   static void *newArray_GaudiAlgcLcLPrintStat(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::PrintStat[nElements] : new ::GaudiAlg::PrintStat[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrintStat(void *p) {
      delete ((::GaudiAlg::PrintStat*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrintStat(void *p) {
      delete [] ((::GaudiAlg::PrintStat*)p);
   }
   static void destruct_GaudiAlgcLcLPrintStat(void *p) {
      typedef ::GaudiAlg::PrintStat current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::PrintStat

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrintTuple(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::PrintTuple : new ::GaudiAlg::PrintTuple;
   }
   static void *newArray_GaudiAlgcLcLPrintTuple(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::PrintTuple[nElements] : new ::GaudiAlg::PrintTuple[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrintTuple(void *p) {
      delete ((::GaudiAlg::PrintTuple*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrintTuple(void *p) {
      delete [] ((::GaudiAlg::PrintTuple*)p);
   }
   static void destruct_GaudiAlgcLcLPrintTuple(void *p) {
      typedef ::GaudiAlg::PrintTuple current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::PrintTuple

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrint(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print : new ::GaudiAlg::Print;
   }
   static void *newArray_GaudiAlgcLcLPrint(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print[nElements] : new ::GaudiAlg::Print[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrint(void *p) {
      delete ((::GaudiAlg::Print*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrint(void *p) {
      delete [] ((::GaudiAlg::Print*)p);
   }
   static void destruct_GaudiAlgcLcLPrint(void *p) {
      typedef ::GaudiAlg::Print current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::Print

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrint1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print1D : new ::GaudiAlg::Print1D;
   }
   static void *newArray_GaudiAlgcLcLPrint1D(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print1D[nElements] : new ::GaudiAlg::Print1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrint1D(void *p) {
      delete ((::GaudiAlg::Print1D*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrint1D(void *p) {
      delete [] ((::GaudiAlg::Print1D*)p);
   }
   static void destruct_GaudiAlgcLcLPrint1D(void *p) {
      typedef ::GaudiAlg::Print1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::Print1D

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrint2DProf(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print2DProf : new ::GaudiAlg::Print2DProf;
   }
   static void *newArray_GaudiAlgcLcLPrint2DProf(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print2DProf[nElements] : new ::GaudiAlg::Print2DProf[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrint2DProf(void *p) {
      delete ((::GaudiAlg::Print2DProf*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrint2DProf(void *p) {
      delete [] ((::GaudiAlg::Print2DProf*)p);
   }
   static void destruct_GaudiAlgcLcLPrint2DProf(void *p) {
      typedef ::GaudiAlg::Print2DProf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::Print2DProf

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrint2D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print2D : new ::GaudiAlg::Print2D;
   }
   static void *newArray_GaudiAlgcLcLPrint2D(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print2D[nElements] : new ::GaudiAlg::Print2D[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrint2D(void *p) {
      delete ((::GaudiAlg::Print2D*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrint2D(void *p) {
      delete [] ((::GaudiAlg::Print2D*)p);
   }
   static void destruct_GaudiAlgcLcLPrint2D(void *p) {
      typedef ::GaudiAlg::Print2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::Print2D

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrint1DProf(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print1DProf : new ::GaudiAlg::Print1DProf;
   }
   static void *newArray_GaudiAlgcLcLPrint1DProf(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print1DProf[nElements] : new ::GaudiAlg::Print1DProf[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrint1DProf(void *p) {
      delete ((::GaudiAlg::Print1DProf*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrint1DProf(void *p) {
      delete [] ((::GaudiAlg::Print1DProf*)p);
   }
   static void destruct_GaudiAlgcLcLPrint1DProf(void *p) {
      typedef ::GaudiAlg::Print1DProf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::Print1DProf

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLPrint3D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print3D : new ::GaudiAlg::Print3D;
   }
   static void *newArray_GaudiAlgcLcLPrint3D(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::Print3D[nElements] : new ::GaudiAlg::Print3D[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLPrint3D(void *p) {
      delete ((::GaudiAlg::Print3D*)p);
   }
   static void deleteArray_GaudiAlgcLcLPrint3D(void *p) {
      delete [] ((::GaudiAlg::Print3D*)p);
   }
   static void destruct_GaudiAlgcLcLPrint3D(void *p) {
      typedef ::GaudiAlg::Print3D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::Print3D

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiAlgcLcLID(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::ID : new ::GaudiAlg::ID;
   }
   static void *newArray_GaudiAlgcLcLID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiAlg::ID[nElements] : new ::GaudiAlg::ID[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiAlgcLcLID(void *p) {
      delete ((::GaudiAlg::ID*)p);
   }
   static void deleteArray_GaudiAlgcLcLID(void *p) {
      delete [] ((::GaudiAlg::ID*)p);
   }
   static void destruct_GaudiAlgcLcLID(void *p) {
      typedef ::GaudiAlg::ID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlg::ID

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudiAlgorithm(void *p) {
      delete ((::GaudiAlgorithm*)p);
   }
   static void deleteArray_GaudiAlgorithm(void *p) {
      delete [] ((::GaudiAlgorithm*)p);
   }
   static void destruct_GaudiAlgorithm(void *p) {
      typedef ::GaudiAlgorithm current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiAlgorithm

namespace ROOT {
} // end of namespace ROOT for class ::GaudiHistoAlg

namespace ROOT {
} // end of namespace ROOT for class ::GaudiPython::PyAlg<GaudiTupleAlg>

namespace ROOT {
} // end of namespace ROOT for class ::GaudiPython::PyAlg<GaudiHistoAlg>

namespace ROOT {
} // end of namespace ROOT for class ::GaudiPython::PyAlg<GaudiAlgorithm>

namespace ROOT {
} // end of namespace ROOT for class ::GaudiTupleAlg

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TuplescLcLTuple(void *p) {
      delete ((::Tuples::Tuple*)p);
   }
   static void deleteArray_TuplescLcLTuple(void *p) {
      delete [] ((::Tuples::Tuple*)p);
   }
   static void destruct_TuplescLcLTuple(void *p) {
      typedef ::Tuples::Tuple current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Tuples::Tuple

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLTupleDecorator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::TupleDecorator : new ::GaudiPython::TupleDecorator;
   }
   static void *newArray_GaudiPythoncLcLTupleDecorator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::TupleDecorator[nElements] : new ::GaudiPython::TupleDecorator[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLTupleDecorator(void *p) {
      delete ((::GaudiPython::TupleDecorator*)p);
   }
   static void deleteArray_GaudiPythoncLcLTupleDecorator(void *p) {
      delete [] ((::GaudiPython::TupleDecorator*)p);
   }
   static void destruct_GaudiPythoncLcLTupleDecorator(void *p) {
      typedef ::GaudiPython::TupleDecorator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::TupleDecorator

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLTupleToolDecorator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::TupleToolDecorator : new ::GaudiPython::TupleToolDecorator;
   }
   static void *newArray_GaudiPythoncLcLTupleToolDecorator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::TupleToolDecorator[nElements] : new ::GaudiPython::TupleToolDecorator[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLTupleToolDecorator(void *p) {
      delete ((::GaudiPython::TupleToolDecorator*)p);
   }
   static void deleteArray_GaudiPythoncLcLTupleToolDecorator(void *p) {
      delete [] ((::GaudiPython::TupleToolDecorator*)p);
   }
   static void destruct_GaudiPythoncLcLTupleToolDecorator(void *p) {
      typedef ::GaudiPython::TupleToolDecorator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::TupleToolDecorator

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLHistoDecorator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::HistoDecorator : new ::GaudiPython::HistoDecorator;
   }
   static void *newArray_GaudiPythoncLcLHistoDecorator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::HistoDecorator[nElements] : new ::GaudiPython::HistoDecorator[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLHistoDecorator(void *p) {
      delete ((::GaudiPython::HistoDecorator*)p);
   }
   static void deleteArray_GaudiPythoncLcLHistoDecorator(void *p) {
      delete [] ((::GaudiPython::HistoDecorator*)p);
   }
   static void destruct_GaudiPythoncLcLHistoDecorator(void *p) {
      typedef ::GaudiPython::HistoDecorator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::HistoDecorator

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLAlgDecorator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::AlgDecorator : new ::GaudiPython::AlgDecorator;
   }
   static void *newArray_GaudiPythoncLcLAlgDecorator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::AlgDecorator[nElements] : new ::GaudiPython::AlgDecorator[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLAlgDecorator(void *p) {
      delete ((::GaudiPython::AlgDecorator*)p);
   }
   static void deleteArray_GaudiPythoncLcLAlgDecorator(void *p) {
      delete [] ((::GaudiPython::AlgDecorator*)p);
   }
   static void destruct_GaudiPythoncLcLAlgDecorator(void *p) {
      typedef ::GaudiPython::AlgDecorator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::AlgDecorator

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLTupleAlgDecorator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::TupleAlgDecorator : new ::GaudiPython::TupleAlgDecorator;
   }
   static void *newArray_GaudiPythoncLcLTupleAlgDecorator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::TupleAlgDecorator[nElements] : new ::GaudiPython::TupleAlgDecorator[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLTupleAlgDecorator(void *p) {
      delete ((::GaudiPython::TupleAlgDecorator*)p);
   }
   static void deleteArray_GaudiPythoncLcLTupleAlgDecorator(void *p) {
      delete [] ((::GaudiPython::TupleAlgDecorator*)p);
   }
   static void destruct_GaudiPythoncLcLTupleAlgDecorator(void *p) {
      typedef ::GaudiPython::TupleAlgDecorator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::TupleAlgDecorator

namespace ROOT {
   // Wrappers around operator new
   static void *new_StatEntity(void *p) {
      return  p ? new(p) ::StatEntity : new ::StatEntity;
   }
   static void *newArray_StatEntity(Long_t nElements, void *p) {
      return p ? new(p) ::StatEntity[nElements] : new ::StatEntity[nElements];
   }
   // Wrapper around operator delete
   static void delete_StatEntity(void *p) {
      delete ((::StatEntity*)p);
   }
   static void deleteArray_StatEntity(void *p) {
      delete [] ((::StatEntity*)p);
   }
   static void destruct_StatEntity(void *p) {
      typedef ::StatEntity current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::StatEntity

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::Printer<ContainedObject> : new ::GaudiPython::Printer<ContainedObject>;
   }
   static void *newArray_GaudiPythoncLcLPrinterlEContainedObjectgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::Printer<ContainedObject>[nElements] : new ::GaudiPython::Printer<ContainedObject>[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p) {
      delete ((::GaudiPython::Printer<ContainedObject>*)p);
   }
   static void deleteArray_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p) {
      delete [] ((::GaudiPython::Printer<ContainedObject>*)p);
   }
   static void destruct_GaudiPythoncLcLPrinterlEContainedObjectgR(void *p) {
      typedef ::GaudiPython::Printer<ContainedObject> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::Printer<ContainedObject>

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudiPythoncLcLPrinterlEDataObjectgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::Printer<DataObject> : new ::GaudiPython::Printer<DataObject>;
   }
   static void *newArray_GaudiPythoncLcLPrinterlEDataObjectgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GaudiPython::Printer<DataObject>[nElements] : new ::GaudiPython::Printer<DataObject>[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLPrinterlEDataObjectgR(void *p) {
      delete ((::GaudiPython::Printer<DataObject>*)p);
   }
   static void deleteArray_GaudiPythoncLcLPrinterlEDataObjectgR(void *p) {
      delete [] ((::GaudiPython::Printer<DataObject>*)p);
   }
   static void destruct_GaudiPythoncLcLPrinterlEDataObjectgR(void *p) {
      typedef ::GaudiPython::Printer<DataObject> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::Printer<DataObject>

namespace ROOT {
} // end of namespace ROOT for class ::GaudiCommon<Algorithm>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudiHistoslEGaudiAlgorithmgR(void *p) {
      delete ((::GaudiHistos<GaudiAlgorithm>*)p);
   }
   static void deleteArray_GaudiHistoslEGaudiAlgorithmgR(void *p) {
      delete [] ((::GaudiHistos<GaudiAlgorithm>*)p);
   }
   static void destruct_GaudiHistoslEGaudiAlgorithmgR(void *p) {
      typedef ::GaudiHistos<GaudiAlgorithm> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiHistos<GaudiAlgorithm>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudiTupleslEGaudiHistoAlggR(void *p) {
      delete ((::GaudiTuples<GaudiHistoAlg>*)p);
   }
   static void deleteArray_GaudiTupleslEGaudiHistoAlggR(void *p) {
      delete [] ((::GaudiTuples<GaudiHistoAlg>*)p);
   }
   static void destruct_GaudiTupleslEGaudiHistoAlggR(void *p) {
      typedef ::GaudiTuples<GaudiHistoAlg> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiTuples<GaudiHistoAlg>

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudicLcLUtilscLcLAida2ROOT(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::Aida2ROOT : new ::Gaudi::Utils::Aida2ROOT;
   }
   static void *newArray_GaudicLcLUtilscLcLAida2ROOT(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::Aida2ROOT[nElements] : new ::Gaudi::Utils::Aida2ROOT[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudicLcLUtilscLcLAida2ROOT(void *p) {
      delete ((::Gaudi::Utils::Aida2ROOT*)p);
   }
   static void deleteArray_GaudicLcLUtilscLcLAida2ROOT(void *p) {
      delete [] ((::Gaudi::Utils::Aida2ROOT*)p);
   }
   static void destruct_GaudicLcLUtilscLcLAida2ROOT(void *p) {
      typedef ::Gaudi::Utils::Aida2ROOT current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::Utils::Aida2ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_Stat(void *p) {
      return  p ? new(p) ::Stat : new ::Stat;
   }
   static void *newArray_Stat(Long_t nElements, void *p) {
      return p ? new(p) ::Stat[nElements] : new ::Stat[nElements];
   }
   // Wrapper around operator delete
   static void delete_Stat(void *p) {
      delete ((::Stat*)p);
   }
   static void deleteArray_Stat(void *p) {
      delete [] ((::Stat*)p);
   }
   static void destruct_Stat(void *p) {
      typedef ::Stat current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Stat

namespace ROOT {
   // Wrappers around operator new
   static void *new_Chrono(void *p) {
      return  p ? new(p) ::Chrono : new ::Chrono;
   }
   static void *newArray_Chrono(Long_t nElements, void *p) {
      return p ? new(p) ::Chrono[nElements] : new ::Chrono[nElements];
   }
   // Wrapper around operator delete
   static void delete_Chrono(void *p) {
      delete ((::Chrono*)p);
   }
   static void deleteArray_Chrono(void *p) {
      delete [] ((::Chrono*)p);
   }
   static void destruct_Chrono(void *p) {
      typedef ::Chrono current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Chrono

namespace ROOT {
   // Wrappers around operator new
   static void *new_ChronoEntity(void *p) {
      return  p ? new(p) ::ChronoEntity : new ::ChronoEntity;
   }
   static void *newArray_ChronoEntity(Long_t nElements, void *p) {
      return p ? new(p) ::ChronoEntity[nElements] : new ::ChronoEntity[nElements];
   }
   // Wrapper around operator delete
   static void delete_ChronoEntity(void *p) {
      delete ((::ChronoEntity*)p);
   }
   static void deleteArray_ChronoEntity(void *p) {
      delete [] ((::ChronoEntity*)p);
   }
   static void destruct_ChronoEntity(void *p) {
      typedef ::ChronoEntity current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ChronoEntity

namespace ROOT {
   // Wrapper around operator delete
   static void delete_PropertyCallbackPointerFunctor(void *p) {
      delete ((::PropertyCallbackPointerFunctor*)p);
   }
   static void deleteArray_PropertyCallbackPointerFunctor(void *p) {
      delete [] ((::PropertyCallbackPointerFunctor*)p);
   }
   static void destruct_PropertyCallbackPointerFunctor(void *p) {
      typedef ::PropertyCallbackPointerFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PropertyCallbackPointerFunctor

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<int,BoundedVerifier<int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<string,NullVerifier<string> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<long,BoundedVerifier<long> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<bool,BoundedVerifier<bool> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<bool,NullVerifier<bool> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<char,BoundedVerifier<char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<char,NullVerifier<char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<signed char,BoundedVerifier<signed char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<signed char,NullVerifier<signed char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<short,BoundedVerifier<short> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<short,NullVerifier<short> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<int,NullVerifier<int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<long,NullVerifier<long> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<float,BoundedVerifier<float> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<float,NullVerifier<float> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<double,BoundedVerifier<double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<double,NullVerifier<double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<long double,BoundedVerifier<long double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<long double,NullVerifier<long double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<string,BoundedVerifier<string> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<float> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<ULong64_t> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<Long64_t> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<unsigned long> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<long> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<unsigned int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<unsigned short> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<short> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<unsigned char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<map<string,vector<double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<signed char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<long double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<string> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<pair<int,int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<pair<double,double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<pair<double,double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<vector<string> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<vector<double> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<map<int,double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<map<string,string> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<map<string,int> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<map<string,double> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<map<string,vector<string> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<map<string,vector<int> > >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<int>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<signed char>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<unsigned char>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<short>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<unsigned short>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<unsigned int>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<long>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<char>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<unsigned long>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<Long64_t>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<ULong64_t>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<float>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<bool>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<double>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<long double>

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<bool> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<vector<char> >

namespace ROOT {
} // end of namespace ROOT for class ::PropertyWithValue<string>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIBaseHistogram(void *p) {
      delete ((::AIDA::IBaseHistogram*)p);
   }
   static void deleteArray_AIDAcLcLIBaseHistogram(void *p) {
      delete [] ((::AIDA::IBaseHistogram*)p);
   }
   static void destruct_AIDAcLcLIBaseHistogram(void *p) {
      typedef ::AIDA::IBaseHistogram current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IBaseHistogram

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIHistogram(void *p) {
      delete ((::AIDA::IHistogram*)p);
   }
   static void deleteArray_AIDAcLcLIHistogram(void *p) {
      delete [] ((::AIDA::IHistogram*)p);
   }
   static void destruct_AIDAcLcLIHistogram(void *p) {
      typedef ::AIDA::IHistogram current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IHistogram

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIHistogram1D(void *p) {
      delete ((::AIDA::IHistogram1D*)p);
   }
   static void deleteArray_AIDAcLcLIHistogram1D(void *p) {
      delete [] ((::AIDA::IHistogram1D*)p);
   }
   static void destruct_AIDAcLcLIHistogram1D(void *p) {
      typedef ::AIDA::IHistogram1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IHistogram1D

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIHistogram2D(void *p) {
      delete ((::AIDA::IHistogram2D*)p);
   }
   static void deleteArray_AIDAcLcLIHistogram2D(void *p) {
      delete [] ((::AIDA::IHistogram2D*)p);
   }
   static void destruct_AIDAcLcLIHistogram2D(void *p) {
      typedef ::AIDA::IHistogram2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IHistogram2D

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIHistogram3D(void *p) {
      delete ((::AIDA::IHistogram3D*)p);
   }
   static void deleteArray_AIDAcLcLIHistogram3D(void *p) {
      delete [] ((::AIDA::IHistogram3D*)p);
   }
   static void destruct_AIDAcLcLIHistogram3D(void *p) {
      typedef ::AIDA::IHistogram3D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IHistogram3D

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIProfile(void *p) {
      delete ((::AIDA::IProfile*)p);
   }
   static void deleteArray_AIDAcLcLIProfile(void *p) {
      delete [] ((::AIDA::IProfile*)p);
   }
   static void destruct_AIDAcLcLIProfile(void *p) {
      typedef ::AIDA::IProfile current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IProfile

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIProfile1D(void *p) {
      delete ((::AIDA::IProfile1D*)p);
   }
   static void deleteArray_AIDAcLcLIProfile1D(void *p) {
      delete [] ((::AIDA::IProfile1D*)p);
   }
   static void destruct_AIDAcLcLIProfile1D(void *p) {
      typedef ::AIDA::IProfile1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IProfile1D

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIProfile2D(void *p) {
      delete ((::AIDA::IProfile2D*)p);
   }
   static void deleteArray_AIDAcLcLIProfile2D(void *p) {
      delete [] ((::AIDA::IProfile2D*)p);
   }
   static void destruct_AIDAcLcLIProfile2D(void *p) {
      typedef ::AIDA::IProfile2D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IProfile2D

namespace ROOT {
   // Wrapper around operator delete
   static void delete_AIDAcLcLIAxis(void *p) {
      delete ((::AIDA::IAxis*)p);
   }
   static void deleteArray_AIDAcLcLIAxis(void *p) {
      delete [] ((::AIDA::IAxis*)p);
   }
   static void destruct_AIDAcLcLIAxis(void *p) {
      typedef ::AIDA::IAxis current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::AIDA::IAxis

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLPyAlgorithm(void *p) {
      delete ((::GaudiPython::PyAlgorithm*)p);
   }
   static void deleteArray_GaudiPythoncLcLPyAlgorithm(void *p) {
      delete [] ((::GaudiPython::PyAlgorithm*)p);
   }
   static void destruct_GaudiPythoncLcLPyAlgorithm(void *p) {
      typedef ::GaudiPython::PyAlgorithm current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::PyAlgorithm

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudiPythoncLcLCallbackStreamBuf(void *p) {
      delete ((::GaudiPython::CallbackStreamBuf*)p);
   }
   static void deleteArray_GaudiPythoncLcLCallbackStreamBuf(void *p) {
      delete [] ((::GaudiPython::CallbackStreamBuf*)p);
   }
   static void destruct_GaudiPythoncLcLCallbackStreamBuf(void *p) {
      typedef ::GaudiPython::CallbackStreamBuf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GaudiPython::CallbackStreamBuf

namespace ROOT {
   // Wrappers around operator new
   static void *new_ParticleProperty(void *p) {
      return  p ? new(p) ::ParticleProperty : new ::ParticleProperty;
   }
   static void *newArray_ParticleProperty(Long_t nElements, void *p) {
      return p ? new(p) ::ParticleProperty[nElements] : new ::ParticleProperty[nElements];
   }
   // Wrapper around operator delete
   static void delete_ParticleProperty(void *p) {
      delete ((::ParticleProperty*)p);
   }
   static void deleteArray_ParticleProperty(void *p) {
      delete [] ((::ParticleProperty*)p);
   }
   static void destruct_ParticleProperty(void *p) {
      typedef ::ParticleProperty current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ParticleProperty

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudicLcLStringKey(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::StringKey : new ::Gaudi::StringKey;
   }
   static void *newArray_GaudicLcLStringKey(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::StringKey[nElements] : new ::Gaudi::StringKey[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudicLcLStringKey(void *p) {
      delete ((::Gaudi::StringKey*)p);
   }
   static void deleteArray_GaudicLcLStringKey(void *p) {
      delete [] ((::Gaudi::StringKey*)p);
   }
   static void destruct_GaudicLcLStringKey(void *p) {
      typedef ::Gaudi::StringKey current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::StringKey

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudicLcLUtilscLcLMapBase(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::MapBase : new ::Gaudi::Utils::MapBase;
   }
   static void *newArray_GaudicLcLUtilscLcLMapBase(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::MapBase[nElements] : new ::Gaudi::Utils::MapBase[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudicLcLUtilscLcLMapBase(void *p) {
      delete ((::Gaudi::Utils::MapBase*)p);
   }
   static void deleteArray_GaudicLcLUtilscLcLMapBase(void *p) {
      delete [] ((::Gaudi::Utils::MapBase*)p);
   }
   static void destruct_GaudicLcLUtilscLcLMapBase(void *p) {
      typedef ::Gaudi::Utils::MapBase current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::Utils::MapBase

namespace ROOT {
} // end of namespace ROOT for class ::IErrorTool

namespace ROOT {
   // Wrapper around operator delete
   static void delete_IGenericTool(void *p) {
      delete ((::IGenericTool*)p);
   }
   static void deleteArray_IGenericTool(void *p) {
      delete [] ((::IGenericTool*)p);
   }
   static void destruct_IGenericTool(void *p) {
      typedef ::IGenericTool current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::IGenericTool

namespace ROOT {
} // end of namespace ROOT for class ::IHistoTool

namespace ROOT {
} // end of namespace ROOT for class ::ITupleTool

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ISequencerTimerTool(void *p) {
      delete ((::ISequencerTimerTool*)p);
   }
   static void deleteArray_ISequencerTimerTool(void *p) {
      delete [] ((::ISequencerTimerTool*)p);
   }
   static void destruct_ISequencerTimerTool(void *p) {
      typedef ::ISequencerTimerTool current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ISequencerTimerTool

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudicLcLIFileCatalog(void *p) {
      delete ((::Gaudi::IFileCatalog*)p);
   }
   static void deleteArray_GaudicLcLIFileCatalog(void *p) {
      delete [] ((::Gaudi::IFileCatalog*)p);
   }
   static void destruct_GaudicLcLIFileCatalog(void *p) {
      typedef ::Gaudi::IFileCatalog current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::IFileCatalog

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudicLcLIFileCatalogMgr(void *p) {
      delete ((::Gaudi::IFileCatalogMgr*)p);
   }
   static void deleteArray_GaudicLcLIFileCatalogMgr(void *p) {
      delete [] ((::Gaudi::IFileCatalogMgr*)p);
   }
   static void destruct_GaudicLcLIFileCatalogMgr(void *p) {
      typedef ::Gaudi::IFileCatalogMgr current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::IFileCatalogMgr

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudicLcLIDataConnection(void *p) {
      delete ((::Gaudi::IDataConnection*)p);
   }
   static void deleteArray_GaudicLcLIDataConnection(void *p) {
      delete [] ((::Gaudi::IDataConnection*)p);
   }
   static void destruct_GaudicLcLIDataConnection(void *p) {
      typedef ::Gaudi::IDataConnection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::IDataConnection

namespace ROOT {
   // Wrapper around operator delete
   static void delete_GaudicLcLIIODataManager(void *p) {
      delete ((::Gaudi::IIODataManager*)p);
   }
   static void deleteArray_GaudicLcLIIODataManager(void *p) {
      delete [] ((::Gaudi::IIODataManager*)p);
   }
   static void destruct_GaudicLcLIIODataManager(void *p) {
      typedef ::Gaudi::IIODataManager current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::IIODataManager

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudicLcLUtilscLcLHistoscLcLTable(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::Histos::Table : new ::Gaudi::Utils::Histos::Table;
   }
   static void *newArray_GaudicLcLUtilscLcLHistoscLcLTable(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::Histos::Table[nElements] : new ::Gaudi::Utils::Histos::Table[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudicLcLUtilscLcLHistoscLcLTable(void *p) {
      delete ((::Gaudi::Utils::Histos::Table*)p);
   }
   static void deleteArray_GaudicLcLUtilscLcLHistoscLcLTable(void *p) {
      delete [] ((::Gaudi::Utils::Histos::Table*)p);
   }
   static void destruct_GaudicLcLUtilscLcLHistoscLcLTable(void *p) {
      typedef ::Gaudi::Utils::Histos::Table current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::Utils::Histos::Table

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudicLcLUtilscLcLHistoStats(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::HistoStats : new ::Gaudi::Utils::HistoStats;
   }
   static void *newArray_GaudicLcLUtilscLcLHistoStats(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::Utils::HistoStats[nElements] : new ::Gaudi::Utils::HistoStats[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudicLcLUtilscLcLHistoStats(void *p) {
      delete ((::Gaudi::Utils::HistoStats*)p);
   }
   static void deleteArray_GaudicLcLUtilscLcLHistoStats(void *p) {
      delete [] ((::Gaudi::Utils::HistoStats*)p);
   }
   static void destruct_GaudicLcLUtilscLcLHistoStats(void *p) {
      typedef ::Gaudi::Utils::HistoStats current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::Utils::HistoStats

namespace ROOT {
   // Wrappers around operator new
   static void *new_GaudicLcLRangeBase_(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::RangeBase_ : new ::Gaudi::RangeBase_;
   }
   static void *newArray_GaudicLcLRangeBase_(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Gaudi::RangeBase_[nElements] : new ::Gaudi::RangeBase_[nElements];
   }
   // Wrapper around operator delete
   static void delete_GaudicLcLRangeBase_(void *p) {
      delete ((::Gaudi::RangeBase_*)p);
   }
   static void deleteArray_GaudicLcLRangeBase_(void *p) {
      delete [] ((::Gaudi::RangeBase_*)p);
   }
   static void destruct_GaudicLcLRangeBase_(void *p) {
      typedef ::Gaudi::RangeBase_ current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Gaudi::RangeBase_

namespace ROOT {
   static TClass *vectorlEvectorlEdoublegRsPgR_Dictionary();
   static void vectorlEvectorlEdoublegRsPgR_TClassManip(TClass*);
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p);
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<double> >*)
   {
      vector<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<double> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<double> >", -2, "vector", 214,
                  typeid(vector<vector<double> >), DefineBehavior(ptr, ptr),
                  &vectorlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<vector<double> >) );
      instance.SetNew(&new_vectorlEvectorlEdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEdoublegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEvectorlEdoublegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<vector<double> >*)0x0)->GetClass();
      vectorlEvectorlEdoublegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEvectorlEdoublegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> > : new vector<vector<double> >;
   }
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> >[nElements] : new vector<vector<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete ((vector<vector<double> >*)p);
   }
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((vector<vector<double> >*)p);
   }
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p) {
      typedef vector<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<double> >

namespace ROOT {
   static TClass *vectorlEstringgR_Dictionary();
   static void vectorlEstringgR_TClassManip(TClass*);
   static void *new_vectorlEstringgR(void *p = 0);
   static void *newArray_vectorlEstringgR(Long_t size, void *p);
   static void delete_vectorlEstringgR(void *p);
   static void deleteArray_vectorlEstringgR(void *p);
   static void destruct_vectorlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<string>*)
   {
      vector<string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<string>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<string>", -2, "vector", 214,
                  typeid(vector<string>), DefineBehavior(ptr, ptr),
                  &vectorlEstringgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<string>) );
      instance.SetNew(&new_vectorlEstringgR);
      instance.SetNewArray(&newArray_vectorlEstringgR);
      instance.SetDelete(&delete_vectorlEstringgR);
      instance.SetDeleteArray(&deleteArray_vectorlEstringgR);
      instance.SetDestructor(&destruct_vectorlEstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<string> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<string>*)0x0)->GetClass();
      vectorlEstringgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<string> : new vector<string>;
   }
   static void *newArray_vectorlEstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<string>[nElements] : new vector<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEstringgR(void *p) {
      delete ((vector<string>*)p);
   }
   static void deleteArray_vectorlEstringgR(void *p) {
      delete [] ((vector<string>*)p);
   }
   static void destruct_vectorlEstringgR(void *p) {
      typedef vector<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<string>

namespace ROOT {
   static TClass *vectorlEdoublegR_Dictionary();
   static void vectorlEdoublegR_TClassManip(TClass*);
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "vector", 214,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  &vectorlEdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEdoublegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
      vectorlEdoublegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEdoublegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   static TClass *vectorlEconstsPStatEntitymUgR_Dictionary();
   static void vectorlEconstsPStatEntitymUgR_TClassManip(TClass*);
   static void *new_vectorlEconstsPStatEntitymUgR(void *p = 0);
   static void *newArray_vectorlEconstsPStatEntitymUgR(Long_t size, void *p);
   static void delete_vectorlEconstsPStatEntitymUgR(void *p);
   static void deleteArray_vectorlEconstsPStatEntitymUgR(void *p);
   static void destruct_vectorlEconstsPStatEntitymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<const StatEntity*>*)
   {
      vector<const StatEntity*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<const StatEntity*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<const StatEntity*>", -2, "vector", 214,
                  typeid(vector<const StatEntity*>), DefineBehavior(ptr, ptr),
                  &vectorlEconstsPStatEntitymUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<const StatEntity*>) );
      instance.SetNew(&new_vectorlEconstsPStatEntitymUgR);
      instance.SetNewArray(&newArray_vectorlEconstsPStatEntitymUgR);
      instance.SetDelete(&delete_vectorlEconstsPStatEntitymUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEconstsPStatEntitymUgR);
      instance.SetDestructor(&destruct_vectorlEconstsPStatEntitymUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<const StatEntity*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<const StatEntity*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEconstsPStatEntitymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<const StatEntity*>*)0x0)->GetClass();
      vectorlEconstsPStatEntitymUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEconstsPStatEntitymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEconstsPStatEntitymUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<const StatEntity*> : new vector<const StatEntity*>;
   }
   static void *newArray_vectorlEconstsPStatEntitymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<const StatEntity*>[nElements] : new vector<const StatEntity*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEconstsPStatEntitymUgR(void *p) {
      delete ((vector<const StatEntity*>*)p);
   }
   static void deleteArray_vectorlEconstsPStatEntitymUgR(void *p) {
      delete [] ((vector<const StatEntity*>*)p);
   }
   static void destruct_vectorlEconstsPStatEntitymUgR(void *p) {
      typedef vector<const StatEntity*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<const StatEntity*>

namespace ROOT {
   static TClass *vectorlEconstsPPropertymUgR_Dictionary();
   static void vectorlEconstsPPropertymUgR_TClassManip(TClass*);
   static void *new_vectorlEconstsPPropertymUgR(void *p = 0);
   static void *newArray_vectorlEconstsPPropertymUgR(Long_t size, void *p);
   static void delete_vectorlEconstsPPropertymUgR(void *p);
   static void deleteArray_vectorlEconstsPPropertymUgR(void *p);
   static void destruct_vectorlEconstsPPropertymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<const Property*>*)
   {
      vector<const Property*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<const Property*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<const Property*>", -2, "vector", 214,
                  typeid(vector<const Property*>), DefineBehavior(ptr, ptr),
                  &vectorlEconstsPPropertymUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<const Property*>) );
      instance.SetNew(&new_vectorlEconstsPPropertymUgR);
      instance.SetNewArray(&newArray_vectorlEconstsPPropertymUgR);
      instance.SetDelete(&delete_vectorlEconstsPPropertymUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEconstsPPropertymUgR);
      instance.SetDestructor(&destruct_vectorlEconstsPPropertymUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<const Property*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<const Property*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEconstsPPropertymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<const Property*>*)0x0)->GetClass();
      vectorlEconstsPPropertymUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEconstsPPropertymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEconstsPPropertymUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<const Property*> : new vector<const Property*>;
   }
   static void *newArray_vectorlEconstsPPropertymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<const Property*>[nElements] : new vector<const Property*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEconstsPPropertymUgR(void *p) {
      delete ((vector<const Property*>*)p);
   }
   static void deleteArray_vectorlEconstsPPropertymUgR(void *p) {
      delete [] ((vector<const Property*>*)p);
   }
   static void destruct_vectorlEconstsPPropertymUgR(void *p) {
      typedef vector<const Property*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<const Property*>

namespace ROOT {
   static TClass *vectorlEPropertymUgR_Dictionary();
   static void vectorlEPropertymUgR_TClassManip(TClass*);
   static void *new_vectorlEPropertymUgR(void *p = 0);
   static void *newArray_vectorlEPropertymUgR(Long_t size, void *p);
   static void delete_vectorlEPropertymUgR(void *p);
   static void deleteArray_vectorlEPropertymUgR(void *p);
   static void destruct_vectorlEPropertymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<Property*>*)
   {
      vector<Property*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<Property*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<Property*>", -2, "vector", 214,
                  typeid(vector<Property*>), DefineBehavior(ptr, ptr),
                  &vectorlEPropertymUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<Property*>) );
      instance.SetNew(&new_vectorlEPropertymUgR);
      instance.SetNewArray(&newArray_vectorlEPropertymUgR);
      instance.SetDelete(&delete_vectorlEPropertymUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEPropertymUgR);
      instance.SetDestructor(&destruct_vectorlEPropertymUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<Property*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<Property*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEPropertymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<Property*>*)0x0)->GetClass();
      vectorlEPropertymUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEPropertymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEPropertymUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Property*> : new vector<Property*>;
   }
   static void *newArray_vectorlEPropertymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<Property*>[nElements] : new vector<Property*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEPropertymUgR(void *p) {
      delete ((vector<Property*>*)p);
   }
   static void deleteArray_vectorlEPropertymUgR(void *p) {
      delete [] ((vector<Property*>*)p);
   }
   static void destruct_vectorlEPropertymUgR(void *p) {
      typedef vector<Property*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<Property*>

namespace ROOT {
   static TClass *vectorlEIServicemUgR_Dictionary();
   static void vectorlEIServicemUgR_TClassManip(TClass*);
   static void *new_vectorlEIServicemUgR(void *p = 0);
   static void *newArray_vectorlEIServicemUgR(Long_t size, void *p);
   static void delete_vectorlEIServicemUgR(void *p);
   static void deleteArray_vectorlEIServicemUgR(void *p);
   static void destruct_vectorlEIServicemUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<IService*>*)
   {
      vector<IService*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<IService*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<IService*>", -2, "vector", 214,
                  typeid(vector<IService*>), DefineBehavior(ptr, ptr),
                  &vectorlEIServicemUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<IService*>) );
      instance.SetNew(&new_vectorlEIServicemUgR);
      instance.SetNewArray(&newArray_vectorlEIServicemUgR);
      instance.SetDelete(&delete_vectorlEIServicemUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEIServicemUgR);
      instance.SetDestructor(&destruct_vectorlEIServicemUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<IService*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<IService*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEIServicemUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<IService*>*)0x0)->GetClass();
      vectorlEIServicemUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEIServicemUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEIServicemUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<IService*> : new vector<IService*>;
   }
   static void *newArray_vectorlEIServicemUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<IService*>[nElements] : new vector<IService*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEIServicemUgR(void *p) {
      delete ((vector<IService*>*)p);
   }
   static void deleteArray_vectorlEIServicemUgR(void *p) {
      delete [] ((vector<IService*>*)p);
   }
   static void destruct_vectorlEIServicemUgR(void *p) {
      typedef vector<IService*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<IService*>

namespace ROOT {
   static TClass *vectorlEIRegistrymUgR_Dictionary();
   static void vectorlEIRegistrymUgR_TClassManip(TClass*);
   static void *new_vectorlEIRegistrymUgR(void *p = 0);
   static void *newArray_vectorlEIRegistrymUgR(Long_t size, void *p);
   static void delete_vectorlEIRegistrymUgR(void *p);
   static void deleteArray_vectorlEIRegistrymUgR(void *p);
   static void destruct_vectorlEIRegistrymUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<IRegistry*>*)
   {
      vector<IRegistry*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<IRegistry*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<IRegistry*>", -2, "vector", 214,
                  typeid(vector<IRegistry*>), DefineBehavior(ptr, ptr),
                  &vectorlEIRegistrymUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<IRegistry*>) );
      instance.SetNew(&new_vectorlEIRegistrymUgR);
      instance.SetNewArray(&newArray_vectorlEIRegistrymUgR);
      instance.SetDelete(&delete_vectorlEIRegistrymUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEIRegistrymUgR);
      instance.SetDestructor(&destruct_vectorlEIRegistrymUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<IRegistry*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<IRegistry*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEIRegistrymUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<IRegistry*>*)0x0)->GetClass();
      vectorlEIRegistrymUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEIRegistrymUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEIRegistrymUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<IRegistry*> : new vector<IRegistry*>;
   }
   static void *newArray_vectorlEIRegistrymUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<IRegistry*>[nElements] : new vector<IRegistry*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEIRegistrymUgR(void *p) {
      delete ((vector<IRegistry*>*)p);
   }
   static void deleteArray_vectorlEIRegistrymUgR(void *p) {
      delete [] ((vector<IRegistry*>*)p);
   }
   static void destruct_vectorlEIRegistrymUgR(void *p) {
      typedef vector<IRegistry*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<IRegistry*>

namespace ROOT {
   static TClass *vectorlEIAlgToolmUgR_Dictionary();
   static void vectorlEIAlgToolmUgR_TClassManip(TClass*);
   static void *new_vectorlEIAlgToolmUgR(void *p = 0);
   static void *newArray_vectorlEIAlgToolmUgR(Long_t size, void *p);
   static void delete_vectorlEIAlgToolmUgR(void *p);
   static void deleteArray_vectorlEIAlgToolmUgR(void *p);
   static void destruct_vectorlEIAlgToolmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<IAlgTool*>*)
   {
      vector<IAlgTool*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<IAlgTool*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<IAlgTool*>", -2, "vector", 214,
                  typeid(vector<IAlgTool*>), DefineBehavior(ptr, ptr),
                  &vectorlEIAlgToolmUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<IAlgTool*>) );
      instance.SetNew(&new_vectorlEIAlgToolmUgR);
      instance.SetNewArray(&newArray_vectorlEIAlgToolmUgR);
      instance.SetDelete(&delete_vectorlEIAlgToolmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEIAlgToolmUgR);
      instance.SetDestructor(&destruct_vectorlEIAlgToolmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<IAlgTool*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<IAlgTool*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEIAlgToolmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<IAlgTool*>*)0x0)->GetClass();
      vectorlEIAlgToolmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEIAlgToolmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEIAlgToolmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<IAlgTool*> : new vector<IAlgTool*>;
   }
   static void *newArray_vectorlEIAlgToolmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<IAlgTool*>[nElements] : new vector<IAlgTool*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEIAlgToolmUgR(void *p) {
      delete ((vector<IAlgTool*>*)p);
   }
   static void deleteArray_vectorlEIAlgToolmUgR(void *p) {
      delete [] ((vector<IAlgTool*>*)p);
   }
   static void destruct_vectorlEIAlgToolmUgR(void *p) {
      typedef vector<IAlgTool*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<IAlgTool*>

namespace ROOT {
   static TClass *vectorlEGaudiAlgcLcLIDgR_Dictionary();
   static void vectorlEGaudiAlgcLcLIDgR_TClassManip(TClass*);
   static void *new_vectorlEGaudiAlgcLcLIDgR(void *p = 0);
   static void *newArray_vectorlEGaudiAlgcLcLIDgR(Long_t size, void *p);
   static void delete_vectorlEGaudiAlgcLcLIDgR(void *p);
   static void deleteArray_vectorlEGaudiAlgcLcLIDgR(void *p);
   static void destruct_vectorlEGaudiAlgcLcLIDgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<GaudiAlg::ID>*)
   {
      vector<GaudiAlg::ID> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<GaudiAlg::ID>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<GaudiAlg::ID>", -2, "vector", 214,
                  typeid(vector<GaudiAlg::ID>), DefineBehavior(ptr, ptr),
                  &vectorlEGaudiAlgcLcLIDgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<GaudiAlg::ID>) );
      instance.SetNew(&new_vectorlEGaudiAlgcLcLIDgR);
      instance.SetNewArray(&newArray_vectorlEGaudiAlgcLcLIDgR);
      instance.SetDelete(&delete_vectorlEGaudiAlgcLcLIDgR);
      instance.SetDeleteArray(&deleteArray_vectorlEGaudiAlgcLcLIDgR);
      instance.SetDestructor(&destruct_vectorlEGaudiAlgcLcLIDgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<GaudiAlg::ID> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<GaudiAlg::ID>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEGaudiAlgcLcLIDgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<GaudiAlg::ID>*)0x0)->GetClass();
      vectorlEGaudiAlgcLcLIDgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEGaudiAlgcLcLIDgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEGaudiAlgcLcLIDgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<GaudiAlg::ID> : new vector<GaudiAlg::ID>;
   }
   static void *newArray_vectorlEGaudiAlgcLcLIDgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<GaudiAlg::ID>[nElements] : new vector<GaudiAlg::ID>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEGaudiAlgcLcLIDgR(void *p) {
      delete ((vector<GaudiAlg::ID>*)p);
   }
   static void deleteArray_vectorlEGaudiAlgcLcLIDgR(void *p) {
      delete [] ((vector<GaudiAlg::ID>*)p);
   }
   static void destruct_vectorlEGaudiAlgcLcLIDgR(void *p) {
      typedef vector<GaudiAlg::ID> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<GaudiAlg::ID>

namespace ROOT {
   static TClass *vectorlEAIDAcLcLIProfile2DmUgR_Dictionary();
   static void vectorlEAIDAcLcLIProfile2DmUgR_TClassManip(TClass*);
   static void *new_vectorlEAIDAcLcLIProfile2DmUgR(void *p = 0);
   static void *newArray_vectorlEAIDAcLcLIProfile2DmUgR(Long_t size, void *p);
   static void delete_vectorlEAIDAcLcLIProfile2DmUgR(void *p);
   static void deleteArray_vectorlEAIDAcLcLIProfile2DmUgR(void *p);
   static void destruct_vectorlEAIDAcLcLIProfile2DmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<AIDA::IProfile2D*>*)
   {
      vector<AIDA::IProfile2D*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AIDA::IProfile2D*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<AIDA::IProfile2D*>", -2, "vector", 214,
                  typeid(vector<AIDA::IProfile2D*>), DefineBehavior(ptr, ptr),
                  &vectorlEAIDAcLcLIProfile2DmUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<AIDA::IProfile2D*>) );
      instance.SetNew(&new_vectorlEAIDAcLcLIProfile2DmUgR);
      instance.SetNewArray(&newArray_vectorlEAIDAcLcLIProfile2DmUgR);
      instance.SetDelete(&delete_vectorlEAIDAcLcLIProfile2DmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAIDAcLcLIProfile2DmUgR);
      instance.SetDestructor(&destruct_vectorlEAIDAcLcLIProfile2DmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<AIDA::IProfile2D*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AIDA::IProfile2D*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEAIDAcLcLIProfile2DmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<AIDA::IProfile2D*>*)0x0)->GetClass();
      vectorlEAIDAcLcLIProfile2DmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEAIDAcLcLIProfile2DmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEAIDAcLcLIProfile2DmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IProfile2D*> : new vector<AIDA::IProfile2D*>;
   }
   static void *newArray_vectorlEAIDAcLcLIProfile2DmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IProfile2D*>[nElements] : new vector<AIDA::IProfile2D*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAIDAcLcLIProfile2DmUgR(void *p) {
      delete ((vector<AIDA::IProfile2D*>*)p);
   }
   static void deleteArray_vectorlEAIDAcLcLIProfile2DmUgR(void *p) {
      delete [] ((vector<AIDA::IProfile2D*>*)p);
   }
   static void destruct_vectorlEAIDAcLcLIProfile2DmUgR(void *p) {
      typedef vector<AIDA::IProfile2D*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<AIDA::IProfile2D*>

namespace ROOT {
   static TClass *vectorlEAIDAcLcLIProfile1DmUgR_Dictionary();
   static void vectorlEAIDAcLcLIProfile1DmUgR_TClassManip(TClass*);
   static void *new_vectorlEAIDAcLcLIProfile1DmUgR(void *p = 0);
   static void *newArray_vectorlEAIDAcLcLIProfile1DmUgR(Long_t size, void *p);
   static void delete_vectorlEAIDAcLcLIProfile1DmUgR(void *p);
   static void deleteArray_vectorlEAIDAcLcLIProfile1DmUgR(void *p);
   static void destruct_vectorlEAIDAcLcLIProfile1DmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<AIDA::IProfile1D*>*)
   {
      vector<AIDA::IProfile1D*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AIDA::IProfile1D*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<AIDA::IProfile1D*>", -2, "vector", 214,
                  typeid(vector<AIDA::IProfile1D*>), DefineBehavior(ptr, ptr),
                  &vectorlEAIDAcLcLIProfile1DmUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<AIDA::IProfile1D*>) );
      instance.SetNew(&new_vectorlEAIDAcLcLIProfile1DmUgR);
      instance.SetNewArray(&newArray_vectorlEAIDAcLcLIProfile1DmUgR);
      instance.SetDelete(&delete_vectorlEAIDAcLcLIProfile1DmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAIDAcLcLIProfile1DmUgR);
      instance.SetDestructor(&destruct_vectorlEAIDAcLcLIProfile1DmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<AIDA::IProfile1D*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AIDA::IProfile1D*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEAIDAcLcLIProfile1DmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<AIDA::IProfile1D*>*)0x0)->GetClass();
      vectorlEAIDAcLcLIProfile1DmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEAIDAcLcLIProfile1DmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEAIDAcLcLIProfile1DmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IProfile1D*> : new vector<AIDA::IProfile1D*>;
   }
   static void *newArray_vectorlEAIDAcLcLIProfile1DmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IProfile1D*>[nElements] : new vector<AIDA::IProfile1D*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAIDAcLcLIProfile1DmUgR(void *p) {
      delete ((vector<AIDA::IProfile1D*>*)p);
   }
   static void deleteArray_vectorlEAIDAcLcLIProfile1DmUgR(void *p) {
      delete [] ((vector<AIDA::IProfile1D*>*)p);
   }
   static void destruct_vectorlEAIDAcLcLIProfile1DmUgR(void *p) {
      typedef vector<AIDA::IProfile1D*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<AIDA::IProfile1D*>

namespace ROOT {
   static TClass *vectorlEAIDAcLcLIHistogram3DmUgR_Dictionary();
   static void vectorlEAIDAcLcLIHistogram3DmUgR_TClassManip(TClass*);
   static void *new_vectorlEAIDAcLcLIHistogram3DmUgR(void *p = 0);
   static void *newArray_vectorlEAIDAcLcLIHistogram3DmUgR(Long_t size, void *p);
   static void delete_vectorlEAIDAcLcLIHistogram3DmUgR(void *p);
   static void deleteArray_vectorlEAIDAcLcLIHistogram3DmUgR(void *p);
   static void destruct_vectorlEAIDAcLcLIHistogram3DmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<AIDA::IHistogram3D*>*)
   {
      vector<AIDA::IHistogram3D*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AIDA::IHistogram3D*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<AIDA::IHistogram3D*>", -2, "vector", 214,
                  typeid(vector<AIDA::IHistogram3D*>), DefineBehavior(ptr, ptr),
                  &vectorlEAIDAcLcLIHistogram3DmUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<AIDA::IHistogram3D*>) );
      instance.SetNew(&new_vectorlEAIDAcLcLIHistogram3DmUgR);
      instance.SetNewArray(&newArray_vectorlEAIDAcLcLIHistogram3DmUgR);
      instance.SetDelete(&delete_vectorlEAIDAcLcLIHistogram3DmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAIDAcLcLIHistogram3DmUgR);
      instance.SetDestructor(&destruct_vectorlEAIDAcLcLIHistogram3DmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<AIDA::IHistogram3D*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AIDA::IHistogram3D*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEAIDAcLcLIHistogram3DmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<AIDA::IHistogram3D*>*)0x0)->GetClass();
      vectorlEAIDAcLcLIHistogram3DmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEAIDAcLcLIHistogram3DmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEAIDAcLcLIHistogram3DmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IHistogram3D*> : new vector<AIDA::IHistogram3D*>;
   }
   static void *newArray_vectorlEAIDAcLcLIHistogram3DmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IHistogram3D*>[nElements] : new vector<AIDA::IHistogram3D*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAIDAcLcLIHistogram3DmUgR(void *p) {
      delete ((vector<AIDA::IHistogram3D*>*)p);
   }
   static void deleteArray_vectorlEAIDAcLcLIHistogram3DmUgR(void *p) {
      delete [] ((vector<AIDA::IHistogram3D*>*)p);
   }
   static void destruct_vectorlEAIDAcLcLIHistogram3DmUgR(void *p) {
      typedef vector<AIDA::IHistogram3D*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<AIDA::IHistogram3D*>

namespace ROOT {
   static TClass *vectorlEAIDAcLcLIHistogram2DmUgR_Dictionary();
   static void vectorlEAIDAcLcLIHistogram2DmUgR_TClassManip(TClass*);
   static void *new_vectorlEAIDAcLcLIHistogram2DmUgR(void *p = 0);
   static void *newArray_vectorlEAIDAcLcLIHistogram2DmUgR(Long_t size, void *p);
   static void delete_vectorlEAIDAcLcLIHistogram2DmUgR(void *p);
   static void deleteArray_vectorlEAIDAcLcLIHistogram2DmUgR(void *p);
   static void destruct_vectorlEAIDAcLcLIHistogram2DmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<AIDA::IHistogram2D*>*)
   {
      vector<AIDA::IHistogram2D*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AIDA::IHistogram2D*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<AIDA::IHistogram2D*>", -2, "vector", 214,
                  typeid(vector<AIDA::IHistogram2D*>), DefineBehavior(ptr, ptr),
                  &vectorlEAIDAcLcLIHistogram2DmUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<AIDA::IHistogram2D*>) );
      instance.SetNew(&new_vectorlEAIDAcLcLIHistogram2DmUgR);
      instance.SetNewArray(&newArray_vectorlEAIDAcLcLIHistogram2DmUgR);
      instance.SetDelete(&delete_vectorlEAIDAcLcLIHistogram2DmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAIDAcLcLIHistogram2DmUgR);
      instance.SetDestructor(&destruct_vectorlEAIDAcLcLIHistogram2DmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<AIDA::IHistogram2D*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AIDA::IHistogram2D*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEAIDAcLcLIHistogram2DmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<AIDA::IHistogram2D*>*)0x0)->GetClass();
      vectorlEAIDAcLcLIHistogram2DmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEAIDAcLcLIHistogram2DmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEAIDAcLcLIHistogram2DmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IHistogram2D*> : new vector<AIDA::IHistogram2D*>;
   }
   static void *newArray_vectorlEAIDAcLcLIHistogram2DmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IHistogram2D*>[nElements] : new vector<AIDA::IHistogram2D*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAIDAcLcLIHistogram2DmUgR(void *p) {
      delete ((vector<AIDA::IHistogram2D*>*)p);
   }
   static void deleteArray_vectorlEAIDAcLcLIHistogram2DmUgR(void *p) {
      delete [] ((vector<AIDA::IHistogram2D*>*)p);
   }
   static void destruct_vectorlEAIDAcLcLIHistogram2DmUgR(void *p) {
      typedef vector<AIDA::IHistogram2D*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<AIDA::IHistogram2D*>

namespace ROOT {
   static TClass *vectorlEAIDAcLcLIHistogram1DmUgR_Dictionary();
   static void vectorlEAIDAcLcLIHistogram1DmUgR_TClassManip(TClass*);
   static void *new_vectorlEAIDAcLcLIHistogram1DmUgR(void *p = 0);
   static void *newArray_vectorlEAIDAcLcLIHistogram1DmUgR(Long_t size, void *p);
   static void delete_vectorlEAIDAcLcLIHistogram1DmUgR(void *p);
   static void deleteArray_vectorlEAIDAcLcLIHistogram1DmUgR(void *p);
   static void destruct_vectorlEAIDAcLcLIHistogram1DmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<AIDA::IHistogram1D*>*)
   {
      vector<AIDA::IHistogram1D*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AIDA::IHistogram1D*>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<AIDA::IHistogram1D*>", -2, "vector", 214,
                  typeid(vector<AIDA::IHistogram1D*>), DefineBehavior(ptr, ptr),
                  &vectorlEAIDAcLcLIHistogram1DmUgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<AIDA::IHistogram1D*>) );
      instance.SetNew(&new_vectorlEAIDAcLcLIHistogram1DmUgR);
      instance.SetNewArray(&newArray_vectorlEAIDAcLcLIHistogram1DmUgR);
      instance.SetDelete(&delete_vectorlEAIDAcLcLIHistogram1DmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAIDAcLcLIHistogram1DmUgR);
      instance.SetDestructor(&destruct_vectorlEAIDAcLcLIHistogram1DmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<AIDA::IHistogram1D*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AIDA::IHistogram1D*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEAIDAcLcLIHistogram1DmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<AIDA::IHistogram1D*>*)0x0)->GetClass();
      vectorlEAIDAcLcLIHistogram1DmUgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEAIDAcLcLIHistogram1DmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEAIDAcLcLIHistogram1DmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IHistogram1D*> : new vector<AIDA::IHistogram1D*>;
   }
   static void *newArray_vectorlEAIDAcLcLIHistogram1DmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AIDA::IHistogram1D*>[nElements] : new vector<AIDA::IHistogram1D*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAIDAcLcLIHistogram1DmUgR(void *p) {
      delete ((vector<AIDA::IHistogram1D*>*)p);
   }
   static void deleteArray_vectorlEAIDAcLcLIHistogram1DmUgR(void *p) {
      delete [] ((vector<AIDA::IHistogram1D*>*)p);
   }
   static void destruct_vectorlEAIDAcLcLIHistogram1DmUgR(void *p) {
      typedef vector<AIDA::IHistogram1D*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<AIDA::IHistogram1D*>

namespace ROOT {
   static TClass *maplEstringcOstringgR_Dictionary();
   static void maplEstringcOstringgR_TClassManip(TClass*);
   static void *new_maplEstringcOstringgR(void *p = 0);
   static void *newArray_maplEstringcOstringgR(Long_t size, void *p);
   static void delete_maplEstringcOstringgR(void *p);
   static void deleteArray_maplEstringcOstringgR(void *p);
   static void destruct_maplEstringcOstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,string>*)
   {
      map<string,string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,string>));
      static ::ROOT::TGenericClassInfo 
         instance("map<string,string>", -2, "map", 96,
                  typeid(map<string,string>), DefineBehavior(ptr, ptr),
                  &maplEstringcOstringgR_Dictionary, isa_proxy, 4,
                  sizeof(map<string,string>) );
      instance.SetNew(&new_maplEstringcOstringgR);
      instance.SetNewArray(&newArray_maplEstringcOstringgR);
      instance.SetDelete(&delete_maplEstringcOstringgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOstringgR);
      instance.SetDestructor(&destruct_maplEstringcOstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,string> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<string,string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *maplEstringcOstringgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const map<string,string>*)0x0)->GetClass();
      maplEstringcOstringgR_TClassManip(theClass);
   return theClass;
   }

   static void maplEstringcOstringgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) map<string,string> : new map<string,string>;
   }
   static void *newArray_maplEstringcOstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) map<string,string>[nElements] : new map<string,string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOstringgR(void *p) {
      delete ((map<string,string>*)p);
   }
   static void deleteArray_maplEstringcOstringgR(void *p) {
      delete [] ((map<string,string>*)p);
   }
   static void destruct_maplEstringcOstringgR(void *p) {
      typedef map<string,string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,string>

namespace ROOT {
   static TClass *listlEIServicemUgR_Dictionary();
   static void listlEIServicemUgR_TClassManip(TClass*);
   static void *new_listlEIServicemUgR(void *p = 0);
   static void *newArray_listlEIServicemUgR(Long_t size, void *p);
   static void delete_listlEIServicemUgR(void *p);
   static void deleteArray_listlEIServicemUgR(void *p);
   static void destruct_listlEIServicemUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<IService*>*)
   {
      list<IService*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<IService*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<IService*>", -2, "list", 447,
                  typeid(list<IService*>), DefineBehavior(ptr, ptr),
                  &listlEIServicemUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<IService*>) );
      instance.SetNew(&new_listlEIServicemUgR);
      instance.SetNewArray(&newArray_listlEIServicemUgR);
      instance.SetDelete(&delete_listlEIServicemUgR);
      instance.SetDeleteArray(&deleteArray_listlEIServicemUgR);
      instance.SetDestructor(&destruct_listlEIServicemUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<IService*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const list<IService*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlEIServicemUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<IService*>*)0x0)->GetClass();
      listlEIServicemUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlEIServicemUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlEIServicemUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) list<IService*> : new list<IService*>;
   }
   static void *newArray_listlEIServicemUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) list<IService*>[nElements] : new list<IService*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlEIServicemUgR(void *p) {
      delete ((list<IService*>*)p);
   }
   static void deleteArray_listlEIServicemUgR(void *p) {
      delete [] ((list<IService*>*)p);
   }
   static void destruct_listlEIServicemUgR(void *p) {
      typedef list<IService*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<IService*>

namespace ROOT {
   static TClass *listlEIAlgorithmmUgR_Dictionary();
   static void listlEIAlgorithmmUgR_TClassManip(TClass*);
   static void *new_listlEIAlgorithmmUgR(void *p = 0);
   static void *newArray_listlEIAlgorithmmUgR(Long_t size, void *p);
   static void delete_listlEIAlgorithmmUgR(void *p);
   static void deleteArray_listlEIAlgorithmmUgR(void *p);
   static void destruct_listlEIAlgorithmmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const list<IAlgorithm*>*)
   {
      list<IAlgorithm*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(list<IAlgorithm*>));
      static ::ROOT::TGenericClassInfo 
         instance("list<IAlgorithm*>", -2, "list", 447,
                  typeid(list<IAlgorithm*>), DefineBehavior(ptr, ptr),
                  &listlEIAlgorithmmUgR_Dictionary, isa_proxy, 4,
                  sizeof(list<IAlgorithm*>) );
      instance.SetNew(&new_listlEIAlgorithmmUgR);
      instance.SetNewArray(&newArray_listlEIAlgorithmmUgR);
      instance.SetDelete(&delete_listlEIAlgorithmmUgR);
      instance.SetDeleteArray(&deleteArray_listlEIAlgorithmmUgR);
      instance.SetDestructor(&destruct_listlEIAlgorithmmUgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< list<IAlgorithm*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const list<IAlgorithm*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *listlEIAlgorithmmUgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const list<IAlgorithm*>*)0x0)->GetClass();
      listlEIAlgorithmmUgR_TClassManip(theClass);
   return theClass;
   }

   static void listlEIAlgorithmmUgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_listlEIAlgorithmmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) list<IAlgorithm*> : new list<IAlgorithm*>;
   }
   static void *newArray_listlEIAlgorithmmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) list<IAlgorithm*>[nElements] : new list<IAlgorithm*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_listlEIAlgorithmmUgR(void *p) {
      delete ((list<IAlgorithm*>*)p);
   }
   static void deleteArray_listlEIAlgorithmmUgR(void *p) {
      delete [] ((list<IAlgorithm*>*)p);
   }
   static void destruct_listlEIAlgorithmmUgR(void *p) {
      typedef list<IAlgorithm*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<IAlgorithm*>

namespace {
  void TriggerDictionaryInitialization_GaudiPythonDict_Impl() {
    static const char* headers[] = {
0    };
    static const char* includePaths[] = {
"/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/GaudiPython",
"/home/seuster/LCGStack/lcgcmake-install/Python/2.7.9/aarch64-ubuntu14.04-gcc49-opt/include/python2.7",
"/home/seuster/LCGStack/lcgcmake-install/clhep/2.1.4.1/aarch64-ubuntu14.04-gcc49-opt/include",
"/home/seuster/LCGStack/lcgcmake-install/AIDA/3.2.1/aarch64-ubuntu14.04-gcc49-opt/src/cpp",
"/home/seuster/LCGStack/lcgcmake-install/ROOT/6.02.99/aarch64-ubuntu14.04-gcc49-opt/include",
"/home/seuster/LCGStack/lcgcmake-install/Boost/1.56.0_python2.7/aarch64-ubuntu14.04-gcc49-opt/include/boost-1_56",
"/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/GaudiPluginService",
"/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/GaudiKernel",
"/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/GaudiUtils",
"/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/GaudiAlg",
"/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/build.aarch64-ubuntu14.04-gcc49-opt/include",
"/home/seuster/LCGStack/lcgcmake-install/ROOT/6.02.99/aarch64-ubuntu14.04-gcc49-opt/include",
"/home/jwsmith/ANA/2_GAUDI/Gaudi-26r1/build.aarch64-ubuntu14.04-gcc49-opt/GaudiPython/",
0
    };
    static const char* fwdDeclCode = 
R"DICTFWDDCLS(
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_Autoloading_Map;
namespace __gnu_cxx{struct dummy;}
namespace std{template <class _CharT> struct __attribute__((annotate("$clingAutoload$string")))  char_traits;
}
namespace std{template <typename > class __attribute__((annotate("$clingAutoload$string")))  allocator;
}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h")))  ID;}
class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  IInterface;
namespace GaudiPython{struct __attribute__((annotate("$clingAutoload$GaudiPython/Helpers.h")))  Helper;}
class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  Property;
class __attribute__((annotate("$clingAutoload$GaudiPython/AlgDecorators.h")))  IRegistry;
namespace std{struct __attribute__((annotate(R"ATTRDUMP(pattern@@@std::_Bit_reference*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  _Bit_reference;}
class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  IAlgorithm;
class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  IService;
class __attribute__((annotate("$clingAutoload$GaudiPython/Helpers.h")))  IAlgTool;
class __attribute__((annotate("$clingAutoload$GaudiKernel/Chrono.h")))  StatEntity;
namespace Gaudi{namespace Utils{namespace Histos{class __attribute__((annotate("$clingAutoload$GaudiUtils/HistoStrings.h")))  HistoStrings;}}}
namespace std{template <typename _Tp> struct __attribute__((annotate("$clingAutoload$string")))  less;
}
template <class T> class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  BoundedVerifier;

template <class T> class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  NullVerifier;

namespace Gaudi{class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  Histo1DDef;}
template <class T> class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  PropertyVerifier;

class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  PropertyCallbackFunctor;
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  PrintStat;}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  PrintTuple;}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  Print;}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  Print1D;}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  Print2DProf;}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  Print2D;}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  Print1DProf;}
namespace GaudiAlg{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiAlg::*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiAlg/Print.h")))  Print3D;}
class __attribute__((annotate("$clingAutoload$GaudiPython/AlgDecorators.h")))  GaudiAlgorithm;
class __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h")))  GaudiHistoAlg;
class __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  GaudiTupleAlg;
namespace GaudiPython{template <class ALGORITHM> class __attribute__((annotate("$clingAutoload$GaudiPython/Algorithm.h")))  PyAlg;
}
namespace Tuples{class __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  Tuple;}
namespace GaudiPython{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiPython::*Decorator*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  TupleDecorator;}
namespace GaudiPython{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiPython::*Decorator*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  TupleToolDecorator;}
namespace GaudiPython{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiPython::*Decorator*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h")))  HistoDecorator;}
namespace GaudiPython{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiPython::*Decorator*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiPython/AlgDecorators.h")))  AlgDecorator;}
namespace GaudiPython{class __attribute__((annotate(R"ATTRDUMP(pattern@@@GaudiPython::*Decorator*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  TupleAlgDecorator;}
class __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  ContainedObject;
namespace GaudiPython{template <class TYPE> struct __attribute__((annotate("$clingAutoload$GaudiPython/Printer.h")))  Printer;
}
class __attribute__((annotate("$clingAutoload$GaudiPython/AlgDecorators.h")))  DataObject;
class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  Algorithm;
template <class BASE> class __attribute__((annotate("$clingAutoload$GaudiPython/AlgDecorators.h")))  GaudiCommon;

template <class PBASE> class __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h")))  GaudiHistos;

template <class PBASE> class __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  GaudiTuples;

namespace Gaudi{namespace Utils{class __attribute__((annotate("$clingAutoload$GaudiUtils/Aida2ROOT.h")))  Aida2ROOT;}}
class __attribute__((annotate("$clingAutoload$GaudiKernel/Stat.h")))  Stat;
class __attribute__((annotate(R"ATTRDUMP(pattern@@@Chrono*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiKernel/Chrono.h")))  Chrono;
class __attribute__((annotate(R"ATTRDUMP(pattern@@@Chrono*)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiKernel/Chrono.h")))  ChronoEntity;
class __attribute__((annotate(R"ATTRDUMP(pattern@@@Property*Functor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  PropertyCallbackPointerFunctor;
template <class TYPE, class VERIFIER> class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  PropertyWithVerifier;

namespace AIDA{class __attribute__((annotate(R"ATTRDUMP(pattern@@@AIDA::I*)ATTRDUMP"))) IBaseHistogram;}
namespace AIDA{class __attribute__((annotate(R"ATTRDUMP(pattern@@@AIDA::I*)ATTRDUMP"))) IHistogram;}
namespace AIDA{class __attribute__((annotate(R"ATTRDUMP(pattern@@@AIDA::I*)ATTRDUMP"))) IProfile;}
namespace AIDA{class __attribute__((annotate(R"ATTRDUMP(pattern@@@AIDA::I*)ATTRDUMP"))) IAxis;}
namespace GaudiPython{class __attribute__((annotate("$clingAutoload$GaudiPython/Algorithm.h")))  PyAlgorithm;}
namespace GaudiPython{class __attribute__((annotate("$clingAutoload$GaudiPython/CallbackStreamBuf.h")))  CallbackStreamBuf;}
class __attribute__((annotate("$clingAutoload$GaudiKernel/ParticleProperty.h")))  ParticleProperty;
namespace Gaudi{class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  StringKey;}
namespace Gaudi{namespace Utils{class __attribute__((annotate("$clingAutoload$GaudiKernel/Algorithm.h")))  MapBase;}}
class __attribute__((annotate("$clingAutoload$GaudiAlg/IErrorTool.h")))  IErrorTool;
class __attribute__((annotate("$clingAutoload$GaudiAlg/IGenericTool.h")))  IGenericTool;
class __attribute__((annotate("$clingAutoload$GaudiAlg/IHistoTool.h")))  IHistoTool;
class __attribute__((annotate("$clingAutoload$GaudiPython/TupleDecorator.h")))  ITupleTool;
class __attribute__((annotate("$clingAutoload$GaudiAlg/ISequencerTimerTool.h")))  ISequencerTimerTool;
namespace Gaudi{class __attribute__((annotate("$clingAutoload$GaudiUtils/IFileCatalog.h")))  IFileCatalog;}
namespace Gaudi{class __attribute__((annotate("$clingAutoload$GaudiUtils/IFileCatalogMgr.h")))  IFileCatalogMgr;}
namespace Gaudi{class __attribute__((annotate("$clingAutoload$GaudiUtils/IIODataManager.h")))  IDataConnection;}
namespace Gaudi{class __attribute__((annotate("$clingAutoload$GaudiUtils/IIODataManager.h")))  IIODataManager;}
namespace Gaudi{namespace Utils{namespace Histos{class __attribute__((annotate("$clingAutoload$GaudiAlg/GaudiHistos.icpp")))  Table;}}}
namespace Gaudi{namespace Utils{class __attribute__((annotate("$clingAutoload$GaudiUtils/HistoStats.h")))  HistoStats;}}
namespace Gaudi{struct __attribute__((annotate("$clingAutoload$GaudiKernel/Range.h")))  RangeBase_;}
namespace Histos{typedef GaudiAlg::ID HistoID __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h"))) ;}
namespace GaudiAlg{typedef Histos::HistoID HistoID __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h"))) ;}
namespace Tuples{typedef GaudiAlg::ID TupleID __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h"))) ;}
namespace GaudiAlg{typedef Tuples::TupleID TupleID __attribute__((annotate("$clingAutoload$GaudiPython/HistoDecorator.h"))) ;}
)DICTFWDDCLS";
    static const char* payloadCode = R"DICTPAYLOAD(
#ifdef _Instantiations
  #undef _Instantiations
#endif

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef _Instantiations
  #define _Instantiations GaudiPython_Instantiations
#endif
#ifndef _GNU_SOURCE
  #define _GNU_SOURCE 1
#endif
#ifndef unix
  #define unix 1
#endif
#ifndef f2cFortran
  #define f2cFortran 1
#endif
#ifndef linux
  #define linux 1
#endif
#ifndef GAUDI_V20_COMPAT
  #define GAUDI_V20_COMPAT 1
#endif
#ifndef BOOST_FILESYSTEM_VERSION
  #define BOOST_FILESYSTEM_VERSION 3
#endif
#ifndef BOOST_SPIRIT_USE_PHOENIX_V3
  #define BOOST_SPIRIT_USE_PHOENIX_V3 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// $Id:
// ============================================================================
// CVS tag $Name:  $, version $Revision: 1.37 $
// ============================================================================
// Python must always be the first.
#include "Python.h"

#include "GaudiKernel/Algorithm.h"
#include "GaudiKernel/ParticleProperty.h"
#include "GaudiKernel/CArrayAsProperty.h"
#include "GaudiKernel/Property.h"
#include "GaudiKernel/PropertyCallbackFunctor.h"
#include "GaudiKernel/Chrono.h"
#include "GaudiKernel/ChronoEntity.h"
#include "GaudiKernel/Stat.h"
#include "GaudiKernel/StatEntity.h"
#include "GaudiKernel/SerializeSTL.h"
#include "GaudiKernel/StringKey.h"
#include "GaudiKernel/MapBase.h"
#include "GaudiKernel/Map.h"
#include "GaudiKernel/HashMap.h"
#include "GaudiKernel/VectorMap.h"
#include "GaudiKernel/Range.h"

#ifdef _WIN32
#include "GaudiKernel/GaudiHandle.h"
#endif

#ifdef __ICC
// disable icc remark #177: declared but never referenced
#pragma warning(disable:177)
// disable icc warning #1125: function "C::X()" is hidden by "Y::X" -- virtual function override intended?
#pragma warning(disable:1125)
#endif

// Force visibility of the classes
#define class class GAUDI_API
#ifdef _WIN32
#include "AIDA/IAnnotation.h"
#endif
#include "AIDA/IHistogram.h"
#include "AIDA/IHistogram1D.h"
#include "AIDA/IHistogram2D.h"
#include "AIDA/IHistogram3D.h"
#include "AIDA/IProfile1D.h"
#include "AIDA/IProfile2D.h"
#include "AIDA/IAxis.h"
#undef class

#include "GaudiPython/Helpers.h"

#include "GaudiPython/GaudiPython.h"
#include "GaudiPython/Interface.h"
#include "GaudiPython/Algorithm.h"
#include "GaudiPython/AlgDecorators.h"
#include "GaudiPython/HistoDecorator.h"
#include "GaudiPython/TupleDecorator.h"
#include "GaudiPython/Printer.h"
#include "GaudiPython/CallbackStreamBuf.h"

#include "GaudiAlg/Tuple.h"
#include "GaudiAlg/Print.h"
#include "GaudiAlg/GaudiTupleAlg.h"
#include "GaudiAlg/GaudiHistoAlg.h"
#include "GaudiAlg/GaudiHistoID.h"
#include "GaudiAlg/GaudiAlgorithm.h"
#include "GaudiAlg/GaudiCommon.h"
#include "GaudiAlg/IErrorTool.h"
#include "GaudiAlg/IGenericTool.h"
#include "GaudiAlg/IHistoTool.h"
#include "GaudiAlg/ITupleTool.h"
#include "GaudiAlg/ISequencerTimerTool.h"
// Added to avoid warnings about inlined functions never implemented.
#include "GaudiAlg/GaudiHistos.icpp"

#include "GaudiUtils/Aida2ROOT.h"
#include "GaudiUtils/IFileCatalog.h"
#include "GaudiUtils/IFileCatalogMgr.h"
#include "GaudiUtils/IIODataManager.h"
#include "GaudiUtils/HistoStats.h"
#include "GaudiUtils/HistoDump.h"
#include "GaudiUtils/HistoStrings.h"

#include <iostream>
#include <istream>
#include <sstream>


template class std::basic_stringstream<char>;

// needed to find operator<< implemented in GaudiUtils.
using namespace GaudiUtils;

namespace GaudiPython
{

  template <class TYPE>
  struct _Property
  {
    TYPE                       m_type ;
    SimpleProperty<TYPE>       m_prop ;
    SimplePropertyRef<TYPE>    m_ref  ;
    // constructor
    _Property()
      : m_type()
      , m_prop()
      , m_ref ( "" , m_type )
    {}
    //
  } ;

  //--- Template instantiations
  struct __Instantiations
  {
    std::vector<Property*>              i0      ;
    std::vector<const Property*>        i00     ;
    std::vector<IRegistry*>             i00000  ;

    std::allocator<IRegistry*>          a0  ;
    std::allocator<IAlgorithm*>         a1  ;
    std::allocator<IService*>           a2  ;

    std::list<IAlgorithm*>              i01     ;
    std::list<IService*>                i02     ;

    std::vector<IService*>              i05_1   ;
    std::vector<IAlgTool*>              i05_2   ;
    std::vector<const StatEntity*>      i05_3   ;
    std::vector<GaudiAlg::ID>           i05_4   ;
    std::vector<AIDA::IHistogram1D*>    i05_5   ;
    std::vector<AIDA::IHistogram2D*>    i05_6   ;
    std::vector<AIDA::IHistogram3D*>    i05_7   ;
    std::vector<AIDA::IProfile1D*>      i05_8   ;
    std::vector<AIDA::IProfile2D*>      i05_9   ;

    //Gaudi::IIODataManager              *gu_i1000;

    GaudiUtils::VectorMap<int,double>   i034 ;


    GaudiPython::PyAlg<GaudiAlgorithm>  _alg0 ;
    GaudiPython::PyAlg<GaudiHistoAlg>   _alg1 ;
    GaudiPython::PyAlg<GaudiTupleAlg>   _alg2 ;

    GaudiPython::Matrix _mtrx ;
    GaudiPython::Vector _vctr ;
    std::vector<std::vector<double> > _vct1 ;

    // primitives:
    _Property<bool>                                               pp_01 ;
    _Property<char>                                               pp_02 ;
    _Property<signed char>                                        pp_03 ;
    _Property<unsigned char>                                      pp_04 ;
    _Property<short>                                              pp_05 ;
    _Property<unsigned short>                                     pp_06 ;
    _Property<int>                                                pp_07 ;
    _Property<unsigned int>                                       pp_08 ;
    _Property<long>                                               pp_09 ;
    _Property<unsigned long>                                      pp_10 ;
    _Property<long long>                                          pp_11 ;
    _Property<unsigned long long>                                 pp_12 ;
    _Property<float>                                              pp_13 ;
    _Property<double>                                             pp_14 ;
    _Property<long double>                                        pp_15 ;
    _Property<std::string>                                        pp_16 ;

    // vectors of primitives
    _Property<std::vector<bool> >                                 vp_01 ;
    _Property<std::vector<char> >                                 vp_02 ;
    _Property<std::vector<signed char> >                          vp_03 ;
    _Property<std::vector<unsigned char> >                        vp_04 ;
    _Property<std::vector<short> >                                vp_05 ;
    _Property<std::vector<unsigned short> >                       vp_06 ;
    _Property<std::vector<int> >                                  vp_07 ;
    _Property<std::vector<unsigned int> >                         vp_08 ;
    _Property<std::vector<long> >                                 vp_09 ;
    _Property<std::vector<unsigned long> >                        vp_10 ;
    _Property<std::vector<long long> >                            vp_11 ;
    _Property<std::vector<unsigned long long> >                   vp_12 ;
    _Property<std::vector<float> >                                vp_13 ;
    _Property<std::vector<double> >                               vp_14 ;
    _Property<std::vector<long double> >                          vp_15 ;
    _Property<std::vector<std::string> >                          vp_16 ;

    // some extended types
    _Property<std::pair<int,int> >                                ep_01 ;
    _Property<std::pair<double,double> >                          ep_02 ;
    _Property<std::vector<std::pair<double,double> > >            ep_04 ;
    _Property<std::vector<std::vector<std::string> > >            ep_05 ;
    _Property<std::vector<std::vector<double> > >                 ep_06 ;
    _Property<std::map<int,double> >                              ep_07 ;
    _Property<std::map<std::string,std::string> >                 ep_08 ;
    _Property<std::map<std::string,int> >                         ep_09 ;
    _Property<std::map<std::string,double> >                      ep_10 ;
    _Property<std::map<std::string,std::vector<std::string> > >   ep_11 ;
    _Property<std::map<std::string,std::vector<int> > >           ep_12 ;
    _Property<std::map<std::string,std::vector<double> > >        ep_13 ;

    __Instantiations  () ;
    ~__Instantiations () ;

  };

} // end of namespace GaudiPython

namespace __gnu_cxx { struct dummy {}; }  // hack to please CINT

#ifdef _WIN32
#pragma warning ( disable : 4345 )
#pragma warning ( disable : 4624 )
#endif

#ifdef __ICC
// disable icc warning #191: type qualifier is meaningless on cast type
// ... a lot of noise produced by the dictionary
#pragma warning(disable:191)
#endif

// ============================================================================
// The END
// ============================================================================

#undef  _BACKWARD_BACKWARD_WARNING_H
)DICTPAYLOAD";
    static const char* classesHeaders[]={
"", payloadCode, "@",
"AIDA::IAxis", payloadCode, "@",
"AIDA::IAxis::(anonymous)", payloadCode, "@",
"AIDA::IBaseHistogram", payloadCode, "@",
"AIDA::IHistogram", payloadCode, "@",
"AIDA::IHistogram1D", payloadCode, "@",
"AIDA::IHistogram2D", payloadCode, "@",
"AIDA::IHistogram3D", payloadCode, "@",
"AIDA::IProfile", payloadCode, "@",
"AIDA::IProfile1D", payloadCode, "@",
"AIDA::IProfile2D", payloadCode, "@",
"BoundedVerifier<Gaudi::Histo1DDef>", payloadCode, "@",
"BoundedVerifier<Long64_t>", payloadCode, "@",
"BoundedVerifier<ULong64_t>", payloadCode, "@",
"BoundedVerifier<bool>", payloadCode, "@",
"BoundedVerifier<char>", payloadCode, "@",
"BoundedVerifier<double>", payloadCode, "@",
"BoundedVerifier<float>", payloadCode, "@",
"BoundedVerifier<int>", payloadCode, "@",
"BoundedVerifier<long double>", payloadCode, "@",
"BoundedVerifier<long>", payloadCode, "@",
"BoundedVerifier<map<int,double> >", payloadCode, "@",
"BoundedVerifier<map<string,double> >", payloadCode, "@",
"BoundedVerifier<map<string,int> >", payloadCode, "@",
"BoundedVerifier<map<string,string> >", payloadCode, "@",
"BoundedVerifier<map<string,vector<double> > >", payloadCode, "@",
"BoundedVerifier<map<string,vector<int> > >", payloadCode, "@",
"BoundedVerifier<map<string,vector<string> > >", payloadCode, "@",
"BoundedVerifier<pair<double,double> >", payloadCode, "@",
"BoundedVerifier<pair<int,int> >", payloadCode, "@",
"BoundedVerifier<short>", payloadCode, "@",
"BoundedVerifier<signed char>", payloadCode, "@",
"BoundedVerifier<string>", payloadCode, "@",
"BoundedVerifier<unsigned char>", payloadCode, "@",
"BoundedVerifier<unsigned int>", payloadCode, "@",
"BoundedVerifier<unsigned long>", payloadCode, "@",
"BoundedVerifier<unsigned short>", payloadCode, "@",
"BoundedVerifier<vector<Long64_t> >", payloadCode, "@",
"BoundedVerifier<vector<ULong64_t> >", payloadCode, "@",
"BoundedVerifier<vector<bool> >", payloadCode, "@",
"BoundedVerifier<vector<char> >", payloadCode, "@",
"BoundedVerifier<vector<double> >", payloadCode, "@",
"BoundedVerifier<vector<float> >", payloadCode, "@",
"BoundedVerifier<vector<int> >", payloadCode, "@",
"BoundedVerifier<vector<long double> >", payloadCode, "@",
"BoundedVerifier<vector<long> >", payloadCode, "@",
"BoundedVerifier<vector<pair<double,double> > >", payloadCode, "@",
"BoundedVerifier<vector<short> >", payloadCode, "@",
"BoundedVerifier<vector<signed char> >", payloadCode, "@",
"BoundedVerifier<vector<string> >", payloadCode, "@",
"BoundedVerifier<vector<unsigned char> >", payloadCode, "@",
"BoundedVerifier<vector<unsigned int> >", payloadCode, "@",
"BoundedVerifier<vector<unsigned long> >", payloadCode, "@",
"BoundedVerifier<vector<unsigned short> >", payloadCode, "@",
"BoundedVerifier<vector<vector<double> > >", payloadCode, "@",
"BoundedVerifier<vector<vector<string> > >", payloadCode, "@",
"Chrono", payloadCode, "@",
"ChronoEntity", payloadCode, "@",
"Gaudi::IDataConnection", payloadCode, "@",
"Gaudi::IFileCatalog", payloadCode, "@",
"Gaudi::IFileCatalogMgr", payloadCode, "@",
"Gaudi::IIODataManager", payloadCode, "@",
"Gaudi::RangeBase_", payloadCode, "@",
"Gaudi::StringKey", payloadCode, "@",
"Gaudi::Utils::Aida2ROOT", payloadCode, "@",
"Gaudi::Utils::HistoStats", payloadCode, "@",
"Gaudi::Utils::Histos::Formats::Format", payloadCode, "@",
"Gaudi::Utils::Histos::Formats::format", payloadCode, "@",
"Gaudi::Utils::Histos::Formats::header", payloadCode, "@",
"Gaudi::Utils::Histos::HistoStrings", payloadCode, "@",
"Gaudi::Utils::Histos::Table", payloadCode, "@",
"Gaudi::Utils::Histos::format", payloadCode, "@",
"Gaudi::Utils::Histos::histoDump", payloadCode, "@",
"Gaudi::Utils::Histos::path", payloadCode, "@",
"Gaudi::Utils::MapBase", payloadCode, "@",
"Gaudi::Utils::hasProperty", payloadCode, "@",
"GaudiAlg::HistoID", payloadCode, "@",
"GaudiAlg::ID", payloadCode, "@",
"GaudiAlg::Print", payloadCode, "@",
"GaudiAlg::Print1D", payloadCode, "@",
"GaudiAlg::Print1DProf", payloadCode, "@",
"GaudiAlg::Print2D", payloadCode, "@",
"GaudiAlg::Print2DProf", payloadCode, "@",
"GaudiAlg::Print3D", payloadCode, "@",
"GaudiAlg::PrintStat", payloadCode, "@",
"GaudiAlg::PrintTuple", payloadCode, "@",
"GaudiAlg::TupleID", payloadCode, "@",
"GaudiAlgorithm", payloadCode, "@",
"GaudiCommon<Algorithm>", payloadCode, "@",
"GaudiHistoAlg", payloadCode, "@",
"GaudiHistos<GaudiAlgorithm>", payloadCode, "@",
"GaudiPython::AlgDecorator", payloadCode, "@",
"GaudiPython::CallbackStreamBuf", payloadCode, "@",
"GaudiPython::Helper", payloadCode, "@",
"GaudiPython::HistoDecorator", payloadCode, "@",
"GaudiPython::Printer<ContainedObject>", payloadCode, "@",
"GaudiPython::Printer<DataObject>", payloadCode, "@",
"GaudiPython::PyAlg<GaudiAlgorithm>", payloadCode, "@",
"GaudiPython::PyAlg<GaudiHistoAlg>", payloadCode, "@",
"GaudiPython::PyAlg<GaudiTupleAlg>", payloadCode, "@",
"GaudiPython::PyAlgorithm", payloadCode, "@",
"GaudiPython::TupleAlgDecorator", payloadCode, "@",
"GaudiPython::TupleDecorator", payloadCode, "@",
"GaudiPython::TupleToolDecorator", payloadCode, "@",
"GaudiTupleAlg", payloadCode, "@",
"GaudiTuples<GaudiHistoAlg>", payloadCode, "@",
"IErrorTool", payloadCode, "@",
"IGenericTool", payloadCode, "@",
"IHistoTool", payloadCode, "@",
"ISequencerTimerTool", payloadCode, "@",
"ITupleTool", payloadCode, "@",
"ParticleProperty", payloadCode, "@",
"PropertyCallbackFunctor", payloadCode, "@",
"PropertyCallbackPointerFunctor", payloadCode, "@",
"PropertyVerifier<Gaudi::Histo1DDef>", payloadCode, "@",
"PropertyVerifier<Long64_t>", payloadCode, "@",
"PropertyVerifier<ULong64_t>", payloadCode, "@",
"PropertyVerifier<bool>", payloadCode, "@",
"PropertyVerifier<char>", payloadCode, "@",
"PropertyVerifier<double>", payloadCode, "@",
"PropertyVerifier<float>", payloadCode, "@",
"PropertyVerifier<int>", payloadCode, "@",
"PropertyVerifier<long double>", payloadCode, "@",
"PropertyVerifier<long>", payloadCode, "@",
"PropertyVerifier<map<int,double> >", payloadCode, "@",
"PropertyVerifier<map<string,double> >", payloadCode, "@",
"PropertyVerifier<map<string,int> >", payloadCode, "@",
"PropertyVerifier<map<string,string> >", payloadCode, "@",
"PropertyVerifier<map<string,vector<double> > >", payloadCode, "@",
"PropertyVerifier<map<string,vector<int> > >", payloadCode, "@",
"PropertyVerifier<map<string,vector<string> > >", payloadCode, "@",
"PropertyVerifier<pair<double,double> >", payloadCode, "@",
"PropertyVerifier<pair<int,int> >", payloadCode, "@",
"PropertyVerifier<short>", payloadCode, "@",
"PropertyVerifier<signed char>", payloadCode, "@",
"PropertyVerifier<string>", payloadCode, "@",
"PropertyVerifier<unsigned char>", payloadCode, "@",
"PropertyVerifier<unsigned int>", payloadCode, "@",
"PropertyVerifier<unsigned long>", payloadCode, "@",
"PropertyVerifier<unsigned short>", payloadCode, "@",
"PropertyVerifier<vector<Long64_t> >", payloadCode, "@",
"PropertyVerifier<vector<ULong64_t> >", payloadCode, "@",
"PropertyVerifier<vector<bool> >", payloadCode, "@",
"PropertyVerifier<vector<char> >", payloadCode, "@",
"PropertyVerifier<vector<double> >", payloadCode, "@",
"PropertyVerifier<vector<float> >", payloadCode, "@",
"PropertyVerifier<vector<int> >", payloadCode, "@",
"PropertyVerifier<vector<long double> >", payloadCode, "@",
"PropertyVerifier<vector<long> >", payloadCode, "@",
"PropertyVerifier<vector<pair<double,double> > >", payloadCode, "@",
"PropertyVerifier<vector<short> >", payloadCode, "@",
"PropertyVerifier<vector<signed char> >", payloadCode, "@",
"PropertyVerifier<vector<string> >", payloadCode, "@",
"PropertyVerifier<vector<unsigned char> >", payloadCode, "@",
"PropertyVerifier<vector<unsigned int> >", payloadCode, "@",
"PropertyVerifier<vector<unsigned long> >", payloadCode, "@",
"PropertyVerifier<vector<unsigned short> >", payloadCode, "@",
"PropertyVerifier<vector<vector<double> > >", payloadCode, "@",
"PropertyVerifier<vector<vector<string> > >", payloadCode, "@",
"PropertyWithValue<Long64_t>", payloadCode, "@",
"PropertyWithValue<ULong64_t>", payloadCode, "@",
"PropertyWithValue<bool>", payloadCode, "@",
"PropertyWithValue<char>", payloadCode, "@",
"PropertyWithValue<double>", payloadCode, "@",
"PropertyWithValue<float>", payloadCode, "@",
"PropertyWithValue<int>", payloadCode, "@",
"PropertyWithValue<long double>", payloadCode, "@",
"PropertyWithValue<long>", payloadCode, "@",
"PropertyWithValue<map<int,double> >", payloadCode, "@",
"PropertyWithValue<map<string,double> >", payloadCode, "@",
"PropertyWithValue<map<string,int> >", payloadCode, "@",
"PropertyWithValue<map<string,string> >", payloadCode, "@",
"PropertyWithValue<map<string,vector<double> > >", payloadCode, "@",
"PropertyWithValue<map<string,vector<int> > >", payloadCode, "@",
"PropertyWithValue<map<string,vector<string> > >", payloadCode, "@",
"PropertyWithValue<pair<double,double> >", payloadCode, "@",
"PropertyWithValue<pair<int,int> >", payloadCode, "@",
"PropertyWithValue<short>", payloadCode, "@",
"PropertyWithValue<signed char>", payloadCode, "@",
"PropertyWithValue<string>", payloadCode, "@",
"PropertyWithValue<unsigned char>", payloadCode, "@",
"PropertyWithValue<unsigned int>", payloadCode, "@",
"PropertyWithValue<unsigned long>", payloadCode, "@",
"PropertyWithValue<unsigned short>", payloadCode, "@",
"PropertyWithValue<vector<Long64_t> >", payloadCode, "@",
"PropertyWithValue<vector<ULong64_t> >", payloadCode, "@",
"PropertyWithValue<vector<bool> >", payloadCode, "@",
"PropertyWithValue<vector<char> >", payloadCode, "@",
"PropertyWithValue<vector<double> >", payloadCode, "@",
"PropertyWithValue<vector<float> >", payloadCode, "@",
"PropertyWithValue<vector<int> >", payloadCode, "@",
"PropertyWithValue<vector<long double> >", payloadCode, "@",
"PropertyWithValue<vector<long> >", payloadCode, "@",
"PropertyWithValue<vector<pair<double,double> > >", payloadCode, "@",
"PropertyWithValue<vector<short> >", payloadCode, "@",
"PropertyWithValue<vector<signed char> >", payloadCode, "@",
"PropertyWithValue<vector<string> >", payloadCode, "@",
"PropertyWithValue<vector<unsigned char> >", payloadCode, "@",
"PropertyWithValue<vector<unsigned int> >", payloadCode, "@",
"PropertyWithValue<vector<unsigned long> >", payloadCode, "@",
"PropertyWithValue<vector<unsigned short> >", payloadCode, "@",
"PropertyWithValue<vector<vector<double> > >", payloadCode, "@",
"PropertyWithValue<vector<vector<string> > >", payloadCode, "@",
"PropertyWithVerifier<Long64_t,BoundedVerifier<Long64_t> >", payloadCode, "@",
"PropertyWithVerifier<Long64_t,NullVerifier<Long64_t> >", payloadCode, "@",
"PropertyWithVerifier<ULong64_t,BoundedVerifier<ULong64_t> >", payloadCode, "@",
"PropertyWithVerifier<ULong64_t,NullVerifier<ULong64_t> >", payloadCode, "@",
"PropertyWithVerifier<bool,BoundedVerifier<bool> >", payloadCode, "@",
"PropertyWithVerifier<bool,NullVerifier<bool> >", payloadCode, "@",
"PropertyWithVerifier<char,BoundedVerifier<char> >", payloadCode, "@",
"PropertyWithVerifier<char,NullVerifier<char> >", payloadCode, "@",
"PropertyWithVerifier<double,BoundedVerifier<double> >", payloadCode, "@",
"PropertyWithVerifier<double,NullVerifier<double> >", payloadCode, "@",
"PropertyWithVerifier<float,BoundedVerifier<float> >", payloadCode, "@",
"PropertyWithVerifier<float,NullVerifier<float> >", payloadCode, "@",
"PropertyWithVerifier<int,BoundedVerifier<int> >", payloadCode, "@",
"PropertyWithVerifier<int,NullVerifier<int> >", payloadCode, "@",
"PropertyWithVerifier<long double,BoundedVerifier<long double> >", payloadCode, "@",
"PropertyWithVerifier<long double,NullVerifier<long double> >", payloadCode, "@",
"PropertyWithVerifier<long,BoundedVerifier<long> >", payloadCode, "@",
"PropertyWithVerifier<long,NullVerifier<long> >", payloadCode, "@",
"PropertyWithVerifier<map<int,double>,BoundedVerifier<map<int,double> > >", payloadCode, "@",
"PropertyWithVerifier<map<int,double>,NullVerifier<map<int,double> > >", payloadCode, "@",
"PropertyWithVerifier<map<string,double>,BoundedVerifier<map<string,double> > >", payloadCode, "@",
"PropertyWithVerifier<map<string,double>,NullVerifier<map<string,double> > >", payloadCode, "@",
"PropertyWithVerifier<map<string,int>,BoundedVerifier<map<string,int> > >", payloadCode, "@",
"PropertyWithVerifier<map<string,int>,NullVerifier<map<string,int> > >", payloadCode, "@",
"PropertyWithVerifier<map<string,string>,BoundedVerifier<map<string,string> > >", payloadCode, "@",
"PropertyWithVerifier<map<string,string>,NullVerifier<map<string,string> > >", payloadCode, "@",
"PropertyWithVerifier<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >", payloadCode, "@",
"PropertyWithVerifier<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >", payloadCode, "@",
"PropertyWithVerifier<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >", payloadCode, "@",
"PropertyWithVerifier<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >", payloadCode, "@",
"PropertyWithVerifier<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >", payloadCode, "@",
"PropertyWithVerifier<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >", payloadCode, "@",
"PropertyWithVerifier<pair<double,double>,BoundedVerifier<pair<double,double> > >", payloadCode, "@",
"PropertyWithVerifier<pair<double,double>,NullVerifier<pair<double,double> > >", payloadCode, "@",
"PropertyWithVerifier<pair<int,int>,BoundedVerifier<pair<int,int> > >", payloadCode, "@",
"PropertyWithVerifier<pair<int,int>,NullVerifier<pair<int,int> > >", payloadCode, "@",
"PropertyWithVerifier<short,BoundedVerifier<short> >", payloadCode, "@",
"PropertyWithVerifier<short,NullVerifier<short> >", payloadCode, "@",
"PropertyWithVerifier<signed char,BoundedVerifier<signed char> >", payloadCode, "@",
"PropertyWithVerifier<signed char,NullVerifier<signed char> >", payloadCode, "@",
"PropertyWithVerifier<string,BoundedVerifier<string> >", payloadCode, "@",
"PropertyWithVerifier<string,NullVerifier<string> >", payloadCode, "@",
"PropertyWithVerifier<unsigned char,BoundedVerifier<unsigned char> >", payloadCode, "@",
"PropertyWithVerifier<unsigned char,NullVerifier<unsigned char> >", payloadCode, "@",
"PropertyWithVerifier<unsigned int,BoundedVerifier<unsigned int> >", payloadCode, "@",
"PropertyWithVerifier<unsigned int,NullVerifier<unsigned int> >", payloadCode, "@",
"PropertyWithVerifier<unsigned long,BoundedVerifier<unsigned long> >", payloadCode, "@",
"PropertyWithVerifier<unsigned long,NullVerifier<unsigned long> >", payloadCode, "@",
"PropertyWithVerifier<unsigned short,BoundedVerifier<unsigned short> >", payloadCode, "@",
"PropertyWithVerifier<unsigned short,NullVerifier<unsigned short> >", payloadCode, "@",
"PropertyWithVerifier<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >", payloadCode, "@",
"PropertyWithVerifier<vector<Long64_t>,NullVerifier<vector<Long64_t> > >", payloadCode, "@",
"PropertyWithVerifier<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >", payloadCode, "@",
"PropertyWithVerifier<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >", payloadCode, "@",
"PropertyWithVerifier<vector<bool>,BoundedVerifier<vector<bool> > >", payloadCode, "@",
"PropertyWithVerifier<vector<bool>,NullVerifier<vector<bool> > >", payloadCode, "@",
"PropertyWithVerifier<vector<char>,BoundedVerifier<vector<char> > >", payloadCode, "@",
"PropertyWithVerifier<vector<char>,NullVerifier<vector<char> > >", payloadCode, "@",
"PropertyWithVerifier<vector<double>,BoundedVerifier<vector<double> > >", payloadCode, "@",
"PropertyWithVerifier<vector<double>,NullVerifier<vector<double> > >", payloadCode, "@",
"PropertyWithVerifier<vector<float>,BoundedVerifier<vector<float> > >", payloadCode, "@",
"PropertyWithVerifier<vector<float>,NullVerifier<vector<float> > >", payloadCode, "@",
"PropertyWithVerifier<vector<int>,BoundedVerifier<vector<int> > >", payloadCode, "@",
"PropertyWithVerifier<vector<int>,NullVerifier<vector<int> > >", payloadCode, "@",
"PropertyWithVerifier<vector<long double>,BoundedVerifier<vector<long double> > >", payloadCode, "@",
"PropertyWithVerifier<vector<long double>,NullVerifier<vector<long double> > >", payloadCode, "@",
"PropertyWithVerifier<vector<long>,BoundedVerifier<vector<long> > >", payloadCode, "@",
"PropertyWithVerifier<vector<long>,NullVerifier<vector<long> > >", payloadCode, "@",
"PropertyWithVerifier<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >", payloadCode, "@",
"PropertyWithVerifier<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >", payloadCode, "@",
"PropertyWithVerifier<vector<short>,BoundedVerifier<vector<short> > >", payloadCode, "@",
"PropertyWithVerifier<vector<short>,NullVerifier<vector<short> > >", payloadCode, "@",
"PropertyWithVerifier<vector<signed char>,BoundedVerifier<vector<signed char> > >", payloadCode, "@",
"PropertyWithVerifier<vector<signed char>,NullVerifier<vector<signed char> > >", payloadCode, "@",
"PropertyWithVerifier<vector<string>,BoundedVerifier<vector<string> > >", payloadCode, "@",
"PropertyWithVerifier<vector<string>,NullVerifier<vector<string> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned char>,NullVerifier<vector<unsigned char> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned int>,NullVerifier<vector<unsigned int> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned long>,NullVerifier<vector<unsigned long> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >", payloadCode, "@",
"PropertyWithVerifier<vector<unsigned short>,NullVerifier<vector<unsigned short> > >", payloadCode, "@",
"PropertyWithVerifier<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >", payloadCode, "@",
"PropertyWithVerifier<vector<vector<double> >,NullVerifier<vector<vector<double> > > >", payloadCode, "@",
"PropertyWithVerifier<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >", payloadCode, "@",
"PropertyWithVerifier<vector<vector<string> >,NullVerifier<vector<vector<string> > > >", payloadCode, "@",
"SimpleProperty<Long64_t,BoundedVerifier<Long64_t> >", payloadCode, "@",
"SimpleProperty<ULong64_t,BoundedVerifier<ULong64_t> >", payloadCode, "@",
"SimpleProperty<bool,BoundedVerifier<bool> >", payloadCode, "@",
"SimpleProperty<char,BoundedVerifier<char> >", payloadCode, "@",
"SimpleProperty<double,BoundedVerifier<double> >", payloadCode, "@",
"SimpleProperty<float,BoundedVerifier<float> >", payloadCode, "@",
"SimpleProperty<int,BoundedVerifier<int> >", payloadCode, "@",
"SimpleProperty<long double,BoundedVerifier<long double> >", payloadCode, "@",
"SimpleProperty<long,BoundedVerifier<long> >", payloadCode, "@",
"SimpleProperty<map<int,double>,BoundedVerifier<map<int,double> > >", payloadCode, "@",
"SimpleProperty<map<string,double>,BoundedVerifier<map<string,double> > >", payloadCode, "@",
"SimpleProperty<map<string,int>,BoundedVerifier<map<string,int> > >", payloadCode, "@",
"SimpleProperty<map<string,string>,BoundedVerifier<map<string,string> > >", payloadCode, "@",
"SimpleProperty<map<string,vector<double> >,BoundedVerifier<map<string,vector<double> > > >", payloadCode, "@",
"SimpleProperty<map<string,vector<int> >,BoundedVerifier<map<string,vector<int> > > >", payloadCode, "@",
"SimpleProperty<map<string,vector<string> >,BoundedVerifier<map<string,vector<string> > > >", payloadCode, "@",
"SimpleProperty<pair<double,double>,BoundedVerifier<pair<double,double> > >", payloadCode, "@",
"SimpleProperty<pair<int,int>,BoundedVerifier<pair<int,int> > >", payloadCode, "@",
"SimpleProperty<short,BoundedVerifier<short> >", payloadCode, "@",
"SimpleProperty<signed char,BoundedVerifier<signed char> >", payloadCode, "@",
"SimpleProperty<string,BoundedVerifier<string> >", payloadCode, "@",
"SimpleProperty<unsigned char,BoundedVerifier<unsigned char> >", payloadCode, "@",
"SimpleProperty<unsigned int,BoundedVerifier<unsigned int> >", payloadCode, "@",
"SimpleProperty<unsigned long,BoundedVerifier<unsigned long> >", payloadCode, "@",
"SimpleProperty<unsigned short,BoundedVerifier<unsigned short> >", payloadCode, "@",
"SimpleProperty<vector<Long64_t>,BoundedVerifier<vector<Long64_t> > >", payloadCode, "@",
"SimpleProperty<vector<ULong64_t>,BoundedVerifier<vector<ULong64_t> > >", payloadCode, "@",
"SimpleProperty<vector<bool>,BoundedVerifier<vector<bool> > >", payloadCode, "@",
"SimpleProperty<vector<char>,BoundedVerifier<vector<char> > >", payloadCode, "@",
"SimpleProperty<vector<double>,BoundedVerifier<vector<double> > >", payloadCode, "@",
"SimpleProperty<vector<float>,BoundedVerifier<vector<float> > >", payloadCode, "@",
"SimpleProperty<vector<int>,BoundedVerifier<vector<int> > >", payloadCode, "@",
"SimpleProperty<vector<long double>,BoundedVerifier<vector<long double> > >", payloadCode, "@",
"SimpleProperty<vector<long>,BoundedVerifier<vector<long> > >", payloadCode, "@",
"SimpleProperty<vector<pair<double,double> >,BoundedVerifier<vector<pair<double,double> > > >", payloadCode, "@",
"SimpleProperty<vector<short>,BoundedVerifier<vector<short> > >", payloadCode, "@",
"SimpleProperty<vector<signed char>,BoundedVerifier<vector<signed char> > >", payloadCode, "@",
"SimpleProperty<vector<string>,BoundedVerifier<vector<string> > >", payloadCode, "@",
"SimpleProperty<vector<unsigned char>,BoundedVerifier<vector<unsigned char> > >", payloadCode, "@",
"SimpleProperty<vector<unsigned int>,BoundedVerifier<vector<unsigned int> > >", payloadCode, "@",
"SimpleProperty<vector<unsigned long>,BoundedVerifier<vector<unsigned long> > >", payloadCode, "@",
"SimpleProperty<vector<unsigned short>,BoundedVerifier<vector<unsigned short> > >", payloadCode, "@",
"SimpleProperty<vector<vector<double> >,BoundedVerifier<vector<vector<double> > > >", payloadCode, "@",
"SimpleProperty<vector<vector<string> >,BoundedVerifier<vector<vector<string> > > >", payloadCode, "@",
"SimplePropertyRef<Long64_t,NullVerifier<Long64_t> >", payloadCode, "@",
"SimplePropertyRef<ULong64_t,NullVerifier<ULong64_t> >", payloadCode, "@",
"SimplePropertyRef<bool,NullVerifier<bool> >", payloadCode, "@",
"SimplePropertyRef<char,NullVerifier<char> >", payloadCode, "@",
"SimplePropertyRef<double,NullVerifier<double> >", payloadCode, "@",
"SimplePropertyRef<float,NullVerifier<float> >", payloadCode, "@",
"SimplePropertyRef<int,NullVerifier<int> >", payloadCode, "@",
"SimplePropertyRef<long double,NullVerifier<long double> >", payloadCode, "@",
"SimplePropertyRef<long,NullVerifier<long> >", payloadCode, "@",
"SimplePropertyRef<map<int,double>,NullVerifier<map<int,double> > >", payloadCode, "@",
"SimplePropertyRef<map<string,double>,NullVerifier<map<string,double> > >", payloadCode, "@",
"SimplePropertyRef<map<string,int>,NullVerifier<map<string,int> > >", payloadCode, "@",
"SimplePropertyRef<map<string,string>,NullVerifier<map<string,string> > >", payloadCode, "@",
"SimplePropertyRef<map<string,vector<double> >,NullVerifier<map<string,vector<double> > > >", payloadCode, "@",
"SimplePropertyRef<map<string,vector<int> >,NullVerifier<map<string,vector<int> > > >", payloadCode, "@",
"SimplePropertyRef<map<string,vector<string> >,NullVerifier<map<string,vector<string> > > >", payloadCode, "@",
"SimplePropertyRef<pair<double,double>,NullVerifier<pair<double,double> > >", payloadCode, "@",
"SimplePropertyRef<pair<int,int>,NullVerifier<pair<int,int> > >", payloadCode, "@",
"SimplePropertyRef<short,NullVerifier<short> >", payloadCode, "@",
"SimplePropertyRef<signed char,NullVerifier<signed char> >", payloadCode, "@",
"SimplePropertyRef<string,NullVerifier<string> >", payloadCode, "@",
"SimplePropertyRef<unsigned char,NullVerifier<unsigned char> >", payloadCode, "@",
"SimplePropertyRef<unsigned int,NullVerifier<unsigned int> >", payloadCode, "@",
"SimplePropertyRef<unsigned long,NullVerifier<unsigned long> >", payloadCode, "@",
"SimplePropertyRef<unsigned short,NullVerifier<unsigned short> >", payloadCode, "@",
"SimplePropertyRef<vector<Long64_t>,NullVerifier<vector<Long64_t> > >", payloadCode, "@",
"SimplePropertyRef<vector<ULong64_t>,NullVerifier<vector<ULong64_t> > >", payloadCode, "@",
"SimplePropertyRef<vector<bool>,NullVerifier<vector<bool> > >", payloadCode, "@",
"SimplePropertyRef<vector<char>,NullVerifier<vector<char> > >", payloadCode, "@",
"SimplePropertyRef<vector<double>,NullVerifier<vector<double> > >", payloadCode, "@",
"SimplePropertyRef<vector<float>,NullVerifier<vector<float> > >", payloadCode, "@",
"SimplePropertyRef<vector<int>,NullVerifier<vector<int> > >", payloadCode, "@",
"SimplePropertyRef<vector<long double>,NullVerifier<vector<long double> > >", payloadCode, "@",
"SimplePropertyRef<vector<long>,NullVerifier<vector<long> > >", payloadCode, "@",
"SimplePropertyRef<vector<pair<double,double> >,NullVerifier<vector<pair<double,double> > > >", payloadCode, "@",
"SimplePropertyRef<vector<short>,NullVerifier<vector<short> > >", payloadCode, "@",
"SimplePropertyRef<vector<signed char>,NullVerifier<vector<signed char> > >", payloadCode, "@",
"SimplePropertyRef<vector<string>,NullVerifier<vector<string> > >", payloadCode, "@",
"SimplePropertyRef<vector<unsigned char>,NullVerifier<vector<unsigned char> > >", payloadCode, "@",
"SimplePropertyRef<vector<unsigned int>,NullVerifier<vector<unsigned int> > >", payloadCode, "@",
"SimplePropertyRef<vector<unsigned long>,NullVerifier<vector<unsigned long> > >", payloadCode, "@",
"SimplePropertyRef<vector<unsigned short>,NullVerifier<vector<unsigned short> > >", payloadCode, "@",
"SimplePropertyRef<vector<vector<double> >,NullVerifier<vector<vector<double> > > >", payloadCode, "@",
"SimplePropertyRef<vector<vector<string> >,NullVerifier<vector<vector<string> > > >", payloadCode, "@",
"Stat", payloadCode, "@",
"StatEntity", payloadCode, "@",
"Tuples::Tuple", payloadCode, "@",
"_Bit_reference", payloadCode, "@",
"__gnu_cxx::dummy", payloadCode, "@",
"allocator<IAlgorithm*>", payloadCode, "@",
"allocator<IRegistry*>", payloadCode, "@",
"allocator<IService*>", payloadCode, "@",
"basic_ostream<char,char_traits<char> >", payloadCode, "@",
"basic_stringbuf<char,char_traits<char>,allocator<char> >", payloadCode, "@",
"basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >", payloadCode, "@",
"list<IAlgorithm*>", payloadCode, "@",
"list<IService*>", payloadCode, "@",
"map<std::string,std::string>", payloadCode, "@",
"map<string,string>", payloadCode, "@",
"ostream", payloadCode, "@",
"std::ostream", payloadCode, "@",
"unary_function<GaudiAlg::ID,unsigned long>", payloadCode, "@",
"unary_function<Long64_t,unsigned long>", payloadCode, "@",
"unary_function<ULong64_t,unsigned long>", payloadCode, "@",
"unary_function<__int128,unsigned long>", payloadCode, "@",
"unary_function<basic_string<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >,unsigned long>", payloadCode, "@",
"unary_function<bool,unsigned long>", payloadCode, "@",
"unary_function<char,bool>", payloadCode, "@",
"unary_function<char,unsigned long>", payloadCode, "@",
"unary_function<const IInterface*,IInterface*>", payloadCode, "@",
"unary_function<const char*,unsigned long>", payloadCode, "@",
"unary_function<double,unsigned long>", payloadCode, "@",
"unary_function<float,unsigned long>", payloadCode, "@",
"unary_function<int,unsigned long>", payloadCode, "@",
"unary_function<long double,unsigned long>", payloadCode, "@",
"unary_function<long,unsigned long>", payloadCode, "@",
"unary_function<pair<const string,AIDA::IHistogram1D*>,const string>", payloadCode, "@",
"unary_function<pair<const string,AIDA::IHistogram2D*>,const string>", payloadCode, "@",
"unary_function<pair<const string,AIDA::IHistogram3D*>,const string>", payloadCode, "@",
"unary_function<pair<const string,AIDA::IProfile1D*>,const string>", payloadCode, "@",
"unary_function<pair<const string,AIDA::IProfile2D*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Array<float>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<IOpaqueAddress*>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<Long64_t>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<ULong64_t>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<bool>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<char>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<double>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<float>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<int>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<short>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<unsigned char>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<unsigned int>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Item<unsigned short>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,NTuple::Matrix<float>*>,const string>", payloadCode, "@",
"unary_function<pair<const string,SmartIF<IService> >,const string>", payloadCode, "@",
"unary_function<pair<const string,Tuples::TupleObj*>,const string>", payloadCode, "@",
"unary_function<pair<const string,string>,const string>", payloadCode, "@",
"unary_function<short,unsigned long>", payloadCode, "@",
"unary_function<signed char,unsigned long>", payloadCode, "@",
"unary_function<string,unsigned long>", payloadCode, "@",
"unary_function<unsigned __int128,unsigned long>", payloadCode, "@",
"unary_function<unsigned char,unsigned long>", payloadCode, "@",
"unary_function<unsigned int,unsigned long>", payloadCode, "@",
"unary_function<unsigned long,unsigned long>", payloadCode, "@",
"unary_function<unsigned short,unsigned long>", payloadCode, "@",
"unary_function<wchar_t,unsigned long>", payloadCode, "@",
"vector<AIDA::IHistogram1D*>", payloadCode, "@",
"vector<AIDA::IHistogram2D*>", payloadCode, "@",
"vector<AIDA::IHistogram3D*>", payloadCode, "@",
"vector<AIDA::IProfile1D*>", payloadCode, "@",
"vector<AIDA::IProfile2D*>", payloadCode, "@",
"vector<GaudiAlg::ID>", payloadCode, "@",
"vector<IAlgTool*>", payloadCode, "@",
"vector<IRegistry*>", payloadCode, "@",
"vector<IService*>", payloadCode, "@",
"vector<Property*>", payloadCode, "@",
"vector<const Property*>", payloadCode, "@",
"vector<const StatEntity*>", payloadCode, "@",
"vector<std::string>", payloadCode, "@",
"vector<std::vector<double> >", payloadCode, "@",
"vector<string>", payloadCode, "@",
"vector<vector<double> >", payloadCode, "@",
nullptr};

    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("GaudiPythonDict",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_GaudiPythonDict_Impl, {}, classesHeaders);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_GaudiPythonDict_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_GaudiPythonDict() {
  TriggerDictionaryInitialization_GaudiPythonDict_Impl();
}
