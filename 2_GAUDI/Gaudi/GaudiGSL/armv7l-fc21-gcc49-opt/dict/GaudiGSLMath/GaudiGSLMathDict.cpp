// Generated at Mon Feb 16 20:17:44 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="lcg-g++-4.9.1"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard "
  GCCXML_EXECUTABLE="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__SSP_STRONG__='3' -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__UINT_LEAST16_MAX__='65535' -D__ARM_SIZEOF_WCHAR_T='32' -D__ATOMIC_ACQUIRE='2' -D__SFRACT_IBIT__='0' -D__FLT_MIN__='1.1754943508222875e-38F' -D__GCC_IEC_559_COMPLEX='2' -D__UFRACT_MAX__='0XFFFFP-16UR' -D__UINT_LEAST8_TYPE__='unsigned char' -D__DQ_FBIT__='63' -D__INTMAX_C(c)='c ## LL' -D__ARM_FEATURE_SAT='1' -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK' -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__UINT8_MAX__='255' -D__ACCUM_FBIT__='15' -D__WINT_MAX__='4294967295U' -D__USFRACT_FBIT__='8' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='4294967295U' -D__ARM_ARCH_ISA_ARM='1' -D__WCHAR_MAX__='4294967295U' -D__LACCUM_IBIT__='32' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.9406564584124654e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__GCC_IEC_559='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__cpp_binary_literals='201304' -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__FRACT_FBIT__='15' -D__UINT_FAST64_MAX__='18446744073709551615ULL' -D__SIG_ATOMIC_TYPE__='int' -D__UACCUM_FBIT__='16' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__ARMEL__='1' -D__ARM_FEATURE_UNALIGNED='1' -D__LFRACT_IBIT__='0' -D__GNUC_PATCHLEVEL__='2' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR' -D__UINT_FAST8_MAX__='255' -D__has_include(STR)='__has_include__(STR)' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615ULL' -D__SA_FBIT__='15' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L' -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16' -D__ARM_FP='12' -D__UFRACT_MIN__='0.0UR' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__CHAR_UNSIGNED__='1' -D__UINT32_MAX__='4294967295U' -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64' -D__LDBL_MAX_EXP__='1024' -D__WINT_MIN__='0U' -D__linux__='1' -D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='0U' -D__INT64_C(c)='c ## LL' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D_FORTIFY_SOURCE='2' -D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='4' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USACCUM_IBIT__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)' -D__HA_IBIT__='8' -D__ARM_NEON_FP='4' -D__TQ_IBIT__='0' -D__FLT_EPSILON__='1.1920928955078125e-7F' -D__APCS_32__='1' -D__GXX_WEAK__='1' -D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L' -D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF' -D__DA_IBIT__='32' -D__ARM_SIZEOF_MINIMAL_ENUM='4' -D__INT32_MAX__='2147483647' -D__UQQ_FBIT__='8' -D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK' -D__STDC_IEC_559__='1' -D__STDC_ISO_10646__='201103L' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR' -D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1' -D__has_include_next(STR)='__has_include_next__(STR)' -D__ARM_PCS_VFP='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32' -D__UACCUM_EPSILON__='0x1P-16UK' -D__GNUC__='4' -D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__GXX_RTTI='1' -D__HQ_IBIT__='0' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D__BIGGEST_ALIGNMENT__='8' -D__DQ_IBIT__='0' -D__DBL_MAX__='double(1.7976931348623157e+308L)' -D__ULFRACT_IBIT__='0' -D__INT_FAST32_MAX__='2147483647' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807LL' -D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-94)' -D__THUMB_INTERWORK__='1' -D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__INT_FAST16_TYPE__='int' -D__LDBL_HAS_DENORM__='1' -D__ARM_FEATURE_LDREX='15' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK' -D__DEC128_EPSILON__='1E-33DL' -D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0' -D__PTRDIFF_MAX__='2147483647' -D__UACCUM_MIN__='0.0UK' -D__STDC_NO_THREADS__='1' -D__UACCUM_IBIT__='16' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4' -D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4' -D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64' -D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR' -D__UFRACT_IBIT__='0' -D__ARM_FEATURE_QBIT='1' -D__INT_FAST64_TYPE__='long long int' -D__DBL_MIN__='double(2.2250738585072014e-308L)' -D__FLT_MIN_10_EXP__='(-37)' -D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32' -D__GXX_TYPEINFO_EQUALITY_INLINE='0' -D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0' -D__UINT8_TYPE__='unsigned char' -D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.9.2 20141101 (Red Hat 4.9.2-1)"' -D__UINT64_C(c)='c ## ULL' -D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R' -D__ULACCUM_MIN__='0.0ULK' -D_STDC_PREDEF_H='1' -D__UDA_FBIT__='32' -D__LLACCUM_EPSILON__='0x1P-31LLK' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__USFRACT_MIN__='0.0UHR' -D__ULLACCUM_IBIT__='32' -D__UQQ_IBIT__='0' -D__STDC_IEC_559_COMPLEX__='1' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -D__INT_FAST32_TYPE__='int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='unsigned int' -D__UINT64_MAX__='18446744073709551615ULL' -D__UDQ_FBIT__='64' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__ARM_ARCH_PROFILE='65' -D__LDBL_EPSILON__='2.2204460492503131e-16L' -D__UINTMAX_C(c)='c ## ULL' -D__GNUC_RH_RELEASE__='1' -D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__VFP_FP__='1' -D__SIZEOF_PTRDIFF_T__='4' -D__LACCUM_EPSILON__='0x1P-31LK' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='2147483647' -D__UINT_FAST32_MAX__='4294967295U' -D__UINT_LEAST64_TYPE__='long long unsigned int' -D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='2147483647L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__unix='1' -D__USA_FBIT__='16' -D__UINT_FAST16_TYPE__='unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__ARM_32BIT_STATE='1' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__SACCUM_FBIT__='7' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long long int' -D__ARM_FEATURE_CLZ='1' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__SQ_FBIT__='31' -D__DEC32_MAX_EXP__='97' -D__ARM_ARCH_ISA_THUMB='2' -D__INT_FAST8_MAX__='127' -D__ARM_ARCH='7' -D__INTPTR_MAX__='2147483647' -D__QQ_FBIT__='7' -Dlinux='1' -D__UTA_IBIT__='64' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='53' -D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__INTPTR_TYPE__='int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='unsigned int' -D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32' -D__UINTPTR_MAX__='4294967295U' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807LL' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long long unsigned int' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31' -D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__INT64_TYPE__='long long int' -D__FLT_MAX_EXP__='128' -D__UTQ_IBIT__='0' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807LL' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0' -D__LDBL_MIN_EXP__='(-1021)' -D__arm__='1' -D__UDA_IBIT__='32' -D__INT_LEAST8_MAX__='127' -D__LFRACT_FBIT__='31' -D__WCHAR_UNSIGNED__='1' -D__ARM_ARCH_7A__='1' -D__LDBL_MAX_10_EXP__='308' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.2204460492503131e-16L)' -D__ARM_FEATURE_SIMD32='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long long unsigned int' -D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127' -D__INT_FAST8_TYPE__='signed char' -D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0' -D__LLACCUM_IBIT__='32' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63' -D__UDQ_IBIT__='0' -D__ORDER_BIG_ENDIAN__='4321' -D__ACCUM_EPSILON__='0x1P-15K' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807LL' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.4012984643248171e-45F' -D__LLFRACT_IBIT__='0' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.4028234663852886e+38F' -D__USACCUM_FBIT__='8' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__UFRACT_EPSILON__='0x1P-16UR' -D__INTMAX_TYPE__='long long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='9' -D__UINTMAX_MAX__='18446744073709551615ULL' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)' -D__ATOMIC_SEQ_CST='5' -D__DA_FBIT__='31' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='unsigned int' -D__USA_IBIT__='16' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__ARM_EABI__='1' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8' -D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='15' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='4294967295U' -D__GNUC_GNU_INLINE__='1' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32' -D__ARM_FEATURE_DSP='1' -D__QQ_IBIT__='0' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/GCC/4.9" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/armv7hl-redhat-linux-gnueabi" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/backward" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/include" -isystem"/usr/local/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9"

Compiler info:
lcg-g++-4.9.1 (GCC) 4.9.2 20141101 (Red Hat 4.9.2-1)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/home/jwsmith/HDD/Gaudi/GaudiGSL/dict/GaudiGSLMath.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("Genfun") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("Genfun::GaudiMathImplementation") );
  ::Reflex::Type type_109 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_627 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2799 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_2779 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1436 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_252 = ::Reflex::TypeBuilder(Reflex::Literal("IGslSvc"));
  ::Reflex::Type type_1875 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_692 = ::Reflex::TypeBuilder(Reflex::Literal("IService"));
  ::Reflex::Type type_436 = ::Reflex::TypeBuilder(Reflex::Literal("GslError"));
  ::Reflex::Type type_607 = ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool"));
  ::Reflex::Type type_160 = ::Reflex::TypeBuilder(Reflex::Literal("InterfaceID"));
  ::Reflex::Type type_2144 = ::Reflex::TypeBuilder(Reflex::Literal("StatusCode"));
  ::Reflex::Type type_51 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1369 = ::Reflex::TypeBuilder(Reflex::Literal("gsl_spline"));
  ::Reflex::Type type_547 = ::Reflex::TypeBuilder(Reflex::Literal("IGslErrorHandler"));
  ::Reflex::Type type_3229 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IFunction"));
  ::Reflex::Type type_3362 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::Argument"));
  ::Reflex::Type type_1009 = ::Reflex::TypeBuilder(Reflex::Literal("gsl_interp_accel"));
  ::Reflex::Type type_3441 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::Variable"));
  ::Reflex::Type type_3359 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction"));
  ::Reflex::Type type_2205 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_797 = ::Reflex::TypeBuilder(Reflex::Literal("gsl_sf_result_struct"));
  ::Reflex::Type type_3429 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::FunctionNoop"));
  ::Reflex::Type type_2229 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3433 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::FunctionComposition"));
  ::Reflex::Type type_8402 = ::Reflex::EnumTypeBuilder(Reflex::Literal("GaudiMath::Integration::Inf"));
  ::Reflex::Type type_8400 = ::Reflex::EnumTypeBuilder(Reflex::Literal("GaudiMath::Integration::Type"));
  ::Reflex::Type type_8398 = ::Reflex::EnumTypeBuilder(Reflex::Literal("GaudiMath::Integration::Limit"));
  ::Reflex::Type type_8403 = ::Reflex::EnumTypeBuilder(Reflex::Literal("GaudiMath::Interpolation::Type"));
  ::Reflex::Type type_8401 = ::Reflex::EnumTypeBuilder(Reflex::Literal("GaudiMath::Integration::Category"));
  ::Reflex::Type type_2206 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<double,double> >"));
  ::Reflex::Type type_8399 = ::Reflex::EnumTypeBuilder(Reflex::Literal("GaudiMath::Integration::KronrodRule"));
  ::Reflex::Type type_3664 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::Constant"));
  ::Reflex::Type type_3669 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSpline"));
  ::Reflex::Type type_3675 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::SplineBase"));
  ::Reflex::Type type_3657 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::SimpleFunction"));
  ::Reflex::Type type_3671 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineInteg"));
  ::Reflex::Type type_3685 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv"));
  ::Reflex::Type type_3662 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv2"));
  ::Reflex::Type type_3683 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::AdapterIFunction"));
  ::Reflex::Type type_3666 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithMode"));
  ::Reflex::Type type_3673 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDerivative"));
  ::Reflex::Type type_3687 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithError"));
  ::Reflex::Type type_3679 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::Adapter2DoubleFunction"));
  ::Reflex::Type type_3681 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::Adapter3DoubleFunction"));
  ::Reflex::Type type_8414 = ::Reflex::EnumTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::SimpleFunction::Case"));
  ::Reflex::Type type_3644 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDefiniteIntegral"));
  ::Reflex::Type type_3660 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError"));
  ::Reflex::Type type_3677 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral"));
  ::Reflex::Type type_8552 = ::Reflex::EnumTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDerivative::Type"));
  ::Reflex::Type type_8347 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDefiniteIntegral::_Workspace"));
  ::Reflex::Type type_8610 = ::Reflex::TypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral::_Workspace"));
  ::Reflex::Type type_3645 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::DefIntegral"), type_3644);
  ::Reflex::Type type_3658 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::SimpleFun"), type_3657);
  ::Reflex::Type type_3659 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::Function"), type_3359);
  ::Reflex::Type type_3661 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::GSLFunctionWithModeAndError"), type_3660);
  ::Reflex::Type type_3663 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::SplineDeriv2"), type_3662);
  ::Reflex::Type type_3665 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::Constant"), type_3664);
  ::Reflex::Type type_3667 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::GSLFunctionWithMode"), type_3666);
  ::Reflex::Type type_3668 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::SimpleFunction"), type_3657);
  ::Reflex::Type type_3670 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::Spline"), type_3669);
  ::Reflex::Type type_3672 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::SplineInteg"), type_3671);
  ::Reflex::Type type_3674 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::Derivative"), type_3673);
  ::Reflex::Type type_3676 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::SimpleSpline"), type_3675);
  ::Reflex::Type type_3678 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::IndIntegral"), type_3677);
  ::Reflex::Type type_3680 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::Function2D"), type_3679);
  ::Reflex::Type type_3682 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::Function3D"), type_3681);
  ::Reflex::Type type_3684 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::AIDAFunction"), type_3683);
  ::Reflex::Type type_3686 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::SplineDeriv"), type_3685);
  ::Reflex::Type type_3688 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GaudiMath::GSLFunctionWithError"), type_3687);
  ::Reflex::Type type_7822 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunction"), type_3657);
  ::Reflex::Type type_8453 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv2::Data2D"), type_2206);
  ::Reflex::Type type_8506 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSpline::Data2D"), type_2206);
  ::Reflex::Type type_8527 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineInteg::Data2D"), type_2206);
  ::Reflex::Type type_8581 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::SplineBase::Data2D"), type_2206);
  ::Reflex::Type type_8698 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv::Data2D"), type_2206);
  ::Reflex::Type type_2799c = ::Reflex::ConstBuilder(type_2799);
  ::Reflex::Type type_2721 = ::Reflex::PointerBuilder(type_2799c);
  ::Reflex::Type type_7292 = ::Reflex::FunctionTypeBuilder(type_627, type_2721, type_2721, type_109, type_109);
  ::Reflex::Type type_2852 = ::Reflex::PointerBuilder(type_7292);
  ::Reflex::Type type_7293 = ::Reflex::ReferenceBuilder(type_252);
  ::Reflex::Type type_252c = ::Reflex::ConstBuilder(type_252);
  ::Reflex::Type type_7294 = ::Reflex::ReferenceBuilder(type_252c);
  ::Reflex::Type type_160c = ::Reflex::ConstBuilder(type_160);
  ::Reflex::Type type_3796 = ::Reflex::ReferenceBuilder(type_160c);
  ::Reflex::Type type_436c = ::Reflex::ConstBuilder(type_436);
  ::Reflex::Type type_7295 = ::Reflex::ReferenceBuilder(type_436c);
  ::Reflex::Type type_109c = ::Reflex::ConstBuilder(type_109);
  ::Reflex::Type type_2241 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2229);
  ::Reflex::Type type_7331 = ::Reflex::ReferenceBuilder(type_436);
  ::Reflex::Type type_2241c = ::Reflex::ConstBuilder(type_2241);
  ::Reflex::Type type_6086 = ::Reflex::ReferenceBuilder(type_2241c);
  ::Reflex::Type type_7384 = ::Reflex::ReferenceBuilder(type_547);
  ::Reflex::Type type_547c = ::Reflex::ConstBuilder(type_547);
  ::Reflex::Type type_7385 = ::Reflex::ReferenceBuilder(type_547c);
  ::Reflex::Type type_3359c = ::Reflex::ConstBuilder(type_3359);
  ::Reflex::Type type_11071 = ::Reflex::PointerBuilder(type_3359c);
  ::Reflex::Type type_1514 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_51);
  ::Reflex::Type type_2803 = ::Reflex::PointerBuilder(type_1875);
  ::Reflex::Type type_11265 = ::Reflex::PointerBuilder(type_8347);
  ::Reflex::Type type_3426 = ::Reflex::ReferenceBuilder(type_3359c);
  ::Reflex::Type type_11266 = ::Reflex::PointerBuilder(type_3644);
  ::Reflex::Type type_1514c = ::Reflex::ConstBuilder(type_1514);
  ::Reflex::Type type_1875c = ::Reflex::ConstBuilder(type_1875);
  ::Reflex::Type type_8400c = ::Reflex::ConstBuilder(type_8400);
  ::Reflex::Type type_8399c = ::Reflex::ConstBuilder(type_8399);
  ::Reflex::Type type_2205c = ::Reflex::ConstBuilder(type_2205);
  ::Reflex::Type type_10485 = ::Reflex::ReferenceBuilder(type_2205c);
  ::Reflex::Type type_8402c = ::Reflex::ConstBuilder(type_8402);
  ::Reflex::Type type_1436c = ::Reflex::ConstBuilder(type_1436);
  ::Reflex::Type type_3644c = ::Reflex::ConstBuilder(type_3644);
  ::Reflex::Type type_11271 = ::Reflex::ReferenceBuilder(type_3644c);
  ::Reflex::Type type_3362c = ::Reflex::ConstBuilder(type_3362);
  ::Reflex::Type type_7888 = ::Reflex::ReferenceBuilder(type_3362c);
  ::Reflex::Type type_3455 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Genfun::Derivative"), type_3429);
  ::Reflex::Type type_11280 = ::Reflex::FunctionTypeBuilder(type_1875, type_1875);
  ::Reflex::Type type_8394 = ::Reflex::PointerBuilder(type_11280);
  ::Reflex::Type type_2801 = ::Reflex::PointerBuilder(type_1875c);
  ::Reflex::Type type_11279 = ::Reflex::FunctionTypeBuilder(type_1875, type_2801);
  ::Reflex::Type type_8393 = ::Reflex::PointerBuilder(type_11279);
  ::Reflex::Type type_11278 = ::Reflex::FunctionTypeBuilder(type_1875, type_10485);
  ::Reflex::Type type_8392 = ::Reflex::PointerBuilder(type_11278);
  ::Reflex::Type type_11284 = ::Reflex::PointerBuilder(type_3657);
  ::Reflex::Type type_3657c = ::Reflex::ConstBuilder(type_3657);
  ::Reflex::Type type_11285 = ::Reflex::ReferenceBuilder(type_3657c);
  ::Reflex::Type type_210 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("gsl_mode_t"), type_51);
  ::Reflex::Type type_2108 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("gsl_sf_result"), type_797);
  ::Reflex::Type type_3701 = ::Reflex::PointerBuilder(type_2108);
  ::Reflex::Type type_11274 = ::Reflex::FunctionTypeBuilder(type_109, type_1875, type_210, type_3701);
  ::Reflex::Type type_8387 = ::Reflex::PointerBuilder(type_11274);
  ::Reflex::Type type_11287 = ::Reflex::PointerBuilder(type_210);
  ::Reflex::Type type_11288 = ::Reflex::PointerBuilder(type_3660);
  ::Reflex::Type type_210c = ::Reflex::ConstBuilder(type_210);
  ::Reflex::Type type_8388 = ::Reflex::ReferenceBuilder(type_210c);
  ::Reflex::Type type_3660c = ::Reflex::ConstBuilder(type_3660);
  ::Reflex::Type type_11289 = ::Reflex::ReferenceBuilder(type_3660c);
  ::Reflex::Type type_2108c = ::Reflex::ConstBuilder(type_2108);
  ::Reflex::Type type_11290 = ::Reflex::ReferenceBuilder(type_2108c);
  ::Reflex::Type type_11292 = ::Reflex::PointerBuilder(type_3662);
  ::Reflex::Type type_8403c = ::Reflex::ConstBuilder(type_8403);
  ::Reflex::Type type_2206c = ::Reflex::ConstBuilder(type_2206);
  ::Reflex::Type type_11294 = ::Reflex::ReferenceBuilder(type_2206c);
  ::Reflex::Type type_3675c = ::Reflex::ConstBuilder(type_3675);
  ::Reflex::Type type_11295 = ::Reflex::ReferenceBuilder(type_3675c);
  ::Reflex::Type type_3662c = ::Reflex::ConstBuilder(type_3662);
  ::Reflex::Type type_11296 = ::Reflex::ReferenceBuilder(type_3662c);
  ::Reflex::Type type_11298 = ::Reflex::PointerBuilder(type_3664);
  ::Reflex::Type type_3664c = ::Reflex::ConstBuilder(type_3664);
  ::Reflex::Type type_11299 = ::Reflex::ReferenceBuilder(type_3664c);
  ::Reflex::Type type_11277 = ::Reflex::FunctionTypeBuilder(type_1875, type_1875, type_210);
  ::Reflex::Type type_8390 = ::Reflex::PointerBuilder(type_11277);
  ::Reflex::Type type_11301 = ::Reflex::PointerBuilder(type_3666);
  ::Reflex::Type type_3666c = ::Reflex::ConstBuilder(type_3666);
  ::Reflex::Type type_11302 = ::Reflex::ReferenceBuilder(type_3666c);
  ::Reflex::Type type_11305 = ::Reflex::PointerBuilder(type_3669);
  ::Reflex::Type type_3669c = ::Reflex::ConstBuilder(type_3669);
  ::Reflex::Type type_11306 = ::Reflex::ReferenceBuilder(type_3669c);
  ::Reflex::Type type_11308 = ::Reflex::PointerBuilder(type_3671);
  ::Reflex::Type type_3671c = ::Reflex::ConstBuilder(type_3671);
  ::Reflex::Type type_11309 = ::Reflex::ReferenceBuilder(type_3671c);
  ::Reflex::Type type_11311 = ::Reflex::PointerBuilder(type_3673);
  ::Reflex::Type type_8552c = ::Reflex::ConstBuilder(type_8552);
  ::Reflex::Type type_11312 = ::Reflex::ReferenceBuilder(type_8552c);
  ::Reflex::Type type_3673c = ::Reflex::ConstBuilder(type_3673);
  ::Reflex::Type type_11313 = ::Reflex::ReferenceBuilder(type_3673c);
  ::Reflex::Type type_4168 = ::Reflex::PointerBuilder(type_1369);
  ::Reflex::Type type_2800 = ::Reflex::PointerBuilder(type_1009);
  ::Reflex::Type type_11316 = ::Reflex::PointerBuilder(type_8610);
  ::Reflex::Type type_11317 = ::Reflex::PointerBuilder(type_3677);
  ::Reflex::Type type_8398c = ::Reflex::ConstBuilder(type_8398);
  ::Reflex::Type type_3677c = ::Reflex::ConstBuilder(type_3677);
  ::Reflex::Type type_11319 = ::Reflex::ReferenceBuilder(type_3677c);
  ::Reflex::Type type_11282 = ::Reflex::FunctionTypeBuilder(type_1875, type_1875, type_1875);
  ::Reflex::Type type_8396 = ::Reflex::PointerBuilder(type_11282);
  ::Reflex::Type type_11322 = ::Reflex::PointerBuilder(type_3679);
  ::Reflex::Type type_3679c = ::Reflex::ConstBuilder(type_3679);
  ::Reflex::Type type_11323 = ::Reflex::ReferenceBuilder(type_3679c);
  ::Reflex::Type type_11281 = ::Reflex::FunctionTypeBuilder(type_1875, type_1875, type_1875, type_1875);
  ::Reflex::Type type_8395 = ::Reflex::PointerBuilder(type_11281);
  ::Reflex::Type type_11325 = ::Reflex::PointerBuilder(type_3681);
  ::Reflex::Type type_3681c = ::Reflex::ConstBuilder(type_3681);
  ::Reflex::Type type_11326 = ::Reflex::ReferenceBuilder(type_3681c);
  ::Reflex::Type type_3229c = ::Reflex::ConstBuilder(type_3229);
  ::Reflex::Type type_11328 = ::Reflex::PointerBuilder(type_3229c);
  ::Reflex::Type type_11329 = ::Reflex::PointerBuilder(type_3683);
  ::Reflex::Type type_8397 = ::Reflex::ReferenceBuilder(type_3229c);
  ::Reflex::Type type_3683c = ::Reflex::ConstBuilder(type_3683);
  ::Reflex::Type type_11330 = ::Reflex::ReferenceBuilder(type_3683c);
  ::Reflex::Type type_11332 = ::Reflex::PointerBuilder(type_3685);
  ::Reflex::Type type_3685c = ::Reflex::ConstBuilder(type_3685);
  ::Reflex::Type type_11333 = ::Reflex::ReferenceBuilder(type_3685c);
  ::Reflex::Type type_11276 = ::Reflex::FunctionTypeBuilder(type_109, type_1875, type_3701);
  ::Reflex::Type type_8389 = ::Reflex::PointerBuilder(type_11276);
  ::Reflex::Type type_11335 = ::Reflex::PointerBuilder(type_3687);
  ::Reflex::Type type_3687c = ::Reflex::ConstBuilder(type_3687);
  ::Reflex::Type type_11304 = ::Reflex::ReferenceBuilder(type_3687c);
  ::Reflex::Type type_11060 = ::Reflex::PointerBuilder(type_3359);
  ::Reflex::Type type_3441c = ::Reflex::ConstBuilder(type_3441);
  ::Reflex::Type type_11061 = ::Reflex::ReferenceBuilder(type_3441c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __IGslSvc
#undef __IGslSvc
#endif
class __IGslSvc : virtual public ::IService {
  public:
  __IGslSvc();
  virtual ~__IGslSvc() throw();
  virtual ::StatusCode handle(GslError const&) const throw();
  virtual ::StatusCode status(int) const throw();
};
#ifdef __GslError
#undef __GslError
#endif
class __GslError {
  public:
  __GslError();
  ::std::string reason;
  ::std::string file;
  int line;
  int code;
};
#ifdef __IGslErrorHandler
#undef __IGslErrorHandler
#endif
class __IGslErrorHandler : virtual public ::IAlgTool {
  public:
  __IGslErrorHandler();
  virtual ~__IGslErrorHandler() throw();
  virtual ::StatusCode handle(GslError const&) const throw();
};
#ifdef __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral
#undef __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral
#endif
class __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral();
  virtual ~__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral() throw();
  void* m_function;
  ::size_t m_DIM;
  ::size_t m_index;
  double m_a;
  double m_b;
  bool m_ia;
  bool m_ib;
  ::GaudiMath::Integration::Type m_type;
  ::GaudiMath::Integration::Category m_category;
  ::GaudiMath::Integration::KronrodRule m_rule;
  ::std::vector<double> m_points;
  void* m_pdata;
  double m_epsabs;
  double m_epsrel;
  double m_result;
  double m_error;
  ::size_t m_size;
  void* m_ws;
  ::Genfun::Argument m_argument;
  ::Genfun::Argument m_argF;
};
#ifdef __Genfun__GaudiMathImplementation__SimpleFunction
#undef __Genfun__GaudiMathImplementation__SimpleFunction
#endif
class __Genfun__GaudiMathImplementation__SimpleFunction : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__SimpleFunction();
  virtual ~__Genfun__GaudiMathImplementation__SimpleFunction() throw();
#ifdef __Genfun__GaudiMathImplementation__SimpleFunction__Case
#undef __Genfun__GaudiMathImplementation__SimpleFunction__Case
#endif
  enum __Genfun__GaudiMathImplementation__SimpleFunction__Case {};
  __Genfun__GaudiMathImplementation__SimpleFunction__Case m_case;
  ::size_t m_DIM;
  void* m_func1;
  void* m_func2;
  void* m_arg2;
  void* m_func3;
  ::std::vector<double> m_arg3;
};
#ifdef __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError
#undef __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError
#endif
class __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError();
  virtual ~__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError() throw();
  void* m_function;
  void* m_mode;
  void* m_result;
};
#ifdef __Genfun__GaudiMathImplementation__GSLSplineDeriv2
#undef __Genfun__GaudiMathImplementation__GSLSplineDeriv2
#endif
class __Genfun__GaudiMathImplementation__GSLSplineDeriv2 : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__GSLSplineDeriv2();
  virtual ~__Genfun__GaudiMathImplementation__GSLSplineDeriv2() throw();
  ::Genfun::GaudiMathImplementation::SplineBase m_spline;
};
#ifdef __Genfun__GaudiMathImplementation__Constant
#undef __Genfun__GaudiMathImplementation__Constant
#endif
class __Genfun__GaudiMathImplementation__Constant : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__Constant();
  virtual ~__Genfun__GaudiMathImplementation__Constant() throw();
  double m_value;
  ::size_t m_DIM;
};
#ifdef __Genfun__GaudiMathImplementation__GSLFunctionWithMode
#undef __Genfun__GaudiMathImplementation__GSLFunctionWithMode
#endif
class __Genfun__GaudiMathImplementation__GSLFunctionWithMode : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__GSLFunctionWithMode();
  virtual ~__Genfun__GaudiMathImplementation__GSLFunctionWithMode() throw();
  void* m_function;
  void* m_mode;
};
#ifdef __Genfun__GaudiMathImplementation__GSLSpline
#undef __Genfun__GaudiMathImplementation__GSLSpline
#endif
class __Genfun__GaudiMathImplementation__GSLSpline : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__GSLSpline();
  virtual ~__Genfun__GaudiMathImplementation__GSLSpline() throw();
  ::Genfun::GaudiMathImplementation::SplineBase m_spline;
};
#ifdef __Genfun__GaudiMathImplementation__GSLSplineInteg
#undef __Genfun__GaudiMathImplementation__GSLSplineInteg
#endif
class __Genfun__GaudiMathImplementation__GSLSplineInteg : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__GSLSplineInteg();
  virtual ~__Genfun__GaudiMathImplementation__GSLSplineInteg() throw();
  ::Genfun::GaudiMathImplementation::SplineBase m_spline;
  double m_low;
};
#ifdef __Genfun__GaudiMathImplementation__NumericalDerivative
#undef __Genfun__GaudiMathImplementation__NumericalDerivative
#endif
class __Genfun__GaudiMathImplementation__NumericalDerivative : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__NumericalDerivative();
  virtual ~__Genfun__GaudiMathImplementation__NumericalDerivative() throw();
  void* m_function;
  ::size_t m_index;
  ::size_t m_DIM;
  ::Genfun::GaudiMathImplementation::NumericalDerivative::Type m_type;
  ::Genfun::Argument m_argument;
  double m_result;
  double m_error;
};
#ifdef __Genfun__GaudiMathImplementation__SplineBase
#undef __Genfun__GaudiMathImplementation__SplineBase
#endif
class __Genfun__GaudiMathImplementation__SplineBase {
  public:
  __Genfun__GaudiMathImplementation__SplineBase();
  virtual ~__Genfun__GaudiMathImplementation__SplineBase() throw();
  bool m_init;
  ::size_t m_dim;
  void* m_x;
  void* m_y;
  void* m_spline;
  void* m_accel;
  ::GaudiMath::Interpolation::Type m_type;
};
#ifdef __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral
#undef __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral
#endif
class __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral();
  virtual ~__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral() throw();
  void* m_function;
  ::size_t m_DIM;
  ::size_t m_index;
  double m_a;
  ::GaudiMath::Integration::Limit m_limit;
  ::GaudiMath::Integration::Type m_type;
  ::GaudiMath::Integration::Category m_category;
  ::GaudiMath::Integration::KronrodRule m_rule;
  ::std::vector<double> m_points;
  void* m_pdata;
  double m_epsabs;
  double m_epsrel;
  double m_result;
  double m_error;
  ::size_t m_size;
  void* m_ws;
  ::Genfun::Argument m_argument;
};
#ifdef __Genfun__GaudiMathImplementation__Adapter2DoubleFunction
#undef __Genfun__GaudiMathImplementation__Adapter2DoubleFunction
#endif
class __Genfun__GaudiMathImplementation__Adapter2DoubleFunction : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__Adapter2DoubleFunction();
  virtual ~__Genfun__GaudiMathImplementation__Adapter2DoubleFunction() throw();
  void* m_func;
};
#ifdef __Genfun__GaudiMathImplementation__Adapter3DoubleFunction
#undef __Genfun__GaudiMathImplementation__Adapter3DoubleFunction
#endif
class __Genfun__GaudiMathImplementation__Adapter3DoubleFunction : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__Adapter3DoubleFunction();
  virtual ~__Genfun__GaudiMathImplementation__Adapter3DoubleFunction() throw();
  void* m_func;
};
#ifdef __Genfun__GaudiMathImplementation__AdapterIFunction
#undef __Genfun__GaudiMathImplementation__AdapterIFunction
#endif
class __Genfun__GaudiMathImplementation__AdapterIFunction : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__AdapterIFunction();
  virtual ~__Genfun__GaudiMathImplementation__AdapterIFunction() throw();
  void* m_fun;
  ::size_t m_dim;
  ::std::vector<double> m_arg;
};
#ifdef __Genfun__GaudiMathImplementation__GSLSplineDeriv
#undef __Genfun__GaudiMathImplementation__GSLSplineDeriv
#endif
class __Genfun__GaudiMathImplementation__GSLSplineDeriv : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__GSLSplineDeriv();
  virtual ~__Genfun__GaudiMathImplementation__GSLSplineDeriv() throw();
  ::Genfun::GaudiMathImplementation::SplineBase m_spline;
};
#ifdef __Genfun__GaudiMathImplementation__GSLFunctionWithError
#undef __Genfun__GaudiMathImplementation__GSLFunctionWithError
#endif
class __Genfun__GaudiMathImplementation__GSLFunctionWithError : public ::Genfun::AbsFunction {
  public:
  __Genfun__GaudiMathImplementation__GSLFunctionWithError();
  virtual ~__Genfun__GaudiMathImplementation__GSLFunctionWithError() throw();
  void* m_function;
  void* m_result;
};
#ifdef __Genfun__AbsFunction
#undef __Genfun__AbsFunction
#endif
class __Genfun__AbsFunction {
  public:
  __Genfun__AbsFunction();
  virtual ~__Genfun__AbsFunction() throw();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class IGslSvc -------------------------------
static  void operator_2854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IGslSvc*)o)->operator=)(*(const ::IGslSvc*)arg[0]);
  else   (((::IGslSvc*)o)->operator=)(*(const ::IGslSvc*)arg[0]);
}

static  void method_2857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IGslSvc*)o)->interfaceID)();
  else   (((::IGslSvc*)o)->interfaceID)();
}

static  void method_2858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IGslSvc*)o)->handle)(*(const ::GslError*)arg[0]));
  else   (((const ::IGslSvc*)o)->handle)(*(const ::GslError*)arg[0]);
}

static  void method_2859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IGslSvc*)o)->handler)());
  else   (((const ::IGslSvc*)o)->handler)();
}

static  void method_2860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IGslSvc*)o)->setHandler)(Reflex::VoidPtrToFunc< void(*)(const char*, const char*, int, int) >(arg[0])));
  else   (((const ::IGslSvc*)o)->setHandler)(Reflex::VoidPtrToFunc< void(*)(const char*, const char*, int, int) >(arg[0]));
}

static  void method_2861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IGslSvc*)o)->status)(*(const int*)arg[0]));
  else   (((const ::IGslSvc*)o)->status)(*(const int*)arg[0]);
}

static void method_x0( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IGslSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IGslSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IGslSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IGslSvc -------------------------------
void __IGslSvc_db_datamem(Reflex::Class*);
void __IGslSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IGslSvc_datamem_bld(&__IGslSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IGslSvc_funcmem_bld(&__IGslSvc_db_funcmem);
void __IGslSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IGslSvc"), typeid(::IGslSvc), sizeof(::IGslSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "IGsl*")
  .AddBase(type_692, ::Reflex::BaseOffset< ::IGslSvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_2852, Reflex::Literal("IGslSvc::GslErrorHandler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7293, type_7294), Reflex::Literal("operator="), operator_2854, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IGslSvc_funcmem_bld);
}

//------Delayed data member builder for class IGslSvc -------------------
void __IGslSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IGslSvc -------------------
void __IGslSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3796), Reflex::Literal("interfaceID"), method_2857, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144, type_7295), Reflex::Literal("handle"), method_2858, 0, "error", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2852), Reflex::Literal("handler"), method_2859, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2852, type_2852), Reflex::Literal("setHandler"), method_2860, 0, "handler", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144, type_109c), Reflex::Literal("status"), method_2861, 0, "error", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class GslError -------------------------------
static void destructor_2941(void*, void * o, const std::vector<void*>&, void *) {
(((::GslError*)o)->::GslError::~GslError)();
}
static  void operator_2942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GslError*)o)->operator=)(*(const ::GslError*)arg[0]);
  else   (((::GslError*)o)->operator=)(*(const ::GslError*)arg[0]);
}

static void constructor_2943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GslError(*(const ::GslError*)arg[0]);
  else ::new(mem) ::GslError(*(const ::GslError*)arg[0]);
}

static void constructor_2944( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::GslError();
  else ::new(mem) ::GslError();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GslError(*(const ::std::string*)arg[0]);
  else ::new(mem) ::GslError(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GslError(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::GslError(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GslError(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const int*)arg[2]);
  else ::new(mem) ::GslError(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GslError(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const int*)arg[2],
      *(const int*)arg[3]);
  else ::new(mem) ::GslError(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const int*)arg[2],
      *(const int*)arg[3]);
  }
}

static  void operator_2945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GslError*)o)->operator<)(*(const ::GslError*)arg[0]));
  else   (((const ::GslError*)o)->operator<)(*(const ::GslError*)arg[0]);
}

static void constructor_x1( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GslError();
  else ::new(mem) ::GslError();
}

static void method_newdel_436( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GslError >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GslError >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GslError >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GslError >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GslError >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GslError -------------------------------
void __GslError_db_datamem(Reflex::Class*);
void __GslError_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GslError_datamem_bld(&__GslError_db_datamem);
Reflex::GenreflexMemberBuilder __GslError_funcmem_bld(&__GslError_db_funcmem);
void __GslError_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GslError"), typeid(::GslError), sizeof(::GslError), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Gsl*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GslError"), destructor_2941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7331, type_7295), Reflex::Literal("operator="), operator_2942, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7295), Reflex::Literal("GslError"), constructor_2943, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6086, type_6086, type_109c, type_109c), Reflex::Literal("GslError"), constructor_2944, 0, "r=\"\";f=\"\";l=0;c=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GslError"), constructor_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_436, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GslError_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GslError_funcmem_bld);
}

//------Delayed data member builder for class GslError -------------------
void __GslError_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2241, Reflex::Literal("reason"), OffsetOf(__shadow__::__GslError, reason), ::Reflex::PUBLIC)
  .AddDataMember(type_2241, Reflex::Literal("file"), OffsetOf(__shadow__::__GslError, file), ::Reflex::PUBLIC)
  .AddDataMember(type_109, Reflex::Literal("line"), OffsetOf(__shadow__::__GslError, line), ::Reflex::PUBLIC)
  .AddDataMember(type_109, Reflex::Literal("code"), OffsetOf(__shadow__::__GslError, code), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class GslError -------------------
void __GslError_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779, type_7295), Reflex::Literal("operator<"), operator_2945, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class IGslErrorHandler -------------------------------
static  void operator_3010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IGslErrorHandler*)o)->operator=)(*(const ::IGslErrorHandler*)arg[0]);
  else   (((::IGslErrorHandler*)o)->operator=)(*(const ::IGslErrorHandler*)arg[0]);
}

static  void method_3013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IGslErrorHandler*)o)->interfaceID)();
  else   (((::IGslErrorHandler*)o)->interfaceID)();
}

static  void method_3014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IGslErrorHandler*)o)->handle)(*(const ::GslError*)arg[0]));
  else   (((const ::IGslErrorHandler*)o)->handle)(*(const ::GslError*)arg[0]);
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::IGslErrorHandler,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IGslErrorHandler,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IGslErrorHandler,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IGslErrorHandler -------------------------------
void __IGslErrorHandler_db_datamem(Reflex::Class*);
void __IGslErrorHandler_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IGslErrorHandler_datamem_bld(&__IGslErrorHandler_db_datamem);
Reflex::GenreflexMemberBuilder __IGslErrorHandler_funcmem_bld(&__IGslErrorHandler_db_funcmem);
void __IGslErrorHandler_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IGslErrorHandler"), typeid(::IGslErrorHandler), sizeof(::IGslErrorHandler), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "IGsl*")
  .AddBase(type_607, ::Reflex::BaseOffset< ::IGslErrorHandler, ::IAlgTool >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7384, type_7385), Reflex::Literal("operator="), operator_3010, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IGslErrorHandler_funcmem_bld);
}

//------Delayed data member builder for class IGslErrorHandler -------------------
void __IGslErrorHandler_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IGslErrorHandler -------------------
void __IGslErrorHandler_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3796), Reflex::Literal("interfaceID"), method_3013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2144, type_7295), Reflex::Literal("handle"), method_3014, 0, "error", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class NumericalDefiniteIntegral -------------------------------
static  void operator_8350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->clone)();
}

static void constructor_8353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7],
      *(const ::size_t*)arg[8]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7],
      *(const ::size_t*)arg[8]);
  }
}

static void constructor_8354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const double*)arg[5]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6],
      *(const ::size_t*)arg[7]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const double*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6],
      *(const ::size_t*)arg[7]);
  }
}

static void constructor_8355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3],
      *(const double*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3],
      *(const double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5],
      *(const ::size_t*)arg[6]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Inf*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5],
      *(const ::size_t*)arg[6]);
  }
}

static void constructor_8356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5],
      *(const ::size_t*)arg[6]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Inf*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4],
      *(const double*)arg[5],
      *(const ::size_t*)arg[6]);
  }
}

static void constructor_8357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const float*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const float*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const float*)arg[2],
      *(const float*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const float*)arg[2],
      *(const float*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const float*)arg[2],
      *(const float*)arg[3],
      *(const ::size_t*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const float*)arg[2],
      *(const float*)arg[3],
      *(const ::size_t*)arg[4]);
  }
}

static void constructor_8358( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral(*(const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)arg[0]);
}

static void destructor_8359(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral::~NumericalDefiniteIntegral)();
}
static  void method_8360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->dimensionality)();
}

static  void operator_8361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->hasAnalyticDerivative)();
}

static  void method_8364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->function)();
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->function)();
}

static  void method_8366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->a)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->a)();
}

static  void method_8367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->b)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->b)();
}

static  void method_8368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->points)();
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->points)();
}

static  void method_8369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->epsabs)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->epsabs)();
}

static  void method_8370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->epsrel)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->epsrel)();
}

static  void method_8371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->result)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->result)();
}

static  void method_8372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->error)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->error)();
}

static  void method_8373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->size)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->size)();
}

static  void method_8374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->type)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->type)();
}

static  void method_8375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->category)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->category)();
}

static  void method_8376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->rule)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral*)o)->rule)();
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NumericalDefiniteIntegral -------------------------------
void __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_datamem_bld(&__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_funcmem_bld(&__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_db_funcmem);
void __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDefiniteIntegral"), typeid(::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral), sizeof(::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::NumericalDefiniteIntegral, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2205, Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDefiniteIntegral::Points"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_1875c, type_1875c, type_8400c, type_8399c, type_1875c, type_1875c, type_1514c), Reflex::Literal("NumericalDefiniteIntegral"), constructor_8353, 0, "function;index;a;b;type=Adaptive;rule=Gauss31;epsabs=1.0000000000000000364321973154977415791655470656e-10;epsrel=9.99999999999999954748111825886258685613938723691e-8;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_1875c, type_1875c, type_10485, type_1875c, type_1875c, type_1514c), Reflex::Literal("NumericalDefiniteIntegral"), constructor_8354, 0, "function;index;a;b;points;epsabs=1.00000000000000006228159145777985641889706869279e-9;epsrel=9.99999999999999954748111825886258685613938723691e-7;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_1875c, type_8402c, type_1875c, type_1875c, type_1514c), Reflex::Literal("NumericalDefiniteIntegral"), constructor_8355, 0, "function;index;a;b=Infinity;epsabs=1.00000000000000006228159145777985641889706869279e-9;epsrel=9.99999999999999954748111825886258685613938723691e-7;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_8402c, type_1875c, type_1875c, type_1875c, type_1514c), Reflex::Literal("NumericalDefiniteIntegral"), constructor_8356, 0, "function;index;a;b;epsabs=1.00000000000000006228159145777985641889706869279e-9;epsrel=9.99999999999999954748111825886258685613938723691e-7;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_1436c, type_1436c, type_1514c), Reflex::Literal("NumericalDefiniteIntegral"), constructor_8357, 0, "function;index;epsabs=1.00000000000000006228159145777985641889706869279e-9;epsrel=9.99999999999999954748111825886258685613938723691e-7;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11271), Reflex::Literal("NumericalDefiniteIntegral"), constructor_8358, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NumericalDefiniteIntegral"), destructor_8359, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_funcmem_bld);
}

//------Delayed data member builder for class NumericalDefiniteIntegral -------------------
void __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11071, Reflex::Literal("m_function"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_function), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_DIM"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_DIM), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_index"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_a"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_a), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_b"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_b), ::Reflex::PRIVATE)
  .AddDataMember(type_2779, Reflex::Literal("m_ia"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_ia), ::Reflex::PRIVATE)
  .AddDataMember(type_2779, Reflex::Literal("m_ib"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_ib), ::Reflex::PRIVATE)
  .AddDataMember(type_8400, Reflex::Literal("m_type"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_type), ::Reflex::PRIVATE)
  .AddDataMember(type_8401, Reflex::Literal("m_category"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_category), ::Reflex::PRIVATE)
  .AddDataMember(type_8399, Reflex::Literal("m_rule"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_rule), ::Reflex::PRIVATE)
  .AddDataMember(type_2205, Reflex::Literal("m_points"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_points), ::Reflex::PRIVATE)
  .AddDataMember(type_2803, Reflex::Literal("m_pdata"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_pdata), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_epsabs"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_epsabs), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_epsrel"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_epsrel), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_result"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_result), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1875, Reflex::Literal("m_error"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_error), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1514, Reflex::Literal("m_size"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_size), ::Reflex::PRIVATE)
  .AddDataMember(type_11265, Reflex::Literal("m_ws"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_ws), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_3362, Reflex::Literal("m_argument"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_argument), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_3362, Reflex::Literal("m_argF"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDefiniteIntegral, m_argF), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class NumericalDefiniteIntegral -------------------
void __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8350, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11266), Reflex::Literal("clone"), method_8351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8360, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8361, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8362, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8363, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8364, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3426), Reflex::Literal("function"), method_8365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("a"), method_8366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("b"), method_8367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10485), Reflex::Literal("points"), method_8368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("epsabs"), method_8369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("epsrel"), method_8370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("result"), method_8371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("error"), method_8372, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1514), Reflex::Literal("size"), method_8373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8400), Reflex::Literal("type"), method_8374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8401), Reflex::Literal("category"), method_8375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8399), Reflex::Literal("rule"), method_8376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SimpleFunction -------------------------------
static  void operator_8415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->clone)();
}

static void constructor_8418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(Reflex::VoidPtrToFunc< double(*)(double) >(arg[0]));
  else ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(Reflex::VoidPtrToFunc< double(*)(double) >(arg[0]));
}

static void constructor_8419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(Reflex::VoidPtrToFunc< double(*)(const double*) >(arg[0]),
      *(const ::size_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(Reflex::VoidPtrToFunc< double(*)(const double*) >(arg[0]),
      *(const ::size_t*)arg[1]);
}

static void constructor_8420( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(Reflex::VoidPtrToFunc< double(*)(const std::vector<double>&) >(arg[0]),
      *(const ::size_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(Reflex::VoidPtrToFunc< double(*)(const std::vector<double>&) >(arg[0]),
      *(const ::size_t*)arg[1]);
}

static void constructor_8421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(*(const ::Genfun::GaudiMathImplementation::SimpleFunction*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::SimpleFunction(*(const ::Genfun::GaudiMathImplementation::SimpleFunction*)arg[0]);
}

static void destructor_8422(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::SimpleFunction*)o)->::Genfun::GaudiMathImplementation::SimpleFunction::~SimpleFunction)();
}
static  void method_8423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->dimensionality)();
}

static  void method_8424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->hasAnalyticDerivative)();
}

static  void operator_8425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::SimpleFunction*)o)->partial)(*(unsigned int*)arg[0]);
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::SimpleFunction,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SimpleFunction -------------------------------
void __Genfun__GaudiMathImplementation__SimpleFunction_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__SimpleFunction_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__SimpleFunction_datamem_bld(&__Genfun__GaudiMathImplementation__SimpleFunction_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__SimpleFunction_funcmem_bld(&__Genfun__GaudiMathImplementation__SimpleFunction_db_funcmem);
void __Genfun__GaudiMathImplementation__SimpleFunction_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::SimpleFunction"), typeid(::Genfun::GaudiMathImplementation::SimpleFunction), sizeof(::Genfun::GaudiMathImplementation::SimpleFunction), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Genfun::GaudiMath*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::SimpleFunction, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_8394, Reflex::Literal("Genfun::GaudiMathImplementation::SimpleFunction::Function1"))
  .AddTypedef(type_8393, Reflex::Literal("Genfun::GaudiMathImplementation::SimpleFunction::Function2"))
  .AddTypedef(type_8392, Reflex::Literal("Genfun::GaudiMathImplementation::SimpleFunction::Function3"))
  .AddEnum(Reflex::Literal("Genfun::GaudiMathImplementation::SimpleFunction::Case"), Reflex::Literal("TrivialArg=0;ArrayArg=1;VectorArg=2"), &typeid(::Reflex::UnknownType), ::Reflex::PROTECTED | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8394), Reflex::Literal("SimpleFunction"), constructor_8418, 0, "func", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8393, type_1514c), Reflex::Literal("SimpleFunction"), constructor_8419, 0, "func;dim", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8392, type_1514c), Reflex::Literal("SimpleFunction"), constructor_8420, 0, "func;dim", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11285), Reflex::Literal("SimpleFunction"), constructor_8421, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SimpleFunction"), destructor_8422, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__SimpleFunction_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__SimpleFunction_funcmem_bld);
}

//------Delayed data member builder for class SimpleFunction -------------------
void __Genfun__GaudiMathImplementation__SimpleFunction_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8414, Reflex::Literal("m_case"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SimpleFunction, m_case), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_DIM"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SimpleFunction, m_DIM), ::Reflex::PRIVATE)
  .AddDataMember(type_8394, Reflex::Literal("m_func1"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SimpleFunction, m_func1), ::Reflex::PRIVATE)
  .AddDataMember(type_8393, Reflex::Literal("m_func2"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SimpleFunction, m_func2), ::Reflex::PRIVATE)
  .AddDataMember(type_2803, Reflex::Literal("m_arg2"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SimpleFunction, m_arg2), ::Reflex::PRIVATE)
  .AddDataMember(type_8392, Reflex::Literal("m_func3"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SimpleFunction, m_func3), ::Reflex::PRIVATE)
  .AddDataMember(type_2205, Reflex::Literal("m_arg3"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SimpleFunction, m_arg3), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SimpleFunction -------------------
void __Genfun__GaudiMathImplementation__SimpleFunction_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8415, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11284), Reflex::Literal("clone"), method_8416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8423, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8424, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8425, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8426, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8427, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class GSLFunctionWithModeAndError -------------------------------
static  void operator_8434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->clone)();
}

static void constructor_8437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError(Reflex::VoidPtrToFunc< int(*)(double, gsl_mode_t, gsl_sf_result*) >(arg[0]),
      *(const ::gsl_mode_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError(Reflex::VoidPtrToFunc< int(*)(double, gsl_mode_t, gsl_sf_result*) >(arg[0]),
      *(const ::gsl_mode_t*)arg[1]);
}

static void constructor_8438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError(*(const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError(*(const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)arg[0]);
}

static void destructor_8439(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError::~GSLFunctionWithModeAndError)();
}
static  void operator_8440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->hasAnalyticDerivative)();
}

static  void method_8443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->dimensionality)();
}

static  void method_8444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->function)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->function)();
}

static  void method_8446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->mode)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->mode)();
}

static  void method_8447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->result)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->result)();
}

static  void method_8448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->error)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError*)o)->error)();
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GSLFunctionWithModeAndError -------------------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_datamem_bld(&__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_funcmem_bld(&__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_db_funcmem);
void __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError"), typeid(::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError), sizeof(::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_8387, Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError::Function"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8387, type_8388), Reflex::Literal("GSLFunctionWithModeAndError"), constructor_8437, 0, "fun;mode", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11289), Reflex::Literal("GSLFunctionWithModeAndError"), constructor_8438, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GSLFunctionWithModeAndError"), destructor_8439, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_funcmem_bld);
}

//------Delayed data member builder for class GSLFunctionWithModeAndError -------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8387, Reflex::Literal("m_function"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError, m_function), ::Reflex::PRIVATE)
  .AddDataMember(type_11287, Reflex::Literal("m_mode"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError, m_mode), ::Reflex::PRIVATE)
  .AddDataMember(type_3701, Reflex::Literal("m_result"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError, m_result), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GSLFunctionWithModeAndError -------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8434, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11288), Reflex::Literal("clone"), method_8435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8440, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8441, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8442, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8443, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8444, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8387), Reflex::Literal("function"), method_8445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8388), Reflex::Literal("mode"), method_8446, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11290), Reflex::Literal("result"), method_8447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("error"), method_8448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GSLSplineDeriv2 -------------------------------
static  void operator_8454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->clone)();
}

static void constructor_8457( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
}

static void constructor_8458( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
}

static void constructor_8459( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
}

static void constructor_8460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv2(*(const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)arg[0]);
}

static void destructor_8461(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->::Genfun::GaudiMathImplementation::GSLSplineDeriv2::~GSLSplineDeriv2)();
}
static  void operator_8462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8463( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->dimensionality)();
}

static  void method_8465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->hasAnalyticDerivative)();
}

static  void method_8466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->spline)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->spline)();
}

static  void converter_8468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv2*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSplineDeriv2,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GSLSplineDeriv2 -------------------------------
void __Genfun__GaudiMathImplementation__GSLSplineDeriv2_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__GSLSplineDeriv2_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSplineDeriv2_datamem_bld(&__Genfun__GaudiMathImplementation__GSLSplineDeriv2_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSplineDeriv2_funcmem_bld(&__Genfun__GaudiMathImplementation__GSLSplineDeriv2_db_funcmem);
void __Genfun__GaudiMathImplementation__GSLSplineDeriv2_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv2"), typeid(::Genfun::GaudiMathImplementation::GSLSplineDeriv2), sizeof(::Genfun::GaudiMathImplementation::GSLSplineDeriv2), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSplineDeriv2, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2205, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv2::Data1D"))
  .AddTypedef(type_2206, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv2::Data2D"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10485, type_10485, type_8403c), Reflex::Literal("GSLSplineDeriv2"), constructor_8457, 0, "x;y;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11294, type_8403c), Reflex::Literal("GSLSplineDeriv2"), constructor_8458, 0, "data;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11295), Reflex::Literal("GSLSplineDeriv2"), constructor_8459, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11296), Reflex::Literal("GSLSplineDeriv2"), constructor_8460, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GSLSplineDeriv2"), destructor_8461, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSplineDeriv2_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSplineDeriv2_funcmem_bld);
}

//------Delayed data member builder for class GSLSplineDeriv2 -------------------
void __Genfun__GaudiMathImplementation__GSLSplineDeriv2_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3675, Reflex::Literal("m_spline"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLSplineDeriv2, m_spline), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GSLSplineDeriv2 -------------------
void __Genfun__GaudiMathImplementation__GSLSplineDeriv2_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8454, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11292), Reflex::Literal("clone"), method_8455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8462, 0, "a", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8463, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8464, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8465, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8466, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("spline"), method_8467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("operator const Genfun::GaudiMathImplementation::SplineBase&"), converter_8468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class Constant -------------------------------
static  void operator_8473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::Constant*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Constant*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::Constant*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::Constant*)o)->clone)();
}

static void constructor_8476( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::Constant(*(const double*)arg[0],
      *(const ::size_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::Constant(*(const double*)arg[0],
      *(const ::size_t*)arg[1]);
}

static void constructor_8477( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::Constant(*(const ::Genfun::GaudiMathImplementation::Constant*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::Constant(*(const ::Genfun::GaudiMathImplementation::Constant*)arg[0]);
}

static void destructor_8478(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::Constant*)o)->::Genfun::GaudiMathImplementation::Constant::~Constant)();
}
static  void method_8479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::Constant*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::Constant*)o)->dimensionality)();
}

static  void method_8480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::Constant*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::Constant*)o)->hasAnalyticDerivative)();
}

static  void operator_8481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Constant*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Constant*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Constant*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Constant*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::Constant*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Constant*)o)->partial)(*(unsigned int*)arg[0]);
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::Constant,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Constant -------------------------------
void __Genfun__GaudiMathImplementation__Constant_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__Constant_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__Constant_datamem_bld(&__Genfun__GaudiMathImplementation__Constant_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__Constant_funcmem_bld(&__Genfun__GaudiMathImplementation__Constant_db_funcmem);
void __Genfun__GaudiMathImplementation__Constant_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::Constant"), typeid(::Genfun::GaudiMathImplementation::Constant), sizeof(::Genfun::GaudiMathImplementation::Constant), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::Constant, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1875c, type_1514c), Reflex::Literal("Constant"), constructor_8476, 0, "value;dim", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11299), Reflex::Literal("Constant"), constructor_8477, 0, "right", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Constant"), destructor_8478, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__Constant_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__Constant_funcmem_bld);
}

//------Delayed data member builder for class Constant -------------------
void __Genfun__GaudiMathImplementation__Constant_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1875, Reflex::Literal("m_value"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__Constant, m_value), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_DIM"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__Constant, m_DIM), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Constant -------------------
void __Genfun__GaudiMathImplementation__Constant_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8473, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11298), Reflex::Literal("clone"), method_8474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8479, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8480, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8481, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8482, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8483, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class GSLFunctionWithMode -------------------------------
static  void operator_8489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->clone)();
}

static void constructor_8492( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithMode(Reflex::VoidPtrToFunc< double(*)(double, gsl_mode_t) >(arg[0]),
      *(const ::gsl_mode_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithMode(Reflex::VoidPtrToFunc< double(*)(double, gsl_mode_t) >(arg[0]),
      *(const ::gsl_mode_t*)arg[1]);
}

static void constructor_8493( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithMode(*(const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithMode(*(const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)arg[0]);
}

static void destructor_8494(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->::Genfun::GaudiMathImplementation::GSLFunctionWithMode::~GSLFunctionWithMode)();
}
static  void operator_8495( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->hasAnalyticDerivative)();
}

static  void method_8498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->dimensionality)();
}

static  void method_8499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->function)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->function)();
}

static  void method_8501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->mode)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithMode*)o)->mode)();
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLFunctionWithMode,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GSLFunctionWithMode -------------------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithMode_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__GSLFunctionWithMode_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLFunctionWithMode_datamem_bld(&__Genfun__GaudiMathImplementation__GSLFunctionWithMode_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLFunctionWithMode_funcmem_bld(&__Genfun__GaudiMathImplementation__GSLFunctionWithMode_db_funcmem);
void __Genfun__GaudiMathImplementation__GSLFunctionWithMode_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithMode"), typeid(::Genfun::GaudiMathImplementation::GSLFunctionWithMode), sizeof(::Genfun::GaudiMathImplementation::GSLFunctionWithMode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLFunctionWithMode, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_8390, Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithMode::Function"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8390, type_8388), Reflex::Literal("GSLFunctionWithMode"), constructor_8492, 0, "fun;mode", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11302), Reflex::Literal("GSLFunctionWithMode"), constructor_8493, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GSLFunctionWithMode"), destructor_8494, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__GSLFunctionWithMode_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__GSLFunctionWithMode_funcmem_bld);
}

//------Delayed data member builder for class GSLFunctionWithMode -------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithMode_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8390, Reflex::Literal("m_function"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLFunctionWithMode, m_function), ::Reflex::PRIVATE)
  .AddDataMember(type_11287, Reflex::Literal("m_mode"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLFunctionWithMode, m_mode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GSLFunctionWithMode -------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithMode_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8489, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11301), Reflex::Literal("clone"), method_8490, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8495, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8496, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8497, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8498, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8499, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8390), Reflex::Literal("function"), method_8500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8388), Reflex::Literal("mode"), method_8501, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GSLSpline -------------------------------
static  void operator_8507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->clone)();
}

static void constructor_8510( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
}

static void constructor_8511( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
}

static void constructor_8512( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
}

static void constructor_8513( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::Genfun::GaudiMathImplementation::GSLSpline*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSpline(*(const ::Genfun::GaudiMathImplementation::GSLSpline*)arg[0]);
}

static void destructor_8514(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::GSLSpline*)o)->::Genfun::GaudiMathImplementation::GSLSpline::~GSLSpline)();
}
static  void operator_8515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->dimensionality)();
}

static  void method_8518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->hasAnalyticDerivative)();
}

static  void method_8519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->spline)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->spline)();
}

static  void converter_8521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSpline*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSpline,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GSLSpline -------------------------------
void __Genfun__GaudiMathImplementation__GSLSpline_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__GSLSpline_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSpline_datamem_bld(&__Genfun__GaudiMathImplementation__GSLSpline_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSpline_funcmem_bld(&__Genfun__GaudiMathImplementation__GSLSpline_db_funcmem);
void __Genfun__GaudiMathImplementation__GSLSpline_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSpline"), typeid(::Genfun::GaudiMathImplementation::GSLSpline), sizeof(::Genfun::GaudiMathImplementation::GSLSpline), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSpline, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2205, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSpline::Data1D"))
  .AddTypedef(type_2206, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSpline::Data2D"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10485, type_10485, type_8403c), Reflex::Literal("GSLSpline"), constructor_8510, 0, "x;y;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11294, type_8403c), Reflex::Literal("GSLSpline"), constructor_8511, 0, "data;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11295), Reflex::Literal("GSLSpline"), constructor_8512, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11306), Reflex::Literal("GSLSpline"), constructor_8513, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GSLSpline"), destructor_8514, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSpline_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSpline_funcmem_bld);
}

//------Delayed data member builder for class GSLSpline -------------------
void __Genfun__GaudiMathImplementation__GSLSpline_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3675, Reflex::Literal("m_spline"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLSpline, m_spline), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GSLSpline -------------------
void __Genfun__GaudiMathImplementation__GSLSpline_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8507, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11305), Reflex::Literal("clone"), method_8508, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8515, 0, "a", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8516, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8517, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8518, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8519, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("spline"), method_8520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("operator const Genfun::GaudiMathImplementation::SplineBase&"), converter_8521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class GSLSplineInteg -------------------------------
static  void operator_8528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->clone)();
}

static void constructor_8531( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2],
      *(const double*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2],
      *(const double*)arg[3]);
  }
}

static void constructor_8532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1],
      *(const double*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1],
      *(const double*)arg[2]);
  }
}

static void constructor_8533( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0],
      *(const double*)arg[1]);
  }
}

static void constructor_8534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineInteg(*(const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)arg[0]);
}

static void destructor_8535(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->::Genfun::GaudiMathImplementation::GSLSplineInteg::~GSLSplineInteg)();
}
static  void operator_8536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->dimensionality)();
}

static  void method_8539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->hasAnalyticDerivative)();
}

static  void method_8540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->spline)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->spline)();
}

static  void converter_8542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineInteg*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSplineInteg,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GSLSplineInteg -------------------------------
void __Genfun__GaudiMathImplementation__GSLSplineInteg_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__GSLSplineInteg_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSplineInteg_datamem_bld(&__Genfun__GaudiMathImplementation__GSLSplineInteg_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSplineInteg_funcmem_bld(&__Genfun__GaudiMathImplementation__GSLSplineInteg_db_funcmem);
void __Genfun__GaudiMathImplementation__GSLSplineInteg_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineInteg"), typeid(::Genfun::GaudiMathImplementation::GSLSplineInteg), sizeof(::Genfun::GaudiMathImplementation::GSLSplineInteg), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSplineInteg, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2205, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineInteg::Data1D"))
  .AddTypedef(type_2206, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineInteg::Data2D"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10485, type_10485, type_8403c, type_1875c), Reflex::Literal("GSLSplineInteg"), constructor_8531, 0, "x;y;type;low=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11294, type_8403c, type_1875c), Reflex::Literal("GSLSplineInteg"), constructor_8532, 0, "data;type;low=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11295, type_1875c), Reflex::Literal("GSLSplineInteg"), constructor_8533, 0, ";low=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11309), Reflex::Literal("GSLSplineInteg"), constructor_8534, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GSLSplineInteg"), destructor_8535, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSplineInteg_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSplineInteg_funcmem_bld);
}

//------Delayed data member builder for class GSLSplineInteg -------------------
void __Genfun__GaudiMathImplementation__GSLSplineInteg_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3675, Reflex::Literal("m_spline"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLSplineInteg, m_spline), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_low"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLSplineInteg, m_low), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GSLSplineInteg -------------------
void __Genfun__GaudiMathImplementation__GSLSplineInteg_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8528, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11308), Reflex::Literal("clone"), method_8529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8536, 0, "a", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8537, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8538, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8539, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8540, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("spline"), method_8541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("operator const Genfun::GaudiMathImplementation::SplineBase&"), converter_8542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class NumericalDerivative -------------------------------
static  void operator_8553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->clone)();
}

static void constructor_8556( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDerivative(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDerivative(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDerivative(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::Genfun::GaudiMathImplementation::NumericalDerivative::Type*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDerivative(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::Genfun::GaudiMathImplementation::NumericalDerivative::Type*)arg[2]);
  }
}

static void constructor_8557( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDerivative(*(const ::Genfun::GaudiMathImplementation::NumericalDerivative*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalDerivative(*(const ::Genfun::GaudiMathImplementation::NumericalDerivative*)arg[0]);
}

static void destructor_8558(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->::Genfun::GaudiMathImplementation::NumericalDerivative::~NumericalDerivative)();
}
static  void method_8559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->dimensionality)();
}

static  void operator_8560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->hasAnalyticDerivative)();
}

static  void method_8563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->function)();
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->function)();
}

static  void method_8565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->index)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->index)();
}

static  void method_8566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->type)();
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->type)();
}

static  void method_8567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->setType)(*(const ::Genfun::GaudiMathImplementation::NumericalDerivative::Type*)arg[0]);
  else   (((::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->setType)(*(const ::Genfun::GaudiMathImplementation::NumericalDerivative::Type*)arg[0]);
}

static  void method_8568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->result)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->result)();
}

static  void method_8569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->error)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalDerivative*)o)->error)();
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::NumericalDerivative,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NumericalDerivative -------------------------------
void __Genfun__GaudiMathImplementation__NumericalDerivative_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__NumericalDerivative_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__NumericalDerivative_datamem_bld(&__Genfun__GaudiMathImplementation__NumericalDerivative_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__NumericalDerivative_funcmem_bld(&__Genfun__GaudiMathImplementation__NumericalDerivative_db_funcmem);
void __Genfun__GaudiMathImplementation__NumericalDerivative_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDerivative"), typeid(::Genfun::GaudiMathImplementation::NumericalDerivative), sizeof(::Genfun::GaudiMathImplementation::NumericalDerivative), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::NumericalDerivative, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalDerivative::Type"), Reflex::Literal("Central=0;Forward=1;Backward=2"), &typeid(Genfun::GaudiMathImplementation::NumericalDerivative::Type), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_11312), Reflex::Literal("NumericalDerivative"), constructor_8556, 0, "function;index;type=Central", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11313), Reflex::Literal("NumericalDerivative"), constructor_8557, 0, "right", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NumericalDerivative"), destructor_8558, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__NumericalDerivative_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__NumericalDerivative_funcmem_bld);
}

//------Delayed data member builder for class NumericalDerivative -------------------
void __Genfun__GaudiMathImplementation__NumericalDerivative_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11071, Reflex::Literal("m_function"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDerivative, m_function), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_index"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDerivative, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_DIM"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDerivative, m_DIM), ::Reflex::PRIVATE)
  .AddDataMember(type_8552, Reflex::Literal("m_type"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDerivative, m_type), ::Reflex::PRIVATE)
  .AddDataMember(type_3362, Reflex::Literal("m_argument"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDerivative, m_argument), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1875, Reflex::Literal("m_result"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDerivative, m_result), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1875, Reflex::Literal("m_error"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalDerivative, m_error), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class NumericalDerivative -------------------
void __Genfun__GaudiMathImplementation__NumericalDerivative_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8553, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11311), Reflex::Literal("clone"), method_8554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8559, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8560, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8561, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8562, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8563, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3426), Reflex::Literal("function"), method_8564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1514), Reflex::Literal("index"), method_8565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11312), Reflex::Literal("type"), method_8566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11312, type_11312), Reflex::Literal("setType"), method_8567, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("result"), method_8568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("error"), method_8569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SplineBase -------------------------------
static void constructor_8582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::SplineBase(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::SplineBase(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
}

static void constructor_8583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::SplineBase(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::SplineBase(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
}

static void constructor_8584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::SplineBase(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::SplineBase(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
}

static void destructor_8585(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::SplineBase*)o)->::Genfun::GaudiMathImplementation::SplineBase::~SplineBase)();
}
static  void method_8586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->eval)(*(const double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->eval)(*(const double*)arg[0]);
}

static  void method_8587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->deriv)(*(const double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->deriv)(*(const double*)arg[0]);
}

static  void method_8588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->deriv2)(*(const double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->deriv2)(*(const double*)arg[0]);
}

static  void method_8589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->integ)(*(const double*)arg[0],
    *(const double*)arg[1]));
  else   (((const ::Genfun::GaudiMathImplementation::SplineBase*)o)->integ)(*(const double*)arg[0],
    *(const double*)arg[1]);
}

//------Dictionary for class SplineBase -------------------------------
void __Genfun__GaudiMathImplementation__SplineBase_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__SplineBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__SplineBase_datamem_bld(&__Genfun__GaudiMathImplementation__SplineBase_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__SplineBase_funcmem_bld(&__Genfun__GaudiMathImplementation__SplineBase_db_funcmem);
void __Genfun__GaudiMathImplementation__SplineBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::SplineBase"), typeid(::Genfun::GaudiMathImplementation::SplineBase), sizeof(::Genfun::GaudiMathImplementation::SplineBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddTypedef(type_2205, Reflex::Literal("Genfun::GaudiMathImplementation::SplineBase::Data1D"))
  .AddTypedef(type_2206, Reflex::Literal("Genfun::GaudiMathImplementation::SplineBase::Data2D"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10485, type_10485, type_8403c), Reflex::Literal("SplineBase"), constructor_8582, 0, "x;y;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11294, type_8403c), Reflex::Literal("SplineBase"), constructor_8583, 0, "data;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11295), Reflex::Literal("SplineBase"), constructor_8584, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SplineBase"), destructor_8585, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__SplineBase_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__SplineBase_funcmem_bld);
}

//------Delayed data member builder for class SplineBase -------------------
void __Genfun__GaudiMathImplementation__SplineBase_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2779, Reflex::Literal("m_init"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SplineBase, m_init), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1514, Reflex::Literal("m_dim"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SplineBase, m_dim), ::Reflex::PRIVATE)
  .AddDataMember(type_2803, Reflex::Literal("m_x"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SplineBase, m_x), ::Reflex::PRIVATE)
  .AddDataMember(type_2803, Reflex::Literal("m_y"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SplineBase, m_y), ::Reflex::PRIVATE)
  .AddDataMember(type_4168, Reflex::Literal("m_spline"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SplineBase, m_spline), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_2800, Reflex::Literal("m_accel"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SplineBase, m_accel), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_8403, Reflex::Literal("m_type"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__SplineBase, m_type), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SplineBase -------------------
void __Genfun__GaudiMathImplementation__SplineBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875c), Reflex::Literal("eval"), method_8586, 0, "x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875c), Reflex::Literal("deriv"), method_8587, 0, "x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875c), Reflex::Literal("deriv2"), method_8588, 0, "x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875c, type_1875c), Reflex::Literal("integ"), method_8589, 0, "a;b", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class NumericalIndefiniteIntegral -------------------------------
static  void operator_8613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->clone)();
}

static void constructor_8616( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7],
      *(const ::size_t*)arg[8]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::GaudiMath::Integration::Limit*)arg[3],
      *(const ::GaudiMath::Integration::Type*)arg[4],
      *(const ::GaudiMath::Integration::KronrodRule*)arg[5],
      *(const double*)arg[6],
      *(const double*)arg[7],
      *(const ::size_t*)arg[8]);
  }
}

static void constructor_8617( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4],
      *(const double*)arg[5]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4],
      *(const double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6],
      *(const ::size_t*)arg[7]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const double*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::GaudiMath::Integration::Limit*)arg[4],
      *(const double*)arg[5],
      *(const double*)arg[6],
      *(const ::size_t*)arg[7]);
  }
}

static void constructor_8618( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2],
      *(const double*)arg[3]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2],
      *(const double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4],
      *(const ::size_t*)arg[5]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::AbsFunction*)arg[0],
      *(const ::size_t*)arg[1],
      *(const ::GaudiMath::Integration::Limit*)arg[2],
      *(const double*)arg[3],
      *(const double*)arg[4],
      *(const ::size_t*)arg[5]);
  }
}

static void constructor_8619( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral(*(const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)arg[0]);
}

static void destructor_8620(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral::~NumericalIndefiniteIntegral)();
}
static  void method_8621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->dimensionality)();
}

static  void operator_8622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->hasAnalyticDerivative)();
}

static  void method_8625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->function)();
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->function)();
}

static  void method_8627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->a)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->a)();
}

static  void method_8628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->points)();
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->points)();
}

static  void method_8629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->epsabs)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->epsabs)();
}

static  void method_8630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->epsrel)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->epsrel)();
}

static  void method_8631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->result)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->result)();
}

static  void method_8632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->error)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->error)();
}

static  void method_8633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->size)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->size)();
}

static  void method_8634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->limit)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->limit)();
}

static  void method_8635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->type)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->type)();
}

static  void method_8636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->category)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->category)();
}

static  void method_8637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->rule)());
  else   (((const ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral*)o)->rule)();
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NumericalIndefiniteIntegral -------------------------------
void __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_datamem_bld(&__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_funcmem_bld(&__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_db_funcmem);
void __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral"), typeid(::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral), sizeof(::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2205, Reflex::Literal("Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral::Points"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_1875c, type_8398c, type_8400c, type_8399c, type_1875c, type_1875c, type_1514c), Reflex::Literal("NumericalIndefiniteIntegral"), constructor_8616, 0, "function;index;a;limit=VariableHighLimit;type=Adaptive;rule=Gauss31;epsabs=1.0000000000000000364321973154977415791655470656e-10;epsrel=9.99999999999999954748111825886258685613938723691e-8;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_1875c, type_10485, type_8398c, type_1875c, type_1875c, type_1514c), Reflex::Literal("NumericalIndefiniteIntegral"), constructor_8617, 0, "function;index;a;points;limit=VariableHighLimit;epsabs=1.00000000000000006228159145777985641889706869279e-9;epsrel=9.99999999999999954748111825886258685613938723691e-7;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3426, type_1514c, type_8398c, type_1875c, type_1875c, type_1514c), Reflex::Literal("NumericalIndefiniteIntegral"), constructor_8618, 0, "function;index;limit=VariableHighLimit;epsabs=1.00000000000000006228159145777985641889706869279e-9;epsrel=9.99999999999999954748111825886258685613938723691e-7;size=1000", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11319), Reflex::Literal("NumericalIndefiniteIntegral"), constructor_8619, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NumericalIndefiniteIntegral"), destructor_8620, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_funcmem_bld);
}

//------Delayed data member builder for class NumericalIndefiniteIntegral -------------------
void __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11071, Reflex::Literal("m_function"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_function), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_DIM"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_DIM), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_index"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_a"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_a), ::Reflex::PRIVATE)
  .AddDataMember(type_8398, Reflex::Literal("m_limit"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_limit), ::Reflex::PRIVATE)
  .AddDataMember(type_8400, Reflex::Literal("m_type"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_type), ::Reflex::PRIVATE)
  .AddDataMember(type_8401, Reflex::Literal("m_category"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_category), ::Reflex::PRIVATE)
  .AddDataMember(type_8399, Reflex::Literal("m_rule"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_rule), ::Reflex::PRIVATE)
  .AddDataMember(type_2205, Reflex::Literal("m_points"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_points), ::Reflex::PRIVATE)
  .AddDataMember(type_2803, Reflex::Literal("m_pdata"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_pdata), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_epsabs"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_epsabs), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_epsrel"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_epsrel), ::Reflex::PRIVATE)
  .AddDataMember(type_1875, Reflex::Literal("m_result"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_result), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1875, Reflex::Literal("m_error"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_error), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1514, Reflex::Literal("m_size"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_size), ::Reflex::PRIVATE)
  .AddDataMember(type_11316, Reflex::Literal("m_ws"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_ws), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_3362, Reflex::Literal("m_argument"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral, m_argument), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class NumericalIndefiniteIntegral -------------------
void __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8613, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11317), Reflex::Literal("clone"), method_8614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8621, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8622, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8623, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8624, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8625, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3426), Reflex::Literal("function"), method_8626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("a"), method_8627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10485), Reflex::Literal("points"), method_8628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("epsabs"), method_8629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("epsrel"), method_8630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("result"), method_8631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("error"), method_8632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1514), Reflex::Literal("size"), method_8633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8398), Reflex::Literal("limit"), method_8634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8400), Reflex::Literal("type"), method_8635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8401), Reflex::Literal("category"), method_8636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8399), Reflex::Literal("rule"), method_8637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Adapter2DoubleFunction -------------------------------
static  void operator_8650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->clone)();
}

static void constructor_8653( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction(Reflex::VoidPtrToFunc< double(*)(double, double) >(arg[0]));
  else ::new(mem) ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction(Reflex::VoidPtrToFunc< double(*)(double, double) >(arg[0]));
}

static void constructor_8654( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction(*(const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction(*(const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)arg[0]);
}

static void destructor_8655(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->::Genfun::GaudiMathImplementation::Adapter2DoubleFunction::~Adapter2DoubleFunction)();
}
static  void operator_8656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->dimensionality)();
}

static  void method_8659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->hasAnalyticDerivative)();
}

static  void method_8660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void operator_8661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(const double*)arg[0],
    *(const double*)arg[1]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction*)o)->operator())(*(const double*)arg[0],
    *(const double*)arg[1]);
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Adapter2DoubleFunction -------------------------------
void __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_datamem_bld(&__Genfun__GaudiMathImplementation__Adapter2DoubleFunction_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_funcmem_bld(&__Genfun__GaudiMathImplementation__Adapter2DoubleFunction_db_funcmem);
void __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::Adapter2DoubleFunction"), typeid(::Genfun::GaudiMathImplementation::Adapter2DoubleFunction), sizeof(::Genfun::GaudiMathImplementation::Adapter2DoubleFunction), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::Adapter2DoubleFunction, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_8396, Reflex::Literal("Genfun::GaudiMathImplementation::Adapter2DoubleFunction::Function"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8396), Reflex::Literal("Adapter2DoubleFunction"), constructor_8653, 0, "func", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11323), Reflex::Literal("Adapter2DoubleFunction"), constructor_8654, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Adapter2DoubleFunction"), destructor_8655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__Adapter2DoubleFunction_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__Adapter2DoubleFunction_funcmem_bld);
}

//------Delayed data member builder for class Adapter2DoubleFunction -------------------
void __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8396, Reflex::Literal("m_func"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__Adapter2DoubleFunction, m_func), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Adapter2DoubleFunction -------------------
void __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8650, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11322), Reflex::Literal("clone"), method_8651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8656, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8657, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8658, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8659, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8660, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875c, type_1875c), Reflex::Literal("operator()"), operator_8661, 0, "x;y", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class Adapter3DoubleFunction -------------------------------
static  void operator_8666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->clone)();
}

static void constructor_8669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction(Reflex::VoidPtrToFunc< double(*)(double, double, double) >(arg[0]));
  else ::new(mem) ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction(Reflex::VoidPtrToFunc< double(*)(double, double, double) >(arg[0]));
}

static void constructor_8670( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction(*(const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction(*(const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)arg[0]);
}

static void destructor_8671(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->::Genfun::GaudiMathImplementation::Adapter3DoubleFunction::~Adapter3DoubleFunction)();
}
static  void operator_8672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->dimensionality)();
}

static  void method_8675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->hasAnalyticDerivative)();
}

static  void method_8676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void operator_8677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(const double*)arg[0],
    *(const double*)arg[1],
    *(const double*)arg[2]));
  else   (((const ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction*)o)->operator())(*(const double*)arg[0],
    *(const double*)arg[1],
    *(const double*)arg[2]);
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Adapter3DoubleFunction -------------------------------
void __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_datamem_bld(&__Genfun__GaudiMathImplementation__Adapter3DoubleFunction_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_funcmem_bld(&__Genfun__GaudiMathImplementation__Adapter3DoubleFunction_db_funcmem);
void __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::Adapter3DoubleFunction"), typeid(::Genfun::GaudiMathImplementation::Adapter3DoubleFunction), sizeof(::Genfun::GaudiMathImplementation::Adapter3DoubleFunction), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::Adapter3DoubleFunction, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_8395, Reflex::Literal("Genfun::GaudiMathImplementation::Adapter3DoubleFunction::Function"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8395), Reflex::Literal("Adapter3DoubleFunction"), constructor_8669, 0, "func", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11326), Reflex::Literal("Adapter3DoubleFunction"), constructor_8670, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Adapter3DoubleFunction"), destructor_8671, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__Adapter3DoubleFunction_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__Adapter3DoubleFunction_funcmem_bld);
}

//------Delayed data member builder for class Adapter3DoubleFunction -------------------
void __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8395, Reflex::Literal("m_func"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__Adapter3DoubleFunction, m_func), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Adapter3DoubleFunction -------------------
void __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8666, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11325), Reflex::Literal("clone"), method_8667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8672, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8673, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8674, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8675, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8676, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875c, type_1875c, type_1875c), Reflex::Literal("operator()"), operator_8677, 0, "x;y;z", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class AdapterIFunction -------------------------------
static  void operator_8683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->clone)();
}

static void constructor_8686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::AdapterIFunction(*(const ::AIDA::IFunction*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::AdapterIFunction(*(const ::AIDA::IFunction*)arg[0]);
}

static void constructor_8687( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::AdapterIFunction(*(const ::Genfun::GaudiMathImplementation::AdapterIFunction*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::AdapterIFunction(*(const ::Genfun::GaudiMathImplementation::AdapterIFunction*)arg[0]);
}

static void destructor_8688(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->::Genfun::GaudiMathImplementation::AdapterIFunction::~AdapterIFunction)();
}
static  void operator_8689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->dimensionality)();
}

static  void method_8692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->hasAnalyticDerivative)();
}

static  void method_8693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::AdapterIFunction*)o)->partial)(*(unsigned int*)arg[0]);
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::AdapterIFunction,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class AdapterIFunction -------------------------------
void __Genfun__GaudiMathImplementation__AdapterIFunction_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__AdapterIFunction_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__AdapterIFunction_datamem_bld(&__Genfun__GaudiMathImplementation__AdapterIFunction_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__AdapterIFunction_funcmem_bld(&__Genfun__GaudiMathImplementation__AdapterIFunction_db_funcmem);
void __Genfun__GaudiMathImplementation__AdapterIFunction_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::AdapterIFunction"), typeid(::Genfun::GaudiMathImplementation::AdapterIFunction), sizeof(::Genfun::GaudiMathImplementation::AdapterIFunction), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::AdapterIFunction, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8397), Reflex::Literal("AdapterIFunction"), constructor_8686, 0, "fun", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11330), Reflex::Literal("AdapterIFunction"), constructor_8687, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AdapterIFunction"), destructor_8688, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__AdapterIFunction_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__AdapterIFunction_funcmem_bld);
}

//------Delayed data member builder for class AdapterIFunction -------------------
void __Genfun__GaudiMathImplementation__AdapterIFunction_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11328, Reflex::Literal("m_fun"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__AdapterIFunction, m_fun), ::Reflex::PRIVATE)
  .AddDataMember(type_1514, Reflex::Literal("m_dim"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__AdapterIFunction, m_dim), ::Reflex::PRIVATE)
  .AddDataMember(type_2205, Reflex::Literal("m_arg"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__AdapterIFunction, m_arg), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class AdapterIFunction -------------------
void __Genfun__GaudiMathImplementation__AdapterIFunction_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8683, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11329), Reflex::Literal("clone"), method_8684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8689, 0, "a", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8690, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8691, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8692, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8693, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class GSLSplineDeriv -------------------------------
static  void operator_8699( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->clone)();
}

static void constructor_8702( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::std::vector<double>*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::GaudiMath::Interpolation::Type*)arg[2]);
}

static void constructor_8703( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::std::vector<std::pair<double,double> >*)arg[0],
      *(const ::GaudiMath::Interpolation::Type*)arg[1]);
}

static void constructor_8704( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::Genfun::GaudiMathImplementation::SplineBase*)arg[0]);
}

static void constructor_8705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLSplineDeriv(*(const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)arg[0]);
}

static void destructor_8706(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->::Genfun::GaudiMathImplementation::GSLSplineDeriv::~GSLSplineDeriv)();
}
static  void operator_8707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->dimensionality)();
}

static  void method_8710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->hasAnalyticDerivative)();
}

static  void method_8711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->spline)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->spline)();
}

static  void converter_8713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLSplineDeriv*)o)->operator const Genfun::GaudiMathImplementation::SplineBase&)();
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSplineDeriv,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GSLSplineDeriv -------------------------------
void __Genfun__GaudiMathImplementation__GSLSplineDeriv_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__GSLSplineDeriv_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSplineDeriv_datamem_bld(&__Genfun__GaudiMathImplementation__GSLSplineDeriv_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLSplineDeriv_funcmem_bld(&__Genfun__GaudiMathImplementation__GSLSplineDeriv_db_funcmem);
void __Genfun__GaudiMathImplementation__GSLSplineDeriv_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv"), typeid(::Genfun::GaudiMathImplementation::GSLSplineDeriv), sizeof(::Genfun::GaudiMathImplementation::GSLSplineDeriv), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLSplineDeriv, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2205, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv::Data1D"))
  .AddTypedef(type_2206, Reflex::Literal("Genfun::GaudiMathImplementation::GSLSplineDeriv::Data2D"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10485, type_10485, type_8403c), Reflex::Literal("GSLSplineDeriv"), constructor_8702, 0, "x;y;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11294, type_8403c), Reflex::Literal("GSLSplineDeriv"), constructor_8703, 0, "data;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11295), Reflex::Literal("GSLSplineDeriv"), constructor_8704, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11333), Reflex::Literal("GSLSplineDeriv"), constructor_8705, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GSLSplineDeriv"), destructor_8706, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSplineDeriv_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__GSLSplineDeriv_funcmem_bld);
}

//------Delayed data member builder for class GSLSplineDeriv -------------------
void __Genfun__GaudiMathImplementation__GSLSplineDeriv_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3675, Reflex::Literal("m_spline"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLSplineDeriv, m_spline), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GSLSplineDeriv -------------------
void __Genfun__GaudiMathImplementation__GSLSplineDeriv_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8699, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11332), Reflex::Literal("clone"), method_8700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8707, 0, "a", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8708, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8709, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8711, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("spline"), method_8712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11295), Reflex::Literal("operator const Genfun::GaudiMathImplementation::SplineBase&"), converter_8713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class GSLFunctionWithError -------------------------------
static  void operator_8719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_8720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->clone)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->clone)();
}

static void constructor_8722( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithError(Reflex::VoidPtrToFunc< int(*)(double, gsl_sf_result*) >(arg[0]));
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithError(Reflex::VoidPtrToFunc< int(*)(double, gsl_sf_result*) >(arg[0]));
}

static void constructor_8723( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithError(*(const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)arg[0]);
  else ::new(mem) ::Genfun::GaudiMathImplementation::GSLFunctionWithError(*(const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)arg[0]);
}

static void destructor_8724(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->::Genfun::GaudiMathImplementation::GSLFunctionWithError::~GSLFunctionWithError)();
}
static  void operator_8725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->operator())(*(double*)arg[0]);
}

static  void operator_8726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_8727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->hasAnalyticDerivative)();
}

static  void method_8728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->dimensionality)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->dimensionality)();
}

static  void method_8729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->partial)(*(unsigned int*)arg[0]);
}

static  void method_8730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->function)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->function)();
}

static  void method_8731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->result)();
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->result)();
}

static  void method_8732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->error)());
  else   (((const ::Genfun::GaudiMathImplementation::GSLFunctionWithError*)o)->error)();
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Genfun::AbsFunction")), ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLFunctionWithError,::Genfun::AbsFunction >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GSLFunctionWithError -------------------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithError_db_datamem(Reflex::Class*);
void __Genfun__GaudiMathImplementation__GSLFunctionWithError_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLFunctionWithError_datamem_bld(&__Genfun__GaudiMathImplementation__GSLFunctionWithError_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__GaudiMathImplementation__GSLFunctionWithError_funcmem_bld(&__Genfun__GaudiMathImplementation__GSLFunctionWithError_db_funcmem);
void __Genfun__GaudiMathImplementation__GSLFunctionWithError_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithError"), typeid(::Genfun::GaudiMathImplementation::GSLFunctionWithError), sizeof(::Genfun::GaudiMathImplementation::GSLFunctionWithError), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddBase(type_3359, ::Reflex::BaseOffset< ::Genfun::GaudiMathImplementation::GSLFunctionWithError, ::Genfun::AbsFunction >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_8389, Reflex::Literal("Genfun::GaudiMathImplementation::GSLFunctionWithError::Function"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8389), Reflex::Literal("GSLFunctionWithError"), constructor_8722, 0, "function", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11304), Reflex::Literal("GSLFunctionWithError"), constructor_8723, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GSLFunctionWithError"), destructor_8724, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Genfun__GaudiMathImplementation__GSLFunctionWithError_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Genfun__GaudiMathImplementation__GSLFunctionWithError_funcmem_bld);
}

//------Delayed data member builder for class GSLFunctionWithError -------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithError_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8389, Reflex::Literal("m_function"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLFunctionWithError, m_function), ::Reflex::PRIVATE)
  .AddDataMember(type_3701, Reflex::Literal("m_result"), OffsetOf(__shadow__::__Genfun__GaudiMathImplementation__GSLFunctionWithError, m_result), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GSLFunctionWithError -------------------
void __Genfun__GaudiMathImplementation__GSLFunctionWithError_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_8719, 0, "function", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11335), Reflex::Literal("clone"), method_8720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_8725, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_8726, 0, "x", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_8727, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_8728, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_8729, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8389), Reflex::Literal("function"), method_8730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11290), Reflex::Literal("result"), method_8731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875), Reflex::Literal("error"), method_8732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class AbsFunction -------------------------------
static void destructor_7499(void*, void * o, const std::vector<void*>&, void *) {
(((::Genfun::AbsFunction*)o)->::Genfun::AbsFunction::~AbsFunction)();
}
static  void method_7500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Genfun::AbsFunction*)o)->dimensionality)());
  else   (((const ::Genfun::AbsFunction*)o)->dimensionality)();
}

static  void operator_7501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::AbsFunction*)o)->operator())(*(double*)arg[0]));
  else   (((const ::Genfun::AbsFunction*)o)->operator())(*(double*)arg[0]);
}

static  void operator_7502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Genfun::AbsFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]));
  else   (((const ::Genfun::AbsFunction*)o)->operator())(*(const ::Genfun::Argument*)arg[0]);
}

static  void method_7503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Genfun::AbsFunction*)o)->clone)());
  else   (((const ::Genfun::AbsFunction*)o)->clone)();
}

static  void operator_7504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::FunctionComposition)((((const ::Genfun::AbsFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]));
  else   (((const ::Genfun::AbsFunction*)o)->operator())(*(const ::Genfun::AbsFunction*)arg[0]);
}

static  void method_7505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::AbsFunction*)o)->derivative)(*(const ::Genfun::Variable*)arg[0]));
  else   (((const ::Genfun::AbsFunction*)o)->derivative)(*(const ::Genfun::Variable*)arg[0]);
}

static  void method_7506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::AbsFunction*)o)->prime)());
  else   (((const ::Genfun::AbsFunction*)o)->prime)();
}

static  void method_7507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Genfun::AbsFunction*)o)->hasAnalyticDerivative)());
  else   (((const ::Genfun::AbsFunction*)o)->hasAnalyticDerivative)();
}

static  void method_7508( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Genfun::Derivative)((((const ::Genfun::AbsFunction*)o)->partial)(*(unsigned int*)arg[0]));
  else   (((const ::Genfun::AbsFunction*)o)->partial)(*(unsigned int*)arg[0]);
}

//------Dictionary for class AbsFunction -------------------------------
void __Genfun__AbsFunction_db_datamem(Reflex::Class*);
void __Genfun__AbsFunction_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Genfun__AbsFunction_datamem_bld(&__Genfun__AbsFunction_db_datamem);
Reflex::GenreflexMemberBuilder __Genfun__AbsFunction_funcmem_bld(&__Genfun__AbsFunction_db_funcmem);
void __Genfun__AbsFunction_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Genfun::AbsFunction"), typeid(::Genfun::AbsFunction), sizeof(::Genfun::AbsFunction), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "GaudiMath::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AbsFunction"), destructor_7499, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__Genfun__AbsFunction_funcmem_bld);
}

//------Delayed data member builder for class AbsFunction -------------------
void __Genfun__AbsFunction_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class AbsFunction -------------------
void __Genfun__AbsFunction_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_51), Reflex::Literal("dimensionality"), method_7500, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_1875), Reflex::Literal("operator()"), operator_7501, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1875, type_7888), Reflex::Literal("operator()"), operator_7502, 0, "argument", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11060), Reflex::Literal("clone"), method_7503, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3433, type_3426), Reflex::Literal("operator()"), operator_7504, 0, "f", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_11061), Reflex::Literal("derivative"), method_7505, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455), Reflex::Literal("prime"), method_7506, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2779), Reflex::Literal("hasAnalyticDerivative"), method_7507, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455, type_51), Reflex::Literal("partial"), method_7508, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __IGslSvc_dict(); 
      __GslError_dict(); 
      __IGslErrorHandler_dict(); 
      __Genfun__GaudiMathImplementation__NumericalDefiniteIntegral_dict(); 
      __Genfun__GaudiMathImplementation__SimpleFunction_dict(); 
      __Genfun__GaudiMathImplementation__GSLFunctionWithModeAndError_dict(); 
      __Genfun__GaudiMathImplementation__GSLSplineDeriv2_dict(); 
      __Genfun__GaudiMathImplementation__Constant_dict(); 
      __Genfun__GaudiMathImplementation__GSLFunctionWithMode_dict(); 
      __Genfun__GaudiMathImplementation__GSLSpline_dict(); 
      __Genfun__GaudiMathImplementation__GSLSplineInteg_dict(); 
      __Genfun__GaudiMathImplementation__NumericalDerivative_dict(); 
      __Genfun__GaudiMathImplementation__SplineBase_dict(); 
      __Genfun__GaudiMathImplementation__NumericalIndefiniteIntegral_dict(); 
      __Genfun__GaudiMathImplementation__Adapter2DoubleFunction_dict(); 
      __Genfun__GaudiMathImplementation__Adapter3DoubleFunction_dict(); 
      __Genfun__GaudiMathImplementation__AdapterIFunction_dict(); 
      __Genfun__GaudiMathImplementation__GSLSplineDeriv_dict(); 
      __Genfun__GaudiMathImplementation__GSLFunctionWithError_dict(); 
      __Genfun__AbsFunction_dict(); 
    }
    ~Dictionaries() {
      type_252.Unload(); // class IGslSvc 
      type_436.Unload(); // class GslError 
      type_547.Unload(); // class IGslErrorHandler 
      type_3644.Unload(); // class Genfun::GaudiMathImplementation::NumericalDefiniteIntegral 
      type_3657.Unload(); // class Genfun::GaudiMathImplementation::SimpleFunction 
      type_3660.Unload(); // class Genfun::GaudiMathImplementation::GSLFunctionWithModeAndError 
      type_3662.Unload(); // class Genfun::GaudiMathImplementation::GSLSplineDeriv2 
      type_3664.Unload(); // class Genfun::GaudiMathImplementation::Constant 
      type_3666.Unload(); // class Genfun::GaudiMathImplementation::GSLFunctionWithMode 
      type_3669.Unload(); // class Genfun::GaudiMathImplementation::GSLSpline 
      type_3671.Unload(); // class Genfun::GaudiMathImplementation::GSLSplineInteg 
      type_3673.Unload(); // class Genfun::GaudiMathImplementation::NumericalDerivative 
      type_3675.Unload(); // class Genfun::GaudiMathImplementation::SplineBase 
      type_3677.Unload(); // class Genfun::GaudiMathImplementation::NumericalIndefiniteIntegral 
      type_3679.Unload(); // class Genfun::GaudiMathImplementation::Adapter2DoubleFunction 
      type_3681.Unload(); // class Genfun::GaudiMathImplementation::Adapter3DoubleFunction 
      type_3683.Unload(); // class Genfun::GaudiMathImplementation::AdapterIFunction 
      type_3685.Unload(); // class Genfun::GaudiMathImplementation::GSLSplineDeriv 
      type_3687.Unload(); // class Genfun::GaudiMathImplementation::GSLFunctionWithError 
      type_3359.Unload(); // class Genfun::AbsFunction 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
