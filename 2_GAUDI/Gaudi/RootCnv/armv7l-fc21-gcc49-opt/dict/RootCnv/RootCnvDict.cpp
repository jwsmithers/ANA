// Generated at Mon Feb 16 20:00:13 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="lcg-g++-4.9.1"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard "
  GCCXML_EXECUTABLE="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__SSP_STRONG__='3' -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__UINT_LEAST16_MAX__='65535' -D__ARM_SIZEOF_WCHAR_T='32' -D__ATOMIC_ACQUIRE='2' -D__SFRACT_IBIT__='0' -D__FLT_MIN__='1.1754943508222875e-38F' -D__GCC_IEC_559_COMPLEX='2' -D__UFRACT_MAX__='0XFFFFP-16UR' -D__UINT_LEAST8_TYPE__='unsigned char' -D__DQ_FBIT__='63' -D__INTMAX_C(c)='c ## LL' -D__ARM_FEATURE_SAT='1' -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK' -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__UINT8_MAX__='255' -D__ACCUM_FBIT__='15' -D__WINT_MAX__='4294967295U' -D__USFRACT_FBIT__='8' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='4294967295U' -D__ARM_ARCH_ISA_ARM='1' -D__WCHAR_MAX__='4294967295U' -D__LACCUM_IBIT__='32' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.9406564584124654e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__GCC_IEC_559='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__cpp_binary_literals='201304' -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__FRACT_FBIT__='15' -D__UINT_FAST64_MAX__='18446744073709551615ULL' -D__SIG_ATOMIC_TYPE__='int' -D__UACCUM_FBIT__='16' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__ARMEL__='1' -D__ARM_FEATURE_UNALIGNED='1' -D__LFRACT_IBIT__='0' -D__GNUC_PATCHLEVEL__='2' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR' -D__UINT_FAST8_MAX__='255' -D__has_include(STR)='__has_include__(STR)' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615ULL' -D__SA_FBIT__='15' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L' -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16' -D__ARM_FP='12' -D__UFRACT_MIN__='0.0UR' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__CHAR_UNSIGNED__='1' -D__UINT32_MAX__='4294967295U' -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64' -D__LDBL_MAX_EXP__='1024' -D__WINT_MIN__='0U' -D__linux__='1' -D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='0U' -D__INT64_C(c)='c ## LL' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D_FORTIFY_SOURCE='2' -D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='4' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USACCUM_IBIT__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)' -D__HA_IBIT__='8' -D__ARM_NEON_FP='4' -D__TQ_IBIT__='0' -D__FLT_EPSILON__='1.1920928955078125e-7F' -D__APCS_32__='1' -D__GXX_WEAK__='1' -D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L' -D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF' -D__DA_IBIT__='32' -D__ARM_SIZEOF_MINIMAL_ENUM='4' -D__INT32_MAX__='2147483647' -D__UQQ_FBIT__='8' -D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK' -D__STDC_IEC_559__='1' -D__STDC_ISO_10646__='201103L' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR' -D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1' -D__has_include_next(STR)='__has_include_next__(STR)' -D__ARM_PCS_VFP='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32' -D__UACCUM_EPSILON__='0x1P-16UK' -D__GNUC__='4' -D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__GXX_RTTI='1' -D__HQ_IBIT__='0' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D__BIGGEST_ALIGNMENT__='8' -D__DQ_IBIT__='0' -D__DBL_MAX__='double(1.7976931348623157e+308L)' -D__ULFRACT_IBIT__='0' -D__INT_FAST32_MAX__='2147483647' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807LL' -D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-94)' -D__THUMB_INTERWORK__='1' -D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__INT_FAST16_TYPE__='int' -D__LDBL_HAS_DENORM__='1' -D__ARM_FEATURE_LDREX='15' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK' -D__DEC128_EPSILON__='1E-33DL' -D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0' -D__PTRDIFF_MAX__='2147483647' -D__UACCUM_MIN__='0.0UK' -D__STDC_NO_THREADS__='1' -D__UACCUM_IBIT__='16' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4' -D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4' -D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64' -D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR' -D__UFRACT_IBIT__='0' -D__ARM_FEATURE_QBIT='1' -D__INT_FAST64_TYPE__='long long int' -D__DBL_MIN__='double(2.2250738585072014e-308L)' -D__FLT_MIN_10_EXP__='(-37)' -D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32' -D__GXX_TYPEINFO_EQUALITY_INLINE='0' -D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0' -D__UINT8_TYPE__='unsigned char' -D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.9.2 20141101 (Red Hat 4.9.2-1)"' -D__UINT64_C(c)='c ## ULL' -D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R' -D__ULACCUM_MIN__='0.0ULK' -D_STDC_PREDEF_H='1' -D__UDA_FBIT__='32' -D__LLACCUM_EPSILON__='0x1P-31LLK' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__USFRACT_MIN__='0.0UHR' -D__ULLACCUM_IBIT__='32' -D__UQQ_IBIT__='0' -D__STDC_IEC_559_COMPLEX__='1' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -D__INT_FAST32_TYPE__='int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='unsigned int' -D__UINT64_MAX__='18446744073709551615ULL' -D__UDQ_FBIT__='64' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__ARM_ARCH_PROFILE='65' -D__LDBL_EPSILON__='2.2204460492503131e-16L' -D__UINTMAX_C(c)='c ## ULL' -D__GNUC_RH_RELEASE__='1' -D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__VFP_FP__='1' -D__SIZEOF_PTRDIFF_T__='4' -D__LACCUM_EPSILON__='0x1P-31LK' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='2147483647' -D__UINT_FAST32_MAX__='4294967295U' -D__UINT_LEAST64_TYPE__='long long unsigned int' -D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='2147483647L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__unix='1' -D__USA_FBIT__='16' -D__UINT_FAST16_TYPE__='unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__ARM_32BIT_STATE='1' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__SACCUM_FBIT__='7' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long long int' -D__ARM_FEATURE_CLZ='1' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__SQ_FBIT__='31' -D__DEC32_MAX_EXP__='97' -D__ARM_ARCH_ISA_THUMB='2' -D__INT_FAST8_MAX__='127' -D__ARM_ARCH='7' -D__INTPTR_MAX__='2147483647' -D__QQ_FBIT__='7' -Dlinux='1' -D__UTA_IBIT__='64' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='53' -D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__INTPTR_TYPE__='int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='unsigned int' -D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32' -D__UINTPTR_MAX__='4294967295U' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807LL' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long long unsigned int' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31' -D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__INT64_TYPE__='long long int' -D__FLT_MAX_EXP__='128' -D__UTQ_IBIT__='0' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807LL' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0' -D__LDBL_MIN_EXP__='(-1021)' -D__arm__='1' -D__UDA_IBIT__='32' -D__INT_LEAST8_MAX__='127' -D__LFRACT_FBIT__='31' -D__WCHAR_UNSIGNED__='1' -D__ARM_ARCH_7A__='1' -D__LDBL_MAX_10_EXP__='308' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.2204460492503131e-16L)' -D__ARM_FEATURE_SIMD32='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long long unsigned int' -D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127' -D__INT_FAST8_TYPE__='signed char' -D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0' -D__LLACCUM_IBIT__='32' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63' -D__UDQ_IBIT__='0' -D__ORDER_BIG_ENDIAN__='4321' -D__ACCUM_EPSILON__='0x1P-15K' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807LL' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.4012984643248171e-45F' -D__LLFRACT_IBIT__='0' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.4028234663852886e+38F' -D__USACCUM_FBIT__='8' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__UFRACT_EPSILON__='0x1P-16UR' -D__INTMAX_TYPE__='long long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='9' -D__UINTMAX_MAX__='18446744073709551615ULL' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)' -D__ATOMIC_SEQ_CST='5' -D__DA_FBIT__='31' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='unsigned int' -D__USA_IBIT__='16' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__ARM_EABI__='1' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8' -D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='15' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='4294967295U' -D__GNUC_GNU_INLINE__='1' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32' -D__ARM_FEATURE_DSP='1' -D__QQ_IBIT__='0' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/GCC/4.9" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/armv7hl-redhat-linux-gnueabi" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/backward" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/include" -isystem"/usr/local/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9"

Compiler info:
lcg-g++-4.9.1 (GCC) 4.9.2 20141101 (Red Hat 4.9.2-1)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/home/jwsmith/HDD/Gaudi/RootCnv/dict/RootCnv_dict.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("pool") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("Gaudi") );
  ::Reflex::Type type_22 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1029 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1139 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_73 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1080 = ::Reflex::TypeBuilder(Reflex::Literal("pool::Token"));
  ::Reflex::Type type_380 = ::Reflex::TypeBuilder(Reflex::Literal("UCharDbArray"));
  ::Reflex::Type type_214 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_490 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_315 = ::Reflex::TypeBuilder(Reflex::Literal("PoolDbTokenWrap"));
  ::Reflex::Type type_1239 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::RootRef"));
  ::Reflex::Type type_792 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_570 = ::Reflex::TypeBuilder(Reflex::Literal("PoolDbLinkManager"));
  ::Reflex::Type type_801 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,int>"));
  ::Reflex::Type type_203 = ::Reflex::TypeBuilder(Reflex::Literal("PoolDbNTupleDescriptor"));
  ::Reflex::Type type_1241 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::RootObjectRefs"));
  ::Reflex::Type type_806 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_789 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pool::Token*>"));
  ::Reflex::Type type_791 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Gaudi::RootRef>"));
  ::Reflex::Type type_864 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<pool::Token*>"));
  ::Reflex::Type type_1240 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::RootNTupleDescriptor"));
  ::Reflex::Type type_866 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Gaudi::RootRef>"));
  ::Reflex::Type type_790 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_1147 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<pool::Token*> >"));
  ::Reflex::Type type_1148 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<Gaudi::RootRef> >"));
  ::Reflex::Type type_949 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pool::Token*,std::allocator<pool::Token*> >"));
  ::Reflex::Type type_950 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Gaudi::RootRef,std::allocator<Gaudi::RootRef> >"));
  ::Reflex::Type type_1190 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >"));
  ::Reflex::Type type_1194 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >"));
  ::Reflex::Type type_1193 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<pool::Token* const*,std::vector<pool::Token*> >"));
  ::Reflex::Type type_1195 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const Gaudi::RootRef*,std::vector<Gaudi::RootRef> >"));
  ::Reflex::Type type_914 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> > >"));
  ::Reflex::Type type_916 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> > >"));
  ::Reflex::Type type_913 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<pool::Token* const*,std::vector<pool::Token*> > >"));
  ::Reflex::Type type_915 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const Gaudi::RootRef*,std::vector<Gaudi::RootRef> > >"));
  ::Reflex::Type type_811 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_806);
  ::Reflex::Type type_3102 = ::Reflex::ReferenceBuilder(type_203);
  ::Reflex::Type type_203c = ::Reflex::ConstBuilder(type_203);
  ::Reflex::Type type_3103 = ::Reflex::ReferenceBuilder(type_203c);
  ::Reflex::Type type_315c = ::Reflex::ConstBuilder(type_315);
  ::Reflex::Type type_3155 = ::Reflex::ReferenceBuilder(type_315c);
  ::Reflex::Type type_3156 = ::Reflex::ReferenceBuilder(type_315);
  ::Reflex::Type type_3182 = ::Reflex::PointerBuilder(type_490);
  ::Reflex::Type type_3183 = ::Reflex::ReferenceBuilder(type_380);
  ::Reflex::Type type_380c = ::Reflex::ConstBuilder(type_380);
  ::Reflex::Type type_3184 = ::Reflex::ReferenceBuilder(type_380c);
  ::Reflex::Type type_3200 = ::Reflex::ReferenceBuilder(type_570);
  ::Reflex::Type type_570c = ::Reflex::ConstBuilder(type_570);
  ::Reflex::Type type_3201 = ::Reflex::ReferenceBuilder(type_570c);
  ::Reflex::Type type_3202 = ::Reflex::ReferenceBuilder(type_789);
  ::Reflex::Type type_3203 = ::Reflex::ReferenceBuilder(type_790);
  ::Reflex::Type type_1605 = ::Reflex::PointerBuilder(type_1080);
  ::Reflex::Type type_1608 = ::Reflex::PointerBuilder(type_1605);
  ::Reflex::Type type_1605c = ::Reflex::ConstBuilder(type_1605);
  ::Reflex::Type type_1642 = ::Reflex::PointerBuilder(type_1605c);
  ::Reflex::Type type_1610 = ::Reflex::ReferenceBuilder(type_1605);
  ::Reflex::Type type_1645 = ::Reflex::ReferenceBuilder(type_1605c);
  ::Reflex::Type type_908 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_73);
  ::Reflex::Type type_885 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_22);
  ::Reflex::Type type_864c = ::Reflex::ConstBuilder(type_864);
  ::Reflex::Type type_3289 = ::Reflex::ReferenceBuilder(type_864c);
  ::Reflex::Type type_789c = ::Reflex::ConstBuilder(type_789);
  ::Reflex::Type type_3290 = ::Reflex::ReferenceBuilder(type_789c);
  ::Reflex::Type type_1239c = ::Reflex::ConstBuilder(type_1239);
  ::Reflex::Type type_1781 = ::Reflex::ReferenceBuilder(type_1239c);
  ::Reflex::Type type_1779 = ::Reflex::ReferenceBuilder(type_1239);
  ::Reflex::Type type_1775 = ::Reflex::PointerBuilder(type_1239);
  ::Reflex::Type type_1777 = ::Reflex::PointerBuilder(type_1239c);
  ::Reflex::Type type_866c = ::Reflex::ConstBuilder(type_866);
  ::Reflex::Type type_3295 = ::Reflex::ReferenceBuilder(type_866c);
  ::Reflex::Type type_791c = ::Reflex::ConstBuilder(type_791);
  ::Reflex::Type type_3296 = ::Reflex::ReferenceBuilder(type_791c);
  ::Reflex::Type type_3297 = ::Reflex::ReferenceBuilder(type_791);
  ::Reflex::Type type_3529 = ::Reflex::ReferenceBuilder(type_1080);
  ::Reflex::Type type_1080c = ::Reflex::ConstBuilder(type_1080);
  ::Reflex::Type type_3530 = ::Reflex::ReferenceBuilder(type_1080c);
  ::Reflex::Type type_3633 = ::Reflex::ReferenceBuilder(type_1240);
  ::Reflex::Type type_1240c = ::Reflex::ConstBuilder(type_1240);
  ::Reflex::Type type_3634 = ::Reflex::ReferenceBuilder(type_1240c);
  ::Reflex::Type type_1241c = ::Reflex::ConstBuilder(type_1241);
  ::Reflex::Type type_3635 = ::Reflex::ReferenceBuilder(type_1241c);
  ::Reflex::Type type_3636 = ::Reflex::ReferenceBuilder(type_1241);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __PoolDbNTupleDescriptor
#undef __PoolDbNTupleDescriptor
#endif
struct __PoolDbNTupleDescriptor {
  public:
  __PoolDbNTupleDescriptor();
  virtual ~__PoolDbNTupleDescriptor() throw();
  ::std::string description;
  ::std::string optional;
  ::std::string container;
  unsigned long clid;
};
#ifdef __PoolDbTokenWrap
#undef __PoolDbTokenWrap
#endif
struct __PoolDbTokenWrap {
  public:
  __PoolDbTokenWrap();
  virtual ~__PoolDbTokenWrap() throw();
  ::pool::Token token;
};
#ifdef __UCharDbArray
#undef __UCharDbArray
#endif
struct __UCharDbArray {
  public:
  __UCharDbArray();
  virtual ~__UCharDbArray() throw();
  int m_size;
  void* m_buffer;
};
#ifdef __PoolDbLinkManager
#undef __PoolDbLinkManager
#endif
class __PoolDbLinkManager {
  public:
  __PoolDbLinkManager();
  virtual ~__PoolDbLinkManager() throw();
  ::std::vector<pool::Token*> m_refs;
  ::std::vector<std::basic_string<char> > m_links;
};
#ifdef __std__vector_pool__Tokenp_
#undef __std__vector_pool__Tokenp_
#endif
class __std__vector_pool__Tokenp_ : protected ::std::_Vector_base<pool::Token*,std::allocator<pool::Token*> > {
  public:
  __std__vector_pool__Tokenp_();
};
#ifdef __Gaudi__RootRef
#undef __Gaudi__RootRef
#endif
struct __Gaudi__RootRef {
  public:
  __Gaudi__RootRef();
  int dbase;
  int container;
  int link;
  int clid;
  int svc;
  int entry;
};
#ifdef __std__vector_Gaudi__RootRef_
#undef __std__vector_Gaudi__RootRef_
#endif
class __std__vector_Gaudi__RootRef_ : protected ::std::_Vector_base<Gaudi::RootRef,std::allocator<Gaudi::RootRef> > {
  public:
  __std__vector_Gaudi__RootRef_();
};
#ifdef __pool__Token
#undef __pool__Token
#endif
class __pool__Token {
  public:
  __pool__Token();
  ::std::pair<int,int> m_oid;
};
#ifdef __Gaudi__RootNTupleDescriptor
#undef __Gaudi__RootNTupleDescriptor
#endif
struct __Gaudi__RootNTupleDescriptor {
  public:
  __Gaudi__RootNTupleDescriptor();
  virtual ~__Gaudi__RootNTupleDescriptor() throw();
  ::std::string description;
  ::std::string optional;
  ::std::string container;
  unsigned long clid;
};
#ifdef __Gaudi__RootObjectRefs
#undef __Gaudi__RootObjectRefs
#endif
struct __Gaudi__RootObjectRefs {
  public:
  __Gaudi__RootObjectRefs();
  ::std::vector<int> links;
  ::std::vector<Gaudi::RootRef> refs;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class PoolDbNTupleDescriptor -------------------------------
static  void operator_1226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PoolDbNTupleDescriptor*)o)->operator=)(*(const ::PoolDbNTupleDescriptor*)arg[0]);
  else   (((::PoolDbNTupleDescriptor*)o)->operator=)(*(const ::PoolDbNTupleDescriptor*)arg[0]);
}

static void constructor_1227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PoolDbNTupleDescriptor(*(const ::PoolDbNTupleDescriptor*)arg[0]);
  else ::new(mem) ::PoolDbNTupleDescriptor(*(const ::PoolDbNTupleDescriptor*)arg[0]);
}

static void constructor_1228( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PoolDbNTupleDescriptor();
  else ::new(mem) ::PoolDbNTupleDescriptor();
}

static void destructor_1229(void*, void * o, const std::vector<void*>&, void *) {
(((::PoolDbNTupleDescriptor*)o)->::PoolDbNTupleDescriptor::~PoolDbNTupleDescriptor)();
}
static void method_newdel_203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PoolDbNTupleDescriptor >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PoolDbNTupleDescriptor >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PoolDbNTupleDescriptor >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PoolDbNTupleDescriptor >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PoolDbNTupleDescriptor >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PoolDbNTupleDescriptor -------------------------------
void __PoolDbNTupleDescriptor_db_datamem(Reflex::Class*);
void __PoolDbNTupleDescriptor_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PoolDbNTupleDescriptor_datamem_bld(&__PoolDbNTupleDescriptor_db_datamem);
Reflex::GenreflexMemberBuilder __PoolDbNTupleDescriptor_funcmem_bld(&__PoolDbNTupleDescriptor_db_funcmem);
void __PoolDbNTupleDescriptor_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PoolDbNTupleDescriptor"), typeid(::PoolDbNTupleDescriptor), sizeof(::PoolDbNTupleDescriptor), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3102, type_3103), Reflex::Literal("operator="), operator_1226, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3103), Reflex::Literal("PoolDbNTupleDescriptor"), constructor_1227, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PoolDbNTupleDescriptor"), constructor_1228, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PoolDbNTupleDescriptor"), destructor_1229, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PoolDbNTupleDescriptor_datamem_bld);
}

//------Delayed data member builder for class PoolDbNTupleDescriptor -------------------
void __PoolDbNTupleDescriptor_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_811, Reflex::Literal("description"), OffsetOf(__shadow__::__PoolDbNTupleDescriptor, description), ::Reflex::PUBLIC)
  .AddDataMember(type_811, Reflex::Literal("optional"), OffsetOf(__shadow__::__PoolDbNTupleDescriptor, optional), ::Reflex::PUBLIC)
  .AddDataMember(type_811, Reflex::Literal("container"), OffsetOf(__shadow__::__PoolDbNTupleDescriptor, container), ::Reflex::PUBLIC)
  .AddDataMember(type_214, Reflex::Literal("clid"), OffsetOf(__shadow__::__PoolDbNTupleDescriptor, clid), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class PoolDbNTupleDescriptor -------------------
void __PoolDbNTupleDescriptor_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PoolDbTokenWrap -------------------------------
static void constructor_1274( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PoolDbTokenWrap();
  else ::new(mem) ::PoolDbTokenWrap();
}

static void constructor_1275( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PoolDbTokenWrap(*(const ::PoolDbTokenWrap*)arg[0]);
  else ::new(mem) ::PoolDbTokenWrap(*(const ::PoolDbTokenWrap*)arg[0]);
}

static void destructor_1276(void*, void * o, const std::vector<void*>&, void *) {
(((::PoolDbTokenWrap*)o)->::PoolDbTokenWrap::~PoolDbTokenWrap)();
}
static  void operator_1277( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PoolDbTokenWrap*)o)->operator==)(*(const ::PoolDbTokenWrap*)arg[0]));
  else   (((const ::PoolDbTokenWrap*)o)->operator==)(*(const ::PoolDbTokenWrap*)arg[0]);
}

static  void operator_1278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PoolDbTokenWrap*)o)->operator=)(*(const ::PoolDbTokenWrap*)arg[0]);
  else   (((::PoolDbTokenWrap*)o)->operator=)(*(const ::PoolDbTokenWrap*)arg[0]);
}

static void method_newdel_315( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PoolDbTokenWrap >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PoolDbTokenWrap >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PoolDbTokenWrap >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PoolDbTokenWrap >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PoolDbTokenWrap >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PoolDbTokenWrap -------------------------------
void __PoolDbTokenWrap_db_datamem(Reflex::Class*);
void __PoolDbTokenWrap_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PoolDbTokenWrap_datamem_bld(&__PoolDbTokenWrap_db_datamem);
Reflex::GenreflexMemberBuilder __PoolDbTokenWrap_funcmem_bld(&__PoolDbTokenWrap_db_funcmem);
void __PoolDbTokenWrap_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PoolDbTokenWrap"), typeid(::PoolDbTokenWrap), sizeof(::PoolDbTokenWrap), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PoolDbTokenWrap"), constructor_1274, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3155), Reflex::Literal("PoolDbTokenWrap"), constructor_1275, 0, "wrp", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PoolDbTokenWrap"), destructor_1276, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_315, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PoolDbTokenWrap_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PoolDbTokenWrap_funcmem_bld);
}

//------Delayed data member builder for class PoolDbTokenWrap -------------------
void __PoolDbTokenWrap_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1080, Reflex::Literal("token"), OffsetOf(__shadow__::__PoolDbTokenWrap, token), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class PoolDbTokenWrap -------------------
void __PoolDbTokenWrap_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1029, type_3155), Reflex::Literal("operator=="), operator_1277, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3156, type_3155), Reflex::Literal("operator="), operator_1278, 0, "wrp", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class UCharDbArray -------------------------------
static  void operator_1307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::UCharDbArray*)o)->operator=)(*(const ::UCharDbArray*)arg[0]);
  else   (((::UCharDbArray*)o)->operator=)(*(const ::UCharDbArray*)arg[0]);
}

static void constructor_1308( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::UCharDbArray(*(const ::UCharDbArray*)arg[0]);
  else ::new(mem) ::UCharDbArray(*(const ::UCharDbArray*)arg[0]);
}

static void constructor_1309( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::UCharDbArray();
  else ::new(mem) ::UCharDbArray();
}

static void destructor_1310(void*, void * o, const std::vector<void*>&, void *) {
(((::UCharDbArray*)o)->::UCharDbArray::~UCharDbArray)();
}
static void method_newdel_380( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::UCharDbArray >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::UCharDbArray >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::UCharDbArray >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::UCharDbArray >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::UCharDbArray >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class UCharDbArray -------------------------------
void __UCharDbArray_db_datamem(Reflex::Class*);
void __UCharDbArray_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __UCharDbArray_datamem_bld(&__UCharDbArray_db_datamem);
Reflex::GenreflexMemberBuilder __UCharDbArray_funcmem_bld(&__UCharDbArray_db_funcmem);
void __UCharDbArray_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("UCharDbArray"), typeid(::UCharDbArray), sizeof(::UCharDbArray), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3183, type_3184), Reflex::Literal("operator="), operator_1307, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3184), Reflex::Literal("UCharDbArray"), constructor_1308, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("UCharDbArray"), constructor_1309, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~UCharDbArray"), destructor_1310, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_380, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__UCharDbArray_datamem_bld);
}

//------Delayed data member builder for class UCharDbArray -------------------
void __UCharDbArray_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("m_size"), OffsetOf(__shadow__::__UCharDbArray, m_size), ::Reflex::PUBLIC)
  .AddDataMember(type_3182, Reflex::Literal("m_buffer"), OffsetOf(__shadow__::__UCharDbArray, m_buffer), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class UCharDbArray -------------------
void __UCharDbArray_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PoolDbLinkManager -------------------------------
static  void operator_1359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PoolDbLinkManager*)o)->operator=)(*(const ::PoolDbLinkManager*)arg[0]);
  else   (((::PoolDbLinkManager*)o)->operator=)(*(const ::PoolDbLinkManager*)arg[0]);
}

static void constructor_1360( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PoolDbLinkManager(*(const ::PoolDbLinkManager*)arg[0]);
  else ::new(mem) ::PoolDbLinkManager(*(const ::PoolDbLinkManager*)arg[0]);
}

static void constructor_1361( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PoolDbLinkManager();
  else ::new(mem) ::PoolDbLinkManager();
}

static void destructor_1362(void*, void * o, const std::vector<void*>&, void *) {
(((::PoolDbLinkManager*)o)->::PoolDbLinkManager::~PoolDbLinkManager)();
}
static  void method_1363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PoolDbLinkManager*)o)->references)();
  else   (((::PoolDbLinkManager*)o)->references)();
}

static  void method_1364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PoolDbLinkManager*)o)->links)();
  else   (((::PoolDbLinkManager*)o)->links)();
}

static void method_newdel_570( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PoolDbLinkManager >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PoolDbLinkManager >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PoolDbLinkManager >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PoolDbLinkManager >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PoolDbLinkManager >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PoolDbLinkManager -------------------------------
void __PoolDbLinkManager_db_datamem(Reflex::Class*);
void __PoolDbLinkManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PoolDbLinkManager_datamem_bld(&__PoolDbLinkManager_db_datamem);
Reflex::GenreflexMemberBuilder __PoolDbLinkManager_funcmem_bld(&__PoolDbLinkManager_db_funcmem);
void __PoolDbLinkManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PoolDbLinkManager"), typeid(::PoolDbLinkManager), sizeof(::PoolDbLinkManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3200, type_3201), Reflex::Literal("operator="), operator_1359, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3201), Reflex::Literal("PoolDbLinkManager"), constructor_1360, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PoolDbLinkManager"), constructor_1361, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PoolDbLinkManager"), destructor_1362, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_570, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PoolDbLinkManager_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PoolDbLinkManager_funcmem_bld);
}

//------Delayed data member builder for class PoolDbLinkManager -------------------
void __PoolDbLinkManager_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_789, Reflex::Literal("m_refs"), OffsetOf(__shadow__::__PoolDbLinkManager, m_refs), ::Reflex::PROTECTED)
  .AddDataMember(type_790, Reflex::Literal("m_links"), OffsetOf(__shadow__::__PoolDbLinkManager, m_links), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PoolDbLinkManager -------------------
void __PoolDbLinkManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3202), Reflex::Literal("references"), method_1363, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3203), Reflex::Literal("links"), method_1364, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<pool::Token*,std::allocator<pool::Token*> > -------------------------------
static void constructor_1654( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pool::Token*>();
  else ::new(mem) ::std::vector<pool::Token*>();
}

static void constructor_1655( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pool::Token*>(*(const ::std::allocator<pool::Token*>*)arg[0]);
  else ::new(mem) ::std::vector<pool::Token*>(*(const ::std::allocator<pool::Token*>*)arg[0]);
}

static void constructor_1656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pool::Token*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<pool::Token*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pool::Token*>(*(::std::size_t*)arg[0],
      *(::pool::Token* const*)arg[1]);
  else ::new(mem) ::std::vector<pool::Token*>(*(::std::size_t*)arg[0],
      *(::pool::Token* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pool::Token*>(*(::std::size_t*)arg[0],
      *(::pool::Token* const*)arg[1],
      *(const ::std::allocator<pool::Token*>*)arg[2]);
  else ::new(mem) ::std::vector<pool::Token*>(*(::std::size_t*)arg[0],
      *(::pool::Token* const*)arg[1],
      *(const ::std::allocator<pool::Token*>*)arg[2]);
  }
}

static void constructor_1657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<pool::Token*>(*(const ::std::vector<pool::Token*>*)arg[0]);
  else ::new(mem) ::std::vector<pool::Token*>(*(const ::std::vector<pool::Token*>*)arg[0]);
}

static void destructor_1658(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<pool::Token*>*)o)->::std::vector<pool::Token*>::~vector)();
}
static  void operator_1659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pool::Token*>*)o)->operator=)(*(const ::std::vector<pool::Token*>*)arg[0]);
  else   (((::std::vector<pool::Token*>*)o)->operator=)(*(const ::std::vector<pool::Token*>*)arg[0]);
}

static  void method_1660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pool::Token*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::pool::Token* const*)arg[1]);
}

static  void method_1661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >)((((::std::vector<pool::Token*>*)o)->begin)());
  else   (((::std::vector<pool::Token*>*)o)->begin)();
}

static  void method_1662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pool::Token* const*,std::vector<pool::Token*> >)((((const ::std::vector<pool::Token*>*)o)->begin)());
  else   (((const ::std::vector<pool::Token*>*)o)->begin)();
}

static  void method_1663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >)((((::std::vector<pool::Token*>*)o)->end)());
  else   (((::std::vector<pool::Token*>*)o)->end)();
}

static  void method_1664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pool::Token* const*,std::vector<pool::Token*> >)((((const ::std::vector<pool::Token*>*)o)->end)());
  else   (((const ::std::vector<pool::Token*>*)o)->end)();
}

static  void method_1669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pool::Token*>*)o)->size)());
  else   (((const ::std::vector<pool::Token*>*)o)->size)();
}

static  void method_1670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pool::Token*>*)o)->max_size)());
  else   (((const ::std::vector<pool::Token*>*)o)->max_size)();
}

static  void method_1671( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<pool::Token*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<pool::Token*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::pool::Token*)arg[1]);
  }
}

static  void method_1672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<pool::Token*>*)o)->capacity)());
  else   (((const ::std::vector<pool::Token*>*)o)->capacity)();
}

static  void method_1673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<pool::Token*>*)o)->empty)());
  else   (((const ::std::vector<pool::Token*>*)o)->empty)();
}

static  void method_1674( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pool::Token*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_1675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pool::Token*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pool::Token*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_1676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pool::Token*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pool::Token*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_1678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pool::Token*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<pool::Token*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_1679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pool::Token*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<pool::Token*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_1680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pool::Token*>*)o)->front)();
  else   (((::std::vector<pool::Token*>*)o)->front)();
}

static  void method_1681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pool::Token*>*)o)->front)();
  else   (((const ::std::vector<pool::Token*>*)o)->front)();
}

static  void method_1682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<pool::Token*>*)o)->back)();
  else   (((::std::vector<pool::Token*>*)o)->back)();
}

static  void method_1683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<pool::Token*>*)o)->back)();
  else   (((const ::std::vector<pool::Token*>*)o)->back)();
}

static  void method_1684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<pool::Token*>*)o)->data)());
  else   (((::std::vector<pool::Token*>*)o)->data)();
}

static  void method_1685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<pool::Token*>*)o)->data)());
  else   (((const ::std::vector<pool::Token*>*)o)->data)();
}

static  void method_1686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pool::Token*>*)o)->push_back)(*(::pool::Token* const*)arg[0]);
}

static  void method_1687( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pool::Token*>*)o)->pop_back)();
}

static  void method_1688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >)((((::std::vector<pool::Token*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[0],
    *(::pool::Token* const*)arg[1]));
  else   (((::std::vector<pool::Token*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[0],
    *(::pool::Token* const*)arg[1]);
}

static  void method_1689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pool::Token*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::pool::Token* const*)arg[2]);
}

static  void method_1690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >)((((::std::vector<pool::Token*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[0]));
  else   (((::std::vector<pool::Token*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[0]);
}

static  void method_1691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >)((((::std::vector<pool::Token*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[1]));
  else   (((::std::vector<pool::Token*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<pool::Token**,std::vector<pool::Token*> >*)arg[1]);
}

static  void method_1692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<pool::Token*>*)o)->swap)(*(::std::vector<pool::Token*>*)arg[0]);
}

static  void method_1693( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<pool::Token*>*)o)->clear)();
}

static void method_newdel_789( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<pool::Token*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<pool::Token*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<pool::Token*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<pool::Token*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<pool::Token*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<pool::Token*,std::allocator<pool::Token*> >")), ::Reflex::BaseOffset< ::std::vector<pool::Token*>,::std::_Vector_base<pool::Token*,std::allocator<pool::Token*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<pool::Token*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<pool::Token*> >::Generate();
}

//------Dictionary for class vector<pool::Token*,std::allocator<pool::Token*> > -------------------------------
void __std__vector_pool__Tokenp__db_datamem(Reflex::Class*);
void __std__vector_pool__Tokenp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_pool__Tokenp__datamem_bld(&__std__vector_pool__Tokenp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_pool__Tokenp__funcmem_bld(&__std__vector_pool__Tokenp__db_funcmem);
void __std__vector_pool__Tokenp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<pool::Token*>"), typeid(::std::vector<pool::Token*>), sizeof(::std::vector<pool::Token*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_949, ::Reflex::BaseOffset< ::std::vector<pool::Token*>, ::std::_Vector_base<pool::Token*,std::allocator<pool::Token*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1605, Reflex::Literal("std::vector<pool::Token*>::_Alloc_value_type"))
  .AddTypedef(type_949, Reflex::Literal("std::vector<pool::Token*>::_Base"))
  .AddTypedef(type_864, Reflex::Literal("std::vector<pool::Token*>::_Tp_alloc_type"))
  .AddTypedef(type_1147, Reflex::Literal("std::vector<pool::Token*>::_Alloc_traits"))
  .AddTypedef(type_1605, Reflex::Literal("std::vector<pool::Token*>::value_type"))
  .AddTypedef(type_1608, Reflex::Literal("std::vector<pool::Token*>::pointer"))
  .AddTypedef(type_1642, Reflex::Literal("std::vector<pool::Token*>::const_pointer"))
  .AddTypedef(type_1610, Reflex::Literal("std::vector<pool::Token*>::reference"))
  .AddTypedef(type_1645, Reflex::Literal("std::vector<pool::Token*>::const_reference"))
  .AddTypedef(type_1190, Reflex::Literal("std::vector<pool::Token*>::iterator"))
  .AddTypedef(type_1193, Reflex::Literal("std::vector<pool::Token*>::const_iterator"))
  .AddTypedef(type_913, Reflex::Literal("std::vector<pool::Token*>::const_reverse_iterator"))
  .AddTypedef(type_914, Reflex::Literal("std::vector<pool::Token*>::reverse_iterator"))
  .AddTypedef(type_908, Reflex::Literal("std::vector<pool::Token*>::size_type"))
  .AddTypedef(type_885, Reflex::Literal("std::vector<pool::Token*>::difference_type"))
  .AddTypedef(type_864, Reflex::Literal("std::vector<pool::Token*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_1654, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3289), Reflex::Literal("vector"), constructor_1655, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_908, type_1645, type_3289), Reflex::Literal("vector"), constructor_1656, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3290), Reflex::Literal("vector"), constructor_1657, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_1658, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_789, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_pool__Tokenp__funcmem_bld);
}

//------Delayed data member builder for class vector<pool::Token*,std::allocator<pool::Token*> > -------------------
void __std__vector_pool__Tokenp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<pool::Token*,std::allocator<pool::Token*> > -------------------
void __std__vector_pool__Tokenp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3202, type_3290), Reflex::Literal("operator="), operator_1659, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_908, type_1645), Reflex::Literal("assign"), method_1660, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1190), Reflex::Literal("begin"), method_1661, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1193), Reflex::Literal("begin"), method_1662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1190), Reflex::Literal("end"), method_1663, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1193), Reflex::Literal("end"), method_1664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_908), Reflex::Literal("size"), method_1669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_908), Reflex::Literal("max_size"), method_1670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_908, type_1605), Reflex::Literal("resize"), method_1671, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_908), Reflex::Literal("capacity"), method_1672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1029), Reflex::Literal("empty"), method_1673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_908), Reflex::Literal("reserve"), method_1674, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1610, type_908), Reflex::Literal("operator[]"), operator_1675, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645, type_908), Reflex::Literal("operator[]"), operator_1676, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1610, type_908), Reflex::Literal("at"), method_1678, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645, type_908), Reflex::Literal("at"), method_1679, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1610), Reflex::Literal("front"), method_1680, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645), Reflex::Literal("front"), method_1681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1610), Reflex::Literal("back"), method_1682, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645), Reflex::Literal("back"), method_1683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1608), Reflex::Literal("data"), method_1684, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1642), Reflex::Literal("data"), method_1685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_1645), Reflex::Literal("push_back"), method_1686, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139), Reflex::Literal("pop_back"), method_1687, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1190, type_1190, type_1645), Reflex::Literal("insert"), method_1688, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_1190, type_908, type_1645), Reflex::Literal("insert"), method_1689, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1190, type_1190), Reflex::Literal("erase"), method_1690, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1190, type_1190, type_1190), Reflex::Literal("erase"), method_1691, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_3202), Reflex::Literal("swap"), method_1692, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139), Reflex::Literal("clear"), method_1693, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RootRef -------------------------------
static void destructor_3112(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::RootRef*)o)->::Gaudi::RootRef::~RootRef)();
}
static void constructor_3113( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::RootRef();
  else ::new(mem) ::Gaudi::RootRef();
}

static void constructor_3114( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::RootRef(*(const ::Gaudi::RootRef*)arg[0]);
  else ::new(mem) ::Gaudi::RootRef(*(const ::Gaudi::RootRef*)arg[0]);
}

static  void operator_3115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::RootRef*)o)->operator=)(*(const ::Gaudi::RootRef*)arg[0]);
  else   (((::Gaudi::RootRef*)o)->operator=)(*(const ::Gaudi::RootRef*)arg[0]);
}

static  void method_3116( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Gaudi::RootRef*)o)->reset)();
}

static void method_newdel_1239( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::RootRef >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::RootRef >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::RootRef >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::RootRef >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::RootRef >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RootRef -------------------------------
void __Gaudi__RootRef_db_datamem(Reflex::Class*);
void __Gaudi__RootRef_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__RootRef_datamem_bld(&__Gaudi__RootRef_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__RootRef_funcmem_bld(&__Gaudi__RootRef_db_funcmem);
void __Gaudi__RootRef_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::RootRef"), typeid(::Gaudi::RootRef), sizeof(::Gaudi::RootRef), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RootRef"), destructor_3112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RootRef"), constructor_3113, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1781), Reflex::Literal("RootRef"), constructor_3114, 0, "c", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1239, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__RootRef_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__RootRef_funcmem_bld);
}

//------Delayed data member builder for class RootRef -------------------
void __Gaudi__RootRef_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("dbase"), OffsetOf(__shadow__::__Gaudi__RootRef, dbase), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("container"), OffsetOf(__shadow__::__Gaudi__RootRef, container), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("link"), OffsetOf(__shadow__::__Gaudi__RootRef, link), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("clid"), OffsetOf(__shadow__::__Gaudi__RootRef, clid), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("svc"), OffsetOf(__shadow__::__Gaudi__RootRef, svc), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("entry"), OffsetOf(__shadow__::__Gaudi__RootRef, entry), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RootRef -------------------
void __Gaudi__RootRef_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1779, type_1781), Reflex::Literal("operator="), operator_3115, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139), Reflex::Literal("reset"), method_3116, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<Gaudi::RootRef,std::allocator<Gaudi::RootRef> > -------------------------------
static void constructor_1790( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::RootRef>();
  else ::new(mem) ::std::vector<Gaudi::RootRef>();
}

static void constructor_1791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::RootRef>(*(const ::std::allocator<Gaudi::RootRef>*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::RootRef>(*(const ::std::allocator<Gaudi::RootRef>*)arg[0]);
}

static void constructor_1792( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::RootRef>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::RootRef>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::RootRef>(*(::std::size_t*)arg[0],
      *(const ::Gaudi::RootRef*)arg[1]);
  else ::new(mem) ::std::vector<Gaudi::RootRef>(*(::std::size_t*)arg[0],
      *(const ::Gaudi::RootRef*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::RootRef>(*(::std::size_t*)arg[0],
      *(const ::Gaudi::RootRef*)arg[1],
      *(const ::std::allocator<Gaudi::RootRef>*)arg[2]);
  else ::new(mem) ::std::vector<Gaudi::RootRef>(*(::std::size_t*)arg[0],
      *(const ::Gaudi::RootRef*)arg[1],
      *(const ::std::allocator<Gaudi::RootRef>*)arg[2]);
  }
}

static void constructor_1793( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::RootRef>(*(const ::std::vector<Gaudi::RootRef>*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::RootRef>(*(const ::std::vector<Gaudi::RootRef>*)arg[0]);
}

static void destructor_1794(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Gaudi::RootRef>*)o)->::std::vector<Gaudi::RootRef>::~vector)();
}
static  void operator_1795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::RootRef>*)o)->operator=)(*(const ::std::vector<Gaudi::RootRef>*)arg[0]);
  else   (((::std::vector<Gaudi::RootRef>*)o)->operator=)(*(const ::std::vector<Gaudi::RootRef>*)arg[0]);
}

static  void method_1796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::RootRef>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::Gaudi::RootRef*)arg[1]);
}

static  void method_1797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >)((((::std::vector<Gaudi::RootRef>*)o)->begin)());
  else   (((::std::vector<Gaudi::RootRef>*)o)->begin)();
}

static  void method_1798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Gaudi::RootRef*,std::vector<Gaudi::RootRef> >)((((const ::std::vector<Gaudi::RootRef>*)o)->begin)());
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->begin)();
}

static  void method_1799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >)((((::std::vector<Gaudi::RootRef>*)o)->end)());
  else   (((::std::vector<Gaudi::RootRef>*)o)->end)();
}

static  void method_1800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Gaudi::RootRef*,std::vector<Gaudi::RootRef> >)((((const ::std::vector<Gaudi::RootRef>*)o)->end)());
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->end)();
}

static  void method_1805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::RootRef>*)o)->size)());
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->size)();
}

static  void method_1806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::RootRef>*)o)->max_size)());
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->max_size)();
}

static  void method_1807( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Gaudi::RootRef>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Gaudi::RootRef>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::Gaudi::RootRef*)arg[1]);
  }
}

static  void method_1808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::RootRef>*)o)->capacity)());
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->capacity)();
}

static  void method_1809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Gaudi::RootRef>*)o)->empty)());
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->empty)();
}

static  void method_1810( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::RootRef>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_1811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::RootRef>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Gaudi::RootRef>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_1812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::RootRef>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_1814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::RootRef>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Gaudi::RootRef>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_1815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::RootRef>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_1816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::RootRef>*)o)->front)();
  else   (((::std::vector<Gaudi::RootRef>*)o)->front)();
}

static  void method_1817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::RootRef>*)o)->front)();
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->front)();
}

static  void method_1818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::RootRef>*)o)->back)();
  else   (((::std::vector<Gaudi::RootRef>*)o)->back)();
}

static  void method_1819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::RootRef>*)o)->back)();
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->back)();
}

static  void method_1820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Gaudi::RootRef>*)o)->data)());
  else   (((::std::vector<Gaudi::RootRef>*)o)->data)();
}

static  void method_1821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Gaudi::RootRef>*)o)->data)());
  else   (((const ::std::vector<Gaudi::RootRef>*)o)->data)();
}

static  void method_1822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::RootRef>*)o)->push_back)(*(const ::Gaudi::RootRef*)arg[0]);
}

static  void method_1823( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Gaudi::RootRef>*)o)->pop_back)();
}

static  void method_1824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >)((((::std::vector<Gaudi::RootRef>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[0],
    *(const ::Gaudi::RootRef*)arg[1]));
  else   (((::std::vector<Gaudi::RootRef>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[0],
    *(const ::Gaudi::RootRef*)arg[1]);
}

static  void method_1825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::RootRef>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::Gaudi::RootRef*)arg[2]);
}

static  void method_1826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >)((((::std::vector<Gaudi::RootRef>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[0]));
  else   (((::std::vector<Gaudi::RootRef>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[0]);
}

static  void method_1827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >)((((::std::vector<Gaudi::RootRef>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[1]));
  else   (((::std::vector<Gaudi::RootRef>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::RootRef*,std::vector<Gaudi::RootRef> >*)arg[1]);
}

static  void method_1828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::RootRef>*)o)->swap)(*(::std::vector<Gaudi::RootRef>*)arg[0]);
}

static  void method_1829( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Gaudi::RootRef>*)o)->clear)();
}

static void method_newdel_791( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::RootRef> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::RootRef> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::RootRef> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::RootRef> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::RootRef> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Gaudi::RootRef,std::allocator<Gaudi::RootRef> >")), ::Reflex::BaseOffset< ::std::vector<Gaudi::RootRef>,::std::_Vector_base<Gaudi::RootRef,std::allocator<Gaudi::RootRef> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Gaudi::RootRef> >::Generate();
  else ::Reflex::Proxy< ::std::vector<Gaudi::RootRef> >::Generate();
}

//------Dictionary for class vector<Gaudi::RootRef,std::allocator<Gaudi::RootRef> > -------------------------------
void __std__vector_Gaudi__RootRef__db_datamem(Reflex::Class*);
void __std__vector_Gaudi__RootRef__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Gaudi__RootRef__datamem_bld(&__std__vector_Gaudi__RootRef__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Gaudi__RootRef__funcmem_bld(&__std__vector_Gaudi__RootRef__db_funcmem);
void __std__vector_Gaudi__RootRef__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Gaudi::RootRef>"), typeid(::std::vector<Gaudi::RootRef>), sizeof(::std::vector<Gaudi::RootRef>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_950, ::Reflex::BaseOffset< ::std::vector<Gaudi::RootRef>, ::std::_Vector_base<Gaudi::RootRef,std::allocator<Gaudi::RootRef> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1239, Reflex::Literal("std::vector<Gaudi::RootRef>::_Alloc_value_type"))
  .AddTypedef(type_950, Reflex::Literal("std::vector<Gaudi::RootRef>::_Base"))
  .AddTypedef(type_866, Reflex::Literal("std::vector<Gaudi::RootRef>::_Tp_alloc_type"))
  .AddTypedef(type_1148, Reflex::Literal("std::vector<Gaudi::RootRef>::_Alloc_traits"))
  .AddTypedef(type_1239, Reflex::Literal("std::vector<Gaudi::RootRef>::value_type"))
  .AddTypedef(type_1775, Reflex::Literal("std::vector<Gaudi::RootRef>::pointer"))
  .AddTypedef(type_1777, Reflex::Literal("std::vector<Gaudi::RootRef>::const_pointer"))
  .AddTypedef(type_1779, Reflex::Literal("std::vector<Gaudi::RootRef>::reference"))
  .AddTypedef(type_1781, Reflex::Literal("std::vector<Gaudi::RootRef>::const_reference"))
  .AddTypedef(type_1194, Reflex::Literal("std::vector<Gaudi::RootRef>::iterator"))
  .AddTypedef(type_1195, Reflex::Literal("std::vector<Gaudi::RootRef>::const_iterator"))
  .AddTypedef(type_915, Reflex::Literal("std::vector<Gaudi::RootRef>::const_reverse_iterator"))
  .AddTypedef(type_916, Reflex::Literal("std::vector<Gaudi::RootRef>::reverse_iterator"))
  .AddTypedef(type_908, Reflex::Literal("std::vector<Gaudi::RootRef>::size_type"))
  .AddTypedef(type_885, Reflex::Literal("std::vector<Gaudi::RootRef>::difference_type"))
  .AddTypedef(type_866, Reflex::Literal("std::vector<Gaudi::RootRef>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_1790, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3295), Reflex::Literal("vector"), constructor_1791, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_908, type_1781, type_3295), Reflex::Literal("vector"), constructor_1792, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3296), Reflex::Literal("vector"), constructor_1793, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_1794, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_791, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Gaudi__RootRef__funcmem_bld);
}

//------Delayed data member builder for class vector<Gaudi::RootRef,std::allocator<Gaudi::RootRef> > -------------------
void __std__vector_Gaudi__RootRef__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Gaudi::RootRef,std::allocator<Gaudi::RootRef> > -------------------
void __std__vector_Gaudi__RootRef__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3297, type_3296), Reflex::Literal("operator="), operator_1795, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_908, type_1781), Reflex::Literal("assign"), method_1796, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1194), Reflex::Literal("begin"), method_1797, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1195), Reflex::Literal("begin"), method_1798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1194), Reflex::Literal("end"), method_1799, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1195), Reflex::Literal("end"), method_1800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_908), Reflex::Literal("size"), method_1805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_908), Reflex::Literal("max_size"), method_1806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_908, type_1239), Reflex::Literal("resize"), method_1807, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_908), Reflex::Literal("capacity"), method_1808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1029), Reflex::Literal("empty"), method_1809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_908), Reflex::Literal("reserve"), method_1810, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1779, type_908), Reflex::Literal("operator[]"), operator_1811, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1781, type_908), Reflex::Literal("operator[]"), operator_1812, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1779, type_908), Reflex::Literal("at"), method_1814, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1781, type_908), Reflex::Literal("at"), method_1815, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1779), Reflex::Literal("front"), method_1816, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1781), Reflex::Literal("front"), method_1817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1779), Reflex::Literal("back"), method_1818, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1781), Reflex::Literal("back"), method_1819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1775), Reflex::Literal("data"), method_1820, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1777), Reflex::Literal("data"), method_1821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_1781), Reflex::Literal("push_back"), method_1822, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139), Reflex::Literal("pop_back"), method_1823, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1194, type_1194, type_1781), Reflex::Literal("insert"), method_1824, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_1194, type_908, type_1781), Reflex::Literal("insert"), method_1825, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1194, type_1194), Reflex::Literal("erase"), method_1826, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1194, type_1194, type_1194), Reflex::Literal("erase"), method_1827, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139, type_3297), Reflex::Literal("swap"), method_1828, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1139), Reflex::Literal("clear"), method_1829, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Token -------------------------------
static void destructor_2722(void*, void * o, const std::vector<void*>&, void *) {
(((::pool::Token*)o)->::pool::Token::~Token)();
}
static  void operator_2723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pool::Token*)o)->operator=)(*(const ::pool::Token*)arg[0]);
  else   (((::pool::Token*)o)->operator=)(*(const ::pool::Token*)arg[0]);
}

static void constructor_2724( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pool::Token(*(const ::pool::Token*)arg[0]);
  else ::new(mem) ::pool::Token(*(const ::pool::Token*)arg[0]);
}

static void constructor_2725( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pool::Token();
  else ::new(mem) ::pool::Token();
}

static  void operator_2726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pool::Token*)o)->operator==)(*(const ::pool::Token*)arg[0]));
  else   (((const ::pool::Token*)o)->operator==)(*(const ::pool::Token*)arg[0]);
}

static void method_newdel_1080( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pool::Token >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pool::Token >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pool::Token >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pool::Token >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pool::Token >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Token -------------------------------
void __pool__Token_db_datamem(Reflex::Class*);
void __pool__Token_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pool__Token_datamem_bld(&__pool__Token_db_datamem);
Reflex::GenreflexMemberBuilder __pool__Token_funcmem_bld(&__pool__Token_db_funcmem);
void __pool__Token_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pool::Token"), typeid(::pool::Token), sizeof(::pool::Token), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Token"), destructor_2722, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3529, type_3530), Reflex::Literal("operator="), operator_2723, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3530), Reflex::Literal("Token"), constructor_2724, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Token"), constructor_2725, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1080, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pool__Token_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pool__Token_funcmem_bld);
}

//------Delayed data member builder for class Token -------------------
void __pool__Token_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_801, Reflex::Literal("m_oid"), OffsetOf(__shadow__::__pool__Token, m_oid), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Token -------------------
void __pool__Token_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1029, type_3530), Reflex::Literal("operator=="), operator_2726, 0, "t", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class RootNTupleDescriptor -------------------------------
static  void operator_3121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::RootNTupleDescriptor*)o)->operator=)(*(const ::Gaudi::RootNTupleDescriptor*)arg[0]);
  else   (((::Gaudi::RootNTupleDescriptor*)o)->operator=)(*(const ::Gaudi::RootNTupleDescriptor*)arg[0]);
}

static void constructor_3122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::RootNTupleDescriptor(*(const ::Gaudi::RootNTupleDescriptor*)arg[0]);
  else ::new(mem) ::Gaudi::RootNTupleDescriptor(*(const ::Gaudi::RootNTupleDescriptor*)arg[0]);
}

static void constructor_3123( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::RootNTupleDescriptor();
  else ::new(mem) ::Gaudi::RootNTupleDescriptor();
}

static void destructor_3124(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::RootNTupleDescriptor*)o)->::Gaudi::RootNTupleDescriptor::~RootNTupleDescriptor)();
}
static void method_newdel_1240( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::RootNTupleDescriptor >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::RootNTupleDescriptor >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::RootNTupleDescriptor >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::RootNTupleDescriptor >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::RootNTupleDescriptor >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RootNTupleDescriptor -------------------------------
void __Gaudi__RootNTupleDescriptor_db_datamem(Reflex::Class*);
void __Gaudi__RootNTupleDescriptor_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__RootNTupleDescriptor_datamem_bld(&__Gaudi__RootNTupleDescriptor_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__RootNTupleDescriptor_funcmem_bld(&__Gaudi__RootNTupleDescriptor_db_funcmem);
void __Gaudi__RootNTupleDescriptor_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::RootNTupleDescriptor"), typeid(::Gaudi::RootNTupleDescriptor), sizeof(::Gaudi::RootNTupleDescriptor), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3633, type_3634), Reflex::Literal("operator="), operator_3121, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3634), Reflex::Literal("RootNTupleDescriptor"), constructor_3122, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RootNTupleDescriptor"), constructor_3123, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RootNTupleDescriptor"), destructor_3124, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1240, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__RootNTupleDescriptor_datamem_bld);
}

//------Delayed data member builder for class RootNTupleDescriptor -------------------
void __Gaudi__RootNTupleDescriptor_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_811, Reflex::Literal("description"), OffsetOf(__shadow__::__Gaudi__RootNTupleDescriptor, description), ::Reflex::PUBLIC)
  .AddDataMember(type_811, Reflex::Literal("optional"), OffsetOf(__shadow__::__Gaudi__RootNTupleDescriptor, optional), ::Reflex::PUBLIC)
  .AddDataMember(type_811, Reflex::Literal("container"), OffsetOf(__shadow__::__Gaudi__RootNTupleDescriptor, container), ::Reflex::PUBLIC)
  .AddDataMember(type_214, Reflex::Literal("clid"), OffsetOf(__shadow__::__Gaudi__RootNTupleDescriptor, clid), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RootNTupleDescriptor -------------------
void __Gaudi__RootNTupleDescriptor_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RootObjectRefs -------------------------------
static void constructor_3127( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::RootObjectRefs();
  else ::new(mem) ::Gaudi::RootObjectRefs();
}

static void constructor_3128( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::RootObjectRefs(*(const ::Gaudi::RootObjectRefs*)arg[0]);
  else ::new(mem) ::Gaudi::RootObjectRefs(*(const ::Gaudi::RootObjectRefs*)arg[0]);
}

static void destructor_3129(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::RootObjectRefs*)o)->::Gaudi::RootObjectRefs::~RootObjectRefs)();
}
static  void operator_3130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::RootObjectRefs*)o)->operator=)(*(const ::Gaudi::RootObjectRefs*)arg[0]);
  else   (((::Gaudi::RootObjectRefs*)o)->operator=)(*(const ::Gaudi::RootObjectRefs*)arg[0]);
}

static void method_newdel_1241( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::RootObjectRefs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::RootObjectRefs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::RootObjectRefs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::RootObjectRefs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::RootObjectRefs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RootObjectRefs -------------------------------
void __Gaudi__RootObjectRefs_db_datamem(Reflex::Class*);
void __Gaudi__RootObjectRefs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__RootObjectRefs_datamem_bld(&__Gaudi__RootObjectRefs_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__RootObjectRefs_funcmem_bld(&__Gaudi__RootObjectRefs_db_funcmem);
void __Gaudi__RootObjectRefs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::RootObjectRefs"), typeid(::Gaudi::RootObjectRefs), sizeof(::Gaudi::RootObjectRefs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RootObjectRefs"), constructor_3127, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3635), Reflex::Literal("RootObjectRefs"), constructor_3128, 0, "r", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RootObjectRefs"), destructor_3129, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1241, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__RootObjectRefs_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__RootObjectRefs_funcmem_bld);
}

//------Delayed data member builder for class RootObjectRefs -------------------
void __Gaudi__RootObjectRefs_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_792, Reflex::Literal("links"), OffsetOf(__shadow__::__Gaudi__RootObjectRefs, links), ::Reflex::PUBLIC)
  .AddDataMember(type_791, Reflex::Literal("refs"), OffsetOf(__shadow__::__Gaudi__RootObjectRefs, refs), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RootObjectRefs -------------------
void __Gaudi__RootObjectRefs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3636, type_3635), Reflex::Literal("operator="), operator_3130, 0, "r", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __PoolDbNTupleDescriptor_dict(); 
      __PoolDbTokenWrap_dict(); 
      __UCharDbArray_dict(); 
      __PoolDbLinkManager_dict(); 
      __std__vector_pool__Tokenp__dict(); 
      __Gaudi__RootRef_dict(); 
      __std__vector_Gaudi__RootRef__dict(); 
      __pool__Token_dict(); 
      __Gaudi__RootNTupleDescriptor_dict(); 
      __Gaudi__RootObjectRefs_dict(); 
    }
    ~Dictionaries() {
      type_203.Unload(); // class PoolDbNTupleDescriptor 
      type_315.Unload(); // class PoolDbTokenWrap 
      type_380.Unload(); // class UCharDbArray 
      type_570.Unload(); // class PoolDbLinkManager 
      type_789.Unload(); // class std::vector<pool::Token*> 
      type_1239.Unload(); // class Gaudi::RootRef 
      type_791.Unload(); // class std::vector<Gaudi::RootRef> 
      type_1080.Unload(); // class pool::Token 
      type_1240.Unload(); // class Gaudi::RootNTupleDescriptor 
      type_1241.Unload(); // class Gaudi::RootObjectRefs 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
