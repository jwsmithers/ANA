// Generated at Mon Feb 16 20:49:29 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="lcg-g++-4.9.1"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard "
  GCCXML_EXECUTABLE="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__SSP_STRONG__='3' -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__UINT_LEAST16_MAX__='65535' -D__ARM_SIZEOF_WCHAR_T='32' -D__ATOMIC_ACQUIRE='2' -D__SFRACT_IBIT__='0' -D__FLT_MIN__='1.1754943508222875e-38F' -D__GCC_IEC_559_COMPLEX='2' -D__UFRACT_MAX__='0XFFFFP-16UR' -D__UINT_LEAST8_TYPE__='unsigned char' -D__DQ_FBIT__='63' -D__INTMAX_C(c)='c ## LL' -D__ARM_FEATURE_SAT='1' -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK' -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__UINT8_MAX__='255' -D__ACCUM_FBIT__='15' -D__WINT_MAX__='4294967295U' -D__USFRACT_FBIT__='8' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='4294967295U' -D__ARM_ARCH_ISA_ARM='1' -D__WCHAR_MAX__='4294967295U' -D__LACCUM_IBIT__='32' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.9406564584124654e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__GCC_IEC_559='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__cpp_binary_literals='201304' -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__FRACT_FBIT__='15' -D__UINT_FAST64_MAX__='18446744073709551615ULL' -D__SIG_ATOMIC_TYPE__='int' -D__UACCUM_FBIT__='16' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__ARMEL__='1' -D__ARM_FEATURE_UNALIGNED='1' -D__LFRACT_IBIT__='0' -D__GNUC_PATCHLEVEL__='2' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR' -D__UINT_FAST8_MAX__='255' -D__has_include(STR)='__has_include__(STR)' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615ULL' -D__SA_FBIT__='15' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L' -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16' -D__ARM_FP='12' -D__UFRACT_MIN__='0.0UR' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__CHAR_UNSIGNED__='1' -D__UINT32_MAX__='4294967295U' -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64' -D__LDBL_MAX_EXP__='1024' -D__WINT_MIN__='0U' -D__linux__='1' -D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='0U' -D__INT64_C(c)='c ## LL' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D_FORTIFY_SOURCE='2' -D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='4' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USACCUM_IBIT__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)' -D__HA_IBIT__='8' -D__ARM_NEON_FP='4' -D__TQ_IBIT__='0' -D__FLT_EPSILON__='1.1920928955078125e-7F' -D__APCS_32__='1' -D__GXX_WEAK__='1' -D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L' -D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF' -D__DA_IBIT__='32' -D__ARM_SIZEOF_MINIMAL_ENUM='4' -D__INT32_MAX__='2147483647' -D__UQQ_FBIT__='8' -D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK' -D__STDC_IEC_559__='1' -D__STDC_ISO_10646__='201103L' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR' -D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1' -D__has_include_next(STR)='__has_include_next__(STR)' -D__ARM_PCS_VFP='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32' -D__UACCUM_EPSILON__='0x1P-16UK' -D__GNUC__='4' -D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__GXX_RTTI='1' -D__HQ_IBIT__='0' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D__BIGGEST_ALIGNMENT__='8' -D__DQ_IBIT__='0' -D__DBL_MAX__='double(1.7976931348623157e+308L)' -D__ULFRACT_IBIT__='0' -D__INT_FAST32_MAX__='2147483647' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807LL' -D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-94)' -D__THUMB_INTERWORK__='1' -D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__INT_FAST16_TYPE__='int' -D__LDBL_HAS_DENORM__='1' -D__ARM_FEATURE_LDREX='15' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK' -D__DEC128_EPSILON__='1E-33DL' -D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0' -D__PTRDIFF_MAX__='2147483647' -D__UACCUM_MIN__='0.0UK' -D__STDC_NO_THREADS__='1' -D__UACCUM_IBIT__='16' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4' -D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4' -D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64' -D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR' -D__UFRACT_IBIT__='0' -D__ARM_FEATURE_QBIT='1' -D__INT_FAST64_TYPE__='long long int' -D__DBL_MIN__='double(2.2250738585072014e-308L)' -D__FLT_MIN_10_EXP__='(-37)' -D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32' -D__GXX_TYPEINFO_EQUALITY_INLINE='0' -D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0' -D__UINT8_TYPE__='unsigned char' -D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.9.2 20141101 (Red Hat 4.9.2-1)"' -D__UINT64_C(c)='c ## ULL' -D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R' -D__ULACCUM_MIN__='0.0ULK' -D_STDC_PREDEF_H='1' -D__UDA_FBIT__='32' -D__LLACCUM_EPSILON__='0x1P-31LLK' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__USFRACT_MIN__='0.0UHR' -D__ULLACCUM_IBIT__='32' -D__UQQ_IBIT__='0' -D__STDC_IEC_559_COMPLEX__='1' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -D__INT_FAST32_TYPE__='int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='unsigned int' -D__UINT64_MAX__='18446744073709551615ULL' -D__UDQ_FBIT__='64' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__ARM_ARCH_PROFILE='65' -D__LDBL_EPSILON__='2.2204460492503131e-16L' -D__UINTMAX_C(c)='c ## ULL' -D__GNUC_RH_RELEASE__='1' -D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__VFP_FP__='1' -D__SIZEOF_PTRDIFF_T__='4' -D__LACCUM_EPSILON__='0x1P-31LK' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='2147483647' -D__UINT_FAST32_MAX__='4294967295U' -D__UINT_LEAST64_TYPE__='long long unsigned int' -D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='2147483647L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__unix='1' -D__USA_FBIT__='16' -D__UINT_FAST16_TYPE__='unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__ARM_32BIT_STATE='1' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__SACCUM_FBIT__='7' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long long int' -D__ARM_FEATURE_CLZ='1' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__SQ_FBIT__='31' -D__DEC32_MAX_EXP__='97' -D__ARM_ARCH_ISA_THUMB='2' -D__INT_FAST8_MAX__='127' -D__ARM_ARCH='7' -D__INTPTR_MAX__='2147483647' -D__QQ_FBIT__='7' -Dlinux='1' -D__UTA_IBIT__='64' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='53' -D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__INTPTR_TYPE__='int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='unsigned int' -D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32' -D__UINTPTR_MAX__='4294967295U' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807LL' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long long unsigned int' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31' -D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__INT64_TYPE__='long long int' -D__FLT_MAX_EXP__='128' -D__UTQ_IBIT__='0' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807LL' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0' -D__LDBL_MIN_EXP__='(-1021)' -D__arm__='1' -D__UDA_IBIT__='32' -D__INT_LEAST8_MAX__='127' -D__LFRACT_FBIT__='31' -D__WCHAR_UNSIGNED__='1' -D__ARM_ARCH_7A__='1' -D__LDBL_MAX_10_EXP__='308' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.2204460492503131e-16L)' -D__ARM_FEATURE_SIMD32='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long long unsigned int' -D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127' -D__INT_FAST8_TYPE__='signed char' -D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0' -D__LLACCUM_IBIT__='32' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63' -D__UDQ_IBIT__='0' -D__ORDER_BIG_ENDIAN__='4321' -D__ACCUM_EPSILON__='0x1P-15K' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807LL' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.4012984643248171e-45F' -D__LLFRACT_IBIT__='0' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.4028234663852886e+38F' -D__USACCUM_FBIT__='8' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__UFRACT_EPSILON__='0x1P-16UR' -D__INTMAX_TYPE__='long long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='9' -D__UINTMAX_MAX__='18446744073709551615ULL' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)' -D__ATOMIC_SEQ_CST='5' -D__DA_FBIT__='31' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='unsigned int' -D__USA_IBIT__='16' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__ARM_EABI__='1' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8' -D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='15' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='4294967295U' -D__GNUC_GNU_INLINE__='1' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32' -D__ARM_FEATURE_DSP='1' -D__QQ_IBIT__='0' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/GCC/4.9" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/armv7hl-redhat-linux-gnueabi" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/backward" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/include" -isystem"/usr/local/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9"

Compiler info:
lcg-g++-4.9.1 (GCC) 4.9.2 20141101 (Red Hat 4.9.2-1)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/home/jwsmith/HDD/Gaudi/GaudiMP/dict/gaudimp_dict.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("GaudiMP") );
  ::Reflex::Type type_202 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_155 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_3728 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_528 = ::Reflex::TypeBuilder(Reflex::Literal("_object"));
  ::Reflex::Type type_3181 = ::Reflex::TypeBuilder(Reflex::Literal("IRegistry"));
  ::Reflex::Type type_1368 = ::Reflex::TypeBuilder(Reflex::Literal("TBufferFile"));
  ::Reflex::Type type_2385 = ::Reflex::TypeBuilder(Reflex::Literal("DataStoreItem"));
  ::Reflex::Type type_1788 = ::Reflex::TypeBuilder(Reflex::Literal("IDataStoreAgent"));
  ::Reflex::Type type_2301 = ::Reflex::TypeBuilder(Reflex::Literal("IDataManagerSvc"));
  ::Reflex::Type type_3310 = ::Reflex::TypeBuilder(Reflex::Literal("IAddressCreator"));
  ::Reflex::Type type_1177 = ::Reflex::TypeBuilder(Reflex::Literal("IDataProviderSvc"));
  ::Reflex::Type type_9111 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiMP::PyROOTPickle"));
  ::Reflex::Type type_9112 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiMP::TESSerializer"));
  ::Reflex::Type type_4086 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_4034 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<DataObject*>"));
  ::Reflex::Type type_4035 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<DataStoreItem*>"));
  ::Reflex::Type type_4036 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_4274 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,TClass*>"));
  ::Reflex::Type type_25944 = ::Reflex::ReferenceBuilder(type_9111);
  ::Reflex::Type type_9111c = ::Reflex::ConstBuilder(type_9111);
  ::Reflex::Type type_25945 = ::Reflex::ReferenceBuilder(type_9111c);
  ::Reflex::Type type_3828 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PyObject"), type_528);
  ::Reflex::Type type_4983 = ::Reflex::PointerBuilder(type_3828);
  ::Reflex::Type type_19313 = ::Reflex::PointerBuilder(type_1177);
  ::Reflex::Type type_25946 = ::Reflex::PointerBuilder(type_2301);
  ::Reflex::Type type_10397 = ::Reflex::PointerBuilder(type_2385);
  ::Reflex::Type type_19352 = ::Reflex::PointerBuilder(type_3310);
  ::Reflex::Type type_25947 = ::Reflex::ReferenceBuilder(type_9112);
  ::Reflex::Type type_9112c = ::Reflex::ConstBuilder(type_9112);
  ::Reflex::Type type_25948 = ::Reflex::ReferenceBuilder(type_9112c);
  ::Reflex::Type type_25949 = ::Reflex::ReferenceBuilder(type_1368);
  ::Reflex::Type type_4101 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_4086);
  ::Reflex::Type type_4101c = ::Reflex::ConstBuilder(type_4101);
  ::Reflex::Type type_7636 = ::Reflex::ReferenceBuilder(type_4101c);
  ::Reflex::Type type_19242 = ::Reflex::PointerBuilder(type_3181);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __GaudiMP__PyROOTPickle
#undef __GaudiMP__PyROOTPickle
#endif
class __GaudiMP__PyROOTPickle {
  public:
  __GaudiMP__PyROOTPickle();
};
#ifdef __GaudiMP__TESSerializer
#undef __GaudiMP__TESSerializer
#endif
class __GaudiMP__TESSerializer : virtual public ::IDataStoreAgent {
  public:
  __GaudiMP__TESSerializer();
  virtual ~__GaudiMP__TESSerializer() throw();
  void* m_TES;
  void* m_TESMgr;
  ::std::vector<std::basic_string<char> > m_itemNames;
  ::std::vector<DataStoreItem*> m_itemList;
  ::std::vector<std::basic_string<char> > m_optItemNames;
  ::std::vector<DataStoreItem*> m_optItemList;
  void* m_currentItem;
  ::std::vector<DataObject*> m_objects;
  ::std::map<std::basic_string<char>,TClass*> m_classMap;
  bool m_verifyItems;
  bool m_strict;
  void* m_addressCreator;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class PyROOTPickle -------------------------------
static void destructor_22188(void*, void * o, const std::vector<void*>&, void *) {
(((::GaudiMP::PyROOTPickle*)o)->::GaudiMP::PyROOTPickle::~PyROOTPickle)();
}
static  void operator_22189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiMP::PyROOTPickle*)o)->operator=)(*(const ::GaudiMP::PyROOTPickle*)arg[0]);
  else   (((::GaudiMP::PyROOTPickle*)o)->operator=)(*(const ::GaudiMP::PyROOTPickle*)arg[0]);
}

static void constructor_22190( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiMP::PyROOTPickle(*(const ::GaudiMP::PyROOTPickle*)arg[0]);
  else ::new(mem) ::GaudiMP::PyROOTPickle(*(const ::GaudiMP::PyROOTPickle*)arg[0]);
}

static void constructor_22191( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiMP::PyROOTPickle();
  else ::new(mem) ::GaudiMP::PyROOTPickle();
}

static  void method_22192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiMP::PyROOTPickle*)o)->Initialize)((::PyObject*)arg[0],
    (::PyObject*)arg[1]);
}

static void method_newdel_9111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GaudiMP::PyROOTPickle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GaudiMP::PyROOTPickle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GaudiMP::PyROOTPickle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GaudiMP::PyROOTPickle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GaudiMP::PyROOTPickle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PyROOTPickle -------------------------------
void __GaudiMP__PyROOTPickle_db_datamem(Reflex::Class*);
void __GaudiMP__PyROOTPickle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GaudiMP__PyROOTPickle_datamem_bld(&__GaudiMP__PyROOTPickle_db_datamem);
Reflex::GenreflexMemberBuilder __GaudiMP__PyROOTPickle_funcmem_bld(&__GaudiMP__PyROOTPickle_db_funcmem);
void __GaudiMP__PyROOTPickle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GaudiMP::PyROOTPickle"), typeid(::GaudiMP::PyROOTPickle), sizeof(::GaudiMP::PyROOTPickle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PyROOTPickle"), destructor_22188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25944, type_25945), Reflex::Literal("operator="), operator_22189, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25945), Reflex::Literal("PyROOTPickle"), constructor_22190, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PyROOTPickle"), constructor_22191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__GaudiMP__PyROOTPickle_funcmem_bld);
}

//------Delayed data member builder for class PyROOTPickle -------------------
void __GaudiMP__PyROOTPickle_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PyROOTPickle -------------------
void __GaudiMP__PyROOTPickle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_155, type_4983, type_4983), Reflex::Literal("Initialize"), method_22192, 0, "libpyroot_pymodule;objectproxy_pytype", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TESSerializer -------------------------------
static  void operator_22208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiMP::TESSerializer*)o)->operator=)(*(const ::GaudiMP::TESSerializer*)arg[0]);
  else   (((::GaudiMP::TESSerializer*)o)->operator=)(*(const ::GaudiMP::TESSerializer*)arg[0]);
}

static void constructor_22209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiMP::TESSerializer(*(const ::GaudiMP::TESSerializer*)arg[0]);
  else ::new(mem) ::GaudiMP::TESSerializer(*(const ::GaudiMP::TESSerializer*)arg[0]);
}

static void constructor_22210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiMP::TESSerializer((::IDataProviderSvc*)arg[0],
      (::IAddressCreator*)arg[1]);
  else ::new(mem) ::GaudiMP::TESSerializer((::IDataProviderSvc*)arg[0],
      (::IAddressCreator*)arg[1]);
}

static  void method_22211( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiMP::TESSerializer*)o)->dumpBuffer)(*(::TBufferFile*)arg[0]);
}

static  void method_22212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiMP::TESSerializer*)o)->loadBuffer)(*(::TBufferFile*)arg[0]);
}

static  void method_22213( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiMP::TESSerializer*)o)->addItem)(*(const ::std::string*)arg[0]);
}

static  void method_22214( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiMP::TESSerializer*)o)->addOptItem)(*(const ::std::string*)arg[0]);
}

static  void method_22215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GaudiMP::TESSerializer*)o)->analyse)((::IRegistry*)arg[0],
    *(int*)arg[1]));
  else   (((::GaudiMP::TESSerializer*)o)->analyse)((::IRegistry*)arg[0],
    *(int*)arg[1]);
}

static  void method_22216( void*, void* o, const std::vector<void*>&, void*)
{
  (((::GaudiMP::TESSerializer*)o)->checkItems)();
}

static void destructor_22217(void*, void * o, const std::vector<void*>&, void *) {
(((::GaudiMP::TESSerializer*)o)->::GaudiMP::TESSerializer::~TESSerializer)();
}
static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IDataStoreAgent")), ::Reflex::BaseOffset< ::GaudiMP::TESSerializer,::IDataStoreAgent >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TESSerializer -------------------------------
void __GaudiMP__TESSerializer_db_datamem(Reflex::Class*);
void __GaudiMP__TESSerializer_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GaudiMP__TESSerializer_datamem_bld(&__GaudiMP__TESSerializer_db_datamem);
Reflex::GenreflexMemberBuilder __GaudiMP__TESSerializer_funcmem_bld(&__GaudiMP__TESSerializer_db_funcmem);
void __GaudiMP__TESSerializer_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GaudiMP::TESSerializer"), typeid(::GaudiMP::TESSerializer), sizeof(::GaudiMP::TESSerializer), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1788, ::Reflex::BaseOffset< ::GaudiMP::TESSerializer, ::IDataStoreAgent >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_4035, Reflex::Literal("GaudiMP::TESSerializer::Items"))
  .AddTypedef(type_4036, Reflex::Literal("GaudiMP::TESSerializer::ItemNames"))
  .AddTypedef(type_4034, Reflex::Literal("GaudiMP::TESSerializer::Objects"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25947, type_25948), Reflex::Literal("operator="), operator_22208, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25948), Reflex::Literal("TESSerializer"), constructor_22209, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19313, type_19352), Reflex::Literal("TESSerializer"), constructor_22210, 0, "svc;ac", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TESSerializer"), destructor_22217, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GaudiMP__TESSerializer_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GaudiMP__TESSerializer_funcmem_bld);
}

//------Delayed data member builder for class TESSerializer -------------------
void __GaudiMP__TESSerializer_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19313, Reflex::Literal("m_TES"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_TES), ::Reflex::PRIVATE)
  .AddDataMember(type_25946, Reflex::Literal("m_TESMgr"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_TESMgr), ::Reflex::PRIVATE)
  .AddDataMember(type_4036, Reflex::Literal("m_itemNames"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_itemNames), ::Reflex::PRIVATE)
  .AddDataMember(type_4035, Reflex::Literal("m_itemList"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_itemList), ::Reflex::PRIVATE)
  .AddDataMember(type_4036, Reflex::Literal("m_optItemNames"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_optItemNames), ::Reflex::PRIVATE)
  .AddDataMember(type_4035, Reflex::Literal("m_optItemList"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_optItemList), ::Reflex::PRIVATE)
  .AddDataMember(type_10397, Reflex::Literal("m_currentItem"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_currentItem), ::Reflex::PRIVATE)
  .AddDataMember(type_4034, Reflex::Literal("m_objects"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_objects), ::Reflex::PRIVATE)
  .AddDataMember(type_4274, Reflex::Literal("m_classMap"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_classMap), ::Reflex::PRIVATE)
  .AddDataMember(type_3728, Reflex::Literal("m_verifyItems"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_verifyItems), ::Reflex::PRIVATE)
  .AddDataMember(type_3728, Reflex::Literal("m_strict"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_strict), ::Reflex::PRIVATE)
  .AddDataMember(type_19352, Reflex::Literal("m_addressCreator"), OffsetOf(__shadow__::__GaudiMP__TESSerializer, m_addressCreator), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TESSerializer -------------------
void __GaudiMP__TESSerializer_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_155, type_25949), Reflex::Literal("dumpBuffer"), method_22211, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_155, type_25949), Reflex::Literal("loadBuffer"), method_22212, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_155, type_7636), Reflex::Literal("addItem"), method_22213, 0, "path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_155, type_7636), Reflex::Literal("addOptItem"), method_22214, 0, "path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_19242, type_202), Reflex::Literal("analyse"), method_22215, 0, "dir;level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_155), Reflex::Literal("checkItems"), method_22216, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __GaudiMP__PyROOTPickle_dict(); 
      __GaudiMP__TESSerializer_dict(); 
    }
    ~Dictionaries() {
      type_9111.Unload(); // class GaudiMP::PyROOTPickle 
      type_9112.Unload(); // class GaudiMP::TESSerializer 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
