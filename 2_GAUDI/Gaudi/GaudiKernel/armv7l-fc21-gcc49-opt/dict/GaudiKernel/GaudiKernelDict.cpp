// Generated at Mon Feb 16 19:32:32 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="lcg-g++-4.9.1"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard "
  GCCXML_EXECUTABLE="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__SSP_STRONG__='3' -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__UINT_LEAST16_MAX__='65535' -D__ARM_SIZEOF_WCHAR_T='32' -D__ATOMIC_ACQUIRE='2' -D__SFRACT_IBIT__='0' -D__FLT_MIN__='1.1754943508222875e-38F' -D__GCC_IEC_559_COMPLEX='2' -D__UFRACT_MAX__='0XFFFFP-16UR' -D__UINT_LEAST8_TYPE__='unsigned char' -D__DQ_FBIT__='63' -D__INTMAX_C(c)='c ## LL' -D__ARM_FEATURE_SAT='1' -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK' -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__UINT8_MAX__='255' -D__ACCUM_FBIT__='15' -D__WINT_MAX__='4294967295U' -D__USFRACT_FBIT__='8' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='4294967295U' -D__ARM_ARCH_ISA_ARM='1' -D__WCHAR_MAX__='4294967295U' -D__LACCUM_IBIT__='32' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.9406564584124654e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__GCC_IEC_559='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__cpp_binary_literals='201304' -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__FRACT_FBIT__='15' -D__UINT_FAST64_MAX__='18446744073709551615ULL' -D__SIG_ATOMIC_TYPE__='int' -D__UACCUM_FBIT__='16' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__ARMEL__='1' -D__ARM_FEATURE_UNALIGNED='1' -D__LFRACT_IBIT__='0' -D__GNUC_PATCHLEVEL__='2' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR' -D__UINT_FAST8_MAX__='255' -D__has_include(STR)='__has_include__(STR)' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615ULL' -D__SA_FBIT__='15' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L' -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16' -D__ARM_FP='12' -D__UFRACT_MIN__='0.0UR' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__CHAR_UNSIGNED__='1' -D__UINT32_MAX__='4294967295U' -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64' -D__LDBL_MAX_EXP__='1024' -D__WINT_MIN__='0U' -D__linux__='1' -D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='0U' -D__INT64_C(c)='c ## LL' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D_FORTIFY_SOURCE='2' -D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='4' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USACCUM_IBIT__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)' -D__HA_IBIT__='8' -D__ARM_NEON_FP='4' -D__TQ_IBIT__='0' -D__FLT_EPSILON__='1.1920928955078125e-7F' -D__APCS_32__='1' -D__GXX_WEAK__='1' -D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L' -D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF' -D__DA_IBIT__='32' -D__ARM_SIZEOF_MINIMAL_ENUM='4' -D__INT32_MAX__='2147483647' -D__UQQ_FBIT__='8' -D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK' -D__STDC_IEC_559__='1' -D__STDC_ISO_10646__='201103L' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR' -D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1' -D__has_include_next(STR)='__has_include_next__(STR)' -D__ARM_PCS_VFP='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32' -D__UACCUM_EPSILON__='0x1P-16UK' -D__GNUC__='4' -D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__GXX_RTTI='1' -D__HQ_IBIT__='0' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D__BIGGEST_ALIGNMENT__='8' -D__DQ_IBIT__='0' -D__DBL_MAX__='double(1.7976931348623157e+308L)' -D__ULFRACT_IBIT__='0' -D__INT_FAST32_MAX__='2147483647' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807LL' -D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-94)' -D__THUMB_INTERWORK__='1' -D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__INT_FAST16_TYPE__='int' -D__LDBL_HAS_DENORM__='1' -D__ARM_FEATURE_LDREX='15' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK' -D__DEC128_EPSILON__='1E-33DL' -D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0' -D__PTRDIFF_MAX__='2147483647' -D__UACCUM_MIN__='0.0UK' -D__STDC_NO_THREADS__='1' -D__UACCUM_IBIT__='16' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4' -D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4' -D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64' -D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR' -D__UFRACT_IBIT__='0' -D__ARM_FEATURE_QBIT='1' -D__INT_FAST64_TYPE__='long long int' -D__DBL_MIN__='double(2.2250738585072014e-308L)' -D__FLT_MIN_10_EXP__='(-37)' -D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32' -D__GXX_TYPEINFO_EQUALITY_INLINE='0' -D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0' -D__UINT8_TYPE__='unsigned char' -D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.9.2 20141101 (Red Hat 4.9.2-1)"' -D__UINT64_C(c)='c ## ULL' -D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R' -D__ULACCUM_MIN__='0.0ULK' -D_STDC_PREDEF_H='1' -D__UDA_FBIT__='32' -D__LLACCUM_EPSILON__='0x1P-31LLK' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__USFRACT_MIN__='0.0UHR' -D__ULLACCUM_IBIT__='32' -D__UQQ_IBIT__='0' -D__STDC_IEC_559_COMPLEX__='1' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -D__INT_FAST32_TYPE__='int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='unsigned int' -D__UINT64_MAX__='18446744073709551615ULL' -D__UDQ_FBIT__='64' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__ARM_ARCH_PROFILE='65' -D__LDBL_EPSILON__='2.2204460492503131e-16L' -D__UINTMAX_C(c)='c ## ULL' -D__GNUC_RH_RELEASE__='1' -D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__VFP_FP__='1' -D__SIZEOF_PTRDIFF_T__='4' -D__LACCUM_EPSILON__='0x1P-31LK' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='2147483647' -D__UINT_FAST32_MAX__='4294967295U' -D__UINT_LEAST64_TYPE__='long long unsigned int' -D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='2147483647L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__unix='1' -D__USA_FBIT__='16' -D__UINT_FAST16_TYPE__='unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__ARM_32BIT_STATE='1' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__SACCUM_FBIT__='7' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long long int' -D__ARM_FEATURE_CLZ='1' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__SQ_FBIT__='31' -D__DEC32_MAX_EXP__='97' -D__ARM_ARCH_ISA_THUMB='2' -D__INT_FAST8_MAX__='127' -D__ARM_ARCH='7' -D__INTPTR_MAX__='2147483647' -D__QQ_FBIT__='7' -Dlinux='1' -D__UTA_IBIT__='64' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='53' -D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__INTPTR_TYPE__='int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='unsigned int' -D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32' -D__UINTPTR_MAX__='4294967295U' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807LL' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long long unsigned int' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31' -D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__INT64_TYPE__='long long int' -D__FLT_MAX_EXP__='128' -D__UTQ_IBIT__='0' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807LL' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0' -D__LDBL_MIN_EXP__='(-1021)' -D__arm__='1' -D__UDA_IBIT__='32' -D__INT_LEAST8_MAX__='127' -D__LFRACT_FBIT__='31' -D__WCHAR_UNSIGNED__='1' -D__ARM_ARCH_7A__='1' -D__LDBL_MAX_10_EXP__='308' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.2204460492503131e-16L)' -D__ARM_FEATURE_SIMD32='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long long unsigned int' -D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127' -D__INT_FAST8_TYPE__='signed char' -D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0' -D__LLACCUM_IBIT__='32' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63' -D__UDQ_IBIT__='0' -D__ORDER_BIG_ENDIAN__='4321' -D__ACCUM_EPSILON__='0x1P-15K' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807LL' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.4012984643248171e-45F' -D__LLFRACT_IBIT__='0' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.4028234663852886e+38F' -D__USACCUM_FBIT__='8' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__UFRACT_EPSILON__='0x1P-16UR' -D__INTMAX_TYPE__='long long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='9' -D__UINTMAX_MAX__='18446744073709551615ULL' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)' -D__ATOMIC_SEQ_CST='5' -D__DA_FBIT__='31' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='unsigned int' -D__USA_IBIT__='16' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__ARM_EABI__='1' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8' -D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='15' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='4294967295U' -D__GNUC_GNU_INLINE__='1' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32' -D__ARM_FEATURE_DSP='1' -D__QQ_IBIT__='0' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/GCC/4.9" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/armv7hl-redhat-linux-gnueabi" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/backward" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/include" -isystem"/usr/local/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9"

Compiler info:
lcg-g++-4.9.1 (GCC) 4.9.2 20141101 (Red Hat 4.9.2-1)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/home/jwsmith/HDD/Gaudi/GaudiKernel/dict/dictionary.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("MSG") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("Rndm") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("Gaudi") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("NTuple") );
  ::Reflex::NamespaceBuilder nsb5( Reflex::Literal("System") );
  ::Reflex::NamespaceBuilder nsb6( Reflex::Literal("Gaudi::Parsers") );
  ::Reflex::NamespaceBuilder nsb7( Reflex::Literal("Gaudi::PluginService") );
  ::Reflex::NamespaceBuilder nsb8( Reflex::Literal("Gaudi::StateMachine") );
  ::Reflex::NamespaceBuilder nsb9( Reflex::Literal("Gaudi::CounterSummary") );
  ::Reflex::NamespaceBuilder nsb10( Reflex::Literal("Gaudi::Utils") );
  ::Reflex::NamespaceBuilder nsb11( Reflex::Literal("Gaudi::Histos") );
  ::Reflex::NamespaceBuilder nsb12( Reflex::Literal("Gaudi::PluginService::Details") );
  ::Reflex::Type type_22 = ::Reflex::TypeBuilder(Reflex::Literal("tm"));
  ::Reflex::Type type_26 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_142 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_72 = ::Reflex::TypeBuilder(Reflex::Literal("Stat"));
  ::Reflex::Type type_843 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2842 = ::Reflex::TypeBuilder(Reflex::Literal("TH1"));
  ::Reflex::Type type_2822 = ::Reflex::TypeBuilder(Reflex::Literal("TH2"));
  ::Reflex::Type type_2855 = ::Reflex::TypeBuilder(Reflex::Literal("TH3"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_4206 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_4274 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_530 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_869 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_1086 = ::Reflex::TypeBuilder(Reflex::Literal("TList"));
  ::Reflex::Type type_1921 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_2603 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_671 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_1805 = ::Reflex::TypeBuilder(Reflex::Literal("TGraph"));
  ::Reflex::Type type_813 = ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool"));
  ::Reflex::Type type_934 = ::Reflex::TypeBuilder(Reflex::Literal("IService"));
  ::Reflex::Type type_208 = ::Reflex::TypeBuilder(Reflex::Literal("Incident"));
  ::Reflex::Type type_1234 = ::Reflex::TypeBuilder(Reflex::Literal("AlgTool"));
  ::Reflex::Type type_1979 = ::Reflex::TypeBuilder(Reflex::Literal("Message"));
  ::Reflex::Type type_1365 = ::Reflex::TypeBuilder(Reflex::Literal("Service"));
  ::Reflex::Type type_1857 = ::Reflex::TypeBuilder(Reflex::Literal("INTuple"));
  ::Reflex::Type type_2061 = ::Reflex::TypeBuilder(Reflex::Literal("Property"));
  ::Reflex::Type type_1590 = ::Reflex::TypeBuilder(Reflex::Literal("IAuditor"));
  ::Reflex::Type type_1763 = ::Reflex::TypeBuilder(Reflex::Literal("IStatSvc"));
  ::Reflex::Type type_2197 = ::Reflex::TypeBuilder(Reflex::Literal("IToolSvc"));
  ::Reflex::Type type_2739 = ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen"));
  ::Reflex::Type type_189 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_2823 = ::Reflex::TypeBuilder(Reflex::Literal("IRunable"));
  ::Reflex::Type type_2383 = ::Reflex::TypeBuilder(Reflex::Literal("IProperty"));
  ::Reflex::Type type_1726 = ::Reflex::TypeBuilder(Reflex::Literal("IRegistry"));
  ::Reflex::Type type_303 = ::Reflex::TypeBuilder(Reflex::Literal("DataObject"));
  ::Reflex::Type type_506 = ::Reflex::TypeBuilder(Reflex::Literal("IClassInfo"));
  ::Reflex::Type type_549 = ::Reflex::TypeBuilder(Reflex::Literal("IAlgorithm"));
  ::Reflex::Type type_581 = ::Reflex::TypeBuilder(Reflex::Literal("ISerialize"));
  ::Reflex::Type type_2654 = ::Reflex::TypeBuilder(Reflex::Literal("IStateful"));
  ::Reflex::Type type_810 = ::Reflex::TypeBuilder(Reflex::Literal("INTupleSvc"));
  ::Reflex::Type type_1544 = ::Reflex::TypeBuilder(Reflex::Literal("ITHistSvc"));
  ::Reflex::Type type_1216 = ::Reflex::TypeBuilder(Reflex::Literal("MsgStream"));
  ::Reflex::Type type_541 = ::Reflex::TypeBuilder(Reflex::Literal("JobHistory"));
  ::Reflex::Type type_2912 = ::Reflex::TypeBuilder(Reflex::Literal("Algorithm"));
  ::Reflex::Type type_2345 = ::Reflex::TypeBuilder(Reflex::Literal("IValidity"));
  ::Reflex::Type type_2390 = ::Reflex::TypeBuilder(Reflex::Literal("IAppMgrUI"));
  ::Reflex::Type type_4208 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Bit"));
  ::Reflex::Type type_1730 = ::Reflex::TypeBuilder(Reflex::Literal("IInterface"));
  ::Reflex::Type type_210 = ::Reflex::TypeBuilder(Reflex::Literal("InterfaceID"));
  ::Reflex::Type type_2872 = ::Reflex::TypeBuilder(Reflex::Literal("StatusCode"));
  ::Reflex::Type type_239 = ::Reflex::TypeBuilder(Reflex::Literal("IUpdateable"));
  ::Reflex::Type type_394 = ::Reflex::TypeBuilder(Reflex::Literal("IDetDataSvc"));
  ::Reflex::Type type_2244 = ::Reflex::TypeBuilder(Reflex::Literal("IChronoSvc"));
  ::Reflex::Type type_1044 = ::Reflex::TypeBuilder(Reflex::Literal("IConverter"));
  ::Reflex::Type type_777 = ::Reflex::TypeBuilder(Reflex::Literal("IMessageSvc"));
  ::Reflex::Type type_788 = ::Reflex::TypeBuilder(Reflex::Literal("IMonitorSvc"));
  ::Reflex::Type type_2375 = ::Reflex::TypeBuilder(Reflex::Literal("StatEntity"));
  ::Reflex::Type type_897 = ::Reflex::TypeBuilder(Reflex::Literal("IRndmEngine"));
  ::Reflex::Type type_1334 = ::Reflex::TypeBuilder(Reflex::Literal("IInspector"));
  ::Reflex::Type type_1885 = ::Reflex::TypeBuilder(Reflex::Literal("TDirectory"));
  ::Reflex::Type type_796 = ::Reflex::TypeBuilder(Reflex::Literal("ISvcFactory"));
  ::Reflex::Type type_1954 = ::Reflex::TypeBuilder(Reflex::Literal("IStagerSvc"));
  ::Reflex::Type type_4225 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Chi2"));
  ::Reflex::Type type_4227 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Flat"));
  ::Reflex::Type type_250 = ::Reflex::TypeBuilder(Reflex::Literal("signed char"));
  ::Reflex::Type type_203 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_2759 = ::Reflex::TypeBuilder(Reflex::Literal("LinkManager"));
  ::Reflex::Type type_4682 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Time"));
  ::Reflex::Type type_1221 = ::Reflex::TypeBuilder(Reflex::Literal("ISvcLocator"));
  ::Reflex::Type type_1222 = ::Reflex::TypeBuilder(Reflex::Literal("IAuditorSvc"));
  ::Reflex::Type type_1062 = ::Reflex::TypeBuilder(Reflex::Literal("PropertyMgr"));
  ::Reflex::Type type_1636 = ::Reflex::TypeBuilder(Reflex::Literal("ISvcManager"));
  ::Reflex::Type type_1710 = ::Reflex::TypeBuilder(Reflex::Literal("IRndmGenSvc"));
  ::Reflex::Type type_1695 = ::Reflex::TypeBuilder(Reflex::Literal("ICounterSvc"));
  ::Reflex::Type type_1005 = ::Reflex::TypeBuilder(Reflex::Literal("INTupleItem"));
  ::Reflex::Type type_2087 = ::Reflex::TypeBuilder(Reflex::Literal("IHistorySvc"));
  ::Reflex::Type type_2965 = ::Reflex::TypeBuilder(Reflex::Literal("DataHistory"));
  ::Reflex::Type type_2099 = ::Reflex::TypeBuilder(Reflex::Literal("IAlgManager"));
  ::Reflex::Type type_2767 = ::Reflex::TypeBuilder(Reflex::Literal("IgnoreError"));
  ::Reflex::Type type_4211 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Gamma"));
  ::Reflex::Type type_4221 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Gauss"));
  ::Reflex::Type type_4100 = ::Reflex::TypeBuilder(Reflex::Literal("long double"));
  ::Reflex::Type type_502 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_278 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_417 = ::Reflex::TypeBuilder(Reflex::Literal("IClassManager"));
  ::Reflex::Type type_2182 = ::Reflex::TypeBuilder(Reflex::Literal("StreamBuffer"));
  ::Reflex::Type type_610 = ::Reflex::TypeBuilder(Reflex::Literal("IExceptionSvc"));
  ::Reflex::Type type_1049 = ::Reflex::TypeBuilder(Reflex::Literal("IEvtSelector"));
  ::Reflex::Type type_1778 = ::Reflex::TypeBuilder(Reflex::Literal("IIncidentSvc"));
  ::Reflex::Type type_1617 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefBase"));
  ::Reflex::Type type_1723 = ::Reflex::TypeBuilder(Reflex::Literal("IPartPropSvc"));
  ::Reflex::Type type_1793 = ::Reflex::TypeBuilder(Reflex::Literal("ChronoEntity"));
  ::Reflex::Type type_2935 = ::Reflex::TypeBuilder(Reflex::Literal("IIssueLogger"));
  ::Reflex::Type type_2950 = ::Reflex::TypeBuilder(Reflex::Literal("IInspectable"));
  ::Reflex::Type type_4228 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Landau"));
  ::Reflex::Type type_5953 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::File"));
  ::Reflex::Type type_573 = ::Reflex::TypeBuilder(Reflex::Literal("IStatusCodeSvc"));
  ::Reflex::Type type_732 = ::Reflex::TypeBuilder(Reflex::Literal("IConversionSvc"));
  ::Reflex::Type type_5990 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Tuple"));
  ::Reflex::Type type_995 = ::Reflex::TypeBuilder(Reflex::Literal("GenericAddress"));
  ::Reflex::Type type_1006 = ::Reflex::TypeBuilder(Reflex::Literal("IssueSeverity"));
  ::Reflex::Type type_1759 = ::Reflex::TypeBuilder(Reflex::Literal("DataStoreItem"));
  ::Reflex::Type type_2722 = ::Reflex::TypeBuilder(Reflex::Literal("IHistogramSvc"));
  ::Reflex::Type type_928 = ::Reflex::TypeBuilder(Reflex::Literal("AlgToolHistory"));
  ::Reflex::Type type_4223 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Poisson"));
  ::Reflex::Type type_4229 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Numbers"));
  ::Reflex::Type type_333 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_686 = ::Reflex::TypeBuilder(Reflex::Literal("IDataStreamTool"));
  ::Reflex::Type type_133 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiHandleInfo"));
  ::Reflex::Type type_120 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiHandleBase"));
  ::Reflex::Type type_2476 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiException"));
  ::Reflex::Type type_3397 = ::Reflex::TypeBuilder(Reflex::Literal("std::exception"));
  ::Reflex::Type type_674 = ::Reflex::TypeBuilder(Reflex::Literal("IDataStoreAgent"));
  ::Reflex::Type type_750 = ::Reflex::TypeBuilder(Reflex::Literal("IPersistencySvc"));
  ::Reflex::Type type_4106 = ::Reflex::EnumTypeBuilder(Reflex::Literal("MSG::Level"));
  ::Reflex::Type type_2811 = ::Reflex::TypeBuilder(Reflex::Literal("IOpaqueAddress"));
  ::Reflex::Type type_1385 = ::Reflex::TypeBuilder(Reflex::Literal("IDataSourceMgr"));
  ::Reflex::Type type_2156 = ::Reflex::TypeBuilder(Reflex::Literal("IAlgContextSvc"));
  ::Reflex::Type type_2374 = ::Reflex::TypeBuilder(Reflex::Literal("IChronoStatSvc"));
  ::Reflex::Type type_86 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IProfile1D"));
  ::Reflex::Type type_10 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IProfile2D"));
  ::Reflex::Type type_1841 = ::Reflex::TypeBuilder(Reflex::Literal("IJobOptionsSvc"));
  ::Reflex::Type type_3396 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_2210 = ::Reflex::TypeBuilder(Reflex::Literal("ServiceHistory"));
  ::Reflex::Type type_4207 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Binomial"));
  ::Reflex::Type type_4209 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::StudentT"));
  ::Reflex::Type type_2776 = ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface"));
  ::Reflex::Type type_1249 = ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject"));
  ::Reflex::Type type_790 = ::Reflex::TypeBuilder(Reflex::Literal("IDataStoreLeaves"));
  ::Reflex::Type type_2469 = ::Reflex::TypeBuilder(Reflex::Literal("IAddressCreator"));
  ::Reflex::Type type_8014 = ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param"));
  ::Reflex::Type type_1699 = ::Reflex::TypeBuilder(Reflex::Literal("IDataManagerSvc"));
  ::Reflex::Type type_1791 = ::Reflex::TypeBuilder(Reflex::Literal("IEventProcessor"));
  ::Reflex::Type type_641 = ::Reflex::TypeBuilder(Reflex::Literal("ParticleProperty"));
  ::Reflex::Type type_4668 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::TimeSpan"));
  ::Reflex::Type type_553 = ::Reflex::TypeBuilder(Reflex::Literal("IIncidentListener"));
  ::Reflex::Type type_1414 = ::Reflex::TypeBuilder(Reflex::Literal("IDataProviderSvc"));
  ::Reflex::Type type_1453 = ::Reflex::TypeBuilder(Reflex::Literal("KeyedObject<int>"));
  ::Reflex::Type type_556 = ::Reflex::TypeBuilder(Reflex::Literal("IComponentManager"));
  ::Reflex::Type type_2260 = ::Reflex::TypeBuilder(Reflex::Literal("ISelectStatement"));
  ::Reflex::Type type_1575 = ::Reflex::TypeBuilder(Reflex::Literal("AlgorithmHistory"));
  ::Reflex::Type type_4210 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::DefinedPdf"));
  ::Reflex::Type type_14 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long long"));
  ::Reflex::Type type_6008 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::TupleImp"));
  ::Reflex::Type type_4661 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::StringKey"));
  ::Reflex::Type type_3188 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_654 = ::Reflex::TypeBuilder(Reflex::Literal("SmartDataObjectPtr"));
  ::Reflex::Type type_5 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IBaseHistogram"));
  ::Reflex::Type type_6012 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Directory"));
  ::Reflex::Type type_3166 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long>"));
  ::Reflex::Type type_1187 = ::Reflex::TypeBuilder(Reflex::Literal("IUpdateManagerSvc"));
  ::Reflex::Type type_1192 = ::Reflex::TypeBuilder(Reflex::Literal("IPartitionControl"));
  ::Reflex::Type type_1593 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IService>"));
  ::Reflex::Type type_1451 = ::Reflex::TypeBuilder(Reflex::Literal("KeyedObject<long>"));
  ::Reflex::Type type_1600 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IToolSvc>"));
  ::Reflex::Type type_3172 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Stat>"));
  ::Reflex::Type type_1946 = ::Reflex::TypeBuilder(Reflex::Literal("IEventTimeDecoder"));
  ::Reflex::Type type_2266 = ::Reflex::TypeBuilder(Reflex::Literal("IMagneticFieldSvc"));
  ::Reflex::Type type_8321 = ::Reflex::TypeBuilder(Reflex::Literal("LinkManager::Link"));
  ::Reflex::Type type_4212 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::Exponential"));
  ::Reflex::Type type_4224 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::BreitWigner"));
  ::Reflex::Type type_5962 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<int>"));
  ::Reflex::Type type_4669 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Histo1DDef"));
  ::Reflex::Type type_3414 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_3193 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<char>"));
  ::Reflex::Type type_3180 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_612 = ::Reflex::TypeBuilder(Reflex::Literal("ObjectContainerBase"));
  ::Reflex::Type type_7395 = ::Reflex::TypeBuilder(Reflex::Literal("IToolSvc::Observer"));
  ::Reflex::Type type_2079 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IHistogram1D"));
  ::Reflex::Type type_2582 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IHistogram2D"));
  ::Reflex::Type type_1275 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IHistogram3D"));
  ::Reflex::Type type_1609 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IProperty>"));
  ::Reflex::Type type_2054 = ::Reflex::TypeBuilder(Reflex::Literal("ICounterSummarySvc"));
  ::Reflex::Type type_4226 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::GaussianTail"));
  ::Reflex::Type type_5919 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<int>"));
  ::Reflex::Type type_5958 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<bool>"));
  ::Reflex::Type type_5966 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<long>"));
  ::Reflex::Type type_5970 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<char>"));
  ::Reflex::Type type_3020 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,int>"));
  ::Reflex::Type type_3183 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_3190 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<short>"));
  ::Reflex::Type type_709 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiHandleArrayBase"));
  ::Reflex::Type type_3167 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_1141 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiHandleProperty"));
  ::Reflex::Type type_1591 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IAlgorithm>"));
  ::Reflex::Type type_1604 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<INTupleSvc>"));
  ::Reflex::Type type_5917 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<bool>"));
  ::Reflex::Type type_5921 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<int>"));
  ::Reflex::Type type_5956 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<long>"));
  ::Reflex::Type type_5960 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<float>"));
  ::Reflex::Type type_5968 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<short>"));
  ::Reflex::Type type_5992 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<char>"));
  ::Reflex::Type type_8938 = ::Reflex::TypeBuilder(Reflex::Literal("System::ProcessTime"));
  ::Reflex::Type type_2987 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<IService*>"));
  ::Reflex::Type type_1596 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<ISvcLocator>"));
  ::Reflex::Type type_1595 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<ISvcManager>"));
  ::Reflex::Type type_1594 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IAuditorSvc>"));
  ::Reflex::Type type_1597 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IMessageSvc>"));
  ::Reflex::Type type_1598 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IMonitorSvc>"));
  ::Reflex::Type type_1602 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IRndmGenSvc>"));
  ::Reflex::Type type_1859 = ::Reflex::TypeBuilder(Reflex::Literal("IParticlePropertySvc"));
  ::Reflex::Type type_2749 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<DataObject>"));
  ::Reflex::Type type_3625 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_5911 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<char>"));
  ::Reflex::Type type_5915 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<float>"));
  ::Reflex::Type type_5954 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<double>"));
  ::Reflex::Type type_5994 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<long>"));
  ::Reflex::Type type_6002 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<bool>"));
  ::Reflex::Type type_6014 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<short>"));
  ::Reflex::Type type_6096 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::RowWiseTuple"));
  ::Reflex::Type type_8939 = ::Reflex::EnumTypeBuilder(Reflex::Literal("System::InfoType"));
  ::Reflex::Type type_8981 = ::Reflex::EnumTypeBuilder(Reflex::Literal("System::TimeType"));
  ::Reflex::Type type_3415 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,double>"));
  ::Reflex::Type type_490 = ::Reflex::TypeBuilder(Reflex::Literal("implements1<IProperty>"));
  ::Reflex::Type type_5193 = ::Reflex::TypeBuilder(Reflex::Literal("IEvtSelector::Context"));
  ::Reflex::Type type_1592 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IIncidentSvc>"));
  ::Reflex::Type type_6517 = ::Reflex::TypeBuilder(Reflex::Literal("ICounterSvc::Printout"));
  ::Reflex::Type type_5905 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<double>"));
  ::Reflex::Type type_5951 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<short>"));
  ::Reflex::Type type_5988 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<float>"));
  ::Reflex::Type type_272 = ::Reflex::TypeBuilder(Reflex::Literal("EventSelectorDataStream"));
  ::Reflex::Type type_3177 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Property*>"));
  ::Reflex::Type type_489 = ::Reflex::TypeBuilder(Reflex::Literal("implements1<IInterface>"));
  ::Reflex::Type type_1601 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IExceptionSvc>"));
  ::Reflex::Type type_682 = ::Reflex::TypeBuilder(Reflex::Literal("AIDA::IHistogramFactory"));
  ::Reflex::Type type_1605 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IHistogramSvc>"));
  ::Reflex::Type type_2985 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<IAlgorithm*>"));
  ::Reflex::Type type_3319 = ::Reflex::TypeBuilder(Reflex::Literal("std::char_traits<char>"));
  ::Reflex::Type type_5923 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<double>"));
  ::Reflex::Type type_8972 = ::Reflex::EnumTypeBuilder(Reflex::Literal("System::MemoryUnit"));
  ::Reflex::Type type_8953 = ::Reflex::EnumTypeBuilder(Reflex::Literal("System::ModuleType"));
  ::Reflex::Type type_3185 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long long>"));
  ::Reflex::Type type_3224 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_1606 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IConversionSvc>"));
  ::Reflex::Type type_1599 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IAlgContextSvc>"));
  ::Reflex::Type type_1603 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IChronoStatSvc>"));
  ::Reflex::Type type_3171 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<IRegistry*>"));
  ::Reflex::Type type_1638 = ::Reflex::TypeBuilder(Reflex::Literal("PropertyCallbackFunctor"));
  ::Reflex::Type type_3178 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Algorithm*>"));
  ::Reflex::Type type_4222 = ::Reflex::TypeBuilder(Reflex::Literal("Rndm::BreitWignerCutOff"));
  ::Reflex::Type type_5965 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<long long>"));
  ::Reflex::Type type_5987 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::ColumnWiseTuple"));
  ::Reflex::Type type_1822 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<DataObject*>"));
  ::Reflex::Type type_3015 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<double,double>"));
  ::Reflex::Type type_5148 = ::Reflex::EnumTypeBuilder(Reflex::Literal("IssueSeverity::Level"));
  ::Reflex::Type type_1608 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IAddressCreator>"));
  ::Reflex::Type type_1223 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiHandleArrayProperty"));
  ::Reflex::Type type_3179 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<IAlgorithm*>"));
  ::Reflex::Type type_4509 = ::Reflex::TypeBuilder(Reflex::Literal("HepPDT::ProcessUnknownID"));
  ::Reflex::Type type_1830 = ::Reflex::TypeBuilder(Reflex::Literal("SmartDataPtr<DataObject>"));
  ::Reflex::Type type_3182 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long double>"));
  ::Reflex::Type type_3192 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<signed char>"));
  ::Reflex::Type type_1607 = ::Reflex::TypeBuilder(Reflex::Literal("SmartIF<IDataProviderSvc>"));
  ::Reflex::Type type_1452 = ::Reflex::TypeBuilder(Reflex::Literal("KeyedObject<unsigned int>"));
  ::Reflex::Type type_4508 = ::Reflex::TypeBuilder(Reflex::Literal("HepPDT::ParticleDataTable"));
  ::Reflex::Type type_3199 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<INTupleItem*>"));
  ::Reflex::Type type_3306 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<ServiceHistory*>"));
  ::Reflex::Type type_3304 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<AlgToolHistory*>"));
  ::Reflex::Type type_2748 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<ContainedObject>"));
  ::Reflex::Type type_3187 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_1450 = ::Reflex::TypeBuilder(Reflex::Literal("KeyedObject<unsigned long>"));
  ::Reflex::Type type_7420 = ::Reflex::EnumTypeBuilder(Reflex::Literal("IChronoSvc::ChronoType"));
  ::Reflex::Type type_2516 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<DataObject>"));
  ::Reflex::Type type_5961 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<unsigned int>"));
  ::Reflex::Type type_3186 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3191 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_46 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces1<IProperty>"));
  ::Reflex::Type type_4847 = ::Reflex::TypeBuilder(Reflex::Literal("Containers::key_traits<int>"));
  ::Reflex::Type type_3305 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<AlgorithmHistory*>"));
  ::Reflex::Type type_2746 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<KeyedObject<int> >"));
  ::Reflex::Type type_5964 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<unsigned long>"));
  ::Reflex::Type type_5969 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<unsigned char>"));
  ::Reflex::Type type_6009 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<unsigned int>"));
  ::Reflex::Type type_3189 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_44 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces1<IInterface>"));
  ::Reflex::Type type_4845 = ::Reflex::TypeBuilder(Reflex::Literal("Containers::key_traits<long>"));
  ::Reflex::Type type_3169 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const Property*>"));
  ::Reflex::Type type_7419 = ::Reflex::EnumTypeBuilder(Reflex::Literal("IChronoSvc::ChronoStatus"));
  ::Reflex::Type type_2744 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<KeyedObject<long> >"));
  ::Reflex::Type type_5909 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<unsigned char>"));
  ::Reflex::Type type_5913 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<unsigned int>"));
  ::Reflex::Type type_5947 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<unsigned long>"));
  ::Reflex::Type type_5967 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<unsigned short>"));
  ::Reflex::Type type_3176 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<GaudiHandleBase*>"));
  ::Reflex::Type type_19688 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Utils::TypeNameString"));
  ::Reflex::Type type_2747 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<ObjectContainerBase>"));
  ::Reflex::Type type_3155 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ContainedObject*>"));
  ::Reflex::Type type_5949 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<unsigned char>"));
  ::Reflex::Type type_6001 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<unsigned long>"));
  ::Reflex::Type type_6013 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<unsigned short>"));
  ::Reflex::Type type_3194 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Gaudi::StringKey>"));
  ::Reflex::Type type_3168 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ParticleProperty*>"));
  ::Reflex::Type type_5907 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<unsigned short>"));
  ::Reflex::Type type_6015 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Array<IOpaqueAddress*>"));
  ::Reflex::Type type_19509 = ::Reflex::EnumTypeBuilder(Reflex::Literal("Gaudi::StateMachine::State"));
  ::Reflex::Type type_5168 = ::Reflex::EnumTypeBuilder(Reflex::Literal("IAuditor::StandardEventType"));
  ::Reflex::Type type_3170 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<IIncidentListener*>"));
  ::Reflex::Type type_2515 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<ContainedObject>"));
  ::Reflex::Type type_3157 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<LinkManager::Link*>"));
  ::Reflex::Type type_5405 = ::Reflex::TypeBuilder(Reflex::Literal("IUpdateManagerSvc::PythonHelper"));
  ::Reflex::Type type_3184 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long long>"));
  ::Reflex::Type type_6003 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Matrix<IOpaqueAddress*>"));
  ::Reflex::Type type_3634 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<ContainedObject*>"));
  ::Reflex::Type type_4740 = ::Reflex::TypeBuilder(Reflex::Literal("SmartDataObjectPtr::ObjectLoader"));
  ::Reflex::Type type_4741 = ::Reflex::TypeBuilder(Reflex::Literal("SmartDataObjectPtr::ObjectFinder"));
  ::Reflex::Type type_5963 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Item<unsigned long long>"));
  ::Reflex::Type type_3196 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<int,int> >"));
  ::Reflex::Type type_261 = ::Reflex::TypeBuilder(Reflex::Literal("extends1<AlgTool,IDataStreamTool>"));
  ::Reflex::Type type_45 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces1<IDataStreamTool>"));
  ::Reflex::Type type_1829 = ::Reflex::TypeBuilder(Reflex::Literal("SmartDataPtr<ObjectContainerBase>"));
  ::Reflex::Type type_2513 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<KeyedObject<int> >"));
  ::Reflex::Type type_3198 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<double> >"));
  ::Reflex::Type type_3307 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<std::basic_string<char> >"));
  ::Reflex::Type type_2511 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<KeyedObject<long> >"));
  ::Reflex::Type type_3164 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<DataObject> >"));
  ::Reflex::Type type_3635 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<LinkManager::Link*>"));
  ::Reflex::Type type_47 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces2<IService,IAuditor>"));
  ::Reflex::Type type_3175 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const GaudiHandleBase*>"));
  ::Reflex::Type type_2514 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<ObjectContainerBase>"));
  ::Reflex::Type type_3156 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const ContainedObject*>"));
  ::Reflex::Type type_4846 = ::Reflex::TypeBuilder(Reflex::Literal("Containers::key_traits<unsigned int>"));
  ::Reflex::Type type_19632 = ::Reflex::EnumTypeBuilder(Reflex::Literal("Gaudi::CounterSummary::SaveType"));
  ::Reflex::Type type_2745 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<KeyedObject<unsigned int> >"));
  ::Reflex::Type type_19629 = ::Reflex::EnumTypeBuilder(Reflex::Literal("Gaudi::StateMachine::Transition"));
  ::Reflex::Type type_3165 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_4844 = ::Reflex::TypeBuilder(Reflex::Literal("Containers::key_traits<unsigned long>"));
  ::Reflex::Type type_2743 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<KeyedObject<unsigned long> >"));
  ::Reflex::Type type_3633 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<DataObject> >"));
  ::Reflex::Type type_3416 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"));
  ::Reflex::Type type_3626 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<const ContainedObject*>"));
  ::Reflex::Type type_13038 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>::_Alloc_hider"));
  ::Reflex::Type type_6019 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<int> >"));
  ::Reflex::Type type_3421 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::basic_string<char> >"));
  ::Reflex::Type type_3195 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<double,double> >"));
  ::Reflex::Type type_27695 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::PluginService::Details::Logger"));
  ::Reflex::Type type_3163 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<ContainedObject> >"));
  ::Reflex::Type type_6042 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<int> >"));
  ::Reflex::Type type_6051 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<bool> >"));
  ::Reflex::Type type_6023 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<long> >"));
  ::Reflex::Type type_6027 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<char> >"));
  ::Reflex::Type type_2986 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<std::pair<InterfaceID,void*> >"));
  ::Reflex::Type type_6049 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<bool> >"));
  ::Reflex::Type type_6031 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<int> >"));
  ::Reflex::Type type_6044 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<long> >"));
  ::Reflex::Type type_6017 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<float> >"));
  ::Reflex::Type type_6025 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<short> >"));
  ::Reflex::Type type_6048 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<char> >"));
  ::Reflex::Type type_3417 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,double>"));
  ::Reflex::Type type_1915 = ::Reflex::TypeBuilder(Reflex::Literal("implements3<IAlgTool,IProperty,IStateful>"));
  ::Reflex::Type type_1893 = ::Reflex::TypeBuilder(Reflex::Literal("SimpleProperty<int,BoundedVerifier<int> >"));
  ::Reflex::Type type_1916 = ::Reflex::TypeBuilder(Reflex::Literal("implements3<IService,IProperty,IStateful>"));
  ::Reflex::Type type_3161 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >"));
  ::Reflex::Type type_6037 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<char> >"));
  ::Reflex::Type type_6040 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<float> >"));
  ::Reflex::Type type_6016 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<double> >"));
  ::Reflex::Type type_6033 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<long> >"));
  ::Reflex::Type type_6038 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<bool> >"));
  ::Reflex::Type type_6046 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<short> >"));
  ::Reflex::Type type_585 = ::Reflex::TypeBuilder(Reflex::Literal("SimpleProperty<bool,BoundedVerifier<bool> >"));
  ::Reflex::Type type_3159 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >"));
  ::Reflex::Type type_2512 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<KeyedObject<unsigned int> >"));
  ::Reflex::Type type_3632 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<ContainedObject> >"));
  ::Reflex::Type type_6039 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<double> >"));
  ::Reflex::Type type_6035 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<short> >"));
  ::Reflex::Type type_6029 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<float> >"));
  ::Reflex::Type type_27755 = ::Reflex::TypeBuilder(Reflex::Literal("std::string(GaudiHandleBase::)(void) const"));
  ::Reflex::Type type_1917 = ::Reflex::TypeBuilder(Reflex::Literal("implements3<IAlgorithm,IProperty,IStateful>"));
  ::Reflex::Type type_2510 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<KeyedObject<unsigned long> >"));
  ::Reflex::Type type_3162 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >"));
  ::Reflex::Type type_6028 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<double> >"));
  ::Reflex::Type type_3630 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<KeyedObject<int> > >"));
  ::Reflex::Type type_6022 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<long long> >"));
  ::Reflex::Type type_3628 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<KeyedObject<long> > >"));
  ::Reflex::Type type_3631 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<ObjectContainerBase> >"));
  ::Reflex::Type type_3423 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,unsigned int>"));
  ::Reflex::Type type_664 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IService,IProperty,IStateful>"));
  ::Reflex::Type type_666 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IService,IChronoSvc,IStatSvc>"));
  ::Reflex::Type type_663 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IAlgTool,IProperty,IStateful>"));
  ::Reflex::Type type_6018 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned int> >"));
  ::Reflex::Type type_3422 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_3955 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_6021 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned long> >"));
  ::Reflex::Type type_6026 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned char> >"));
  ::Reflex::Type type_6041 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned int> >"));
  ::Reflex::Type type_665 = ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IAlgorithm,IProperty,IStateful>"));
  ::Reflex::Type type_6047 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned char> >"));
  ::Reflex::Type type_6030 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned int> >"));
  ::Reflex::Type type_6043 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned long> >"));
  ::Reflex::Type type_6024 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned short> >"));
  ::Reflex::Type type_3160 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >"));
  ::Reflex::Type type_6036 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned char> >"));
  ::Reflex::Type type_6032 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned long> >"));
  ::Reflex::Type type_6045 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned short> >"));
  ::Reflex::Type type_3158 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >"));
  ::Reflex::Type type_6034 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned short> >"));
  ::Reflex::Type type_3424 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,Gaudi::Histo1DDef>"));
  ::Reflex::Type type_3419 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<int> >"));
  ::Reflex::Type type_3197 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_3629 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<KeyedObject<unsigned int> > >"));
  ::Reflex::Type type_6020 = ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned long long> >"));
  ::Reflex::Type type_3627 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<KeyedObject<unsigned long> > >"));
  ::Reflex::Type type_3420 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<double> >"));
  ::Reflex::Type type_3413 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_2566 = ::Reflex::TypeBuilder(Reflex::Literal("CommonMessaging<implements3<IService,IProperty,IStateful> >"));
  ::Reflex::Type type_3425 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::pair<double,double> >"));
  ::Reflex::Type type_6856 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<ContainedObject*> >"));
  ::Reflex::Type type_6711 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >"));
  ::Reflex::Type type_1083 = ::Reflex::TypeBuilder(Reflex::Literal("SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>"));
  ::Reflex::Type type_6858 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<LinkManager::Link*> >"));
  ::Reflex::Type type_6799 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<DataObject> > >"));
  ::Reflex::Type type_6792 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<const ContainedObject*> >"));
  ::Reflex::Type type_6766 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >"));
  ::Reflex::Type type_3113 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ContainedObject*,std::allocator<ContainedObject*> >"));
  ::Reflex::Type type_6798 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<ContainedObject> > >"));
  ::Reflex::Type type_1082 = ::Reflex::TypeBuilder(Reflex::Literal("SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>"));
  ::Reflex::Type type_6796 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<KeyedObject<int> > > >"));
  ::Reflex::Type type_3418 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_3115 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<LinkManager::Link*,std::allocator<LinkManager::Link*> >"));
  ::Reflex::Type type_6794 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<KeyedObject<long> > > >"));
  ::Reflex::Type type_6797 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<ObjectContainerBase> > >"));
  ::Reflex::Type type_6754 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >"));
  ::Reflex::Type type_3084 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > >"));
  ::Reflex::Type type_6697 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<ParticleProperty**,std::vector<ParticleProperty*> >"));
  ::Reflex::Type type_3077 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const ContainedObject*,std::allocator<const ContainedObject*> >"));
  ::Reflex::Type type_6795 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<KeyedObject<unsigned int> > > >"));
  ::Reflex::Type type_6758 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >"));
  ::Reflex::Type type_6793 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<KeyedObject<unsigned long> > > >"));
  ::Reflex::Type type_6755 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<ContainedObject* const*,std::vector<ContainedObject*> >"));
  ::Reflex::Type type_3945 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::basic_string<char> > >"));
  ::Reflex::Type type_5704 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::PluginService::Factory2<IService*,const std::basic_string<char>&,ISvcLocator*>"));
  ::Reflex::Type type_6698 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<ParticleProperty* const*,std::vector<ParticleProperty*> >"));
  ::Reflex::Type type_8802 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::PluginService::Factory2<IAlgorithm*,const std::basic_string<char>&,ISvcLocator*>"));
  ::Reflex::Type type_6695 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >"));
  ::Reflex::Type type_6759 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<LinkManager::Link* const*,std::vector<LinkManager::Link*> >"));
  ::Reflex::Type type_3083 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > >"));
  ::Reflex::Type type_6681 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >"));
  ::Reflex::Type type_3944 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> > >"));
  ::Reflex::Type type_3081 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > >"));
  ::Reflex::Type type_6696 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >"));
  ::Reflex::Type type_3079 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<long> >,std::allocator<SmartRef<KeyedObject<long> > > >"));
  ::Reflex::Type type_6682 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const ContainedObject* const*,std::vector<const ContainedObject*> >"));
  ::Reflex::Type type_3082 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > >"));
  ::Reflex::Type type_6693 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >"));
  ::Reflex::Type type_24212 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_6689 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >"));
  ::Reflex::Type type_3933 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> > >"));
  ::Reflex::Type type_6694 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >"));
  ::Reflex::Type type_6685 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >"));
  ::Reflex::Type type_24208 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_6691 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >"));
  ::Reflex::Type type_3937 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> > >"));
  ::Reflex::Type type_6690 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >"));
  ::Reflex::Type type_3932 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<ContainedObject* const*,std::vector<ContainedObject*> > >"));
  ::Reflex::Type type_6686 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >"));
  ::Reflex::Type type_3080 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > >"));
  ::Reflex::Type type_6692 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >"));
  ::Reflex::Type type_3843 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > > >"));
  ::Reflex::Type type_3936 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<LinkManager::Link* const*,std::vector<LinkManager::Link*> > >"));
  ::Reflex::Type type_3078 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<unsigned long> >,std::allocator<SmartRef<KeyedObject<unsigned long> > > >"));
  ::Reflex::Type type_3829 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> > >"));
  ::Reflex::Type type_3842 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > > >"));
  ::Reflex::Type type_6687 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >"));
  ::Reflex::Type type_3828 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const ContainedObject* const*,std::vector<const ContainedObject*> > >"));
  ::Reflex::Type type_5558 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::PluginService::Factory3<IAlgTool*,const std::basic_string<char>&,const std::basic_string<char>&,const IInterface*>"));
  ::Reflex::Type type_6683 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >"));
  ::Reflex::Type type_3841 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > > >"));
  ::Reflex::Type type_6688 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >"));
  ::Reflex::Type type_3837 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > > >"));
  ::Reflex::Type type_6684 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >"));
  ::Reflex::Type type_3833 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > > >"));
  ::Reflex::Type type_3840 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > > >"));
  ::Reflex::Type type_3839 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > > >"));
  ::Reflex::Type type_3836 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > > >"));
  ::Reflex::Type type_3832 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > > >"));
  ::Reflex::Type type_8759 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiUtils::VectorMap<Gaudi::StringKey,double,std::less<const Gaudi::StringKey>,std::allocator<std::pair<Gaudi::StringKey,double> > >"));
  ::Reflex::Type type_3838 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > > >"));
  ::Reflex::Type type_3835 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > > >"));
  ::Reflex::Type type_3831 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > > >"));
  ::Reflex::Type type_3834 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > > >"));
  ::Reflex::Type type_3830 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > > >"));
  ::Reflex::Type type_8760 = ::Reflex::TypeBuilder(Reflex::Literal("GaudiUtils::VectorMap<std::basic_string<char>,double,std::less<const std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,double> > >"));
  ::Reflex::Type type_1823 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("IDataSelector"), type_1822);
  ::Reflex::Type type_4960 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("IDataStoreLeaves::LeavesList"), type_1822);
  ::Reflex::Type type_24119 = ::Reflex::ReferenceBuilder(type_1730);
  ::Reflex::Type type_1730c = ::Reflex::ConstBuilder(type_1730);
  ::Reflex::Type type_24120 = ::Reflex::ReferenceBuilder(type_1730c);
  ::Reflex::Type type_210c = ::Reflex::ConstBuilder(type_210);
  ::Reflex::Type type_7851 = ::Reflex::ReferenceBuilder(type_210c);
  ::Reflex::Type type_1454 = ::Reflex::PointerBuilder(type_843);
  ::Reflex::Type type_4283 = ::Reflex::PointerBuilder(type_1454);
  ::Reflex::Type type_19268 = ::Reflex::ReferenceBuilder(type_44);
  ::Reflex::Type type_44c = ::Reflex::ConstBuilder(type_44);
  ::Reflex::Type type_19269 = ::Reflex::ReferenceBuilder(type_44c);
  ::Reflex::Type type_19811 = ::Reflex::ReferenceBuilder(type_686);
  ::Reflex::Type type_686c = ::Reflex::ConstBuilder(type_686);
  ::Reflex::Type type_19812 = ::Reflex::ReferenceBuilder(type_686c);
  ::Reflex::Type type_10094 = ::Reflex::PointerBuilder(type_272);
  ::Reflex::Type type_272c = ::Reflex::ConstBuilder(type_272);
  ::Reflex::Type type_27750 = ::Reflex::PointerBuilder(type_272c);
  ::Reflex::Type type_19813 = ::Reflex::ReferenceBuilder(type_27750);
  ::Reflex::Type type_10899 = ::Reflex::ReferenceBuilder(type_26);
  ::Reflex::Type type_3236 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_3224);
  ::Reflex::Type type_3236c = ::Reflex::ConstBuilder(type_3236);
  ::Reflex::Type type_6134 = ::Reflex::ReferenceBuilder(type_3236c);
  ::Reflex::Type type_3165c = ::Reflex::ConstBuilder(type_3165);
  ::Reflex::Type type_12573 = ::Reflex::ReferenceBuilder(type_3165c);
  ::Reflex::Type type_19270 = ::Reflex::ReferenceBuilder(type_45);
  ::Reflex::Type type_45c = ::Reflex::ConstBuilder(type_45);
  ::Reflex::Type type_19271 = ::Reflex::ReferenceBuilder(type_45c);
  ::Reflex::Type type_21009 = ::Reflex::ReferenceBuilder(type_2383);
  ::Reflex::Type type_2383c = ::Reflex::ConstBuilder(type_2383);
  ::Reflex::Type type_24311 = ::Reflex::ReferenceBuilder(type_2383c);
  ::Reflex::Type type_2061c = ::Reflex::ConstBuilder(type_2061);
  ::Reflex::Type type_7834 = ::Reflex::ReferenceBuilder(type_2061c);
  ::Reflex::Type type_11428 = ::Reflex::PointerBuilder(type_2061);
  ::Reflex::Type type_19991 = ::Reflex::ReferenceBuilder(type_3236);
  ::Reflex::Type type_3177c = ::Reflex::ConstBuilder(type_3177);
  ::Reflex::Type type_19992 = ::Reflex::ReferenceBuilder(type_3177c);
  ::Reflex::Type type_19272 = ::Reflex::ReferenceBuilder(type_46);
  ::Reflex::Type type_46c = ::Reflex::ConstBuilder(type_46);
  ::Reflex::Type type_19273 = ::Reflex::ReferenceBuilder(type_46c);
  ::Reflex::Type type_19274 = ::Reflex::ReferenceBuilder(type_47);
  ::Reflex::Type type_47c = ::Reflex::ConstBuilder(type_47);
  ::Reflex::Type type_19275 = ::Reflex::ReferenceBuilder(type_47c);
  ::Reflex::Type type_19420 = ::Reflex::ReferenceBuilder(type_120);
  ::Reflex::Type type_120c = ::Reflex::ConstBuilder(type_120);
  ::Reflex::Type type_19421 = ::Reflex::ReferenceBuilder(type_120c);
  ::Reflex::Type type_19423 = ::Reflex::ReferenceBuilder(type_133);
  ::Reflex::Type type_133c = ::Reflex::ConstBuilder(type_133);
  ::Reflex::Type type_7833 = ::Reflex::ReferenceBuilder(type_133c);
  ::Reflex::Type type_19432 = ::Reflex::ReferenceBuilder(type_208);
  ::Reflex::Type type_208c = ::Reflex::ConstBuilder(type_208);
  ::Reflex::Type type_19433 = ::Reflex::ReferenceBuilder(type_208c);
  ::Reflex::Type type_19434 = ::Reflex::ReferenceBuilder(type_210);
  ::Reflex::Type type_4274c = ::Reflex::ConstBuilder(type_4274);
  ::Reflex::Type type_4095 = ::Reflex::PointerBuilder(type_4274c);
  ::Reflex::Type type_19436 = ::Reflex::ReferenceBuilder(type_239);
  ::Reflex::Type type_239c = ::Reflex::ConstBuilder(type_239);
  ::Reflex::Type type_19437 = ::Reflex::ReferenceBuilder(type_239c);
  ::Reflex::Type type_10115 = ::Reflex::PointerBuilder(type_1726);
  ::Reflex::Type type_19454 = ::Reflex::PointerBuilder(type_2759);
  ::Reflex::Type type_19455 = ::Reflex::ReferenceBuilder(type_303);
  ::Reflex::Type type_303c = ::Reflex::ConstBuilder(type_303);
  ::Reflex::Type type_7853 = ::Reflex::ReferenceBuilder(type_303c);
  ::Reflex::Type type_1849 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("CLID"), type_203);
  ::Reflex::Type type_1849c = ::Reflex::ConstBuilder(type_1849);
  ::Reflex::Type type_19456 = ::Reflex::ReferenceBuilder(type_1849c);
  ::Reflex::Type type_4085 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_3955);
  ::Reflex::Type type_7831 = ::Reflex::ReferenceBuilder(type_4085);
  ::Reflex::Type type_19465 = ::Reflex::ReferenceBuilder(type_394);
  ::Reflex::Type type_394c = ::Reflex::ConstBuilder(type_394);
  ::Reflex::Type type_19466 = ::Reflex::ReferenceBuilder(type_394c);
  ::Reflex::Type type_4682c = ::Reflex::ConstBuilder(type_4682);
  ::Reflex::Type type_4403 = ::Reflex::ReferenceBuilder(type_4682c);
  ::Reflex::Type type_19488 = ::Reflex::ReferenceBuilder(type_417);
  ::Reflex::Type type_417c = ::Reflex::ConstBuilder(type_417);
  ::Reflex::Type type_19489 = ::Reflex::ReferenceBuilder(type_417c);
  ::Reflex::Type type_489c = ::Reflex::ConstBuilder(type_489);
  ::Reflex::Type type_19493 = ::Reflex::ReferenceBuilder(type_489c);
  ::Reflex::Type type_19494 = ::Reflex::ReferenceBuilder(type_489);
  ::Reflex::Type type_19496 = ::Reflex::ReferenceBuilder(type_490);
  ::Reflex::Type type_490c = ::Reflex::ConstBuilder(type_490);
  ::Reflex::Type type_19495 = ::Reflex::ReferenceBuilder(type_490c);
  ::Reflex::Type type_19499 = ::Reflex::ReferenceBuilder(type_506);
  ::Reflex::Type type_506c = ::Reflex::ConstBuilder(type_506);
  ::Reflex::Type type_19500 = ::Reflex::ReferenceBuilder(type_506c);
  ::Reflex::Type type_19507 = ::Reflex::ReferenceBuilder(type_549);
  ::Reflex::Type type_549c = ::Reflex::ConstBuilder(type_549);
  ::Reflex::Type type_19508 = ::Reflex::ReferenceBuilder(type_549c);
  ::Reflex::Type type_19513 = ::Reflex::ReferenceBuilder(type_553);
  ::Reflex::Type type_553c = ::Reflex::ConstBuilder(type_553);
  ::Reflex::Type type_19514 = ::Reflex::ReferenceBuilder(type_553c);
  ::Reflex::Type type_19517 = ::Reflex::ReferenceBuilder(type_573);
  ::Reflex::Type type_573c = ::Reflex::ConstBuilder(type_573);
  ::Reflex::Type type_19518 = ::Reflex::ReferenceBuilder(type_573c);
  ::Reflex::Type type_19519 = ::Reflex::ReferenceBuilder(type_581);
  ::Reflex::Type type_581c = ::Reflex::ConstBuilder(type_581);
  ::Reflex::Type type_19520 = ::Reflex::ReferenceBuilder(type_581c);
  ::Reflex::Type type_5648 = ::Reflex::ReferenceBuilder(type_2182);
  ::Reflex::Type type_19758 = ::Reflex::ReferenceBuilder(type_610);
  ::Reflex::Type type_610c = ::Reflex::ConstBuilder(type_610);
  ::Reflex::Type type_19759 = ::Reflex::ReferenceBuilder(type_610c);
  ::Reflex::Type type_2776c = ::Reflex::ConstBuilder(type_2776);
  ::Reflex::Type type_19469 = ::Reflex::ReferenceBuilder(type_2776c);
  ::Reflex::Type type_2476c = ::Reflex::ConstBuilder(type_2476);
  ::Reflex::Type type_7838 = ::Reflex::ReferenceBuilder(type_2476c);
  ::Reflex::Type type_3397c = ::Reflex::ConstBuilder(type_3397);
  ::Reflex::Type type_19760 = ::Reflex::ReferenceBuilder(type_3397c);
  ::Reflex::Type type_2872c = ::Reflex::ConstBuilder(type_2872);
  ::Reflex::Type type_7461 = ::Reflex::ReferenceBuilder(type_2872c);
  ::Reflex::Type type_2023 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_203);
  ::Reflex::Type type_19761 = ::Reflex::ReferenceBuilder(type_612);
  ::Reflex::Type type_612c = ::Reflex::ConstBuilder(type_612);
  ::Reflex::Type type_19762 = ::Reflex::ReferenceBuilder(type_612c);
  ::Reflex::Type type_1249c = ::Reflex::ConstBuilder(type_1249);
  ::Reflex::Type type_10234 = ::Reflex::PointerBuilder(type_1249c);
  ::Reflex::Type type_10166 = ::Reflex::PointerBuilder(type_1249);
  ::Reflex::Type type_19780 = ::Reflex::PointerBuilder(type_1414);
  ::Reflex::Type type_19429 = ::Reflex::PointerBuilder(type_303);
  ::Reflex::Type type_19794 = ::Reflex::PointerBuilder(type_654);
  ::Reflex::Type type_19781 = ::Reflex::FunctionTypeBuilder(type_19429, type_19794);
  ::Reflex::Type type_4738 = ::Reflex::PointerBuilder(type_19781);
  ::Reflex::Type type_654c = ::Reflex::ConstBuilder(type_654);
  ::Reflex::Type type_19792 = ::Reflex::ReferenceBuilder(type_654c);
  ::Reflex::Type type_19793 = ::Reflex::ReferenceBuilder(type_654);
  ::Reflex::Type type_19801 = ::Reflex::ReferenceBuilder(type_664);
  ::Reflex::Type type_664c = ::Reflex::ConstBuilder(type_664);
  ::Reflex::Type type_19802 = ::Reflex::ReferenceBuilder(type_664c);
  ::Reflex::Type type_19803 = ::Reflex::ReferenceBuilder(type_665);
  ::Reflex::Type type_665c = ::Reflex::ConstBuilder(type_665);
  ::Reflex::Type type_19804 = ::Reflex::ReferenceBuilder(type_665c);
  ::Reflex::Type type_19805 = ::Reflex::ReferenceBuilder(type_666);
  ::Reflex::Type type_666c = ::Reflex::ConstBuilder(type_666);
  ::Reflex::Type type_19806 = ::Reflex::ReferenceBuilder(type_666c);
  ::Reflex::Type type_19807 = ::Reflex::ReferenceBuilder(type_674);
  ::Reflex::Type type_674c = ::Reflex::ConstBuilder(type_674);
  ::Reflex::Type type_19808 = ::Reflex::ReferenceBuilder(type_674c);
  ::Reflex::Type type_19828 = ::Reflex::ReferenceBuilder(type_709);
  ::Reflex::Type type_709c = ::Reflex::ConstBuilder(type_709);
  ::Reflex::Type type_19829 = ::Reflex::ReferenceBuilder(type_709c);
  ::Reflex::Type type_19831 = ::Reflex::PointerBuilder(type_27755);
  ::Reflex::Type type_19832 = ::Reflex::ReferenceBuilder(type_732);
  ::Reflex::Type type_732c = ::Reflex::ConstBuilder(type_732);
  ::Reflex::Type type_19833 = ::Reflex::ReferenceBuilder(type_732c);
  ::Reflex::Type type_19834 = ::Reflex::PointerBuilder(type_1044);
  ::Reflex::Type type_19839 = ::Reflex::ReferenceBuilder(type_750);
  ::Reflex::Type type_750c = ::Reflex::ConstBuilder(type_750);
  ::Reflex::Type type_19840 = ::Reflex::ReferenceBuilder(type_750c);
  ::Reflex::Type type_19841 = ::Reflex::PointerBuilder(type_732);
  ::Reflex::Type type_19842 = ::Reflex::ReferenceBuilder(type_19841);
  ::Reflex::Type type_19846 = ::Reflex::ReferenceBuilder(type_777);
  ::Reflex::Type type_777c = ::Reflex::ConstBuilder(type_777);
  ::Reflex::Type type_19847 = ::Reflex::ReferenceBuilder(type_777c);
  ::Reflex::Type type_1979c = ::Reflex::ConstBuilder(type_1979);
  ::Reflex::Type type_19848 = ::Reflex::ReferenceBuilder(type_1979c);
  ::Reflex::Type type_19849 = ::Reflex::PointerBuilder(type_4085);
  ::Reflex::Type type_19850 = ::Reflex::ReferenceBuilder(type_788);
  ::Reflex::Type type_788c = ::Reflex::ConstBuilder(type_788);
  ::Reflex::Type type_19851 = ::Reflex::ReferenceBuilder(type_788c);
  ::Reflex::Type type_4206c = ::Reflex::ConstBuilder(type_4206);
  ::Reflex::Type type_17505 = ::Reflex::ReferenceBuilder(type_4206c);
  ::Reflex::Type type_19852 = ::Reflex::PointerBuilder(type_1730c);
  ::Reflex::Type type_142c = ::Reflex::ConstBuilder(type_142);
  ::Reflex::Type type_12039 = ::Reflex::ReferenceBuilder(type_142c);
  ::Reflex::Type type_26c = ::Reflex::ConstBuilder(type_26);
  ::Reflex::Type type_10901 = ::Reflex::ReferenceBuilder(type_26c);
  ::Reflex::Type type_2603c = ::Reflex::ConstBuilder(type_2603);
  ::Reflex::Type type_10968 = ::Reflex::ReferenceBuilder(type_2603c);
  ::Reflex::Type type_3015c = ::Reflex::ConstBuilder(type_3015);
  ::Reflex::Type type_12439 = ::Reflex::ReferenceBuilder(type_3015c);
  ::Reflex::Type type_5c = ::Reflex::ConstBuilder(type_5);
  ::Reflex::Type type_19853 = ::Reflex::PointerBuilder(type_5c);
  ::Reflex::Type type_2375c = ::Reflex::ConstBuilder(type_2375);
  ::Reflex::Type type_7460 = ::Reflex::ReferenceBuilder(type_2375c);
  ::Reflex::Type type_843c = ::Reflex::ConstBuilder(type_843);
  ::Reflex::Type type_4284 = ::Reflex::PointerBuilder(type_843c);
  ::Reflex::Type type_19854 = ::Reflex::PointerBuilder(type_3307);
  ::Reflex::Type type_19855 = ::Reflex::ReferenceBuilder(type_790);
  ::Reflex::Type type_790c = ::Reflex::ConstBuilder(type_790);
  ::Reflex::Type type_19856 = ::Reflex::ReferenceBuilder(type_790c);
  ::Reflex::Type type_1822c = ::Reflex::ConstBuilder(type_1822);
  ::Reflex::Type type_19857 = ::Reflex::ReferenceBuilder(type_1822c);
  ::Reflex::Type type_19858 = ::Reflex::ReferenceBuilder(type_810);
  ::Reflex::Type type_810c = ::Reflex::ConstBuilder(type_810);
  ::Reflex::Type type_19859 = ::Reflex::ReferenceBuilder(type_810c);
  ::Reflex::Type type_19861 = ::Reflex::PointerBuilder(type_5990);
  ::Reflex::Type type_19860 = ::Reflex::ReferenceBuilder(type_19861);
  ::Reflex::Type type_19862 = ::Reflex::PointerBuilder(type_6012);
  ::Reflex::Type type_19907 = ::Reflex::ReferenceBuilder(type_897);
  ::Reflex::Type type_897c = ::Reflex::ConstBuilder(type_897);
  ::Reflex::Type type_19908 = ::Reflex::ReferenceBuilder(type_897c);
  ::Reflex::Type type_12638 = ::Reflex::ReferenceBuilder(type_3167);
  ::Reflex::Type type_3166c = ::Reflex::ConstBuilder(type_3166);
  ::Reflex::Type type_19909 = ::Reflex::ReferenceBuilder(type_3166c);
  ::Reflex::Type type_19910 = ::Reflex::ReferenceBuilder(type_3166);
  ::Reflex::Type type_19913 = ::Reflex::ReferenceBuilder(type_934);
  ::Reflex::Type type_934c = ::Reflex::ConstBuilder(type_934);
  ::Reflex::Type type_19914 = ::Reflex::ReferenceBuilder(type_934c);
  ::Reflex::Type type_19921 = ::Reflex::ArrayBuilder(type_3236, 3);
  ::Reflex::Type type_19922 = ::Reflex::ArrayBuilder(type_502, 2);
  ::Reflex::Type type_19923 = ::Reflex::ReferenceBuilder(type_995);
  ::Reflex::Type type_995c = ::Reflex::ConstBuilder(type_995);
  ::Reflex::Type type_19924 = ::Reflex::ReferenceBuilder(type_995c);
  ::Reflex::Type type_19925 = ::Reflex::PointerBuilder(type_3236c);
  ::Reflex::Type type_502c = ::Reflex::ConstBuilder(type_502);
  ::Reflex::Type type_11902 = ::Reflex::PointerBuilder(type_502c);
  ::Reflex::Type type_5148c = ::Reflex::ConstBuilder(type_5148);
  ::Reflex::Type type_19932 = ::Reflex::ReferenceBuilder(type_5148c);
  ::Reflex::Type type_1006c = ::Reflex::ConstBuilder(type_1006);
  ::Reflex::Type type_7854 = ::Reflex::ReferenceBuilder(type_1006c);
  ::Reflex::Type type_8738 = ::Reflex::PointerBuilder(type_1006);
  ::Reflex::Type type_19933 = ::Reflex::ReferenceBuilder(type_1006);
  ::Reflex::Type type_19935 = ::Reflex::ReferenceBuilder(type_1044);
  ::Reflex::Type type_1044c = ::Reflex::ConstBuilder(type_1044);
  ::Reflex::Type type_19936 = ::Reflex::ReferenceBuilder(type_1044c);
  ::Reflex::Type type_19937 = ::Reflex::ReferenceBuilder(type_1607);
  ::Reflex::Type type_19938 = ::Reflex::ReferenceBuilder(type_1606);
  ::Reflex::Type type_19939 = ::Reflex::PointerBuilder(type_2469);
  ::Reflex::Type type_19940 = ::Reflex::ReferenceBuilder(type_1608);
  ::Reflex::Type type_19941 = ::Reflex::PointerBuilder(type_2811);
  ::Reflex::Type type_19795 = ::Reflex::ReferenceBuilder(type_19429);
  ::Reflex::Type type_19942 = ::Reflex::ReferenceBuilder(type_19941);
  ::Reflex::Type type_19948 = ::Reflex::ReferenceBuilder(type_1049);
  ::Reflex::Type type_1049c = ::Reflex::ConstBuilder(type_1049);
  ::Reflex::Type type_19949 = ::Reflex::ReferenceBuilder(type_1049c);
  ::Reflex::Type type_27781 = ::Reflex::PointerBuilder(type_5193);
  ::Reflex::Type type_19950 = ::Reflex::ReferenceBuilder(type_27781);
  ::Reflex::Type type_19951 = ::Reflex::ReferenceBuilder(type_5193);
  ::Reflex::Type type_5193c = ::Reflex::ConstBuilder(type_5193);
  ::Reflex::Type type_19952 = ::Reflex::ReferenceBuilder(type_5193c);
  ::Reflex::Type type_19995 = ::Reflex::PointerBuilder(type_612);
  ::Reflex::Type type_19996 = ::Reflex::ReferenceBuilder(type_1082);
  ::Reflex::Type type_1082c = ::Reflex::ConstBuilder(type_1082);
  ::Reflex::Type type_19997 = ::Reflex::ReferenceBuilder(type_1082c);
  ::Reflex::Type type_3224c = ::Reflex::ConstBuilder(type_3224);
  ::Reflex::Type type_7844 = ::Reflex::ReferenceBuilder(type_3224c);
  ::Reflex::Type type_19998 = ::Reflex::PointerBuilder(type_303c);
  ::Reflex::Type type_19999 = ::Reflex::ReferenceBuilder(type_1083);
  ::Reflex::Type type_1083c = ::Reflex::ConstBuilder(type_1083);
  ::Reflex::Type type_20000 = ::Reflex::ReferenceBuilder(type_1083c);
  ::Reflex::Type type_11360 = ::Reflex::PointerBuilder(type_120);
  ::Reflex::Type type_20007 = ::Reflex::ReferenceBuilder(type_1141);
  ::Reflex::Type type_1141c = ::Reflex::ConstBuilder(type_1141);
  ::Reflex::Type type_20008 = ::Reflex::ReferenceBuilder(type_1141c);
  ::Reflex::Type type_20009 = ::Reflex::PointerBuilder(type_1141);
  ::Reflex::Type type_19969 = ::Reflex::ReferenceBuilder(type_2061);
  ::Reflex::Type type_20021 = ::Reflex::ReferenceBuilder(type_1187);
  ::Reflex::Type type_1187c = ::Reflex::ConstBuilder(type_1187);
  ::Reflex::Type type_20022 = ::Reflex::ReferenceBuilder(type_1187c);
  ::Reflex::Type type_20023 = ::Reflex::PointerBuilder(type_394);
  ::Reflex::Type type_5663 = ::Reflex::ReferenceBuilder(type_4682);
  ::Reflex::Type type_20025 = ::Reflex::ReferenceBuilder(type_1192);
  ::Reflex::Type type_1192c = ::Reflex::ConstBuilder(type_1192);
  ::Reflex::Type type_20026 = ::Reflex::ReferenceBuilder(type_1192c);
  ::Reflex::Type type_19539 = ::Reflex::PointerBuilder(type_1730);
  ::Reflex::Type type_20027 = ::Reflex::ReferenceBuilder(type_19539);
  ::Reflex::Type type_19467 = ::Reflex::ReferenceBuilder(type_1221);
  ::Reflex::Type type_1221c = ::Reflex::ConstBuilder(type_1221);
  ::Reflex::Type type_20038 = ::Reflex::ReferenceBuilder(type_1221c);
  ::Reflex::Type type_19688c = ::Reflex::ConstBuilder(type_19688);
  ::Reflex::Type type_20039 = ::Reflex::ReferenceBuilder(type_19688c);
  ::Reflex::Type type_20957 = ::Reflex::PointerBuilder(type_934);
  ::Reflex::Type type_20040 = ::Reflex::ReferenceBuilder(type_20957);
  ::Reflex::Type type_2987c = ::Reflex::ConstBuilder(type_2987);
  ::Reflex::Type type_20041 = ::Reflex::ReferenceBuilder(type_2987c);
  ::Reflex::Type type_20042 = ::Reflex::ReferenceBuilder(type_1593);
  ::Reflex::Type type_20043 = ::Reflex::ReferenceBuilder(type_1222);
  ::Reflex::Type type_1222c = ::Reflex::ConstBuilder(type_1222);
  ::Reflex::Type type_20044 = ::Reflex::ReferenceBuilder(type_1222c);
  ::Reflex::Type type_20045 = ::Reflex::PointerBuilder(type_1590);
  ::Reflex::Type type_20046 = ::Reflex::PointerBuilder(type_709);
  ::Reflex::Type type_20047 = ::Reflex::ReferenceBuilder(type_1223);
  ::Reflex::Type type_1223c = ::Reflex::ConstBuilder(type_1223);
  ::Reflex::Type type_20048 = ::Reflex::ReferenceBuilder(type_1223c);
  ::Reflex::Type type_20049 = ::Reflex::PointerBuilder(type_1223);
  ::Reflex::Type type_2896 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("IntegerProperty"), type_1893);
  ::Reflex::Type type_19445 = ::Reflex::PointerBuilder(type_1221);
  ::Reflex::Type type_20028 = ::Reflex::PointerBuilder(type_777);
  ::Reflex::Type type_20050 = ::Reflex::PointerBuilder(type_2197);
  ::Reflex::Type type_20051 = ::Reflex::PointerBuilder(type_788);
  ::Reflex::Type type_20052 = ::Reflex::PointerBuilder(type_1062);
  ::Reflex::Type type_20053 = ::Reflex::PointerBuilder(type_1222);
  ::Reflex::Type type_586 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("BooleanProperty"), type_585);
  ::Reflex::Type type_1234c = ::Reflex::ConstBuilder(type_1234);
  ::Reflex::Type type_20054 = ::Reflex::ReferenceBuilder(type_1234c);
  ::Reflex::Type type_19990 = ::Reflex::PointerBuilder(type_2383);
  ::Reflex::Type type_20056 = ::Reflex::ReferenceBuilder(type_1249);
  ::Reflex::Type type_7852 = ::Reflex::ReferenceBuilder(type_1249c);
  ::Reflex::Type type_20057 = ::Reflex::PointerBuilder(type_612c);
  ::Reflex::Type type_20098 = ::Reflex::ReferenceBuilder(type_1334);
  ::Reflex::Type type_1334c = ::Reflex::ConstBuilder(type_1334);
  ::Reflex::Type type_20099 = ::Reflex::ReferenceBuilder(type_1334c);
  ::Reflex::Type type_20107 = ::Reflex::ReferenceBuilder(type_1365);
  ::Reflex::Type type_20108 = ::Reflex::ReferenceBuilder(type_1596);
  ::Reflex::Type type_20109 = ::Reflex::ReferenceBuilder(type_1594);
  ::Reflex::Type type_20110 = ::Reflex::ReferenceBuilder(type_1385);
  ::Reflex::Type type_1385c = ::Reflex::ConstBuilder(type_1385);
  ::Reflex::Type type_20111 = ::Reflex::ReferenceBuilder(type_1385c);
  ::Reflex::Type type_20115 = ::Reflex::ReferenceBuilder(type_1414);
  ::Reflex::Type type_1414c = ::Reflex::ConstBuilder(type_1414);
  ::Reflex::Type type_20116 = ::Reflex::ReferenceBuilder(type_1414c);
  ::Reflex::Type type_1759c = ::Reflex::ConstBuilder(type_1759);
  ::Reflex::Type type_20117 = ::Reflex::ReferenceBuilder(type_1759c);
  ::Reflex::Type type_20139 = ::Reflex::ReferenceBuilder(type_1450);
  ::Reflex::Type type_1450c = ::Reflex::ConstBuilder(type_1450);
  ::Reflex::Type type_20140 = ::Reflex::ReferenceBuilder(type_1450c);
  ::Reflex::Type type_7841 = ::Reflex::ReferenceBuilder(type_502c);
  ::Reflex::Type type_20141 = ::Reflex::ReferenceBuilder(type_1451);
  ::Reflex::Type type_1451c = ::Reflex::ConstBuilder(type_1451);
  ::Reflex::Type type_20142 = ::Reflex::ReferenceBuilder(type_1451c);
  ::Reflex::Type type_20143 = ::Reflex::ReferenceBuilder(type_1452);
  ::Reflex::Type type_1452c = ::Reflex::ConstBuilder(type_1452);
  ::Reflex::Type type_20144 = ::Reflex::ReferenceBuilder(type_1452c);
  ::Reflex::Type type_203c = ::Reflex::ConstBuilder(type_203);
  ::Reflex::Type type_11972 = ::Reflex::ReferenceBuilder(type_203c);
  ::Reflex::Type type_20145 = ::Reflex::ReferenceBuilder(type_1453);
  ::Reflex::Type type_1453c = ::Reflex::ConstBuilder(type_1453);
  ::Reflex::Type type_20146 = ::Reflex::ReferenceBuilder(type_1453c);
  ::Reflex::Type type_20930 = ::Reflex::ReferenceBuilder(type_1544);
  ::Reflex::Type type_1544c = ::Reflex::ConstBuilder(type_1544);
  ::Reflex::Type type_20931 = ::Reflex::ReferenceBuilder(type_1544c);
  ::Reflex::Type type_20932 = ::Reflex::PointerBuilder(type_2842);
  ::Reflex::Type type_20933 = ::Reflex::PointerBuilder(type_2822);
  ::Reflex::Type type_20934 = ::Reflex::PointerBuilder(type_2855);
  ::Reflex::Type type_20935 = ::Reflex::ReferenceBuilder(type_20932);
  ::Reflex::Type type_20936 = ::Reflex::ReferenceBuilder(type_20933);
  ::Reflex::Type type_20937 = ::Reflex::ReferenceBuilder(type_20934);
  ::Reflex::Type type_20938 = ::Reflex::PointerBuilder(type_530);
  ::Reflex::Type type_20939 = ::Reflex::ReferenceBuilder(type_20938);
  ::Reflex::Type type_20940 = ::Reflex::PointerBuilder(type_671);
  ::Reflex::Type type_20941 = ::Reflex::PointerBuilder(type_1885);
  ::Reflex::Type type_20942 = ::Reflex::ReferenceBuilder(type_1086);
  ::Reflex::Type type_20943 = ::Reflex::PointerBuilder(type_1805);
  ::Reflex::Type type_20944 = ::Reflex::ReferenceBuilder(type_20943);
  ::Reflex::Type type_20945 = ::Reflex::ReferenceBuilder(type_1590);
  ::Reflex::Type type_1590c = ::Reflex::ConstBuilder(type_1590);
  ::Reflex::Type type_20946 = ::Reflex::ReferenceBuilder(type_1590c);
  ::Reflex::Type type_20947 = ::Reflex::PointerBuilder(type_2776);
  ::Reflex::Type type_20948 = ::Reflex::PointerBuilder(type_549);
  ::Reflex::Type type_1591c = ::Reflex::ConstBuilder(type_1591);
  ::Reflex::Type type_20949 = ::Reflex::ReferenceBuilder(type_1591c);
  ::Reflex::Type type_20950 = ::Reflex::ReferenceBuilder(type_20948);
  ::Reflex::Type type_20951 = ::Reflex::ReferenceBuilder(type_1591);
  ::Reflex::Type type_20954 = ::Reflex::ReferenceBuilder(type_1778);
  ::Reflex::Type type_1778c = ::Reflex::ConstBuilder(type_1778);
  ::Reflex::Type type_24127 = ::Reflex::ReferenceBuilder(type_1778c);
  ::Reflex::Type type_24128 = ::Reflex::PointerBuilder(type_553);
  ::Reflex::Type type_24129 = ::Reflex::ReferenceBuilder(type_3170);
  ::Reflex::Type type_20952 = ::Reflex::PointerBuilder(type_1778);
  ::Reflex::Type type_1592c = ::Reflex::ConstBuilder(type_1592);
  ::Reflex::Type type_20953 = ::Reflex::ReferenceBuilder(type_1592c);
  ::Reflex::Type type_20955 = ::Reflex::ReferenceBuilder(type_20952);
  ::Reflex::Type type_20956 = ::Reflex::ReferenceBuilder(type_1592);
  ::Reflex::Type type_1593c = ::Reflex::ConstBuilder(type_1593);
  ::Reflex::Type type_20958 = ::Reflex::ReferenceBuilder(type_1593c);
  ::Reflex::Type type_1594c = ::Reflex::ConstBuilder(type_1594);
  ::Reflex::Type type_20959 = ::Reflex::ReferenceBuilder(type_1594c);
  ::Reflex::Type type_20960 = ::Reflex::ReferenceBuilder(type_20053);
  ::Reflex::Type type_20962 = ::Reflex::ReferenceBuilder(type_1636);
  ::Reflex::Type type_1636c = ::Reflex::ConstBuilder(type_1636);
  ::Reflex::Type type_21019 = ::Reflex::ReferenceBuilder(type_1636c);
  ::Reflex::Type type_796c = ::Reflex::ConstBuilder(type_796);
  ::Reflex::Type type_21020 = ::Reflex::ReferenceBuilder(type_796c);
  ::Reflex::Type type_28132 = ::Reflex::PointerBuilder(type_796c);
  ::Reflex::Type type_21021 = ::Reflex::ReferenceBuilder(type_28132);
  ::Reflex::Type type_19915 = ::Reflex::PointerBuilder(type_1636);
  ::Reflex::Type type_1595c = ::Reflex::ConstBuilder(type_1595);
  ::Reflex::Type type_20961 = ::Reflex::ReferenceBuilder(type_1595c);
  ::Reflex::Type type_20963 = ::Reflex::ReferenceBuilder(type_19915);
  ::Reflex::Type type_20964 = ::Reflex::ReferenceBuilder(type_1595);
  ::Reflex::Type type_1596c = ::Reflex::ConstBuilder(type_1596);
  ::Reflex::Type type_20965 = ::Reflex::ReferenceBuilder(type_1596c);
  ::Reflex::Type type_20966 = ::Reflex::ReferenceBuilder(type_19445);
  ::Reflex::Type type_1597c = ::Reflex::ConstBuilder(type_1597);
  ::Reflex::Type type_20967 = ::Reflex::ReferenceBuilder(type_1597c);
  ::Reflex::Type type_20968 = ::Reflex::ReferenceBuilder(type_20028);
  ::Reflex::Type type_20969 = ::Reflex::ReferenceBuilder(type_1597);
  ::Reflex::Type type_1598c = ::Reflex::ConstBuilder(type_1598);
  ::Reflex::Type type_20970 = ::Reflex::ReferenceBuilder(type_1598c);
  ::Reflex::Type type_20971 = ::Reflex::ReferenceBuilder(type_20051);
  ::Reflex::Type type_20972 = ::Reflex::ReferenceBuilder(type_1598);
  ::Reflex::Type type_20975 = ::Reflex::ReferenceBuilder(type_2156);
  ::Reflex::Type type_2156c = ::Reflex::ConstBuilder(type_2156);
  ::Reflex::Type type_24215 = ::Reflex::ReferenceBuilder(type_2156c);
  ::Reflex::Type type_3179c = ::Reflex::ConstBuilder(type_3179);
  ::Reflex::Type type_24216 = ::Reflex::ReferenceBuilder(type_3179c);
  ::Reflex::Type type_20973 = ::Reflex::PointerBuilder(type_2156);
  ::Reflex::Type type_1599c = ::Reflex::ConstBuilder(type_1599);
  ::Reflex::Type type_20974 = ::Reflex::ReferenceBuilder(type_1599c);
  ::Reflex::Type type_20976 = ::Reflex::ReferenceBuilder(type_20973);
  ::Reflex::Type type_20977 = ::Reflex::ReferenceBuilder(type_1599);
  ::Reflex::Type type_20979 = ::Reflex::ReferenceBuilder(type_2197);
  ::Reflex::Type type_2197c = ::Reflex::ConstBuilder(type_2197);
  ::Reflex::Type type_24274 = ::Reflex::ReferenceBuilder(type_2197c);
  ::Reflex::Type type_24276 = ::Reflex::PointerBuilder(type_813);
  ::Reflex::Type type_24275 = ::Reflex::ReferenceBuilder(type_24276);
  ::Reflex::Type type_24277 = ::Reflex::PointerBuilder(type_7395);
  ::Reflex::Type type_1600c = ::Reflex::ConstBuilder(type_1600);
  ::Reflex::Type type_20978 = ::Reflex::ReferenceBuilder(type_1600c);
  ::Reflex::Type type_20980 = ::Reflex::ReferenceBuilder(type_20050);
  ::Reflex::Type type_20981 = ::Reflex::ReferenceBuilder(type_1600);
  ::Reflex::Type type_20982 = ::Reflex::PointerBuilder(type_610);
  ::Reflex::Type type_1601c = ::Reflex::ConstBuilder(type_1601);
  ::Reflex::Type type_20983 = ::Reflex::ReferenceBuilder(type_1601c);
  ::Reflex::Type type_20984 = ::Reflex::ReferenceBuilder(type_20982);
  ::Reflex::Type type_20985 = ::Reflex::ReferenceBuilder(type_1601);
  ::Reflex::Type type_20988 = ::Reflex::ReferenceBuilder(type_1710);
  ::Reflex::Type type_1710c = ::Reflex::ConstBuilder(type_1710);
  ::Reflex::Type type_21097 = ::Reflex::ReferenceBuilder(type_1710c);
  ::Reflex::Type type_21098 = ::Reflex::PointerBuilder(type_897);
  ::Reflex::Type type_8014c = ::Reflex::ConstBuilder(type_8014);
  ::Reflex::Type type_21099 = ::Reflex::ReferenceBuilder(type_8014c);
  ::Reflex::Type type_27643 = ::Reflex::PointerBuilder(type_2739);
  ::Reflex::Type type_21100 = ::Reflex::ReferenceBuilder(type_27643);
  ::Reflex::Type type_20986 = ::Reflex::PointerBuilder(type_1710);
  ::Reflex::Type type_1602c = ::Reflex::ConstBuilder(type_1602);
  ::Reflex::Type type_20987 = ::Reflex::ReferenceBuilder(type_1602c);
  ::Reflex::Type type_20989 = ::Reflex::ReferenceBuilder(type_20986);
  ::Reflex::Type type_20990 = ::Reflex::ReferenceBuilder(type_1602);
  ::Reflex::Type type_20993 = ::Reflex::ReferenceBuilder(type_2374);
  ::Reflex::Type type_2374c = ::Reflex::ConstBuilder(type_2374);
  ::Reflex::Type type_24310 = ::Reflex::ReferenceBuilder(type_2374c);
  ::Reflex::Type type_20991 = ::Reflex::PointerBuilder(type_2374);
  ::Reflex::Type type_1603c = ::Reflex::ConstBuilder(type_1603);
  ::Reflex::Type type_20992 = ::Reflex::ReferenceBuilder(type_1603c);
  ::Reflex::Type type_20994 = ::Reflex::ReferenceBuilder(type_20991);
  ::Reflex::Type type_20995 = ::Reflex::ReferenceBuilder(type_1603);
  ::Reflex::Type type_20996 = ::Reflex::PointerBuilder(type_810);
  ::Reflex::Type type_1604c = ::Reflex::ConstBuilder(type_1604);
  ::Reflex::Type type_20997 = ::Reflex::ReferenceBuilder(type_1604c);
  ::Reflex::Type type_20998 = ::Reflex::ReferenceBuilder(type_20996);
  ::Reflex::Type type_20999 = ::Reflex::ReferenceBuilder(type_1604);
  ::Reflex::Type type_21002 = ::Reflex::ReferenceBuilder(type_2722);
  ::Reflex::Type type_2722c = ::Reflex::ConstBuilder(type_2722);
  ::Reflex::Type type_24380 = ::Reflex::ReferenceBuilder(type_2722c);
  ::Reflex::Type type_24381 = ::Reflex::PointerBuilder(type_682);
  ::Reflex::Type type_24382 = ::Reflex::PointerBuilder(type_2079);
  ::Reflex::Type type_24383 = ::Reflex::PointerBuilder(type_86);
  ::Reflex::Type type_24384 = ::Reflex::PointerBuilder(type_2582);
  ::Reflex::Type type_24385 = ::Reflex::PointerBuilder(type_10);
  ::Reflex::Type type_24386 = ::Reflex::PointerBuilder(type_1275);
  ::Reflex::Type type_24387 = ::Reflex::PointerBuilder(type_5);
  ::Reflex::Type type_24388 = ::Reflex::ReferenceBuilder(type_24382);
  ::Reflex::Type type_24389 = ::Reflex::ReferenceBuilder(type_24383);
  ::Reflex::Type type_24390 = ::Reflex::ReferenceBuilder(type_24384);
  ::Reflex::Type type_24391 = ::Reflex::ReferenceBuilder(type_24385);
  ::Reflex::Type type_24392 = ::Reflex::ReferenceBuilder(type_24386);
  ::Reflex::Type type_21000 = ::Reflex::PointerBuilder(type_2722);
  ::Reflex::Type type_1605c = ::Reflex::ConstBuilder(type_1605);
  ::Reflex::Type type_21001 = ::Reflex::ReferenceBuilder(type_1605c);
  ::Reflex::Type type_21003 = ::Reflex::ReferenceBuilder(type_21000);
  ::Reflex::Type type_21004 = ::Reflex::ReferenceBuilder(type_1605);
  ::Reflex::Type type_1606c = ::Reflex::ConstBuilder(type_1606);
  ::Reflex::Type type_21005 = ::Reflex::ReferenceBuilder(type_1606c);
  ::Reflex::Type type_1607c = ::Reflex::ConstBuilder(type_1607);
  ::Reflex::Type type_21006 = ::Reflex::ReferenceBuilder(type_1607c);
  ::Reflex::Type type_21007 = ::Reflex::ReferenceBuilder(type_19780);
  ::Reflex::Type type_1609c = ::Reflex::ConstBuilder(type_1609);
  ::Reflex::Type type_21008 = ::Reflex::ReferenceBuilder(type_1609c);
  ::Reflex::Type type_21010 = ::Reflex::ReferenceBuilder(type_19990);
  ::Reflex::Type type_21011 = ::Reflex::ReferenceBuilder(type_1609);
  ::Reflex::Type type_21017 = ::Reflex::ReferenceBuilder(type_1617);
  ::Reflex::Type type_1617c = ::Reflex::ConstBuilder(type_1617);
  ::Reflex::Type type_21018 = ::Reflex::ReferenceBuilder(type_1617c);
  ::Reflex::Type type_21088 = ::Reflex::ReferenceBuilder(type_1695);
  ::Reflex::Type type_1695c = ::Reflex::ConstBuilder(type_1695);
  ::Reflex::Type type_21089 = ::Reflex::ReferenceBuilder(type_1695c);
  ::Reflex::Type type_19281 = ::Reflex::PointerBuilder(type_2375);
  ::Reflex::Type type_1498 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("longlong"), type_189);
  ::Reflex::Type type_21090 = ::Reflex::ReferenceBuilder(type_19281);
  ::Reflex::Type type_21091 = ::Reflex::ReferenceBuilder(type_6517);
  ::Reflex::Type type_19286 = ::Reflex::PointerBuilder(type_2375c);
  ::Reflex::Type type_72c = ::Reflex::ConstBuilder(type_72);
  ::Reflex::Type type_7458 = ::Reflex::ReferenceBuilder(type_72c);
  ::Reflex::Type type_7148 = ::Reflex::ReferenceBuilder(type_1216);
  ::Reflex::Type type_21092 = ::Reflex::ReferenceBuilder(type_1699);
  ::Reflex::Type type_1699c = ::Reflex::ConstBuilder(type_1699);
  ::Reflex::Type type_21093 = ::Reflex::ReferenceBuilder(type_1699c);
  ::Reflex::Type type_11168 = ::Reflex::ReferenceBuilder(type_10115);
  ::Reflex::Type type_1726c = ::Reflex::ConstBuilder(type_1726);
  ::Reflex::Type type_21094 = ::Reflex::PointerBuilder(type_1726c);
  ::Reflex::Type type_21095 = ::Reflex::ReferenceBuilder(type_3171);
  ::Reflex::Type type_21096 = ::Reflex::PointerBuilder(type_674);
  ::Reflex::Type type_21101 = ::Reflex::ReferenceBuilder(type_1723);
  ::Reflex::Type type_1723c = ::Reflex::ConstBuilder(type_1723);
  ::Reflex::Type type_21102 = ::Reflex::ReferenceBuilder(type_1723c);
  ::Reflex::Type type_21103 = ::Reflex::PointerBuilder(type_4508);
  ::Reflex::Type type_21104 = ::Reflex::PointerBuilder(type_4509);
  ::Reflex::Type type_24117 = ::Reflex::ReferenceBuilder(type_1726);
  ::Reflex::Type type_24118 = ::Reflex::ReferenceBuilder(type_1726c);
  ::Reflex::Type type_24125 = ::Reflex::ReferenceBuilder(type_1763);
  ::Reflex::Type type_1763c = ::Reflex::ConstBuilder(type_1763);
  ::Reflex::Type type_24126 = ::Reflex::ReferenceBuilder(type_1763c);
  ::Reflex::Type type_24130 = ::Reflex::ReferenceBuilder(type_1791);
  ::Reflex::Type type_1791c = ::Reflex::ConstBuilder(type_1791);
  ::Reflex::Type type_24131 = ::Reflex::ReferenceBuilder(type_1791c);
  ::Reflex::Type type_24135 = ::Reflex::ReferenceBuilder(type_1829);
  ::Reflex::Type type_1829c = ::Reflex::ConstBuilder(type_1829);
  ::Reflex::Type type_24136 = ::Reflex::ReferenceBuilder(type_1829c);
  ::Reflex::Type type_24137 = ::Reflex::ReferenceBuilder(type_1830);
  ::Reflex::Type type_1830c = ::Reflex::ConstBuilder(type_1830);
  ::Reflex::Type type_24138 = ::Reflex::ReferenceBuilder(type_1830c);
  ::Reflex::Type type_24139 = ::Reflex::ReferenceBuilder(type_1841);
  ::Reflex::Type type_1841c = ::Reflex::ConstBuilder(type_1841);
  ::Reflex::Type type_24140 = ::Reflex::ReferenceBuilder(type_1841c);
  ::Reflex::Type type_3169c = ::Reflex::ConstBuilder(type_3169);
  ::Reflex::Type type_24141 = ::Reflex::PointerBuilder(type_3169c);
  ::Reflex::Type type_24142 = ::Reflex::ReferenceBuilder(type_1857);
  ::Reflex::Type type_1857c = ::Reflex::ConstBuilder(type_1857);
  ::Reflex::Type type_24143 = ::Reflex::ReferenceBuilder(type_1857c);
  ::Reflex::Type type_24144 = ::Reflex::ReferenceBuilder(type_3199);
  ::Reflex::Type type_3199c = ::Reflex::ConstBuilder(type_3199);
  ::Reflex::Type type_24145 = ::Reflex::ReferenceBuilder(type_3199c);
  ::Reflex::Type type_158 = ::Reflex::PointerBuilder(type_4274);
  ::Reflex::Type type_1005c = ::Reflex::ConstBuilder(type_1005);
  ::Reflex::Type type_19929 = ::Reflex::PointerBuilder(type_1005c);
  ::Reflex::Type type_12697 = ::Reflex::PointerBuilder(type_1005);
  ::Reflex::Type type_24146 = ::Reflex::PointerBuilder(type_2260);
  ::Reflex::Type type_24147 = ::Reflex::ReferenceBuilder(type_1859);
  ::Reflex::Type type_1859c = ::Reflex::ConstBuilder(type_1859);
  ::Reflex::Type type_24148 = ::Reflex::ReferenceBuilder(type_1859c);
  ::Reflex::Type type_11025 = ::Reflex::PointerBuilder(type_641);
  ::Reflex::Type type_24166 = ::Reflex::ReferenceBuilder(type_1916);
  ::Reflex::Type type_1916c = ::Reflex::ConstBuilder(type_1916);
  ::Reflex::Type type_24165 = ::Reflex::ReferenceBuilder(type_1916c);
  ::Reflex::Type type_24168 = ::Reflex::ReferenceBuilder(type_1917);
  ::Reflex::Type type_1917c = ::Reflex::ConstBuilder(type_1917);
  ::Reflex::Type type_24167 = ::Reflex::ReferenceBuilder(type_1917c);
  ::Reflex::Type type_24169 = ::Reflex::ReferenceBuilder(type_1946);
  ::Reflex::Type type_1946c = ::Reflex::ConstBuilder(type_1946);
  ::Reflex::Type type_24170 = ::Reflex::ReferenceBuilder(type_1946c);
  ::Reflex::Type type_24171 = ::Reflex::ReferenceBuilder(type_1954);
  ::Reflex::Type type_1954c = ::Reflex::ConstBuilder(type_1954);
  ::Reflex::Type type_24172 = ::Reflex::ReferenceBuilder(type_1954c);
  ::Reflex::Type type_24179 = ::Reflex::ReferenceBuilder(type_2054);
  ::Reflex::Type type_2054c = ::Reflex::ConstBuilder(type_2054);
  ::Reflex::Type type_24180 = ::Reflex::ReferenceBuilder(type_2054c);
  ::Reflex::Type type_19632c = ::Reflex::ConstBuilder(type_19632);
  ::Reflex::Type type_3396c = ::Reflex::ConstBuilder(type_3396);
  ::Reflex::Type type_24182 = ::Reflex::PointerBuilder(type_3396c);
  ::Reflex::Type type_21026 = ::Reflex::PointerBuilder(type_1638);
  ::Reflex::Type type_1638c = ::Reflex::ConstBuilder(type_1638);
  ::Reflex::Type type_21022 = ::Reflex::PointerBuilder(type_1638c);
  ::Reflex::Type type_24194 = ::Reflex::ReferenceBuilder(type_2087);
  ::Reflex::Type type_2087c = ::Reflex::ConstBuilder(type_2087);
  ::Reflex::Type type_24195 = ::Reflex::ReferenceBuilder(type_2087c);
  ::Reflex::Type type_24196 = ::Reflex::PointerBuilder(type_541);
  ::Reflex::Type type_24197 = ::Reflex::PointerBuilder(type_2210);
  ::Reflex::Type type_24198 = ::Reflex::ReferenceBuilder(type_3306);
  ::Reflex::Type type_2912c = ::Reflex::ConstBuilder(type_2912);
  ::Reflex::Type type_24199 = ::Reflex::ReferenceBuilder(type_2912c);
  ::Reflex::Type type_24200 = ::Reflex::PointerBuilder(type_1575);
  ::Reflex::Type type_24201 = ::Reflex::ReferenceBuilder(type_3305);
  ::Reflex::Type type_813c = ::Reflex::ConstBuilder(type_813);
  ::Reflex::Type type_19864 = ::Reflex::ReferenceBuilder(type_813c);
  ::Reflex::Type type_24202 = ::Reflex::PointerBuilder(type_928);
  ::Reflex::Type type_24203 = ::Reflex::ReferenceBuilder(type_3304);
  ::Reflex::Type type_24204 = ::Reflex::PointerBuilder(type_2965);
  ::Reflex::Type type_24205 = ::Reflex::ReferenceBuilder(type_2099);
  ::Reflex::Type type_2099c = ::Reflex::ConstBuilder(type_2099);
  ::Reflex::Type type_24206 = ::Reflex::ReferenceBuilder(type_2099c);
  ::Reflex::Type type_2985c = ::Reflex::ConstBuilder(type_2985);
  ::Reflex::Type type_24207 = ::Reflex::ReferenceBuilder(type_2985c);
  ::Reflex::Type type_24293 = ::Reflex::ReferenceBuilder(type_2244);
  ::Reflex::Type type_2244c = ::Reflex::ConstBuilder(type_2244);
  ::Reflex::Type type_24294 = ::Reflex::ReferenceBuilder(type_2244c);
  ::Reflex::Type type_24295 = ::Reflex::PointerBuilder(type_1793);
  ::Reflex::Type type_1793c = ::Reflex::ConstBuilder(type_1793);
  ::Reflex::Type type_24296 = ::Reflex::PointerBuilder(type_1793c);
  ::Reflex::Type type_24297 = ::Reflex::ReferenceBuilder(type_2260);
  ::Reflex::Type type_2260c = ::Reflex::ConstBuilder(type_2260);
  ::Reflex::Type type_24298 = ::Reflex::ReferenceBuilder(type_2260c);
  ::Reflex::Type type_24301 = ::Reflex::ReferenceBuilder(type_2266);
  ::Reflex::Type type_2266c = ::Reflex::ConstBuilder(type_2266);
  ::Reflex::Type type_24302 = ::Reflex::ReferenceBuilder(type_2266c);
  ::Reflex::Type type_24213 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ROOT::Math::XYZPoint"), type_24212);
  ::Reflex::Type type_24213c = ::Reflex::ConstBuilder(type_24213);
  ::Reflex::Type type_24303 = ::Reflex::ReferenceBuilder(type_24213c);
  ::Reflex::Type type_24210 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ROOT::Math::XYZVector"), type_24208);
  ::Reflex::Type type_24304 = ::Reflex::ReferenceBuilder(type_24210);
  ::Reflex::Type type_24308 = ::Reflex::ReferenceBuilder(type_2345);
  ::Reflex::Type type_2345c = ::Reflex::ConstBuilder(type_2345);
  ::Reflex::Type type_24309 = ::Reflex::ReferenceBuilder(type_2345c);
  ::Reflex::Type type_24312 = ::Reflex::ReferenceBuilder(type_2390);
  ::Reflex::Type type_2390c = ::Reflex::ConstBuilder(type_2390);
  ::Reflex::Type type_24313 = ::Reflex::ReferenceBuilder(type_2390c);
  ::Reflex::Type type_24314 = ::Reflex::ReferenceBuilder(type_2469);
  ::Reflex::Type type_2469c = ::Reflex::ConstBuilder(type_2469);
  ::Reflex::Type type_24315 = ::Reflex::ReferenceBuilder(type_2469c);
  ::Reflex::Type type_2811c = ::Reflex::ConstBuilder(type_2811);
  ::Reflex::Type type_24193 = ::Reflex::PointerBuilder(type_2811c);
  ::Reflex::Type type_2510c = ::Reflex::ConstBuilder(type_2510);
  ::Reflex::Type type_7819 = ::Reflex::ReferenceBuilder(type_2510c);
  ::Reflex::Type type_5649 = ::Reflex::ReferenceBuilder(type_2510);
  ::Reflex::Type type_2511c = ::Reflex::ConstBuilder(type_2511);
  ::Reflex::Type type_7820 = ::Reflex::ReferenceBuilder(type_2511c);
  ::Reflex::Type type_5650 = ::Reflex::ReferenceBuilder(type_2511);
  ::Reflex::Type type_2512c = ::Reflex::ConstBuilder(type_2512);
  ::Reflex::Type type_7821 = ::Reflex::ReferenceBuilder(type_2512c);
  ::Reflex::Type type_5651 = ::Reflex::ReferenceBuilder(type_2512);
  ::Reflex::Type type_2513c = ::Reflex::ConstBuilder(type_2513);
  ::Reflex::Type type_7822 = ::Reflex::ReferenceBuilder(type_2513c);
  ::Reflex::Type type_5652 = ::Reflex::ReferenceBuilder(type_2513);
  ::Reflex::Type type_2514c = ::Reflex::ConstBuilder(type_2514);
  ::Reflex::Type type_7823 = ::Reflex::ReferenceBuilder(type_2514c);
  ::Reflex::Type type_5653 = ::Reflex::ReferenceBuilder(type_2514);
  ::Reflex::Type type_2515c = ::Reflex::ConstBuilder(type_2515);
  ::Reflex::Type type_7824 = ::Reflex::ReferenceBuilder(type_2515c);
  ::Reflex::Type type_5654 = ::Reflex::ReferenceBuilder(type_2515);
  ::Reflex::Type type_2516c = ::Reflex::ConstBuilder(type_2516);
  ::Reflex::Type type_7825 = ::Reflex::ReferenceBuilder(type_2516c);
  ::Reflex::Type type_5655 = ::Reflex::ReferenceBuilder(type_2516);
  ::Reflex::Type type_24341 = ::Reflex::ReferenceBuilder(type_2654);
  ::Reflex::Type type_2654c = ::Reflex::ConstBuilder(type_2654);
  ::Reflex::Type type_24342 = ::Reflex::ReferenceBuilder(type_2654c);
  ::Reflex::Type type_24399 = ::Reflex::ReferenceBuilder(type_2739);
  ::Reflex::Type type_2739c = ::Reflex::ConstBuilder(type_2739);
  ::Reflex::Type type_24400 = ::Reflex::ReferenceBuilder(type_2739c);
  ::Reflex::Type type_24401 = ::Reflex::PointerBuilder(type_8014c);
  ::Reflex::Type type_24402 = ::Reflex::PointerBuilder(type_1450c);
  ::Reflex::Type type_24403 = ::Reflex::PointerBuilder(type_1450);
  ::Reflex::Type type_2743c = ::Reflex::ConstBuilder(type_2743);
  ::Reflex::Type type_7826 = ::Reflex::ReferenceBuilder(type_2743c);
  ::Reflex::Type type_5656 = ::Reflex::ReferenceBuilder(type_2743);
  ::Reflex::Type type_24404 = ::Reflex::PointerBuilder(type_1451c);
  ::Reflex::Type type_24405 = ::Reflex::PointerBuilder(type_1451);
  ::Reflex::Type type_2744c = ::Reflex::ConstBuilder(type_2744);
  ::Reflex::Type type_7827 = ::Reflex::ReferenceBuilder(type_2744c);
  ::Reflex::Type type_5657 = ::Reflex::ReferenceBuilder(type_2744);
  ::Reflex::Type type_24406 = ::Reflex::PointerBuilder(type_1452c);
  ::Reflex::Type type_24407 = ::Reflex::PointerBuilder(type_1452);
  ::Reflex::Type type_2745c = ::Reflex::ConstBuilder(type_2745);
  ::Reflex::Type type_7828 = ::Reflex::ReferenceBuilder(type_2745c);
  ::Reflex::Type type_5658 = ::Reflex::ReferenceBuilder(type_2745);
  ::Reflex::Type type_24408 = ::Reflex::PointerBuilder(type_1453c);
  ::Reflex::Type type_24409 = ::Reflex::PointerBuilder(type_1453);
  ::Reflex::Type type_2746c = ::Reflex::ConstBuilder(type_2746);
  ::Reflex::Type type_7829 = ::Reflex::ReferenceBuilder(type_2746c);
  ::Reflex::Type type_5659 = ::Reflex::ReferenceBuilder(type_2746);
  ::Reflex::Type type_2747c = ::Reflex::ConstBuilder(type_2747);
  ::Reflex::Type type_7830 = ::Reflex::ReferenceBuilder(type_2747c);
  ::Reflex::Type type_5660 = ::Reflex::ReferenceBuilder(type_2747);
  ::Reflex::Type type_2748c = ::Reflex::ConstBuilder(type_2748);
  ::Reflex::Type type_7835 = ::Reflex::ReferenceBuilder(type_2748c);
  ::Reflex::Type type_5661 = ::Reflex::ReferenceBuilder(type_2748);
  ::Reflex::Type type_2749c = ::Reflex::ConstBuilder(type_2749);
  ::Reflex::Type type_7836 = ::Reflex::ReferenceBuilder(type_2749c);
  ::Reflex::Type type_5662 = ::Reflex::ReferenceBuilder(type_2749);
  ::Reflex::Type type_24425 = ::Reflex::ReferenceBuilder(type_2759);
  ::Reflex::Type type_2759c = ::Reflex::ConstBuilder(type_2759);
  ::Reflex::Type type_24426 = ::Reflex::ReferenceBuilder(type_2759c);
  ::Reflex::Type type_28740 = ::Reflex::FunctionTypeBuilder(type_19454);
  ::Reflex::Type type_24427 = ::Reflex::PointerBuilder(type_28740);
  ::Reflex::Type type_10302 = ::Reflex::PointerBuilder(type_8321);
  ::Reflex::Type type_26050 = ::Reflex::ReferenceBuilder(type_2776);
  ::Reflex::Type type_26051 = ::Reflex::ReferenceBuilder(type_2811);
  ::Reflex::Type type_26052 = ::Reflex::ReferenceBuilder(type_2811c);
  ::Reflex::Type type_26053 = ::Reflex::ReferenceBuilder(type_2823);
  ::Reflex::Type type_2823c = ::Reflex::ConstBuilder(type_2823);
  ::Reflex::Type type_26054 = ::Reflex::ReferenceBuilder(type_2823c);
  ::Reflex::Type type_26057 = ::Reflex::ReferenceBuilder(type_2872);
  ::Reflex::Type type_26063 = ::Reflex::PointerBuilder(type_3178);
  ::Reflex::Type type_31005 = ::Reflex::PointerBuilder(type_2912);
  ::Reflex::Type type_26064 = ::Reflex::ReferenceBuilder(type_31005);
  ::Reflex::Type type_26066 = ::Reflex::ReferenceBuilder(type_2935);
  ::Reflex::Type type_2935c = ::Reflex::ConstBuilder(type_2935);
  ::Reflex::Type type_26067 = ::Reflex::ReferenceBuilder(type_2935c);
  ::Reflex::Type type_26068 = ::Reflex::ReferenceBuilder(type_2950);
  ::Reflex::Type type_2950c = ::Reflex::ConstBuilder(type_2950);
  ::Reflex::Type type_26069 = ::Reflex::ReferenceBuilder(type_2950c);
  ::Reflex::Type type_26070 = ::Reflex::PointerBuilder(type_1334);
  ::Reflex::Type type_9968 = ::Reflex::PointerBuilder(type_10166);
  ::Reflex::Type type_10166c = ::Reflex::ConstBuilder(type_10166);
  ::Reflex::Type type_10173 = ::Reflex::PointerBuilder(type_10166c);
  ::Reflex::Type type_10175 = ::Reflex::ReferenceBuilder(type_10166);
  ::Reflex::Type type_10177 = ::Reflex::ReferenceBuilder(type_10166c);
  ::Reflex::Type type_3592 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_203);
  ::Reflex::Type type_3309 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_142);
  ::Reflex::Type type_3634c = ::Reflex::ConstBuilder(type_3634);
  ::Reflex::Type type_26589 = ::Reflex::ReferenceBuilder(type_3634c);
  ::Reflex::Type type_3155c = ::Reflex::ConstBuilder(type_3155);
  ::Reflex::Type type_26682 = ::Reflex::ReferenceBuilder(type_3155c);
  ::Reflex::Type type_26683 = ::Reflex::ReferenceBuilder(type_3155);
  ::Reflex::Type type_9294 = ::Reflex::PointerBuilder(type_10234);
  ::Reflex::Type type_10234c = ::Reflex::ConstBuilder(type_10234);
  ::Reflex::Type type_10241 = ::Reflex::PointerBuilder(type_10234c);
  ::Reflex::Type type_10243 = ::Reflex::ReferenceBuilder(type_10234);
  ::Reflex::Type type_10245 = ::Reflex::ReferenceBuilder(type_10234c);
  ::Reflex::Type type_3626c = ::Reflex::ConstBuilder(type_3626);
  ::Reflex::Type type_26121 = ::Reflex::ReferenceBuilder(type_3626c);
  ::Reflex::Type type_3156c = ::Reflex::ConstBuilder(type_3156);
  ::Reflex::Type type_26685 = ::Reflex::ReferenceBuilder(type_3156c);
  ::Reflex::Type type_26686 = ::Reflex::ReferenceBuilder(type_3156);
  ::Reflex::Type type_10005 = ::Reflex::PointerBuilder(type_10302);
  ::Reflex::Type type_10302c = ::Reflex::ConstBuilder(type_10302);
  ::Reflex::Type type_10309 = ::Reflex::PointerBuilder(type_10302c);
  ::Reflex::Type type_10311 = ::Reflex::ReferenceBuilder(type_10302);
  ::Reflex::Type type_10313 = ::Reflex::ReferenceBuilder(type_10302c);
  ::Reflex::Type type_3635c = ::Reflex::ConstBuilder(type_3635);
  ::Reflex::Type type_26615 = ::Reflex::ReferenceBuilder(type_3635c);
  ::Reflex::Type type_3157c = ::Reflex::ConstBuilder(type_3157);
  ::Reflex::Type type_26688 = ::Reflex::ReferenceBuilder(type_3157c);
  ::Reflex::Type type_26689 = ::Reflex::ReferenceBuilder(type_3157);
  ::Reflex::Type type_9313 = ::Reflex::PointerBuilder(type_2743);
  ::Reflex::Type type_10376 = ::Reflex::PointerBuilder(type_2743c);
  ::Reflex::Type type_3627c = ::Reflex::ConstBuilder(type_3627);
  ::Reflex::Type type_26134 = ::Reflex::ReferenceBuilder(type_3627c);
  ::Reflex::Type type_3158c = ::Reflex::ConstBuilder(type_3158);
  ::Reflex::Type type_26690 = ::Reflex::ReferenceBuilder(type_3158c);
  ::Reflex::Type type_26691 = ::Reflex::ReferenceBuilder(type_3158);
  ::Reflex::Type type_9332 = ::Reflex::PointerBuilder(type_2744);
  ::Reflex::Type type_10441 = ::Reflex::PointerBuilder(type_2744c);
  ::Reflex::Type type_3628c = ::Reflex::ConstBuilder(type_3628);
  ::Reflex::Type type_26147 = ::Reflex::ReferenceBuilder(type_3628c);
  ::Reflex::Type type_3159c = ::Reflex::ConstBuilder(type_3159);
  ::Reflex::Type type_26692 = ::Reflex::ReferenceBuilder(type_3159c);
  ::Reflex::Type type_26693 = ::Reflex::ReferenceBuilder(type_3159);
  ::Reflex::Type type_9351 = ::Reflex::PointerBuilder(type_2745);
  ::Reflex::Type type_10506 = ::Reflex::PointerBuilder(type_2745c);
  ::Reflex::Type type_3629c = ::Reflex::ConstBuilder(type_3629);
  ::Reflex::Type type_26160 = ::Reflex::ReferenceBuilder(type_3629c);
  ::Reflex::Type type_3160c = ::Reflex::ConstBuilder(type_3160);
  ::Reflex::Type type_26694 = ::Reflex::ReferenceBuilder(type_3160c);
  ::Reflex::Type type_26695 = ::Reflex::ReferenceBuilder(type_3160);
  ::Reflex::Type type_9370 = ::Reflex::PointerBuilder(type_2746);
  ::Reflex::Type type_10571 = ::Reflex::PointerBuilder(type_2746c);
  ::Reflex::Type type_3630c = ::Reflex::ConstBuilder(type_3630);
  ::Reflex::Type type_26173 = ::Reflex::ReferenceBuilder(type_3630c);
  ::Reflex::Type type_3161c = ::Reflex::ConstBuilder(type_3161);
  ::Reflex::Type type_26696 = ::Reflex::ReferenceBuilder(type_3161c);
  ::Reflex::Type type_26697 = ::Reflex::ReferenceBuilder(type_3161);
  ::Reflex::Type type_9389 = ::Reflex::PointerBuilder(type_2747);
  ::Reflex::Type type_10636 = ::Reflex::PointerBuilder(type_2747c);
  ::Reflex::Type type_3631c = ::Reflex::ConstBuilder(type_3631);
  ::Reflex::Type type_26186 = ::Reflex::ReferenceBuilder(type_3631c);
  ::Reflex::Type type_3162c = ::Reflex::ConstBuilder(type_3162);
  ::Reflex::Type type_26698 = ::Reflex::ReferenceBuilder(type_3162c);
  ::Reflex::Type type_26699 = ::Reflex::ReferenceBuilder(type_3162);
  ::Reflex::Type type_9408 = ::Reflex::PointerBuilder(type_2748);
  ::Reflex::Type type_10701 = ::Reflex::PointerBuilder(type_2748c);
  ::Reflex::Type type_3632c = ::Reflex::ConstBuilder(type_3632);
  ::Reflex::Type type_26199 = ::Reflex::ReferenceBuilder(type_3632c);
  ::Reflex::Type type_3163c = ::Reflex::ConstBuilder(type_3163);
  ::Reflex::Type type_26700 = ::Reflex::ReferenceBuilder(type_3163c);
  ::Reflex::Type type_26701 = ::Reflex::ReferenceBuilder(type_3163);
  ::Reflex::Type type_9427 = ::Reflex::PointerBuilder(type_2749);
  ::Reflex::Type type_10766 = ::Reflex::PointerBuilder(type_2749c);
  ::Reflex::Type type_3633c = ::Reflex::ConstBuilder(type_3633);
  ::Reflex::Type type_26212 = ::Reflex::ReferenceBuilder(type_3633c);
  ::Reflex::Type type_3164c = ::Reflex::ConstBuilder(type_3164);
  ::Reflex::Type type_26702 = ::Reflex::ReferenceBuilder(type_3164c);
  ::Reflex::Type type_26703 = ::Reflex::ReferenceBuilder(type_3164);
  ::Reflex::Type type_10108 = ::Reflex::ReferenceBuilder(type_4274);
  ::Reflex::Type type_12372 = ::Reflex::ReferenceBuilder(type_4274c);
  ::Reflex::Type type_3625c = ::Reflex::ConstBuilder(type_3625);
  ::Reflex::Type type_26316 = ::Reflex::ReferenceBuilder(type_3625c);
  ::Reflex::Type type_10833 = ::Reflex::ReferenceBuilder(type_3224);
  ::Reflex::Type type_4207c = ::Reflex::ConstBuilder(type_4207);
  ::Reflex::Type type_27628 = ::Reflex::ReferenceBuilder(type_4207c);
  ::Reflex::Type type_27629 = ::Reflex::PointerBuilder(type_8014);
  ::Reflex::Type type_4208c = ::Reflex::ConstBuilder(type_4208);
  ::Reflex::Type type_27630 = ::Reflex::ReferenceBuilder(type_4208c);
  ::Reflex::Type type_4209c = ::Reflex::ConstBuilder(type_4209);
  ::Reflex::Type type_27631 = ::Reflex::ReferenceBuilder(type_4209c);
  ::Reflex::Type type_4210c = ::Reflex::ConstBuilder(type_4210);
  ::Reflex::Type type_27632 = ::Reflex::ReferenceBuilder(type_4210c);
  ::Reflex::Type type_3167c = ::Reflex::ConstBuilder(type_3167);
  ::Reflex::Type type_12640 = ::Reflex::ReferenceBuilder(type_3167c);
  ::Reflex::Type type_4211c = ::Reflex::ConstBuilder(type_4211);
  ::Reflex::Type type_27633 = ::Reflex::ReferenceBuilder(type_4211c);
  ::Reflex::Type type_4212c = ::Reflex::ConstBuilder(type_4212);
  ::Reflex::Type type_27634 = ::Reflex::ReferenceBuilder(type_4212c);
  ::Reflex::Type type_4221c = ::Reflex::ConstBuilder(type_4221);
  ::Reflex::Type type_27635 = ::Reflex::ReferenceBuilder(type_4221c);
  ::Reflex::Type type_4222c = ::Reflex::ConstBuilder(type_4222);
  ::Reflex::Type type_27636 = ::Reflex::ReferenceBuilder(type_4222c);
  ::Reflex::Type type_4223c = ::Reflex::ConstBuilder(type_4223);
  ::Reflex::Type type_27637 = ::Reflex::ReferenceBuilder(type_4223c);
  ::Reflex::Type type_4224c = ::Reflex::ConstBuilder(type_4224);
  ::Reflex::Type type_27638 = ::Reflex::ReferenceBuilder(type_4224c);
  ::Reflex::Type type_4225c = ::Reflex::ConstBuilder(type_4225);
  ::Reflex::Type type_27639 = ::Reflex::ReferenceBuilder(type_4225c);
  ::Reflex::Type type_4226c = ::Reflex::ConstBuilder(type_4226);
  ::Reflex::Type type_27640 = ::Reflex::ReferenceBuilder(type_4226c);
  ::Reflex::Type type_4227c = ::Reflex::ConstBuilder(type_4227);
  ::Reflex::Type type_27641 = ::Reflex::ReferenceBuilder(type_4227c);
  ::Reflex::Type type_4228c = ::Reflex::ConstBuilder(type_4228);
  ::Reflex::Type type_27642 = ::Reflex::ReferenceBuilder(type_4228c);
  ::Reflex::Type type_4229c = ::Reflex::ConstBuilder(type_4229);
  ::Reflex::Type type_27645 = ::Reflex::ReferenceBuilder(type_4229c);
  ::Reflex::Type type_22c = ::Reflex::ConstBuilder(type_22);
  ::Reflex::Type type_19264 = ::Reflex::ReferenceBuilder(type_22c);
  ::Reflex::Type type_4096 = ::Reflex::PointerBuilder(type_142);
  ::Reflex::Type type_4668c = ::Reflex::ConstBuilder(type_4668);
  ::Reflex::Type type_4402 = ::Reflex::ReferenceBuilder(type_4668c);
  ::Reflex::Type type_27738 = ::Reflex::ReferenceBuilder(type_4740);
  ::Reflex::Type type_4740c = ::Reflex::ConstBuilder(type_4740);
  ::Reflex::Type type_27739 = ::Reflex::ReferenceBuilder(type_4740c);
  ::Reflex::Type type_27740 = ::Reflex::ReferenceBuilder(type_4741);
  ::Reflex::Type type_4741c = ::Reflex::ConstBuilder(type_4741);
  ::Reflex::Type type_27741 = ::Reflex::ReferenceBuilder(type_4741c);
  ::Reflex::Type type_27801 = ::Reflex::ReferenceBuilder(type_5405);
  ::Reflex::Type type_5405c = ::Reflex::ConstBuilder(type_5405);
  ::Reflex::Type type_27802 = ::Reflex::ReferenceBuilder(type_5405c);
  ::Reflex::Type type_27803 = ::Reflex::PointerBuilder(type_1187);
  ::Reflex::Type type_5905c = ::Reflex::ConstBuilder(type_5905);
  ::Reflex::Type type_27840 = ::Reflex::ReferenceBuilder(type_5905c);
  ::Reflex::Type type_5907c = ::Reflex::ConstBuilder(type_5907);
  ::Reflex::Type type_27841 = ::Reflex::ReferenceBuilder(type_5907c);
  ::Reflex::Type type_5909c = ::Reflex::ConstBuilder(type_5909);
  ::Reflex::Type type_27842 = ::Reflex::ReferenceBuilder(type_5909c);
  ::Reflex::Type type_5911c = ::Reflex::ConstBuilder(type_5911);
  ::Reflex::Type type_27843 = ::Reflex::ReferenceBuilder(type_5911c);
  ::Reflex::Type type_5913c = ::Reflex::ConstBuilder(type_5913);
  ::Reflex::Type type_27844 = ::Reflex::ReferenceBuilder(type_5913c);
  ::Reflex::Type type_5915c = ::Reflex::ConstBuilder(type_5915);
  ::Reflex::Type type_27845 = ::Reflex::ReferenceBuilder(type_5915c);
  ::Reflex::Type type_5917c = ::Reflex::ConstBuilder(type_5917);
  ::Reflex::Type type_27846 = ::Reflex::ReferenceBuilder(type_5917c);
  ::Reflex::Type type_5919c = ::Reflex::ConstBuilder(type_5919);
  ::Reflex::Type type_27847 = ::Reflex::ReferenceBuilder(type_5919c);
  ::Reflex::Type type_5921c = ::Reflex::ConstBuilder(type_5921);
  ::Reflex::Type type_27848 = ::Reflex::ReferenceBuilder(type_5921c);
  ::Reflex::Type type_5923c = ::Reflex::ConstBuilder(type_5923);
  ::Reflex::Type type_27849 = ::Reflex::ReferenceBuilder(type_5923c);
  ::Reflex::Type type_5947c = ::Reflex::ConstBuilder(type_5947);
  ::Reflex::Type type_27850 = ::Reflex::ReferenceBuilder(type_5947c);
  ::Reflex::Type type_5949c = ::Reflex::ConstBuilder(type_5949);
  ::Reflex::Type type_27851 = ::Reflex::ReferenceBuilder(type_5949c);
  ::Reflex::Type type_5951c = ::Reflex::ConstBuilder(type_5951);
  ::Reflex::Type type_27852 = ::Reflex::ReferenceBuilder(type_5951c);
  ::Reflex::Type type_27853 = ::Reflex::ReferenceBuilder(type_5953);
  ::Reflex::Type type_5953c = ::Reflex::ConstBuilder(type_5953);
  ::Reflex::Type type_27854 = ::Reflex::ReferenceBuilder(type_5953c);
  ::Reflex::Type type_5954c = ::Reflex::ConstBuilder(type_5954);
  ::Reflex::Type type_27855 = ::Reflex::ReferenceBuilder(type_5954c);
  ::Reflex::Type type_27856 = ::Reflex::ReferenceBuilder(type_5954);
  ::Reflex::Type type_5956c = ::Reflex::ConstBuilder(type_5956);
  ::Reflex::Type type_27857 = ::Reflex::ReferenceBuilder(type_5956c);
  ::Reflex::Type type_5958c = ::Reflex::ConstBuilder(type_5958);
  ::Reflex::Type type_27858 = ::Reflex::ReferenceBuilder(type_5958c);
  ::Reflex::Type type_5960c = ::Reflex::ConstBuilder(type_5960);
  ::Reflex::Type type_27860 = ::Reflex::ReferenceBuilder(type_5960c);
  ::Reflex::Type type_1921c = ::Reflex::ConstBuilder(type_1921);
  ::Reflex::Type type_27861 = ::Reflex::ReferenceBuilder(type_5960);
  ::Reflex::Type type_5961c = ::Reflex::ConstBuilder(type_5961);
  ::Reflex::Type type_27862 = ::Reflex::ReferenceBuilder(type_5961c);
  ::Reflex::Type type_27863 = ::Reflex::ReferenceBuilder(type_5961);
  ::Reflex::Type type_5962c = ::Reflex::ConstBuilder(type_5962);
  ::Reflex::Type type_27864 = ::Reflex::ReferenceBuilder(type_5962c);
  ::Reflex::Type type_27865 = ::Reflex::ReferenceBuilder(type_5962);
  ::Reflex::Type type_5963c = ::Reflex::ConstBuilder(type_5963);
  ::Reflex::Type type_27866 = ::Reflex::ReferenceBuilder(type_5963c);
  ::Reflex::Type type_14c = ::Reflex::ConstBuilder(type_14);
  ::Reflex::Type type_27867 = ::Reflex::ReferenceBuilder(type_5963);
  ::Reflex::Type type_5964c = ::Reflex::ConstBuilder(type_5964);
  ::Reflex::Type type_27868 = ::Reflex::ReferenceBuilder(type_5964c);
  ::Reflex::Type type_27869 = ::Reflex::ReferenceBuilder(type_5964);
  ::Reflex::Type type_5965c = ::Reflex::ConstBuilder(type_5965);
  ::Reflex::Type type_27870 = ::Reflex::ReferenceBuilder(type_5965c);
  ::Reflex::Type type_189c = ::Reflex::ConstBuilder(type_189);
  ::Reflex::Type type_27871 = ::Reflex::ReferenceBuilder(type_5965);
  ::Reflex::Type type_5966c = ::Reflex::ConstBuilder(type_5966);
  ::Reflex::Type type_27872 = ::Reflex::ReferenceBuilder(type_5966c);
  ::Reflex::Type type_27873 = ::Reflex::ReferenceBuilder(type_5966);
  ::Reflex::Type type_5967c = ::Reflex::ConstBuilder(type_5967);
  ::Reflex::Type type_27874 = ::Reflex::ReferenceBuilder(type_5967c);
  ::Reflex::Type type_333c = ::Reflex::ConstBuilder(type_333);
  ::Reflex::Type type_27875 = ::Reflex::ReferenceBuilder(type_5967);
  ::Reflex::Type type_5968c = ::Reflex::ConstBuilder(type_5968);
  ::Reflex::Type type_27876 = ::Reflex::ReferenceBuilder(type_5968c);
  ::Reflex::Type type_869c = ::Reflex::ConstBuilder(type_869);
  ::Reflex::Type type_27877 = ::Reflex::ReferenceBuilder(type_5968);
  ::Reflex::Type type_5969c = ::Reflex::ConstBuilder(type_5969);
  ::Reflex::Type type_27878 = ::Reflex::ReferenceBuilder(type_5969c);
  ::Reflex::Type type_278c = ::Reflex::ConstBuilder(type_278);
  ::Reflex::Type type_27879 = ::Reflex::ReferenceBuilder(type_5969);
  ::Reflex::Type type_5970c = ::Reflex::ConstBuilder(type_5970);
  ::Reflex::Type type_27880 = ::Reflex::ReferenceBuilder(type_5970c);
  ::Reflex::Type type_27881 = ::Reflex::ReferenceBuilder(type_5970);
  ::Reflex::Type type_27895 = ::Reflex::ReferenceBuilder(type_5987);
  ::Reflex::Type type_5987c = ::Reflex::ConstBuilder(type_5987);
  ::Reflex::Type type_27896 = ::Reflex::ReferenceBuilder(type_5987c);
  ::Reflex::Type type_5988c = ::Reflex::ConstBuilder(type_5988);
  ::Reflex::Type type_27897 = ::Reflex::ReferenceBuilder(type_5988c);
  ::Reflex::Type type_5992c = ::Reflex::ConstBuilder(type_5992);
  ::Reflex::Type type_27901 = ::Reflex::ReferenceBuilder(type_5992c);
  ::Reflex::Type type_5994c = ::Reflex::ConstBuilder(type_5994);
  ::Reflex::Type type_27902 = ::Reflex::ReferenceBuilder(type_5994c);
  ::Reflex::Type type_6001c = ::Reflex::ConstBuilder(type_6001);
  ::Reflex::Type type_27913 = ::Reflex::ReferenceBuilder(type_6001c);
  ::Reflex::Type type_6002c = ::Reflex::ConstBuilder(type_6002);
  ::Reflex::Type type_27914 = ::Reflex::ReferenceBuilder(type_6002c);
  ::Reflex::Type type_6009c = ::Reflex::ConstBuilder(type_6009);
  ::Reflex::Type type_27919 = ::Reflex::ReferenceBuilder(type_6009c);
  ::Reflex::Type type_27920 = ::Reflex::ReferenceBuilder(type_6012);
  ::Reflex::Type type_6012c = ::Reflex::ConstBuilder(type_6012);
  ::Reflex::Type type_27921 = ::Reflex::ReferenceBuilder(type_6012c);
  ::Reflex::Type type_6013c = ::Reflex::ConstBuilder(type_6013);
  ::Reflex::Type type_27922 = ::Reflex::ReferenceBuilder(type_6013c);
  ::Reflex::Type type_6014c = ::Reflex::ConstBuilder(type_6014);
  ::Reflex::Type type_27923 = ::Reflex::ReferenceBuilder(type_6014c);
  ::Reflex::Type type_28106 = ::Reflex::ReferenceBuilder(type_6096);
  ::Reflex::Type type_6096c = ::Reflex::ConstBuilder(type_6096);
  ::Reflex::Type type_28107 = ::Reflex::ReferenceBuilder(type_6096c);
  ::Reflex::Type type_8321c = ::Reflex::ConstBuilder(type_8321);
  ::Reflex::Type type_28737 = ::Reflex::ReferenceBuilder(type_8321c);
  ::Reflex::Type type_28738 = ::Reflex::ReferenceBuilder(type_8321);
  ::Reflex::Type type_4661c = ::Reflex::ConstBuilder(type_4661);
  ::Reflex::Type type_19538 = ::Reflex::ReferenceBuilder(type_4661c);
  ::Reflex::Type type_19623 = ::Reflex::PointerBuilder(type_2390);
  ::Reflex::Type type_19715 = ::Reflex::PointerBuilder(type_19429);
  ::Reflex::Type type_4669c = ::Reflex::ConstBuilder(type_4669);
  ::Reflex::Type type_19716 = ::Reflex::ReferenceBuilder(type_4669c);
  ::Reflex::Type type_19928 = ::Reflex::ReferenceBuilder(type_3396c);
  ::Reflex::Type type_1376 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pthread_t"), type_502);
  ::Reflex::Type type_8956 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("System::ThreadHandle"), type_1376);
  ::Reflex::Type type_8989 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("System::ProcessHandle"), type_1454);
  ::Reflex::Type type_4141 = ::Reflex::PointerBuilder(type_158);
  ::Reflex::Type type_8964 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("System::ImageHandle"), type_1454);
  ::Reflex::Type type_26073 = ::Reflex::PointerBuilder(type_8964);
  ::Reflex::Type type_12772 = ::Reflex::ReferenceBuilder(type_1454);
  ::Reflex::Type type_26072 = ::Reflex::FunctionTypeBuilder(type_1454);
  ::Reflex::Type type_8927 = ::Reflex::PointerBuilder(type_26072);
  ::Reflex::Type type_8928 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("System::Creator"), type_8927);
  ::Reflex::Type type_26084 = ::Reflex::PointerBuilder(type_8928);
  ::Reflex::Type type_26071 = ::Reflex::FunctionTypeBuilder(type_502, type_502, type_4283);
  ::Reflex::Type type_8900 = ::Reflex::PointerBuilder(type_26071);
  ::Reflex::Type type_8901 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("System::EntryPoint"), type_8900);
  ::Reflex::Type type_26085 = ::Reflex::PointerBuilder(type_8901);
  ::Reflex::Type type_27681 = ::Reflex::ReferenceBuilder(type_8759);
  ::Reflex::Type type_27682 = ::Reflex::ReferenceBuilder(type_8760);
  ::Reflex::Type type_27683 = ::Reflex::ReferenceBuilder(type_3194);
  ::Reflex::Type type_27684 = ::Reflex::ReferenceBuilder(type_4661);
  ::Reflex::Type type_27131 = ::Reflex::ReferenceBuilder(type_3425);
  ::Reflex::Type type_27126 = ::Reflex::ReferenceBuilder(type_3424);
  ::Reflex::Type type_27127 = ::Reflex::ReferenceBuilder(type_4669);
  ::Reflex::Type type_27122 = ::Reflex::ReferenceBuilder(type_3423);
  ::Reflex::Type type_27118 = ::Reflex::ReferenceBuilder(type_3422);
  ::Reflex::Type type_27113 = ::Reflex::ReferenceBuilder(type_3421);
  ::Reflex::Type type_27109 = ::Reflex::ReferenceBuilder(type_3420);
  ::Reflex::Type type_27105 = ::Reflex::ReferenceBuilder(type_3419);
  ::Reflex::Type type_27101 = ::Reflex::ReferenceBuilder(type_3418);
  ::Reflex::Type type_27097 = ::Reflex::ReferenceBuilder(type_3417);
  ::Reflex::Type type_27093 = ::Reflex::ReferenceBuilder(type_3416);
  ::Reflex::Type type_27080 = ::Reflex::ReferenceBuilder(type_3413);
  ::Reflex::Type type_27089 = ::Reflex::ReferenceBuilder(type_3415);
  ::Reflex::Type type_27085 = ::Reflex::ReferenceBuilder(type_3414);
  ::Reflex::Type type_26763 = ::Reflex::ReferenceBuilder(type_3198);
  ::Reflex::Type type_26760 = ::Reflex::ReferenceBuilder(type_3197);
  ::Reflex::Type type_26758 = ::Reflex::ReferenceBuilder(type_3196);
  ::Reflex::Type type_26755 = ::Reflex::ReferenceBuilder(type_3195);
  ::Reflex::Type type_12504 = ::Reflex::ReferenceBuilder(type_3020);
  ::Reflex::Type type_12437 = ::Reflex::ReferenceBuilder(type_3015);
  ::Reflex::Type type_12571 = ::Reflex::ReferenceBuilder(type_3165);
  ::Reflex::Type type_26729 = ::Reflex::ReferenceBuilder(type_3182);
  ::Reflex::Type type_26731 = ::Reflex::ReferenceBuilder(type_3183);
  ::Reflex::Type type_26733 = ::Reflex::ReferenceBuilder(type_3184);
  ::Reflex::Type type_26735 = ::Reflex::ReferenceBuilder(type_3185);
  ::Reflex::Type type_26737 = ::Reflex::ReferenceBuilder(type_3186);
  ::Reflex::Type type_26739 = ::Reflex::ReferenceBuilder(type_3187);
  ::Reflex::Type type_26743 = ::Reflex::ReferenceBuilder(type_3189);
  ::Reflex::Type type_26745 = ::Reflex::ReferenceBuilder(type_3190);
  ::Reflex::Type type_26741 = ::Reflex::ReferenceBuilder(type_3188);
  ::Reflex::Type type_26750 = ::Reflex::ReferenceBuilder(type_3192);
  ::Reflex::Type type_26747 = ::Reflex::ReferenceBuilder(type_3191);
  ::Reflex::Type type_26752 = ::Reflex::ReferenceBuilder(type_3193);
  ::Reflex::Type type_26723 = ::Reflex::ReferenceBuilder(type_3180);
  ::Reflex::Type type_11636 = ::Reflex::ReferenceBuilder(type_4100);
  ::Reflex::Type type_11703 = ::Reflex::ReferenceBuilder(type_1921);
  ::Reflex::Type type_10966 = ::Reflex::ReferenceBuilder(type_2603);
  ::Reflex::Type type_11770 = ::Reflex::ReferenceBuilder(type_14);
  ::Reflex::Type type_11837 = ::Reflex::ReferenceBuilder(type_189);
  ::Reflex::Type type_11904 = ::Reflex::ReferenceBuilder(type_502);
  ::Reflex::Type type_11970 = ::Reflex::ReferenceBuilder(type_203);
  ::Reflex::Type type_12104 = ::Reflex::ReferenceBuilder(type_333);
  ::Reflex::Type type_12171 = ::Reflex::ReferenceBuilder(type_869);
  ::Reflex::Type type_12037 = ::Reflex::ReferenceBuilder(type_142);
  ::Reflex::Type type_12305 = ::Reflex::ReferenceBuilder(type_250);
  ::Reflex::Type type_12238 = ::Reflex::ReferenceBuilder(type_278);
  ::Reflex::Type type_13607 = ::Reflex::ReferenceBuilder(type_4206);
  ::Reflex::Type type_19629c = ::Reflex::ConstBuilder(type_19629);
  ::Reflex::Type type_19509c = ::Reflex::ConstBuilder(type_19509);
  ::Reflex::Type type_27698 = ::Reflex::ReferenceBuilder(type_19629c);
  ::Reflex::Type type_27699 = ::Reflex::ReferenceBuilder(type_19509c);
  ::Reflex::Type type_4100c = ::Reflex::ConstBuilder(type_4100);
  ::Reflex::Type type_10067 = ::Reflex::ReferenceBuilder(type_3955);
  ::Reflex::Type type_11093 = ::Reflex::PointerBuilder(type_2061c);
  ::Reflex::Type type_27722 = ::Reflex::PointerBuilder(type_2383c);
  ::Reflex::Type type_11093c = ::Reflex::ConstBuilder(type_11093);
  ::Reflex::Type type_11104 = ::Reflex::ReferenceBuilder(type_11093c);
  ::Reflex::Type type_31594 = ::Reflex::PointerBuilder(type_27695);
  ::Reflex::Type type_31595 = ::Reflex::ReferenceBuilder(type_27695);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __IInterface
#undef __IInterface
#endif
class __IInterface {
  public:
  __IInterface();
  virtual ~__IInterface() throw();
};
#ifdef __extend_interfaces1_IInterface_
#undef __extend_interfaces1_IInterface_
#endif
struct __extend_interfaces1_IInterface_ : virtual public ::IInterface {
  public:
  __extend_interfaces1_IInterface_();
  virtual ~__extend_interfaces1_IInterface_() throw();
};
#ifdef __IDataStreamTool
#undef __IDataStreamTool
#endif
class __IDataStreamTool : virtual public ::IAlgTool {
  public:
  __IDataStreamTool();
  virtual ~__IDataStreamTool() throw();
  virtual ::StatusCode clear() throw();
  virtual ::EventSelectorDataStream* getStream(std::string const&) throw();
  virtual ::EventSelectorDataStream* getStream(long) throw();
  virtual ::StatusCode finalizeStream(EventSelectorDataStream*) throw();
  virtual ::StatusCode getPreviousStream(EventSelectorDataStream const*&, long&) throw();
  virtual ::StatusCode createStream(std::string const&, std::string const&, EventSelectorDataStream*&) throw();
  virtual ::StatusCode createSelector(std::string const&, std::string const&, IEvtSelector*&) throw();
  virtual long size() throw();
  virtual ::StatusCode addStream(std::string const&) throw();
  virtual ::StatusCode addStreams(std::vector<std::string, std::allocator<std::string> > const&) throw();
  virtual ::StatusCode initializeStream(EventSelectorDataStream*) throw();
  virtual ::StatusCode getNextStream(EventSelectorDataStream const*&, long&) throw();
  virtual ::EventSelectorDataStream* lastStream() throw();
  virtual ::StatusCode eraseStream(std::string const&) throw();
};
#ifdef __extend_interfaces1_IDataStreamTool_
#undef __extend_interfaces1_IDataStreamTool_
#endif
struct __extend_interfaces1_IDataStreamTool_ : virtual public ::IDataStreamTool {
  public:
  __extend_interfaces1_IDataStreamTool_();
  virtual ~__extend_interfaces1_IDataStreamTool_() throw();
};
#ifdef __IProperty
#undef __IProperty
#endif
class __IProperty : virtual public ::IInterface {
  public:
  __IProperty();
  virtual ~__IProperty() throw();
};
#ifdef __extend_interfaces1_IProperty_
#undef __extend_interfaces1_IProperty_
#endif
struct __extend_interfaces1_IProperty_ : virtual public ::IProperty {
  public:
  __extend_interfaces1_IProperty_();
  virtual ~__extend_interfaces1_IProperty_() throw();
};
#ifdef __extend_interfaces2_IService_IAuditor_
#undef __extend_interfaces2_IService_IAuditor_
#endif
struct __extend_interfaces2_IService_IAuditor_ : virtual public ::IService, virtual public ::IAuditor {
  public:
  __extend_interfaces2_IService_IAuditor_();
  virtual ~__extend_interfaces2_IService_IAuditor_() throw();
};
#ifdef __GaudiHandleBase
#undef __GaudiHandleBase
#endif
class __GaudiHandleBase : public ::GaudiHandleInfo {
  public:
  __GaudiHandleBase();
  virtual ~__GaudiHandleBase() throw();
  ::std::string m_typeAndName;
};
#ifdef __GaudiHandleInfo
#undef __GaudiHandleInfo
#endif
class __GaudiHandleInfo {
  public:
  __GaudiHandleInfo();
  virtual ~__GaudiHandleInfo() throw();
  ::std::string m_componentType;
  ::std::string m_propertyName;
  ::std::string m_parentName;
};
#ifdef __Incident
#undef __Incident
#endif
class __Incident {
  public:
  __Incident();
  virtual ~__Incident() throw();
  ::std::string m_source;
  ::std::string m_type;
};
#ifdef __InterfaceID
#undef __InterfaceID
#endif
class __InterfaceID {
  public:
  __InterfaceID();
  unsigned long m_id;
  unsigned long m_major_ver;
  unsigned long m_minor_ver;
};
#ifdef __IUpdateable
#undef __IUpdateable
#endif
class __IUpdateable {
  public:
  __IUpdateable();
  virtual ~__IUpdateable() throw();
};
#ifdef __extends1_AlgTool_IDataStreamTool_
#undef __extends1_AlgTool_IDataStreamTool_
#endif
struct __extends1_AlgTool_IDataStreamTool_ : public ::AlgTool, virtual public ::extend_interfaces1<IDataStreamTool> {
  public:
  __extends1_AlgTool_IDataStreamTool_();
  virtual ~__extends1_AlgTool_IDataStreamTool_() throw();
  virtual void* i_cast(InterfaceID const&) const throw();
  virtual ::StatusCode queryInterface(InterfaceID const&, void**) throw();
  virtual ::std::vector<std::basic_string<char> > getInterfaceNames() const throw();
};
#ifdef __DataObject
#undef __DataObject
#endif
class __DataObject {
  public:
  __DataObject();
  virtual ~__DataObject() throw();
  unsigned long m_refCount;
  unsigned char m_version;
  void* m_pRegistry;
  void* m_pLinkMgr;
};
#ifdef __IDetDataSvc
#undef __IDetDataSvc
#endif
class __IDetDataSvc : virtual public ::IInterface {
  public:
  __IDetDataSvc();
  virtual ~__IDetDataSvc() throw();
};
#ifdef __IClassManager
#undef __IClassManager
#endif
class __IClassManager : virtual public ::IInterface {
  public:
  __IClassManager();
  virtual ~__IClassManager() throw();
};
#ifdef __implements1_IInterface_
#undef __implements1_IInterface_
#endif
struct __implements1_IInterface_ : virtual public ::extend_interfaces1<IInterface> {
  public:
  __implements1_IInterface_();
  virtual ~__implements1_IInterface_() throw();
  virtual ::StatusCode queryInterface(InterfaceID const&, void**) throw();
  virtual unsigned long refCount() const throw();
  virtual ::std::vector<std::basic_string<char> > getInterfaceNames() const throw();
  virtual void* i_cast(InterfaceID const&) const throw();
  virtual unsigned long addRef() throw();
  virtual unsigned long release() throw();
  unsigned long m_refCount;
};
#ifdef __implements1_IProperty_
#undef __implements1_IProperty_
#endif
struct __implements1_IProperty_ : virtual public ::extend_interfaces1<IProperty> {
  public:
  __implements1_IProperty_();
  virtual ~__implements1_IProperty_() throw();
  virtual ::StatusCode queryInterface(InterfaceID const&, void**) throw();
  virtual unsigned long refCount() const throw();
  virtual ::std::vector<std::basic_string<char> > getInterfaceNames() const throw();
  virtual void* i_cast(InterfaceID const&) const throw();
  virtual unsigned long addRef() throw();
  virtual unsigned long release() throw();
  unsigned long m_refCount;
};
#ifdef __IClassInfo
#undef __IClassInfo
#endif
class __IClassInfo {
  public:
  __IClassInfo();
  virtual ~__IClassInfo() throw();
};
#ifdef __IAlgorithm
#undef __IAlgorithm
#endif
class __IAlgorithm : virtual public ::INamedInterface {
  public:
  __IAlgorithm();
  virtual ~__IAlgorithm() throw();
  virtual ::StatusCode endRun() throw();
  virtual ::StatusCode sysExecute() throw();
  virtual ::StatusCode sysStart() throw();
  virtual void setFilterPassed(bool) throw();
  virtual ::StatusCode beginRun() throw();
  virtual ::StatusCode sysEndRun() throw();
  virtual ::StatusCode sysBeginRun() throw();
  virtual void setExecuted(bool) throw();
  virtual bool isExecuted() const throw();
  virtual ::StatusCode reinitialize() throw();
  virtual bool isFinalized() const throw();
  virtual ::StatusCode start() throw();
  virtual ::Gaudi::StateMachine::State FSMState() const throw();
  virtual ::StatusCode sysReinitialize() throw();
  virtual bool filterPassed() const throw();
  virtual ::StatusCode initialize() throw();
  virtual ::StatusCode configure() throw();
  virtual ::StatusCode restart() throw();
  virtual ::StatusCode sysStop() throw();
  virtual ::StatusCode terminate() throw();
  virtual void resetExecuted() throw();
  virtual bool isEnabled() const throw();
  virtual const ::std::string& version() const throw();
  virtual ::StatusCode sysRestart() throw();
  virtual ::StatusCode finalize() throw();
  virtual ::StatusCode sysInitialize() throw();
  virtual ::StatusCode sysFinalize() throw();
  virtual ::StatusCode execute() throw();
  virtual bool isInitialized() const throw();
  virtual ::StatusCode stop() throw();
};
#ifdef __IIncidentListener
#undef __IIncidentListener
#endif
class __IIncidentListener : virtual public ::IInterface {
  public:
  __IIncidentListener();
  virtual ~__IIncidentListener() throw();
};
#ifdef __IStatusCodeSvc
#undef __IStatusCodeSvc
#endif
class __IStatusCodeSvc : virtual public ::IService {
  public:
  __IStatusCodeSvc();
  virtual ~__IStatusCodeSvc() throw();
  virtual void regFnc(std::string const&, std::string const&) throw();
  virtual void list() const throw();
  virtual bool suppressCheck() const throw();
};
#ifdef __ISerialize
#undef __ISerialize
#endif
class __ISerialize : virtual public ::IInterface {
  public:
  __ISerialize();
  virtual ~__ISerialize() throw();
};
#ifdef __IExceptionSvc
#undef __IExceptionSvc
#endif
class __IExceptionSvc : virtual public ::IInterface {
  public:
  __IExceptionSvc();
  virtual ~__IExceptionSvc() throw();
};
#ifdef __ObjectContainerBase
#undef __ObjectContainerBase
#endif
class __ObjectContainerBase : public ::DataObject {
  public:
  __ObjectContainerBase();
  virtual ~__ObjectContainerBase() throw();
};
#ifdef __SmartDataObjectPtr
#undef __SmartDataObjectPtr
#endif
class __SmartDataObjectPtr {
  public:
  __SmartDataObjectPtr();
  virtual ~__SmartDataObjectPtr() throw();
  void* m_dataProvider;
  void* m_pRegistry;
  ::StatusCode m_status;
  ::std::string m_path;
  void* m_accessFunc;
};
#ifdef __extend_interfaces3_IAlgTool_IProperty_IStateful_
#undef __extend_interfaces3_IAlgTool_IProperty_IStateful_
#endif
struct __extend_interfaces3_IAlgTool_IProperty_IStateful_ : virtual public ::IAlgTool, virtual public ::IProperty, virtual public ::IStateful {
  public:
  __extend_interfaces3_IAlgTool_IProperty_IStateful_();
  virtual ~__extend_interfaces3_IAlgTool_IProperty_IStateful_() throw();
};
#ifdef __extend_interfaces3_IService_IProperty_IStateful_
#undef __extend_interfaces3_IService_IProperty_IStateful_
#endif
struct __extend_interfaces3_IService_IProperty_IStateful_ : virtual public ::IService, virtual public ::IProperty, virtual public ::IStateful {
  public:
  __extend_interfaces3_IService_IProperty_IStateful_();
  virtual ~__extend_interfaces3_IService_IProperty_IStateful_() throw();
};
#ifdef __extend_interfaces3_IAlgorithm_IProperty_IStateful_
#undef __extend_interfaces3_IAlgorithm_IProperty_IStateful_
#endif
struct __extend_interfaces3_IAlgorithm_IProperty_IStateful_ : virtual public ::IAlgorithm, virtual public ::IProperty, virtual public ::IStateful {
  public:
  __extend_interfaces3_IAlgorithm_IProperty_IStateful_();
  virtual ~__extend_interfaces3_IAlgorithm_IProperty_IStateful_() throw();
};
#ifdef __extend_interfaces3_IService_IChronoSvc_IStatSvc_
#undef __extend_interfaces3_IService_IChronoSvc_IStatSvc_
#endif
struct __extend_interfaces3_IService_IChronoSvc_IStatSvc_ : virtual public ::IService, virtual public ::IChronoSvc, virtual public ::IStatSvc {
  public:
  __extend_interfaces3_IService_IChronoSvc_IStatSvc_();
  virtual ~__extend_interfaces3_IService_IChronoSvc_IStatSvc_() throw();
};
#ifdef __IDataStoreAgent
#undef __IDataStoreAgent
#endif
class __IDataStoreAgent {
  public:
  __IDataStoreAgent();
  virtual ~__IDataStoreAgent() throw();
};
#ifdef __GaudiHandleArrayBase
#undef __GaudiHandleArrayBase
#endif
class __GaudiHandleArrayBase : public ::GaudiHandleInfo {
  public:
  __GaudiHandleArrayBase();
  virtual ~__GaudiHandleArrayBase() throw();
};
#ifdef __IConversionSvc
#undef __IConversionSvc
#endif
class __IConversionSvc : virtual public ::IConverter {
  public:
  __IConversionSvc();
  virtual ~__IConversionSvc() throw();
  virtual ::StatusCode addConverter(unsigned int const&) throw();
  virtual ::StatusCode addConverter(IConverter*) throw();
  virtual ::StatusCode connectOutput(std::string const&) throw();
  virtual ::StatusCode commitOutput(std::string const&, bool) throw();
  virtual ::StatusCode connectOutput(std::string const&, std::string const&) throw();
  virtual ::StatusCode removeConverter(unsigned int const&) throw();
  virtual ::IConverter* converter(unsigned int const&) throw();
};
#ifdef __IPersistencySvc
#undef __IPersistencySvc
#endif
class __IPersistencySvc : virtual public ::IInterface {
  public:
  __IPersistencySvc();
  virtual ~__IPersistencySvc() throw();
};
#ifdef __IMessageSvc
#undef __IMessageSvc
#endif
class __IMessageSvc : virtual public ::IInterface {
  public:
  __IMessageSvc();
  virtual ~__IMessageSvc() throw();
};
#ifdef __IMonitorSvc
#undef __IMonitorSvc
#endif
class __IMonitorSvc : virtual public ::IInterface {
  public:
  __IMonitorSvc();
  virtual ~__IMonitorSvc() throw();
};
#ifdef __IDataStoreLeaves
#undef __IDataStoreLeaves
#endif
class __IDataStoreLeaves : virtual public ::IAlgTool {
  public:
  __IDataStoreLeaves();
  virtual ~__IDataStoreLeaves() throw();
  virtual const ::std::vector<DataObject*>& leaves() const throw();
};
#ifdef __INTupleSvc
#undef __INTupleSvc
#endif
class __INTupleSvc : virtual public ::IDataProviderSvc {
  public:
  __INTupleSvc();
  virtual ~__INTupleSvc() throw();
  virtual ::StatusCode create(unsigned int const&, std::string const&, NTuple::Tuple*&) throw();
  virtual ::StatusCode writeRecord(DataObject*, std::string const&) throw();
  virtual ::StatusCode readRecord(std::string const&) throw();
  virtual ::NTuple::Directory* createDirectory(std::string const&, long) throw();
  virtual ::NTuple::Directory* createDirectory(DataObject*, std::string const&) throw();
  virtual ::StatusCode save(NTuple::Tuple*) throw();
  virtual ::NTuple::Tuple* book(DataObject*, long, unsigned int const&, std::string const&) throw();
  virtual ::StatusCode save(std::string const&) throw();
  virtual ::NTuple::Directory* createDirectory(std::string const&, std::string const&) throw();
  virtual ::StatusCode readRecord(NTuple::Tuple*) throw();
  virtual ::NTuple::Directory* createDirectory(DataObject*, long) throw();
  virtual ::NTuple::Tuple* book(std::string const&, std::string const&, unsigned int const&, std::string const&) throw();
  virtual ::NTuple::Tuple* access(std::string const&, std::string const&) throw();
  virtual ::NTuple::Tuple* book(std::string const&, long, unsigned int const&, std::string const&) throw();
  virtual ::StatusCode writeRecord(std::string const&) throw();
  virtual ::StatusCode save(DataObject*, std::string const&) throw();
  virtual ::NTuple::Tuple* book(DataObject*, std::string const&, unsigned int const&, std::string const&) throw();
  virtual ::StatusCode readRecord(DataObject*, std::string const&) throw();
  virtual ::StatusCode writeRecord(NTuple::Tuple*) throw();
  virtual ::NTuple::Directory* createDirectory(std::string const&) throw();
  virtual ::NTuple::Tuple* book(std::string const&, unsigned int const&, std::string const&) throw();
};
#ifdef __IAlgTool
#undef __IAlgTool
#endif
class __IAlgTool : virtual public ::INamedInterface {
  public:
  __IAlgTool();
  virtual ~__IAlgTool() throw();
  virtual ::StatusCode reinitialize() throw();
  virtual ::StatusCode sysInitialize() throw();
  virtual const ::IInterface* parent() const throw();
  virtual ::StatusCode configure() throw();
  virtual ::StatusCode restart() throw();
  virtual ::StatusCode sysStart() throw();
  virtual ::StatusCode terminate() throw();
  virtual const ::std::string& type() const throw();
  virtual ::StatusCode sysFinalize() throw();
  virtual ::StatusCode start() throw();
  virtual ::StatusCode sysStop() throw();
  virtual unsigned long refCount() const throw();
  virtual ::Gaudi::StateMachine::State FSMState() const throw();
  virtual ::StatusCode sysReinitialize() throw();
  virtual ::StatusCode finalize() throw();
  virtual ::StatusCode initialize() throw();
  virtual ::StatusCode sysRestart() throw();
  virtual ::StatusCode stop() throw();
};
#ifdef __IRndmEngine
#undef __IRndmEngine
#endif
class __IRndmEngine : virtual public ::IInterface {
  public:
  __IRndmEngine();
  virtual ~__IRndmEngine() throw();
};
#ifdef __IService
#undef __IService
#endif
class __IService : virtual public ::INamedInterface {
  public:
  __IService();
  virtual ~__IService() throw();
  virtual ::StatusCode reinitialize() throw();
  virtual ::StatusCode sysInitialize() throw();
  virtual ::StatusCode sysFinalize() throw();
  virtual ::StatusCode configure() throw();
  virtual ::StatusCode restart() throw();
  virtual ::StatusCode sysStart() throw();
  virtual ::StatusCode terminate() throw();
  virtual ::StatusCode start() throw();
  virtual ::StatusCode sysStop() throw();
  virtual ::Gaudi::StateMachine::State targetFSMState() const throw();
  virtual ::Gaudi::StateMachine::State FSMState() const throw();
  virtual ::StatusCode sysReinitialize() throw();
  virtual ::StatusCode finalize() throw();
  virtual ::StatusCode stop() throw();
  virtual void setServiceManager(ISvcManager*) throw();
  virtual ::StatusCode sysRestart() throw();
  virtual ::StatusCode initialize() throw();
};
#ifdef __GenericAddress
#undef __GenericAddress
#endif
class __GenericAddress : public ::IOpaqueAddress {
  public:
  __GenericAddress();
  virtual ~__GenericAddress() throw();
  unsigned long m_refCount;
  long m_svcType;
  ::CLID m_clID;
  ::std::string m_par[3];
  unsigned long m_ipar[2];
  void* m_pRegistry;
};
#ifdef __IssueSeverity
#undef __IssueSeverity
#endif
class __IssueSeverity {
  public:
  __IssueSeverity();
  int m_line;
  ::std::string m_file;
  ::IssueSeverity::Level m_level;
  ::std::string m_msg;
  bool m_reported;
};
#ifdef __IConverter
#undef __IConverter
#endif
class __IConverter : virtual public ::IInterface {
  public:
  __IConverter();
  virtual ~__IConverter() throw();
};
#ifdef __IEvtSelector
#undef __IEvtSelector
#endif
class __IEvtSelector : virtual public ::IInterface {
  public:
  __IEvtSelector();
  virtual ~__IEvtSelector() throw();
};
#ifdef __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader_
#undef __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader_
#endif
class __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader_ : public ::SmartDataObjectPtr {
  public:
  __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader_();
  virtual ~__SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader_() throw();
  void* m_pObject;
};
#ifdef __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader_
#undef __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader_
#endif
class __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader_ : public ::SmartDataObjectPtr {
  public:
  __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader_();
  virtual ~__SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader_() throw();
  void* m_pObject;
};
#ifdef __GaudiHandleProperty
#undef __GaudiHandleProperty
#endif
class __GaudiHandleProperty : public ::Property {
  public:
  __GaudiHandleProperty();
  virtual ~__GaudiHandleProperty() throw();
  void* m_pValue;
};
#ifdef __IUpdateManagerSvc
#undef __IUpdateManagerSvc
#endif
class __IUpdateManagerSvc : virtual public ::IInterface {
  public:
  __IUpdateManagerSvc();
  virtual ~__IUpdateManagerSvc() throw();
};
#ifdef __IPartitionControl
#undef __IPartitionControl
#endif
class __IPartitionControl : virtual public ::IInterface {
  public:
  __IPartitionControl();
  virtual ~__IPartitionControl() throw();
};
#ifdef __ISvcLocator
#undef __ISvcLocator
#endif
class __ISvcLocator : virtual public ::IInterface {
  public:
  __ISvcLocator();
  virtual ~__ISvcLocator() throw();
};
#ifdef __IAuditorSvc
#undef __IAuditorSvc
#endif
class __IAuditorSvc : virtual public ::extend_interfaces2<IService,IAuditor> {
  public:
  __IAuditorSvc();
  virtual ~__IAuditorSvc() throw();
  virtual ::IAuditor* getAuditor(std::string const&) throw();
};
#ifdef __GaudiHandleArrayProperty
#undef __GaudiHandleArrayProperty
#endif
class __GaudiHandleArrayProperty : public ::Property {
  public:
  __GaudiHandleArrayProperty();
  virtual ~__GaudiHandleArrayProperty() throw();
  void* m_pValue;
};
#ifdef __AlgTool
#undef __AlgTool
#endif
class __AlgTool : public ::implements3<IAlgTool,IProperty,IStateful> {
  public:
  __AlgTool();
  virtual ~__AlgTool() throw();
  virtual ::StatusCode setProperty(std::string const&, std::string const&) throw();
  virtual ::StatusCode sysStart() throw();
  virtual ::StatusCode setProperty(std::string const&) throw();
  virtual ::Gaudi::StateMachine::State targetFSMState() const throw();
  virtual const ::std::string& name() const throw();
  virtual ::StatusCode getProperty(std::string const&, std::string&) const throw();
  virtual ::StatusCode reinitialize() throw();
  virtual const ::IInterface* parent() const throw();
  virtual const ::Property& getProperty(std::string const&) const throw();
  virtual ::StatusCode start() throw();
  virtual ::Gaudi::StateMachine::State FSMState() const throw();
  virtual ::StatusCode sysReinitialize() throw();
  virtual ::StatusCode initialize() throw();
  virtual ::StatusCode queryInterface(InterfaceID const&, void**) throw();
  virtual ::StatusCode configure() throw();
  virtual ::StatusCode restart() throw();
  virtual const ::std::string& type() const throw();
  virtual ::StatusCode sysStop() throw();
  virtual const ::std::vector<Property*>& getProperties() const throw();
  virtual ::StatusCode terminate() throw();
  virtual ::StatusCode getProperty(Property*) const throw();
  virtual ::StatusCode sysRestart() throw();
  virtual ::StatusCode finalize() throw();
  virtual ::StatusCode sysInitialize() throw();
  virtual ::StatusCode sysFinalize() throw();
  virtual ::StatusCode setProperty(Property const&) throw();
  virtual ::StatusCode stop() throw();
  ::IntegerProperty m_outputLevel;
  ::std::string m_type;
  ::std::string m_name;
  void* m_parent;
  void* m_svcLocator;
  void* m_messageSvc;
  void* m_ptoolSvc;
  void* m_pMonitorSvc;
  ::std::string m_monitorSvcName;
  void* m_propertyMgr;
  ::std::list<std::pair<InterfaceID,void*> > m_interfaceList;
  ::std::string m_threadID;
  void* m_pAuditorSvc;
  ::BooleanProperty m_auditInit;
  bool m_auditorInitialize;
  bool m_auditorStart;
  bool m_auditorStop;
  bool m_auditorFinalize;
  bool m_auditorReinitialize;
  bool m_auditorRestart;
  ::Gaudi::StateMachine::State m_state;
  ::Gaudi::StateMachine::State m_targetState;
};
#ifdef __ContainedObject
#undef __ContainedObject
#endif
class __ContainedObject {
  public:
  __ContainedObject();
  virtual ~__ContainedObject() throw();
  void* m_parent;
};
#ifdef __IInspector
#undef __IInspector
#endif
class __IInspector : virtual public ::IInterface {
  public:
  __IInspector();
  virtual ~__IInspector() throw();
#ifdef __IInspector__IValue
#undef __IInspector__IValue
#endif
  class __IInspector__IValue {
    public:
    __IInspector__IValue();
    virtual ~__IInspector__IValue() throw();
    void* m_P;
  };
#ifdef __IInspector__Tag
#undef __IInspector__Tag
#endif
  class __IInspector__Tag {
    public:
    __IInspector__Tag();
    long first;
    int& second;
  };
};
#ifdef __Service
#undef __Service
#endif
class __Service : public ::CommonMessaging<implements3<IService,IProperty,IStateful> > {
  public:
  __Service();
  virtual ~__Service() throw();
  virtual ::StatusCode setProperty(std::string const&, std::string const&) throw();
  virtual ::StatusCode sysStart() throw();
  virtual ::StatusCode setProperty(std::string const&) throw();
  virtual ::Gaudi::StateMachine::State targetFSMState() const throw();
  virtual ::StatusCode getProperty(std::string const&, std::string&) const throw();
  virtual ::StatusCode reinitialize() throw();
  virtual const ::Property& getProperty(std::string const&) const throw();
  virtual ::StatusCode start() throw();
  virtual ::Gaudi::StateMachine::State FSMState() const throw();
  virtual ::StatusCode sysReinitialize() throw();
  virtual ::StatusCode finalize() throw();
  virtual ::StatusCode initialize() throw();
  virtual const ::std::string& name() const throw();
  virtual ::StatusCode configure() throw();
  virtual ::StatusCode restart() throw();
  virtual ::StatusCode sysStop() throw();
  virtual const ::std::vector<Property*>& getProperties() const throw();
  virtual ::StatusCode terminate() throw();
  virtual ::StatusCode getProperty(Property*) const throw();
  virtual ::SmartIF<ISvcLocator>& serviceLocator() const throw();
  virtual ::StatusCode sysRestart() throw();
  virtual unsigned long release() throw();
  virtual ::StatusCode sysInitialize() throw();
  virtual ::StatusCode sysFinalize() throw();
  virtual void setServiceManager(ISvcManager*) throw();
  virtual ::StatusCode setProperty(Property const&) throw();
  virtual ::StatusCode stop() throw();
  ::IntegerProperty m_outputLevel;
  ::Gaudi::StateMachine::State m_state;
  ::Gaudi::StateMachine::State m_targetState;
  ::std::string m_name;
  ::SmartIF<ISvcLocator> m_svcLocator;
  ::SmartIF<ISvcManager> m_svcManager;
  void* m_propertyMgr;
  ::SmartIF<IAuditorSvc> m_pAuditorSvc;
  ::BooleanProperty m_auditInit;
  bool m_auditorInitialize;
  bool m_auditorStart;
  bool m_auditorStop;
  bool m_auditorFinalize;
  bool m_auditorReinitialize;
  bool m_auditorRestart;
};
#ifdef __IDataSourceMgr
#undef __IDataSourceMgr
#endif
class __IDataSourceMgr : virtual public ::IInterface {
  public:
  __IDataSourceMgr();
  virtual ~__IDataSourceMgr() throw();
};
#ifdef __IDataProviderSvc
#undef __IDataProviderSvc
#endif
class __IDataProviderSvc : virtual public ::IInterface {
  public:
  __IDataProviderSvc();
  virtual ~__IDataProviderSvc() throw();
};
#ifdef __KeyedObject_unsignedslong_
#undef __KeyedObject_unsignedslong_
#endif
class __KeyedObject_unsignedslong_ : public ::ContainedObject {
  public:
  __KeyedObject_unsignedslong_();
  virtual ~__KeyedObject_unsignedslong_() throw();
  unsigned long m_key;
  long m_refCount;
  bool m_hasKey;
};
#ifdef __KeyedObject_long_
#undef __KeyedObject_long_
#endif
class __KeyedObject_long_ : public ::ContainedObject {
  public:
  __KeyedObject_long_();
  virtual ~__KeyedObject_long_() throw();
  long m_key;
  long m_refCount;
  bool m_hasKey;
};
#ifdef __KeyedObject_unsignedsint_
#undef __KeyedObject_unsignedsint_
#endif
class __KeyedObject_unsignedsint_ : public ::ContainedObject {
  public:
  __KeyedObject_unsignedsint_();
  virtual ~__KeyedObject_unsignedsint_() throw();
  unsigned int m_key;
  long m_refCount;
  bool m_hasKey;
};
#ifdef __KeyedObject_int_
#undef __KeyedObject_int_
#endif
class __KeyedObject_int_ : public ::ContainedObject {
  public:
  __KeyedObject_int_();
  virtual ~__KeyedObject_int_() throw();
  int m_key;
  long m_refCount;
  bool m_hasKey;
};
#ifdef __ITHistSvc
#undef __ITHistSvc
#endif
class __ITHistSvc : virtual public ::IService {
  public:
  __ITHistSvc();
  virtual ~__ITHistSvc() throw();
  virtual ::StatusCode getTTrees(TDirectory*, TList&, bool, bool) throw();
  virtual ::StatusCode getTTrees(TDirectory*, TList&, bool) const throw();
  virtual ::std::vector<std::basic_string<char> > getGraphs() const throw();
  virtual ::StatusCode getHist(std::string const&, TH2*&) const throw();
  virtual ::StatusCode getGraph(std::string const&, TGraph*&) const throw();
  virtual ::StatusCode regHist(std::string const&, TH1*) throw();
  virtual ::StatusCode regTree(std::string const&) throw();
  virtual bool exists(std::string const&) const throw();
  virtual ::StatusCode getHist(std::string const&, TH3*&) const throw();
  virtual ::StatusCode regGraph(std::string const&) throw();
  virtual ::StatusCode regHist(std::string const&, TH2*) throw();
  virtual ::StatusCode getTHists(TDirectory*, TList&, bool) const throw();
  virtual ::StatusCode getTTrees(std::string const&, TList&, bool) const throw();
  virtual ::StatusCode getTTrees(std::string const&, TList&, bool, bool) throw();
  virtual ::StatusCode getTHists(TDirectory*, TList&, bool, bool) throw();
  virtual ::StatusCode getTHists(std::string const&, TList&, bool, bool) throw();
  virtual ::StatusCode regGraph(std::string const&, TGraph*) throw();
  virtual ::StatusCode getTHists(std::string const&, TList&, bool) const throw();
  virtual ::StatusCode regTree(std::string const&, TTree*) throw();
  virtual ::StatusCode regHist(std::string const&) throw();
  virtual ::StatusCode regHist(std::string const&, TH3*) throw();
  virtual ::std::vector<std::basic_string<char> > getHists() const throw();
  virtual ::StatusCode getHist(std::string const&, TH1*&) const throw();
  virtual ::std::vector<std::basic_string<char> > getTrees() const throw();
  virtual ::StatusCode deReg(TObject*) throw();
  virtual ::StatusCode getTree(std::string const&, TTree*&) const throw();
  virtual ::StatusCode deReg(std::string const&) throw();
};
#ifdef __IAuditor
#undef __IAuditor
#endif
class __IAuditor : virtual public ::INamedInterface {
  public:
  __IAuditor();
  virtual ~__IAuditor() throw();
  virtual void afterFinalize(INamedInterface*) throw();
  virtual void beforeExecute(INamedInterface*) throw();
  virtual void before(IAuditor::StandardEventType, INamedInterface*) throw();
  virtual void afterEndRun(INamedInterface*) throw();
  virtual void after(IAuditor::StandardEventType, INamedInterface*, StatusCode const&) throw();
  virtual void beforeBeginRun(INamedInterface*) throw();
  virtual void after(std::string const&, INamedInterface*, StatusCode const&) throw();
  virtual void afterReinitialize(INamedInterface*) throw();
  virtual void beforeFinalize(INamedInterface*) throw();
  virtual void before(std::string const&, INamedInterface*) throw();
  virtual void after(IAuditor::StandardEventType, std::string const&, StatusCode const&) throw();
  virtual void afterInitialize(INamedInterface*) throw();
  virtual void beforeInitialize(INamedInterface*) throw();
  virtual void before(std::string const&, std::string const&) throw();
  virtual void afterExecute(INamedInterface*, StatusCode const&) throw();
  virtual void beforeEndRun(INamedInterface*) throw();
  virtual void before(IAuditor::StandardEventType, std::string const&) throw();
  virtual void afterBeginRun(INamedInterface*) throw();
  virtual bool isEnabled() const throw();
  virtual ::StatusCode sysInitialize() throw();
  virtual ::StatusCode sysFinalize() throw();
  virtual void after(std::string const&, std::string const&, StatusCode const&) throw();
  virtual void beforeReinitialize(INamedInterface*) throw();
};
#ifdef __SmartIF_IAlgorithm_
#undef __SmartIF_IAlgorithm_
#endif
class __SmartIF_IAlgorithm_ {
  public:
  __SmartIF_IAlgorithm_();
  void* m_interface;
};
#ifdef __IIncidentSvc
#undef __IIncidentSvc
#endif
class __IIncidentSvc : virtual public ::IInterface {
  public:
  __IIncidentSvc();
  virtual ~__IIncidentSvc() throw();
};
#ifdef __SmartIF_IIncidentSvc_
#undef __SmartIF_IIncidentSvc_
#endif
class __SmartIF_IIncidentSvc_ {
  public:
  __SmartIF_IIncidentSvc_();
  void* m_interface;
};
#ifdef __SmartIF_IService_
#undef __SmartIF_IService_
#endif
class __SmartIF_IService_ {
  public:
  __SmartIF_IService_();
  void* m_interface;
};
#ifdef __SmartIF_IAuditorSvc_
#undef __SmartIF_IAuditorSvc_
#endif
class __SmartIF_IAuditorSvc_ {
  public:
  __SmartIF_IAuditorSvc_();
  void* m_interface;
};
#ifdef __ISvcManager
#undef __ISvcManager
#endif
class __ISvcManager : virtual public ::IComponentManager {
  public:
  __ISvcManager();
  virtual ~__ISvcManager() throw();
  virtual ::StatusCode addService(IService*, int) throw();
  virtual ::StatusCode finalizeServices() throw();
  virtual ::SmartIF<IService>& createService(Gaudi::Utils::TypeNameString const&) throw();
  virtual ::StatusCode addService(Gaudi::Utils::TypeNameString const&, int) throw();
  virtual ::StatusCode restartServices() throw();
  virtual ::StatusCode getFactory(std::string const&, ISvcFactory const*&) const throw();
  virtual ::StatusCode declareSvcType(std::string const&, std::string const&) throw();
  virtual ::StatusCode addService(std::string const&, std::string const&, int) throw();
  virtual ::StatusCode removeService(std::string const&) throw();
  virtual ::StatusCode stopServices() throw();
  virtual ::StatusCode startServices() throw();
  virtual ::StatusCode reinitializeServices() throw();
  virtual int getPriority(std::string const&) const throw();
  virtual ::StatusCode declareSvcFactory(ISvcFactory const&, std::string const&) throw();
  virtual void setLoopCheckEnabled(bool) throw();
  virtual bool loopCheckEnabled() const throw();
  virtual ::StatusCode removeService(IService*) throw();
  virtual ::StatusCode initializeServices() throw();
  virtual ::StatusCode setPriority(std::string const&, int) throw();
  virtual ::StatusCode createService(std::string const&, std::string const&, IService*&) throw();
};
#ifdef __SmartIF_ISvcManager_
#undef __SmartIF_ISvcManager_
#endif
class __SmartIF_ISvcManager_ {
  public:
  __SmartIF_ISvcManager_();
  void* m_interface;
};
#ifdef __SmartIF_ISvcLocator_
#undef __SmartIF_ISvcLocator_
#endif
class __SmartIF_ISvcLocator_ {
  public:
  __SmartIF_ISvcLocator_();
  void* m_interface;
};
#ifdef __SmartIF_IMessageSvc_
#undef __SmartIF_IMessageSvc_
#endif
class __SmartIF_IMessageSvc_ {
  public:
  __SmartIF_IMessageSvc_();
  void* m_interface;
};
#ifdef __SmartIF_IMonitorSvc_
#undef __SmartIF_IMonitorSvc_
#endif
class __SmartIF_IMonitorSvc_ {
  public:
  __SmartIF_IMonitorSvc_();
  void* m_interface;
};
#ifdef __IAlgContextSvc
#undef __IAlgContextSvc
#endif
class __IAlgContextSvc : virtual public ::IInterface {
  public:
  __IAlgContextSvc();
  virtual ~__IAlgContextSvc() throw();
};
#ifdef __SmartIF_IAlgContextSvc_
#undef __SmartIF_IAlgContextSvc_
#endif
class __SmartIF_IAlgContextSvc_ {
  public:
  __SmartIF_IAlgContextSvc_();
  void* m_interface;
};
#ifdef __IToolSvc
#undef __IToolSvc
#endif
class __IToolSvc : virtual public ::IInterface {
  public:
  __IToolSvc();
  virtual ~__IToolSvc() throw();
};
#ifdef __SmartIF_IToolSvc_
#undef __SmartIF_IToolSvc_
#endif
class __SmartIF_IToolSvc_ {
  public:
  __SmartIF_IToolSvc_();
  void* m_interface;
};
#ifdef __SmartIF_IExceptionSvc_
#undef __SmartIF_IExceptionSvc_
#endif
class __SmartIF_IExceptionSvc_ {
  public:
  __SmartIF_IExceptionSvc_();
  void* m_interface;
};
#ifdef __IRndmGenSvc
#undef __IRndmGenSvc
#endif
class __IRndmGenSvc : virtual public ::IService {
  public:
  __IRndmGenSvc();
  virtual ~__IRndmGenSvc() throw();
  virtual ::StatusCode generator(IRndmGen::Param const&, IRndmGen*&) throw();
  virtual ::IRndmEngine* engine() throw();
};
#ifdef __SmartIF_IRndmGenSvc_
#undef __SmartIF_IRndmGenSvc_
#endif
class __SmartIF_IRndmGenSvc_ {
  public:
  __SmartIF_IRndmGenSvc_();
  void* m_interface;
};
#ifdef __IChronoStatSvc
#undef __IChronoStatSvc
#endif
class __IChronoStatSvc : virtual public ::extend_interfaces3<IService,IChronoSvc,IStatSvc> {
  public:
  __IChronoStatSvc();
  virtual ~__IChronoStatSvc() throw();
};
#ifdef __SmartIF_IChronoStatSvc_
#undef __SmartIF_IChronoStatSvc_
#endif
class __SmartIF_IChronoStatSvc_ {
  public:
  __SmartIF_IChronoStatSvc_();
  void* m_interface;
};
#ifdef __SmartIF_INTupleSvc_
#undef __SmartIF_INTupleSvc_
#endif
class __SmartIF_INTupleSvc_ {
  public:
  __SmartIF_INTupleSvc_();
  void* m_interface;
};
#ifdef __IHistogramSvc
#undef __IHistogramSvc
#endif
class __IHistogramSvc : virtual public ::IDataProviderSvc {
  public:
  __IHistogramSvc();
  virtual ~__IHistogramSvc() throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, int, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode retrieveObject(DataObject*, int, AIDA::IHistogram3D*&) throw();
  virtual ::StatusCode findObject(std::string const&, int, AIDA::IHistogram3D*&) throw();
  virtual ::StatusCode findObject(std::string const&, int, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode findObject(std::string const&, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::AIDA::IProfile1D* bookProf(DataObject*, std::string const&, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(DataObject*, int, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode unregisterObject(AIDA::IBaseHistogram*, int) throw();
  virtual ::StatusCode retrieveObject(DataObject*, int, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode unregisterObject(AIDA::IBaseHistogram*) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IHistogramFactory* histogramFactory() throw();
  virtual ::AIDA::IProfile2D* bookProf(DataObject*, int, std::string const&, int, double, double, int, double, double) throw();
  virtual ::StatusCode findObject(std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode findObject(DataObject*, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, std::string const&, std::string const&, int, double, double, double, double, std::string const&) throw();
  virtual ::AIDA::IHistogram2D* book(std::string const&, int, std::string const&, int, double, double, int, double, double) throw();
  virtual ::AIDA::IProfile2D* bookProf(std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IHistogram3D* book(DataObject*, int, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::std::ostream& write(AIDA::IBaseHistogram*, std::ostream&) const throw();
  virtual ::AIDA::IHistogram1D* book(std::string const&, int, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IHistogram1D* book(DataObject*, int, std::string const&, int, double, double) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, int, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, int, AIDA::IHistogram1D*&) throw();
  virtual ::AIDA::IHistogram2D* book(std::string const&, std::string const&, int, double, double, int, double, double) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, int, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode registerObject(std::string const&, AIDA::IBaseHistogram*) throw();
  virtual ::StatusCode retrieveObject(std::string const&, int, AIDA::IHistogram3D*&) throw();
  virtual ::AIDA::IProfile2D* bookProf(std::string const&, std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(IRegistry*, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::AIDA::IHistogram2D* book(std::string const&, std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IProfile2D* bookProf(std::string const&, int, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(std::string const&, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode retrieveObject(IRegistry*, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::StatusCode retrieveObject(DataObject*, int, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode findObject(std::string const&, int, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, int, AIDA::IProfile2D*&) throw();
  virtual ::AIDA::IHistogram2D* book(DataObject*, std::string const&, std::string const&, int, double, double, int, double, double) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, int, AIDA::IHistogram3D*&) throw();
  virtual ::AIDA::IHistogram1D* book(std::string const&, std::string const&, int, double, double) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, int, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, int, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode findObject(std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode findObject(DataObject*, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode retrieveObject(DataObject*, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, int, AIDA::IProfile1D*&) throw();
  virtual ::AIDA::IHistogram2D* book(std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(std::string const&, int, AIDA::IHistogram1D*&) throw();
  virtual ::AIDA::IHistogram2D* book(DataObject*, std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode retrieveObject(std::string const&, AIDA::IHistogram2D*&) throw();
  virtual int write(AIDA::IBaseHistogram*, char const*) const throw();
  virtual ::StatusCode retrieveObject(DataObject*, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode findObject(std::string const&, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::DataObject* createPath(std::string const&) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, int, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode findObject(std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, std::string const&, std::string const&, int, double, double, std::string const&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::AIDA::IProfile2D* bookProf(DataObject*, std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IHistogram1D* book(std::string const&, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode retrieveObject(IRegistry*, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode findObject(DataObject*, int, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::AIDA::IProfile1D* bookProf(DataObject*, int, std::string const&, int, double, double, double, double, std::string const&) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::AIDA::IProfile2D* bookProf(std::string const&, std::string const&, std::string const&, int, double, double, int, double, double) throw();
  virtual ::AIDA::IProfile2D* bookProf(std::string const&, std::string const&, int, double, double, int, double, double) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, int, std::string const&, int, double, double, double, double, std::string const&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, std::string const&, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(std::string const&, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::AIDA::IProfile1D* bookProf(DataObject*, std::string const&, std::string const&, int, double, double, double, double, std::string const&) throw();
  virtual ::StatusCode registerObject(std::string const&, int, AIDA::IBaseHistogram*) throw();
  virtual ::StatusCode retrieveObject(IRegistry*, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::AIDA::IHistogram1D* book(DataObject*, int, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(std::string const&, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, int, AIDA::IHistogram1D*&) throw();
  virtual ::DataObject* createDirectory(std::string const&, std::string const&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::AIDA::IHistogram3D* book(std::string const&, int, std::string const&, int, double, double, int, double, double, int, double, double) throw();
  virtual ::StatusCode findObject(std::string const&, int, AIDA::IProfile1D*&) throw();
  virtual ::AIDA::IProfile2D* bookProf(DataObject*, int, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(IRegistry*, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode registerObject(std::string const&, std::string const&, AIDA::IBaseHistogram*) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, std::string const&, int, double, double, std::string const&) throw();
  virtual ::AIDA::IProfile1D* bookProf(DataObject*, int, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IHistogram1D* book(std::string const&, std::string const&, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, std::string const&, int, double, double, double, double, std::string const&) throw();
  virtual ::StatusCode retrieveObject(DataObject*, int, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode unregisterObject(AIDA::IBaseHistogram*, std::string const&) throw();
  virtual ::AIDA::IProfile2D* bookProf(std::string const&, int, std::string const&, int, double, double, int, double, double) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::AIDA::IHistogram3D* book(std::string const&, int, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IHistogram3D* book(DataObject*, std::string const&, std::string const&, int, double, double, int, double, double, int, double, double) throw();
  virtual ::AIDA::IHistogram3D* book(std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IHistogram3D* book(DataObject*, std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, int, std::string const&, int, double, double, std::string const&) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::AIDA::IProfile1D* bookProf(DataObject*, std::string const&, std::string const&, int, double, double, std::string const&) throw();
  virtual ::std::ostream& print(AIDA::IBaseHistogram*, std::ostream&) const throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, int, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode findObject(DataObject*, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::AIDA::IHistogram3D* book(std::string const&, std::string const&, std::string const&, int, double, double, int, double, double, int, double, double) throw();
  virtual ::StatusCode registerObject(DataObject*, std::string const&, AIDA::IBaseHistogram*) throw();
  virtual ::StatusCode findObject(DataObject*, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::AIDA::IHistogram1D* book(DataObject*, std::string const&, std::string const&, int, double, double) throw();
  virtual ::AIDA::IHistogram3D* book(std::string const&, std::string const&, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode retrieveObject(DataObject*, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::AIDA::IHistogram1D* book(DataObject*, std::string const&, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode retrieveObject(std::string const&, int, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode retrieveObject(DataObject*, int, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode findObject(IRegistry*, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::AIDA::IHistogram3D* book(std::string const&, std::string const&, int, double, double, int, double, double, int, double, double) throw();
  virtual ::StatusCode retrieveObject(IRegistry*, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::StatusCode registerObject(DataObject*, int, AIDA::IBaseHistogram*) throw();
  virtual ::AIDA::IProfile1D* bookProf(DataObject*, int, std::string const&, int, double, double, std::string const&) throw();
  virtual ::AIDA::IHistogram1D* book(std::string const&, std::string const&, std::string const&, int, double, double) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::AIDA::IHistogram3D* book(DataObject*, int, std::string const&, int, double, double, int, double, double, int, double, double) throw();
  virtual ::AIDA::IProfile2D* bookProf(DataObject*, std::string const&, std::string const&, int, double, double, int, double, double) throw();
  virtual ::AIDA::IProfile1D* bookProf(std::string const&, int, std::string const&, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode retrieveObject(IRegistry*, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode findObject(std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::StatusCode findObject(DataObject*, int, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode findObject(DataObject*, int, AIDA::IHistogram3D*&) throw();
  virtual ::AIDA::IHistogram2D* book(DataObject*, int, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode retrieveObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode retrieveObject(std::string const&, std::string const&, AIDA::IProfile1D*&) throw();
  virtual ::AIDA::IHistogram2D* book(std::string const&, std::string const&, std::string const&, int, double, double, int, double, double) throw();
  virtual ::AIDA::IHistogram1D* book(std::string const&, int, std::string const&, int, double, double) throw();
  virtual ::StatusCode findObject(IRegistry*, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::AIDA::IHistogram2D* book(std::string const&, int, std::string const&, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >) throw();
  virtual ::StatusCode registerObject(AIDA::IBaseHistogram*, std::string const&, AIDA::IBaseHistogram*) throw();
  virtual ::StatusCode findObject(DataObject*, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::StatusCode findObject(IRegistry*, std::string const&, AIDA::IProfile2D*&) throw();
  virtual ::StatusCode registerObject(AIDA::IBaseHistogram*, int, AIDA::IBaseHistogram*) throw();
  virtual ::StatusCode findObject(std::string const&, AIDA::IHistogram2D*&) throw();
  virtual ::StatusCode retrieveObject(DataObject*, std::string const&, AIDA::IHistogram3D*&) throw();
  virtual ::AIDA::IHistogram2D* book(DataObject*, int, std::string const&, int, double, double, int, double, double) throw();
  virtual ::StatusCode retrieveObject(DataObject*, std::string const&, AIDA::IHistogram1D*&) throw();
  virtual ::StatusCode findObject(AIDA::IBaseHistogram*, int, AIDA::IHistogram3D*&) throw();
  virtual ::StatusCode findObject(DataObject*, int, AIDA::IHistogram2D*&) throw();
};
#ifdef __SmartIF_IHistogramSvc_
#undef __SmartIF_IHistogramSvc_
#endif
class __SmartIF_IHistogramSvc_ {
  public:
  __SmartIF_IHistogramSvc_();
  void* m_interface;
};
#ifdef __SmartIF_IConversionSvc_
#undef __SmartIF_IConversionSvc_
#endif
class __SmartIF_IConversionSvc_ {
  public:
  __SmartIF_IConversionSvc_();
  void* m_interface;
};
#ifdef __SmartIF_IDataProviderSvc_
#undef __SmartIF_IDataProviderSvc_
#endif
class __SmartIF_IDataProviderSvc_ {
  public:
  __SmartIF_IDataProviderSvc_();
  void* m_interface;
};
#ifdef __SmartIF_IProperty_
#undef __SmartIF_IProperty_
#endif
class __SmartIF_IProperty_ {
  public:
  __SmartIF_IProperty_();
  void* m_interface;
};
#ifdef __SmartRefBase
#undef __SmartRefBase
#endif
class __SmartRefBase {
  public:
  __SmartRefBase();
  long m_hintID;
  long m_linkID;
  void* m_data;
  void* m_contd;
  long m_type;
};
#ifdef __ICounterSvc
#undef __ICounterSvc
#endif
class __ICounterSvc : virtual public ::IInterface {
  public:
  __ICounterSvc();
  virtual ~__ICounterSvc() throw();
};
#ifdef __IDataManagerSvc
#undef __IDataManagerSvc
#endif
class __IDataManagerSvc : virtual public ::IInterface {
  public:
  __IDataManagerSvc();
  virtual ~__IDataManagerSvc() throw();
};
#ifdef __IPartPropSvc
#undef __IPartPropSvc
#endif
class __IPartPropSvc : virtual public ::IService {
  public:
  __IPartPropSvc();
  virtual ~__IPartPropSvc() throw();
  virtual void setUnknownParticleHandler(HepPDT::ProcessUnknownID*, std::string const&) throw();
  virtual ::HepPDT::ParticleDataTable* PDT() throw();
};
#ifdef __IRegistry
#undef __IRegistry
#endif
class __IRegistry {
  public:
  __IRegistry();
  virtual ~__IRegistry() throw();
};
#ifdef __IStatSvc
#undef __IStatSvc
#endif
class __IStatSvc : virtual public ::IInterface {
  public:
  __IStatSvc();
  virtual ~__IStatSvc() throw();
};
#ifdef __IEventProcessor
#undef __IEventProcessor
#endif
class __IEventProcessor : virtual public ::IInterface {
  public:
  __IEventProcessor();
  virtual ~__IEventProcessor() throw();
};
#ifdef __SmartDataPtr_ObjectContainerBase_
#undef __SmartDataPtr_ObjectContainerBase_
#endif
class __SmartDataPtr_ObjectContainerBase_ : public ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> {
  public:
  __SmartDataPtr_ObjectContainerBase_();
  virtual ~__SmartDataPtr_ObjectContainerBase_() throw();
};
#ifdef __SmartDataPtr_DataObject_
#undef __SmartDataPtr_DataObject_
#endif
class __SmartDataPtr_DataObject_ : public ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> {
  public:
  __SmartDataPtr_DataObject_();
  virtual ~__SmartDataPtr_DataObject_() throw();
};
#ifdef __IJobOptionsSvc
#undef __IJobOptionsSvc
#endif
class __IJobOptionsSvc : virtual public ::IInterface {
  public:
  __IJobOptionsSvc();
  virtual ~__IJobOptionsSvc() throw();
};
#ifdef __INTuple
#undef __INTuple
#endif
class __INTuple {
  public:
  __INTuple();
  virtual ~__INTuple() throw();
};
#ifdef __IParticlePropertySvc
#undef __IParticlePropertySvc
#endif
class __IParticlePropertySvc : virtual public ::IService {
  public:
  __IParticlePropertySvc();
  virtual ~__IParticlePropertySvc() throw();
  virtual ::StatusCode erase(std::string const&) throw();
  virtual ::ParticleProperty* find(std::string const&) throw();
  virtual ::StatusCode erase(int) throw();
  virtual ::StatusCode push_back(std::string const&, int, int, double, double, double, std::string const&, int, double) throw();
  virtual ::__gnu_cxx::__normal_iterator<ParticleProperty* const*,std::vector<ParticleProperty*> > end() const throw();
  virtual int size() const throw();
  virtual ::StatusCode push_back(ParticleProperty*) throw();
  virtual ::StatusCode eraseByStdHepID(int) throw();
  virtual ::ParticleProperty* findByPythiaID(int) throw();
  virtual ::ParticleProperty* find(int) throw();
  virtual ::ParticleProperty* findByStdHepID(int) throw();
  virtual ::__gnu_cxx::__normal_iterator<ParticleProperty* const*,std::vector<ParticleProperty*> > begin() const throw();
};
#ifdef __implements3_IAlgTool_IProperty_IStateful_
#undef __implements3_IAlgTool_IProperty_IStateful_
#endif
struct __implements3_IAlgTool_IProperty_IStateful_ : virtual public ::extend_interfaces3<IAlgTool,IProperty,IStateful> {
  public:
  __implements3_IAlgTool_IProperty_IStateful_();
  virtual ~__implements3_IAlgTool_IProperty_IStateful_() throw();
  virtual ::StatusCode queryInterface(InterfaceID const&, void**) throw();
  virtual unsigned long refCount() const throw();
  virtual ::std::vector<std::basic_string<char> > getInterfaceNames() const throw();
  virtual void* i_cast(InterfaceID const&) const throw();
  virtual unsigned long addRef() throw();
  virtual unsigned long release() throw();
  unsigned long m_refCount;
};
#ifdef __implements3_IService_IProperty_IStateful_
#undef __implements3_IService_IProperty_IStateful_
#endif
struct __implements3_IService_IProperty_IStateful_ : virtual public ::extend_interfaces3<IService,IProperty,IStateful> {
  public:
  __implements3_IService_IProperty_IStateful_();
  virtual ~__implements3_IService_IProperty_IStateful_() throw();
  virtual ::StatusCode queryInterface(InterfaceID const&, void**) throw();
  virtual unsigned long refCount() const throw();
  virtual ::std::vector<std::basic_string<char> > getInterfaceNames() const throw();
  virtual void* i_cast(InterfaceID const&) const throw();
  virtual unsigned long addRef() throw();
  virtual unsigned long release() throw();
  unsigned long m_refCount;
};
#ifdef __implements3_IAlgorithm_IProperty_IStateful_
#undef __implements3_IAlgorithm_IProperty_IStateful_
#endif
struct __implements3_IAlgorithm_IProperty_IStateful_ : virtual public ::extend_interfaces3<IAlgorithm,IProperty,IStateful> {
  public:
  __implements3_IAlgorithm_IProperty_IStateful_();
  virtual ~__implements3_IAlgorithm_IProperty_IStateful_() throw();
  virtual ::StatusCode queryInterface(InterfaceID const&, void**) throw();
  virtual unsigned long refCount() const throw();
  virtual ::std::vector<std::basic_string<char> > getInterfaceNames() const throw();
  virtual void* i_cast(InterfaceID const&) const throw();
  virtual unsigned long addRef() throw();
  virtual unsigned long release() throw();
  unsigned long m_refCount;
};
#ifdef __IEventTimeDecoder
#undef __IEventTimeDecoder
#endif
class __IEventTimeDecoder : virtual public ::IAlgTool {
  public:
  __IEventTimeDecoder();
  virtual ~__IEventTimeDecoder() throw();
  virtual ::Gaudi::Time getTime() const throw();
};
#ifdef __IStagerSvc
#undef __IStagerSvc
#endif
class __IStagerSvc : virtual public ::IInterface {
  public:
  __IStagerSvc();
  virtual ~__IStagerSvc() throw();
};
#ifdef __ICounterSummarySvc
#undef __ICounterSummarySvc
#endif
class __ICounterSummarySvc : virtual public ::IService {
  public:
  __ICounterSummarySvc();
  virtual ~__ICounterSummarySvc() throw();
  virtual void addCounter(std::string, std::string, Stat const&, Gaudi::CounterSummary::SaveType) throw();
  virtual void addCounter(std::string, std::string, StatEntity const&, Gaudi::CounterSummary::SaveType) throw();
};
#ifdef __Property
#undef __Property
#endif
class __Property {
  public:
  __Property();
  virtual ~__Property() throw();
  ::std::string m_name;
  ::std::string m_documentation;
  void* m_typeinfo;
  void* m_readCallBack;
  void* m_updateCallBack;
};
#ifdef __IHistorySvc
#undef __IHistorySvc
#endif
class __IHistorySvc : virtual public ::IService {
  public:
  __IHistorySvc();
  virtual ~__IHistorySvc() throw();
  virtual void getServiceHistory(std::set<ServiceHistory*, std::less<ServiceHistory*>, std::allocator<ServiceHistory*> >&) const throw();
  virtual ::StatusCode listProperties(IService const&) const throw();
  virtual ::JobHistory* getJobHistory() const throw();
  virtual ::DataHistory* getDataHistory(unsigned int const&, std::string const&, std::string const&) const throw();
  virtual ::DataHistory* createDataHistoryObj(unsigned int const&, std::string const&, std::string const&) throw();
  virtual ::StatusCode listProperties() const throw();
  virtual ::StatusCode registerJob() throw();
  virtual void getAlgHistory(std::set<AlgorithmHistory*, std::less<AlgorithmHistory*>, std::allocator<AlgorithmHistory*> >&) const throw();
  virtual ::AlgorithmHistory* getAlgHistory(Algorithm const&) const throw();
  virtual ::StatusCode listProperties(IAlgTool const&) const throw();
  virtual void getAlgToolHistory(std::set<AlgToolHistory*, std::less<AlgToolHistory*>, std::allocator<AlgToolHistory*> >&) const throw();
  virtual ::StatusCode registerAlg(Algorithm const&) throw();
  virtual ::StatusCode registerAlgTool(IAlgTool const&) throw();
  virtual ::AlgToolHistory* getAlgToolHistory(IAlgTool const&) const throw();
  virtual ::StatusCode registerSvc(IService const&) throw();
  virtual ::ServiceHistory* getServiceHistory(IService const&) const throw();
  virtual ::StatusCode listProperties(Algorithm const&) const throw();
};
#ifdef __IAlgManager
#undef __IAlgManager
#endif
class __IAlgManager : virtual public ::IComponentManager {
  public:
  __IAlgManager();
  virtual ~__IAlgManager() throw();
  virtual ::StatusCode finalizeAlgorithms() throw();
  virtual ::StatusCode removeAlgorithm(IAlgorithm*) throw();
  virtual ::StatusCode initializeAlgorithms() throw();
  virtual ::StatusCode restartAlgorithms() throw();
  virtual ::StatusCode stopAlgorithms() throw();
  virtual ::StatusCode addAlgorithm(IAlgorithm*) throw();
  virtual bool existsAlgorithm(std::string const&) const throw();
  virtual ::StatusCode createAlgorithm(std::string const&, std::string const&, IAlgorithm*&, bool) throw();
  virtual ::StatusCode startAlgorithms() throw();
  virtual ::StatusCode getAlgorithm(std::string const&, IAlgorithm*&) const throw();
  virtual ::SmartIF<IAlgorithm>& algorithm(Gaudi::Utils::TypeNameString const&, bool) throw();
  virtual ::StatusCode reinitializeAlgorithms() throw();
  virtual const ::std::list<IAlgorithm*>& getAlgorithms() const throw();
};
#ifdef __IChronoSvc
#undef __IChronoSvc
#endif
class __IChronoSvc : virtual public ::IInterface {
  public:
  __IChronoSvc();
  virtual ~__IChronoSvc() throw();
};
#ifdef __ISelectStatement
#undef __ISelectStatement
#endif
class __ISelectStatement : virtual public ::IInterface {
  public:
  __ISelectStatement();
  virtual ~__ISelectStatement() throw();
};
#ifdef __IMagneticFieldSvc
#undef __IMagneticFieldSvc
#endif
class __IMagneticFieldSvc : virtual public ::IService {
  public:
  __IMagneticFieldSvc();
  virtual ~__IMagneticFieldSvc() throw();
  virtual ::StatusCode fieldVector(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag> const&, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag>&) const throw();
};
#ifdef __IValidity
#undef __IValidity
#endif
class __IValidity {
  public:
  __IValidity();
  virtual ~__IValidity() throw();
};
#ifdef __IAppMgrUI
#undef __IAppMgrUI
#endif
class __IAppMgrUI : virtual public ::IInterface {
  public:
  __IAppMgrUI();
  virtual ~__IAppMgrUI() throw();
};
#ifdef __IAddressCreator
#undef __IAddressCreator
#endif
class __IAddressCreator : virtual public ::IInterface {
  public:
  __IAddressCreator();
  virtual ~__IAddressCreator() throw();
};
#ifdef __SmartRefVector_KeyedObject_unsignedslong_s_
#undef __SmartRefVector_KeyedObject_unsignedslong_s_
#endif
class __SmartRefVector_KeyedObject_unsignedslong_s_ : public ::std::vector<SmartRef<KeyedObject<unsigned long> > > {
  public:
  __SmartRefVector_KeyedObject_unsignedslong_s_();
  void* m_data;
  void* m_contd;
};
#ifdef __SmartRefVector_KeyedObject_long_s_
#undef __SmartRefVector_KeyedObject_long_s_
#endif
class __SmartRefVector_KeyedObject_long_s_ : public ::std::vector<SmartRef<KeyedObject<long> > > {
  public:
  __SmartRefVector_KeyedObject_long_s_();
  void* m_data;
  void* m_contd;
};
#ifdef __SmartRefVector_KeyedObject_unsignedsint_s_
#undef __SmartRefVector_KeyedObject_unsignedsint_s_
#endif
class __SmartRefVector_KeyedObject_unsignedsint_s_ : public ::std::vector<SmartRef<KeyedObject<unsigned int> > > {
  public:
  __SmartRefVector_KeyedObject_unsignedsint_s_();
  void* m_data;
  void* m_contd;
};
#ifdef __SmartRefVector_KeyedObject_int_s_
#undef __SmartRefVector_KeyedObject_int_s_
#endif
class __SmartRefVector_KeyedObject_int_s_ : public ::std::vector<SmartRef<KeyedObject<int> > > {
  public:
  __SmartRefVector_KeyedObject_int_s_();
  void* m_data;
  void* m_contd;
};
#ifdef __SmartRefVector_ObjectContainerBase_
#undef __SmartRefVector_ObjectContainerBase_
#endif
class __SmartRefVector_ObjectContainerBase_ : public ::std::vector<SmartRef<ObjectContainerBase> > {
  public:
  __SmartRefVector_ObjectContainerBase_();
  void* m_data;
  void* m_contd;
};
#ifdef __SmartRefVector_ContainedObject_
#undef __SmartRefVector_ContainedObject_
#endif
class __SmartRefVector_ContainedObject_ : public ::std::vector<SmartRef<ContainedObject> > {
  public:
  __SmartRefVector_ContainedObject_();
  void* m_data;
  void* m_contd;
};
#ifdef __SmartRefVector_DataObject_
#undef __SmartRefVector_DataObject_
#endif
class __SmartRefVector_DataObject_ : public ::std::vector<SmartRef<DataObject> > {
  public:
  __SmartRefVector_DataObject_();
  void* m_data;
  void* m_contd;
};
#ifdef __IStateful
#undef __IStateful
#endif
class __IStateful : virtual public ::IInterface {
  public:
  __IStateful();
  virtual ~__IStateful() throw();
};
#ifdef __IRndmGen
#undef __IRndmGen
#endif
class __IRndmGen : virtual public ::IInterface {
  public:
  __IRndmGen();
  virtual ~__IRndmGen() throw();
};
#ifdef __SmartRef_KeyedObject_unsignedslong_s_
#undef __SmartRef_KeyedObject_unsignedslong_s_
#endif
class __SmartRef_KeyedObject_unsignedslong_s_ {
  public:
  __SmartRef_KeyedObject_unsignedslong_s_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_KeyedObject_long_s_
#undef __SmartRef_KeyedObject_long_s_
#endif
class __SmartRef_KeyedObject_long_s_ {
  public:
  __SmartRef_KeyedObject_long_s_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_KeyedObject_unsignedsint_s_
#undef __SmartRef_KeyedObject_unsignedsint_s_
#endif
class __SmartRef_KeyedObject_unsignedsint_s_ {
  public:
  __SmartRef_KeyedObject_unsignedsint_s_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_KeyedObject_int_s_
#undef __SmartRef_KeyedObject_int_s_
#endif
class __SmartRef_KeyedObject_int_s_ {
  public:
  __SmartRef_KeyedObject_int_s_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_ObjectContainerBase_
#undef __SmartRef_ObjectContainerBase_
#endif
class __SmartRef_ObjectContainerBase_ {
  public:
  __SmartRef_ObjectContainerBase_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_ContainedObject_
#undef __SmartRef_ContainedObject_
#endif
class __SmartRef_ContainedObject_ {
  public:
  __SmartRef_ContainedObject_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_DataObject_
#undef __SmartRef_DataObject_
#endif
class __SmartRef_DataObject_ {
  public:
  __SmartRef_DataObject_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __LinkManager
#undef __LinkManager
#endif
class __LinkManager {
  public:
  __LinkManager();
  virtual ~__LinkManager() throw();
  ::std::vector<LinkManager::Link*> m_linkVector;
};
#ifdef __INamedInterface
#undef __INamedInterface
#endif
class __INamedInterface : virtual public ::IInterface {
  public:
  __INamedInterface();
  virtual ~__INamedInterface() throw();
};
#ifdef __IOpaqueAddress
#undef __IOpaqueAddress
#endif
class __IOpaqueAddress {
  public:
  __IOpaqueAddress();
  virtual ~__IOpaqueAddress() throw();
};
#ifdef __IRunable
#undef __IRunable
#endif
class __IRunable : virtual public ::IInterface {
  public:
  __IRunable();
  virtual ~__IRunable() throw();
};
#ifdef __StatusCode
#undef __StatusCode
#endif
class __StatusCode {
  public:
  __StatusCode();
  unsigned long d_code;
  bool m_checked;
  void* m_severity;
};
#ifdef __Algorithm
#undef __Algorithm
#endif
class __Algorithm : public ::implements3<IAlgorithm,IProperty,IStateful> {
  public:
  __Algorithm();
  virtual ~__Algorithm() throw();
  virtual ::StatusCode endRun() throw();
  virtual ::StatusCode sysExecute() throw();
  virtual ::StatusCode sysStart() throw();
  virtual void setFilterPassed(bool) throw();
  virtual ::StatusCode getProperty(Property*) const throw();
  virtual ::StatusCode setProperty(std::string const&) throw();
  virtual ::StatusCode beginRun() throw();
  virtual ::Gaudi::StateMachine::State targetFSMState() const throw();
  virtual ::StatusCode sysBeginRun() throw();
  virtual void setExecuted(bool) throw();
  virtual bool isExecuted() const throw();
  virtual ::StatusCode getProperty(std::string const&, std::string&) const throw();
  virtual ::StatusCode reinitialize() throw();
  virtual const ::Property& getProperty(std::string const&) const throw();
  virtual ::StatusCode start() throw();
  virtual ::Gaudi::StateMachine::State FSMState() const throw();
  virtual ::StatusCode sysReinitialize() throw();
  virtual ::StatusCode setProperty(std::string const&, std::string const&) throw();
  virtual bool isFinalized() const throw();
  virtual bool filterPassed() const throw();
  virtual ::StatusCode initialize() throw();
  virtual const ::std::string& name() const throw();
  virtual ::StatusCode configure() throw();
  virtual ::StatusCode restart() throw();
  virtual bool isInitialized() const throw();
  virtual ::StatusCode sysInitialize() throw();
  virtual const ::std::vector<Property*>& getProperties() const throw();
  virtual ::StatusCode terminate() throw();
  virtual void resetExecuted() throw();
  virtual bool isEnabled() const throw();
  virtual const ::std::string& version() const throw();
  virtual ::StatusCode sysRestart() throw();
  virtual ::StatusCode sysFinalize() throw();
  virtual ::StatusCode sysStop() throw();
  virtual ::StatusCode finalize() throw();
  virtual ::StatusCode sysEndRun() throw();
  virtual ::StatusCode setProperty(Property const&) throw();
  virtual ::StatusCode stop() throw();
  ::std::string m_name;
  ::std::string m_version;
  void* m_subAlgms;
  ::SmartIF<IMessageSvc> m_MS;
  ::SmartIF<IDataProviderSvc> m_EDS;
  ::SmartIF<IConversionSvc> m_ECS;
  ::SmartIF<IDataProviderSvc> m_DDS;
  ::SmartIF<IConversionSvc> m_DCS;
  ::SmartIF<IHistogramSvc> m_HDS;
  ::SmartIF<INTupleSvc> m_NTS;
  ::SmartIF<IChronoStatSvc> m_CSS;
  ::SmartIF<IRndmGenSvc> m_RGS;
  ::SmartIF<IExceptionSvc> m_EXS;
  ::SmartIF<IAuditorSvc> m_pAuditorSvc;
  ::SmartIF<IToolSvc> m_ptoolSvc;
  ::SmartIF<IMonitorSvc> m_pMonitorSvc;
  ::SmartIF<IAlgContextSvc> m_contextSvc;
  bool m_registerContext;
  ::std::string m_monitorSvcName;
  ::SmartIF<ISvcLocator> m_pSvcLocator;
  void* m_propertyMgr;
  ::IntegerProperty m_outputLevel;
  int m_errorMax;
  int m_errorCount;
  ::BooleanProperty m_auditInit;
  bool m_auditorInitialize;
  bool m_auditorReinitialize;
  bool m_auditorRestart;
  bool m_auditorExecute;
  bool m_auditorFinalize;
  bool m_auditorBeginRun;
  bool m_auditorEndRun;
  bool m_auditorStart;
  bool m_auditorStop;
  bool m_filterPassed;
  bool m_isEnabled;
  bool m_isExecuted;
  ::Gaudi::StateMachine::State m_state;
  ::Gaudi::StateMachine::State m_targetState;
  bool m_isFinalized;
};
#ifdef __IIssueLogger
#undef __IIssueLogger
#endif
class __IIssueLogger : virtual public ::IService {
  public:
  __IIssueLogger();
  virtual ~__IIssueLogger() throw();
  virtual void report(IssueSeverity const&) throw();
  virtual void report(IssueSeverity::Level, std::string const&, std::string const&) throw();
};
#ifdef __IInspectable
#undef __IInspectable
#endif
class __IInspectable {
  public:
  __IInspectable();
  virtual ~__IInspectable() throw();
};
#ifdef __std__vector_ContainedObjectp_
#undef __std__vector_ContainedObjectp_
#endif
class __std__vector_ContainedObjectp_ : protected ::std::_Vector_base<ContainedObject*,std::allocator<ContainedObject*> > {
  public:
  __std__vector_ContainedObjectp_();
};
#ifdef __std__vector_constsContainedObjectp_
#undef __std__vector_constsContainedObjectp_
#endif
class __std__vector_constsContainedObjectp_ : protected ::std::_Vector_base<const ContainedObject*,std::allocator<const ContainedObject*> > {
  public:
  __std__vector_constsContainedObjectp_();
};
#ifdef __std__vector_LinkManager__Linkp_
#undef __std__vector_LinkManager__Linkp_
#endif
class __std__vector_LinkManager__Linkp_ : protected ::std::_Vector_base<LinkManager::Link*,std::allocator<LinkManager::Link*> > {
  public:
  __std__vector_LinkManager__Linkp_();
};
#ifdef __std__vector_SmartRef_KeyedObject_unsignedslong_s_s_
#undef __std__vector_SmartRef_KeyedObject_unsignedslong_s_s_
#endif
class __std__vector_SmartRef_KeyedObject_unsignedslong_s_s_ : protected ::std::_Vector_base<SmartRef<KeyedObject<unsigned long> >,std::allocator<SmartRef<KeyedObject<unsigned long> > > > {
  public:
  __std__vector_SmartRef_KeyedObject_unsignedslong_s_s_();
};
#ifdef __std__vector_SmartRef_KeyedObject_long_s_s_
#undef __std__vector_SmartRef_KeyedObject_long_s_s_
#endif
class __std__vector_SmartRef_KeyedObject_long_s_s_ : protected ::std::_Vector_base<SmartRef<KeyedObject<long> >,std::allocator<SmartRef<KeyedObject<long> > > > {
  public:
  __std__vector_SmartRef_KeyedObject_long_s_s_();
};
#ifdef __std__vector_SmartRef_KeyedObject_unsignedsint_s_s_
#undef __std__vector_SmartRef_KeyedObject_unsignedsint_s_s_
#endif
class __std__vector_SmartRef_KeyedObject_unsignedsint_s_s_ : protected ::std::_Vector_base<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > {
  public:
  __std__vector_SmartRef_KeyedObject_unsignedsint_s_s_();
};
#ifdef __std__vector_SmartRef_KeyedObject_int_s_s_
#undef __std__vector_SmartRef_KeyedObject_int_s_s_
#endif
class __std__vector_SmartRef_KeyedObject_int_s_s_ : protected ::std::_Vector_base<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > {
  public:
  __std__vector_SmartRef_KeyedObject_int_s_s_();
};
#ifdef __std__vector_SmartRef_ObjectContainerBase_s_
#undef __std__vector_SmartRef_ObjectContainerBase_s_
#endif
class __std__vector_SmartRef_ObjectContainerBase_s_ : protected ::std::_Vector_base<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > {
  public:
  __std__vector_SmartRef_ObjectContainerBase_s_();
};
#ifdef __std__vector_SmartRef_ContainedObject_s_
#undef __std__vector_SmartRef_ContainedObject_s_
#endif
class __std__vector_SmartRef_ContainedObject_s_ : protected ::std::_Vector_base<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > {
  public:
  __std__vector_SmartRef_ContainedObject_s_();
};
#ifdef __std__vector_SmartRef_DataObject_s_
#undef __std__vector_SmartRef_DataObject_s_
#endif
class __std__vector_SmartRef_DataObject_s_ : protected ::std::_Vector_base<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > {
  public:
  __std__vector_SmartRef_DataObject_s_();
};
#ifdef __std__basic_string_char_
#undef __std__basic_string_char_
#endif
struct __std__basic_string_char_ {
  public:
  __std__basic_string_char_();
#ifdef __std__basic_string_char____Rep_base
#undef __std__basic_string_char____Rep_base
#endif
  struct __std__basic_string_char____Rep_base {
    public:
    __std__basic_string_char____Rep_base();
    ::std::size_t _M_length;
    ::std::size_t _M_capacity;
    ::_Atomic_word _M_refcount;
  };
#ifdef __std__basic_string_char____Rep
#undef __std__basic_string_char____Rep
#endif
  struct __std__basic_string_char____Rep :   public __std__basic_string_char____Rep_base   {
    public:
    __std__basic_string_char____Rep();
  };
#ifdef __std__basic_string_char____Alloc_hider
#undef __std__basic_string_char____Alloc_hider
#endif
  struct __std__basic_string_char____Alloc_hider :   public ::std::allocator<char>   {
    public:
    __std__basic_string_char____Alloc_hider();
    void* _M_p;
  };
  __std__basic_string_char____Alloc_hider _M_dataplus;
};
#ifdef __Rndm__Binomial
#undef __Rndm__Binomial
#endif
class __Rndm__Binomial : public ::IRndmGen::Param {
  public:
  __Rndm__Binomial();
  virtual ~__Rndm__Binomial() throw();
  long m_nEvent;
  double m_probability;
};
#ifdef __Rndm__Bit
#undef __Rndm__Bit
#endif
class __Rndm__Bit : public ::IRndmGen::Param {
  public:
  __Rndm__Bit();
  virtual ~__Rndm__Bit() throw();
};
#ifdef __Rndm__StudentT
#undef __Rndm__StudentT
#endif
class __Rndm__StudentT : public ::IRndmGen::Param {
  public:
  __Rndm__StudentT();
  virtual ~__Rndm__StudentT() throw();
  double m_aValue;
};
#ifdef __Rndm__DefinedPdf
#undef __Rndm__DefinedPdf
#endif
class __Rndm__DefinedPdf : public ::IRndmGen::Param {
  public:
  __Rndm__DefinedPdf();
  virtual ~__Rndm__DefinedPdf() throw();
  ::std::vector<double> m_pdf;
  long m_interpolation;
};
#ifdef __Rndm__Gamma
#undef __Rndm__Gamma
#endif
class __Rndm__Gamma : public ::IRndmGen::Param {
  public:
  __Rndm__Gamma();
  virtual ~__Rndm__Gamma() throw();
  double m_kValue;
  double m_lambda;
};
#ifdef __Rndm__Exponential
#undef __Rndm__Exponential
#endif
class __Rndm__Exponential : public ::IRndmGen::Param {
  public:
  __Rndm__Exponential();
  virtual ~__Rndm__Exponential() throw();
  double m_mean;
};
#ifdef __Rndm__Gauss
#undef __Rndm__Gauss
#endif
class __Rndm__Gauss : public ::IRndmGen::Param {
  public:
  __Rndm__Gauss();
  virtual ~__Rndm__Gauss() throw();
  double m_mean;
  double m_sigma;
};
#ifdef __Rndm__BreitWignerCutOff
#undef __Rndm__BreitWignerCutOff
#endif
class __Rndm__BreitWignerCutOff : public ::IRndmGen::Param {
  public:
  __Rndm__BreitWignerCutOff();
  virtual ~__Rndm__BreitWignerCutOff() throw();
  double m_mean;
  double m_gamma;
  double m_cut;
};
#ifdef __Rndm__Poisson
#undef __Rndm__Poisson
#endif
class __Rndm__Poisson : public ::IRndmGen::Param {
  public:
  __Rndm__Poisson();
  virtual ~__Rndm__Poisson() throw();
  double m_mean;
};
#ifdef __Rndm__BreitWigner
#undef __Rndm__BreitWigner
#endif
class __Rndm__BreitWigner : public ::IRndmGen::Param {
  public:
  __Rndm__BreitWigner();
  virtual ~__Rndm__BreitWigner() throw();
  double m_mean;
  double m_gamma;
};
#ifdef __Rndm__Chi2
#undef __Rndm__Chi2
#endif
class __Rndm__Chi2 : public ::IRndmGen::Param {
  public:
  __Rndm__Chi2();
  virtual ~__Rndm__Chi2() throw();
  long m_nDOF;
};
#ifdef __Rndm__GaussianTail
#undef __Rndm__GaussianTail
#endif
class __Rndm__GaussianTail : public ::IRndmGen::Param {
  public:
  __Rndm__GaussianTail();
  virtual ~__Rndm__GaussianTail() throw();
  double m_cut;
  double m_sigma;
};
#ifdef __Rndm__Flat
#undef __Rndm__Flat
#endif
class __Rndm__Flat : public ::IRndmGen::Param {
  public:
  __Rndm__Flat();
  virtual ~__Rndm__Flat() throw();
  double m_minimum;
  double m_maximum;
};
#ifdef __Rndm__Landau
#undef __Rndm__Landau
#endif
class __Rndm__Landau : public ::IRndmGen::Param {
  public:
  __Rndm__Landau();
  virtual ~__Rndm__Landau() throw();
  double m_mean;
  double m_sigma;
};
#ifdef __Rndm__Numbers
#undef __Rndm__Numbers
#endif
class __Rndm__Numbers {
  public:
  __Rndm__Numbers();
  virtual ~__Rndm__Numbers() throw();
  void* m_generator;
};
#ifdef __Gaudi__Time
#undef __Gaudi__Time
#endif
class __Gaudi__Time {
  public:
  __Gaudi__Time();
  ::longlong m_nsecs;
};
#ifdef __SmartDataObjectPtr__ObjectLoader
#undef __SmartDataObjectPtr__ObjectLoader
#endif
class __SmartDataObjectPtr__ObjectLoader {
  public:
  __SmartDataObjectPtr__ObjectLoader();
};
#ifdef __SmartDataObjectPtr__ObjectFinder
#undef __SmartDataObjectPtr__ObjectFinder
#endif
class __SmartDataObjectPtr__ObjectFinder {
  public:
  __SmartDataObjectPtr__ObjectFinder();
};
#ifdef __IUpdateManagerSvc__PythonHelper
#undef __IUpdateManagerSvc__PythonHelper
#endif
class __IUpdateManagerSvc__PythonHelper {
  public:
  __IUpdateManagerSvc__PythonHelper();
};
#ifdef __NTuple__Array_double_
#undef __NTuple__Array_double_
#endif
class __NTuple__Array_double_ : virtual public ::NTuple::_Accessor<NTuple::_Array<double> > {
  public:
  __NTuple__Array_double_();
  virtual ~__NTuple__Array_double_() throw();
};
#ifdef __NTuple__Matrix_unsignedsshort_
#undef __NTuple__Matrix_unsignedsshort_
#endif
class __NTuple__Matrix_unsignedsshort_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<unsigned short> > {
  public:
  __NTuple__Matrix_unsignedsshort_();
  virtual ~__NTuple__Matrix_unsignedsshort_() throw();
};
#ifdef __NTuple__Array_unsignedschar_
#undef __NTuple__Array_unsignedschar_
#endif
class __NTuple__Array_unsignedschar_ : virtual public ::NTuple::_Accessor<NTuple::_Array<unsigned char> > {
  public:
  __NTuple__Array_unsignedschar_();
  virtual ~__NTuple__Array_unsignedschar_() throw();
};
#ifdef __NTuple__Matrix_char_
#undef __NTuple__Matrix_char_
#endif
class __NTuple__Matrix_char_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<char> > {
  public:
  __NTuple__Matrix_char_();
  virtual ~__NTuple__Matrix_char_() throw();
};
#ifdef __NTuple__Matrix_unsignedsint_
#undef __NTuple__Matrix_unsignedsint_
#endif
class __NTuple__Matrix_unsignedsint_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<unsigned int> > {
  public:
  __NTuple__Matrix_unsignedsint_();
  virtual ~__NTuple__Matrix_unsignedsint_() throw();
};
#ifdef __NTuple__Array_float_
#undef __NTuple__Array_float_
#endif
class __NTuple__Array_float_ : virtual public ::NTuple::_Accessor<NTuple::_Array<float> > {
  public:
  __NTuple__Array_float_();
  virtual ~__NTuple__Array_float_() throw();
};
#ifdef __NTuple__Array_bool_
#undef __NTuple__Array_bool_
#endif
class __NTuple__Array_bool_ : virtual public ::NTuple::_Accessor<NTuple::_Array<bool> > {
  public:
  __NTuple__Array_bool_();
  virtual ~__NTuple__Array_bool_() throw();
};
#ifdef __NTuple__Array_int_
#undef __NTuple__Array_int_
#endif
class __NTuple__Array_int_ : virtual public ::NTuple::_Accessor<NTuple::_Array<int> > {
  public:
  __NTuple__Array_int_();
  virtual ~__NTuple__Array_int_() throw();
};
#ifdef __NTuple__Matrix_int_
#undef __NTuple__Matrix_int_
#endif
class __NTuple__Matrix_int_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<int> > {
  public:
  __NTuple__Matrix_int_();
  virtual ~__NTuple__Matrix_int_() throw();
};
#ifdef __NTuple__Matrix_double_
#undef __NTuple__Matrix_double_
#endif
class __NTuple__Matrix_double_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<double> > {
  public:
  __NTuple__Matrix_double_();
  virtual ~__NTuple__Matrix_double_() throw();
};
#ifdef __NTuple__Array_unsignedslong_
#undef __NTuple__Array_unsignedslong_
#endif
class __NTuple__Array_unsignedslong_ : virtual public ::NTuple::_Accessor<NTuple::_Array<unsigned long> > {
  public:
  __NTuple__Array_unsignedslong_();
  virtual ~__NTuple__Array_unsignedslong_() throw();
};
#ifdef __NTuple__Matrix_unsignedschar_
#undef __NTuple__Matrix_unsignedschar_
#endif
class __NTuple__Matrix_unsignedschar_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<unsigned char> > {
  public:
  __NTuple__Matrix_unsignedschar_();
  virtual ~__NTuple__Matrix_unsignedschar_() throw();
};
#ifdef __NTuple__Matrix_short_
#undef __NTuple__Matrix_short_
#endif
class __NTuple__Matrix_short_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<short> > {
  public:
  __NTuple__Matrix_short_();
  virtual ~__NTuple__Matrix_short_() throw();
};
#ifdef __NTuple__File
#undef __NTuple__File
#endif
class __NTuple__File : public ::NTuple::Directory {
  public:
  __NTuple__File();
  virtual ~__NTuple__File() throw();
  virtual const ::CLID& clID() const throw();
  ::std::string m_name;
  ::std::string m_logName;
  long m_type;
  bool m_isOpen;
};
#ifdef __NTuple__Item_double_
#undef __NTuple__Item_double_
#endif
class __NTuple__Item_double_ : virtual public ::NTuple::_Accessor<NTuple::_Item<double> > {
  public:
  __NTuple__Item_double_();
  virtual ~__NTuple__Item_double_() throw();
};
#ifdef __NTuple__Array_long_
#undef __NTuple__Array_long_
#endif
class __NTuple__Array_long_ : virtual public ::NTuple::_Accessor<NTuple::_Array<long> > {
  public:
  __NTuple__Array_long_();
  virtual ~__NTuple__Array_long_() throw();
};
#ifdef __NTuple__Item_bool_
#undef __NTuple__Item_bool_
#endif
class __NTuple__Item_bool_ : virtual public ::NTuple::_Accessor<NTuple::_Item<bool> > {
  public:
  __NTuple__Item_bool_();
  virtual ~__NTuple__Item_bool_() throw();
};
#ifdef __NTuple__Item_float_
#undef __NTuple__Item_float_
#endif
class __NTuple__Item_float_ : virtual public ::NTuple::_Accessor<NTuple::_Item<float> > {
  public:
  __NTuple__Item_float_();
  virtual ~__NTuple__Item_float_() throw();
};
#ifdef __NTuple__Item_unsignedsint_
#undef __NTuple__Item_unsignedsint_
#endif
class __NTuple__Item_unsignedsint_ : virtual public ::NTuple::_Accessor<NTuple::_Item<unsigned int> > {
  public:
  __NTuple__Item_unsignedsint_();
  virtual ~__NTuple__Item_unsignedsint_() throw();
};
#ifdef __NTuple__Item_int_
#undef __NTuple__Item_int_
#endif
class __NTuple__Item_int_ : virtual public ::NTuple::_Accessor<NTuple::_Item<int> > {
  public:
  __NTuple__Item_int_();
  virtual ~__NTuple__Item_int_() throw();
};
#ifdef __NTuple__Item_unsignedslongslong_
#undef __NTuple__Item_unsignedslongslong_
#endif
class __NTuple__Item_unsignedslongslong_ : virtual public ::NTuple::_Accessor<NTuple::_Item<unsigned long long> > {
  public:
  __NTuple__Item_unsignedslongslong_();
  virtual ~__NTuple__Item_unsignedslongslong_() throw();
};
#ifdef __NTuple__Item_unsignedslong_
#undef __NTuple__Item_unsignedslong_
#endif
class __NTuple__Item_unsignedslong_ : virtual public ::NTuple::_Accessor<NTuple::_Item<unsigned long> > {
  public:
  __NTuple__Item_unsignedslong_();
  virtual ~__NTuple__Item_unsignedslong_() throw();
};
#ifdef __NTuple__Item_longslong_
#undef __NTuple__Item_longslong_
#endif
class __NTuple__Item_longslong_ : virtual public ::NTuple::_Accessor<NTuple::_Item<long long> > {
  public:
  __NTuple__Item_longslong_();
  virtual ~__NTuple__Item_longslong_() throw();
};
#ifdef __NTuple__Item_long_
#undef __NTuple__Item_long_
#endif
class __NTuple__Item_long_ : virtual public ::NTuple::_Accessor<NTuple::_Item<long> > {
  public:
  __NTuple__Item_long_();
  virtual ~__NTuple__Item_long_() throw();
};
#ifdef __NTuple__Item_unsignedsshort_
#undef __NTuple__Item_unsignedsshort_
#endif
class __NTuple__Item_unsignedsshort_ : virtual public ::NTuple::_Accessor<NTuple::_Item<unsigned short> > {
  public:
  __NTuple__Item_unsignedsshort_();
  virtual ~__NTuple__Item_unsignedsshort_() throw();
};
#ifdef __NTuple__Item_short_
#undef __NTuple__Item_short_
#endif
class __NTuple__Item_short_ : virtual public ::NTuple::_Accessor<NTuple::_Item<short> > {
  public:
  __NTuple__Item_short_();
  virtual ~__NTuple__Item_short_() throw();
};
#ifdef __NTuple__Item_unsignedschar_
#undef __NTuple__Item_unsignedschar_
#endif
class __NTuple__Item_unsignedschar_ : virtual public ::NTuple::_Accessor<NTuple::_Item<unsigned char> > {
  public:
  __NTuple__Item_unsignedschar_();
  virtual ~__NTuple__Item_unsignedschar_() throw();
};
#ifdef __NTuple__Item_char_
#undef __NTuple__Item_char_
#endif
class __NTuple__Item_char_ : virtual public ::NTuple::_Accessor<NTuple::_Item<char> > {
  public:
  __NTuple__Item_char_();
  virtual ~__NTuple__Item_char_() throw();
};
#ifdef __NTuple__ColumnWiseTuple
#undef __NTuple__ColumnWiseTuple
#endif
class __NTuple__ColumnWiseTuple : public ::NTuple::TupleImp {
  public:
  __NTuple__ColumnWiseTuple();
  virtual ~__NTuple__ColumnWiseTuple() throw();
  virtual const ::CLID& clID() const throw();
};
#ifdef __NTuple__Matrix_float_
#undef __NTuple__Matrix_float_
#endif
class __NTuple__Matrix_float_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<float> > {
  public:
  __NTuple__Matrix_float_();
  virtual ~__NTuple__Matrix_float_() throw();
};
#ifdef __NTuple__Array_char_
#undef __NTuple__Array_char_
#endif
class __NTuple__Array_char_ : virtual public ::NTuple::_Accessor<NTuple::_Array<char> > {
  public:
  __NTuple__Array_char_();
  virtual ~__NTuple__Array_char_() throw();
};
#ifdef __NTuple__Matrix_long_
#undef __NTuple__Matrix_long_
#endif
class __NTuple__Matrix_long_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<long> > {
  public:
  __NTuple__Matrix_long_();
  virtual ~__NTuple__Matrix_long_() throw();
};
#ifdef __NTuple__Matrix_unsignedslong_
#undef __NTuple__Matrix_unsignedslong_
#endif
class __NTuple__Matrix_unsignedslong_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<unsigned long> > {
  public:
  __NTuple__Matrix_unsignedslong_();
  virtual ~__NTuple__Matrix_unsignedslong_() throw();
};
#ifdef __NTuple__Matrix_bool_
#undef __NTuple__Matrix_bool_
#endif
class __NTuple__Matrix_bool_ : virtual public ::NTuple::_Accessor<NTuple::_Matrix<bool> > {
  public:
  __NTuple__Matrix_bool_();
  virtual ~__NTuple__Matrix_bool_() throw();
};
#ifdef __NTuple__Matrix_IOpaqueAddressp_
#undef __NTuple__Matrix_IOpaqueAddressp_
#endif
class __NTuple__Matrix_IOpaqueAddressp_ {
  public:
  __NTuple__Matrix_IOpaqueAddressp_();
  virtual ~__NTuple__Matrix_IOpaqueAddressp_() throw();
};
#ifdef __NTuple__Array_unsignedsint_
#undef __NTuple__Array_unsignedsint_
#endif
class __NTuple__Array_unsignedsint_ : virtual public ::NTuple::_Accessor<NTuple::_Array<unsigned int> > {
  public:
  __NTuple__Array_unsignedsint_();
  virtual ~__NTuple__Array_unsignedsint_() throw();
};
#ifdef __NTuple__Directory
#undef __NTuple__Directory
#endif
class __NTuple__Directory : public ::DataObject {
  public:
  __NTuple__Directory();
  virtual ~__NTuple__Directory() throw();
};
#ifdef __NTuple__Array_unsignedsshort_
#undef __NTuple__Array_unsignedsshort_
#endif
class __NTuple__Array_unsignedsshort_ : virtual public ::NTuple::_Accessor<NTuple::_Array<unsigned short> > {
  public:
  __NTuple__Array_unsignedsshort_();
  virtual ~__NTuple__Array_unsignedsshort_() throw();
};
#ifdef __NTuple__Array_short_
#undef __NTuple__Array_short_
#endif
class __NTuple__Array_short_ : virtual public ::NTuple::_Accessor<NTuple::_Array<short> > {
  public:
  __NTuple__Array_short_();
  virtual ~__NTuple__Array_short_() throw();
};
#ifdef __NTuple__Array_IOpaqueAddressp_
#undef __NTuple__Array_IOpaqueAddressp_
#endif
class __NTuple__Array_IOpaqueAddressp_ {
  public:
  __NTuple__Array_IOpaqueAddressp_();
  virtual ~__NTuple__Array_IOpaqueAddressp_() throw();
};
#ifdef __NTuple__RowWiseTuple
#undef __NTuple__RowWiseTuple
#endif
class __NTuple__RowWiseTuple : public ::NTuple::TupleImp {
  public:
  __NTuple__RowWiseTuple();
  virtual ~__NTuple__RowWiseTuple() throw();
  virtual const ::CLID& clID() const throw();
};
#ifdef __IRndmGen__Param
#undef __IRndmGen__Param
#endif
class __IRndmGen__Param {
  public:
  __IRndmGen__Param();
  virtual ~__IRndmGen__Param() throw();
  ::InterfaceID m_type;
};
#ifdef __LinkManager__Link
#undef __LinkManager__Link
#endif
class __LinkManager__Link {
  public:
  __LinkManager__Link();
  virtual ~__LinkManager__Link() throw();
  ::std::string m_path;
  void* m_pObject;
  long m_id;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class IInterface -------------------------------
static  void operator_6953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IInterface*)o)->operator=)(*(const ::IInterface*)arg[0]);
  else   (((::IInterface*)o)->operator=)(*(const ::IInterface*)arg[0]);
}

static  void method_6956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IInterface*)o)->interfaceID)();
  else   (((::IInterface*)o)->interfaceID)();
}

static  void method_6957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IInterface*)o)->i_cast)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::IInterface*)o)->i_cast)(*(const ::InterfaceID*)arg[0]);
}

static  void method_6958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::IInterface*)o)->getInterfaceNames)());
  else   (((const ::IInterface*)o)->getInterfaceNames)();
}

static  void method_6959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::IInterface*)o)->addRef)());
  else   (((::IInterface*)o)->addRef)();
}

static  void method_6960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::IInterface*)o)->release)());
  else   (((::IInterface*)o)->release)();
}

static  void method_6961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::IInterface*)o)->refCount)());
  else   (((const ::IInterface*)o)->refCount)();
}

static  void method_6962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IInterface*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::IInterface*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static void destructor_6963(void*, void * o, const std::vector<void*>&, void *) {
(((::IInterface*)o)->::IInterface::~IInterface)();
}
//------Dictionary for class IInterface -------------------------------
void __IInterface_db_datamem(Reflex::Class*);
void __IInterface_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IInterface_datamem_bld(&__IInterface_db_datamem);
Reflex::GenreflexMemberBuilder __IInterface_funcmem_bld(&__IInterface_db_funcmem);
void __IInterface_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IInterface"), typeid(::IInterface), sizeof(::IInterface), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("IInterface::Status"), Reflex::Literal("SUCCESS=1;NO_INTERFACE=2;VERSMISMATCH=3;LAST_ERROR=4"), &typeid(IInterface::Status), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24119, type_24120), Reflex::Literal("operator="), operator_6953, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IInterface"), destructor_6963, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IInterface_funcmem_bld);
}

//------Delayed data member builder for class IInterface -------------------
void __IInterface_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IInterface -------------------
void __IInterface_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6956, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7851), Reflex::Literal("i_cast"), method_6957, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getInterfaceNames"), method_6958, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_6959, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_6960, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_6961, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_6962, 0, "ti;pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class extend_interfaces1<IInterface> -------------------------------
static  void operator_4145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::extend_interfaces1<IInterface>*)o)->operator=)(*(const ::extend_interfaces1<IInterface>*)arg[0]);
  else   (((::extend_interfaces1<IInterface>*)o)->operator=)(*(const ::extend_interfaces1<IInterface>*)arg[0]);
}

static void destructor_4148(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces1<IInterface>*)o)->::extend_interfaces1<IInterface>::~extend_interfaces1)();
}
static void method_x0( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces1<IInterface>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces1<IInterface> -------------------------------
void __extend_interfaces1_IInterface__db_datamem(Reflex::Class*);
void __extend_interfaces1_IInterface__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces1_IInterface__datamem_bld(&__extend_interfaces1_IInterface__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces1_IInterface__funcmem_bld(&__extend_interfaces1_IInterface__db_funcmem);
void __extend_interfaces1_IInterface__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces1<IInterface>"), typeid(::extend_interfaces1<IInterface>), sizeof(::extend_interfaces1<IInterface>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_1730, ::Reflex::BaseOffset< ::extend_interfaces1<IInterface>, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19268, type_19269), Reflex::Literal("operator="), operator_4145, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces1"), destructor_4148, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces1<IInterface> -------------------
void __extend_interfaces1_IInterface__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces1<IInterface> -------------------
void __extend_interfaces1_IInterface__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IDataStreamTool -------------------------------
static  void operator_4802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataStreamTool*)o)->operator=)(*(const ::IDataStreamTool*)arg[0]);
  else   (((::IDataStreamTool*)o)->operator=)(*(const ::IDataStreamTool*)arg[0]);
}

static  void method_4805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataStreamTool*)o)->interfaceID)();
  else   (((::IDataStreamTool*)o)->interfaceID)();
}

static  void method_4806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->initializeStream)((::EventSelectorDataStream*)arg[0]));
  else   (((::IDataStreamTool*)o)->initializeStream)((::EventSelectorDataStream*)arg[0]);
}

static  void method_4807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->finalizeStream)((::EventSelectorDataStream*)arg[0]));
  else   (((::IDataStreamTool*)o)->finalizeStream)((::EventSelectorDataStream*)arg[0]);
}

static  void method_4808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->getNextStream)(*(const ::EventSelectorDataStream**)arg[0],
    *(long*)arg[1]));
  else   (((::IDataStreamTool*)o)->getNextStream)(*(const ::EventSelectorDataStream**)arg[0],
    *(long*)arg[1]);
}

static  void method_4809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->getPreviousStream)(*(const ::EventSelectorDataStream**)arg[0],
    *(long*)arg[1]));
  else   (((::IDataStreamTool*)o)->getPreviousStream)(*(const ::EventSelectorDataStream**)arg[0],
    *(long*)arg[1]);
}

static  void method_4810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->addStream)(*(const ::std::string*)arg[0]));
  else   (((::IDataStreamTool*)o)->addStream)(*(const ::std::string*)arg[0]);
}

static  void method_4811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->addStreams)(*(const ::std::vector<std::basic_string<char> >*)arg[0]));
  else   (((::IDataStreamTool*)o)->addStreams)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_4812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->eraseStream)(*(const ::std::string*)arg[0]));
  else   (((::IDataStreamTool*)o)->eraseStream)(*(const ::std::string*)arg[0]);
}

static  void method_4813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IDataStreamTool*)o)->getStream)(*(long*)arg[0]));
  else   (((::IDataStreamTool*)o)->getStream)(*(long*)arg[0]);
}

static  void method_4814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IDataStreamTool*)o)->getStream)(*(const ::std::string*)arg[0]));
  else   (((::IDataStreamTool*)o)->getStream)(*(const ::std::string*)arg[0]);
}

static  void method_4815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IDataStreamTool*)o)->lastStream)());
  else   (((::IDataStreamTool*)o)->lastStream)();
}

static  void method_4816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((::IDataStreamTool*)o)->size)());
  else   (((::IDataStreamTool*)o)->size)();
}

static  void method_4817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataStreamTool*)o)->clear)());
  else   (((::IDataStreamTool*)o)->clear)();
}

static void destructor_4820(void*, void * o, const std::vector<void*>&, void *) {
(((::IDataStreamTool*)o)->::IDataStreamTool::~IDataStreamTool)();
}
static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::IDataStreamTool,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IDataStreamTool,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IDataStreamTool,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IDataStreamTool -------------------------------
void __IDataStreamTool_db_datamem(Reflex::Class*);
void __IDataStreamTool_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IDataStreamTool_datamem_bld(&__IDataStreamTool_db_datamem);
Reflex::GenreflexMemberBuilder __IDataStreamTool_funcmem_bld(&__IDataStreamTool_db_funcmem);
void __IDataStreamTool_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IDataStreamTool"), typeid(::IDataStreamTool), sizeof(::IDataStreamTool), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_813, ::Reflex::BaseOffset< ::IDataStreamTool, ::IAlgTool >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_3165, Reflex::Literal("IDataStreamTool::StreamSpecs"))
  .AddTypedef(type_26, Reflex::Literal("IDataStreamTool::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19811, type_19812), Reflex::Literal("operator="), operator_4802, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDataStreamTool"), destructor_4820, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IDataStreamTool_funcmem_bld);
}

//------Delayed data member builder for class IDataStreamTool -------------------
void __IDataStreamTool_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDataStreamTool -------------------
void __IDataStreamTool_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4805, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10094), Reflex::Literal("initializeStream"), method_4806, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10094), Reflex::Literal("finalizeStream"), method_4807, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19813, type_10899), Reflex::Literal("getNextStream"), method_4808, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19813, type_10899), Reflex::Literal("getPreviousStream"), method_4809, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("addStream"), method_4810, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_12573), Reflex::Literal("addStreams"), method_4811, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("eraseStream"), method_4812, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10094, type_26), Reflex::Literal("getStream"), method_4813, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10094, type_6134), Reflex::Literal("getStream"), method_4814, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10094), Reflex::Literal("lastStream"), method_4815, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("size"), method_4816, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("clear"), method_4817, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class extend_interfaces1<IDataStreamTool> -------------------------------
static  void operator_4149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::extend_interfaces1<IDataStreamTool>*)o)->operator=)(*(const ::extend_interfaces1<IDataStreamTool>*)arg[0]);
  else   (((::extend_interfaces1<IDataStreamTool>*)o)->operator=)(*(const ::extend_interfaces1<IDataStreamTool>*)arg[0]);
}

static void destructor_4152(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces1<IDataStreamTool>*)o)->::extend_interfaces1<IDataStreamTool>::~extend_interfaces1)();
}
static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IDataStreamTool")), ::Reflex::BaseOffset< ::extend_interfaces1<IDataStreamTool>,::IDataStreamTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::extend_interfaces1<IDataStreamTool>,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::extend_interfaces1<IDataStreamTool>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces1<IDataStreamTool>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces1<IDataStreamTool> -------------------------------
void __extend_interfaces1_IDataStreamTool__db_datamem(Reflex::Class*);
void __extend_interfaces1_IDataStreamTool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces1_IDataStreamTool__datamem_bld(&__extend_interfaces1_IDataStreamTool__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces1_IDataStreamTool__funcmem_bld(&__extend_interfaces1_IDataStreamTool__db_funcmem);
void __extend_interfaces1_IDataStreamTool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces1<IDataStreamTool>"), typeid(::extend_interfaces1<IDataStreamTool>), sizeof(::extend_interfaces1<IDataStreamTool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_686, ::Reflex::BaseOffset< ::extend_interfaces1<IDataStreamTool>, ::IDataStreamTool >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19270, type_19271), Reflex::Literal("operator="), operator_4149, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces1"), destructor_4152, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces1<IDataStreamTool> -------------------
void __extend_interfaces1_IDataStreamTool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces1<IDataStreamTool> -------------------
void __extend_interfaces1_IDataStreamTool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IProperty -------------------------------
static  void operator_7534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IProperty*)o)->operator=)(*(const ::IProperty*)arg[0]);
  else   (((::IProperty*)o)->operator=)(*(const ::IProperty*)arg[0]);
}

static  void method_7537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IProperty*)o)->interfaceID)();
  else   (((::IProperty*)o)->interfaceID)();
}

static  void method_7538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IProperty*)o)->setProperty)(*(const ::Property*)arg[0]));
  else   (((::IProperty*)o)->setProperty)(*(const ::Property*)arg[0]);
}

static  void method_7539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IProperty*)o)->setProperty)(*(const ::std::string*)arg[0]));
  else   (((::IProperty*)o)->setProperty)(*(const ::std::string*)arg[0]);
}

static  void method_7540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IProperty*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IProperty*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IProperty*)o)->getProperty)((::Property*)arg[0]));
  else   (((const ::IProperty*)o)->getProperty)((::Property*)arg[0]);
}

static  void method_7542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IProperty*)o)->getProperty)(*(const ::std::string*)arg[0]);
  else   (((const ::IProperty*)o)->getProperty)(*(const ::std::string*)arg[0]);
}

static  void method_7543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IProperty*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::IProperty*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_7544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IProperty*)o)->getProperties)();
  else   (((const ::IProperty*)o)->getProperties)();
}

static void destructor_7545(void*, void * o, const std::vector<void*>&, void *) {
(((::IProperty*)o)->::IProperty::~IProperty)();
}
static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IProperty,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IProperty -------------------------------
void __IProperty_db_datamem(Reflex::Class*);
void __IProperty_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IProperty_datamem_bld(&__IProperty_db_datamem);
Reflex::GenreflexMemberBuilder __IProperty_funcmem_bld(&__IProperty_db_funcmem);
void __IProperty_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IProperty"), typeid(::IProperty), sizeof(::IProperty), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IProperty, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21009, type_24311), Reflex::Literal("operator="), operator_7534, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IProperty"), destructor_7545, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IProperty_funcmem_bld);
}

//------Delayed data member builder for class IProperty -------------------
void __IProperty_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IProperty -------------------
void __IProperty_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7537, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7834), Reflex::Literal("setProperty"), method_7538, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("setProperty"), method_7539, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("setProperty"), method_7540, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_11428), Reflex::Literal("getProperty"), method_7541, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7834, type_6134), Reflex::Literal("getProperty"), method_7542, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19991), Reflex::Literal("getProperty"), method_7543, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19992), Reflex::Literal("getProperties"), method_7544, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class extend_interfaces1<IProperty> -------------------------------
static  void operator_4153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::extend_interfaces1<IProperty>*)o)->operator=)(*(const ::extend_interfaces1<IProperty>*)arg[0]);
  else   (((::extend_interfaces1<IProperty>*)o)->operator=)(*(const ::extend_interfaces1<IProperty>*)arg[0]);
}

static void destructor_4156(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces1<IProperty>*)o)->::extend_interfaces1<IProperty>::~extend_interfaces1)();
}
static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::extend_interfaces1<IProperty>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces1<IProperty>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces1<IProperty> -------------------------------
void __extend_interfaces1_IProperty__db_datamem(Reflex::Class*);
void __extend_interfaces1_IProperty__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces1_IProperty__datamem_bld(&__extend_interfaces1_IProperty__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces1_IProperty__funcmem_bld(&__extend_interfaces1_IProperty__db_funcmem);
void __extend_interfaces1_IProperty__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces1<IProperty>"), typeid(::extend_interfaces1<IProperty>), sizeof(::extend_interfaces1<IProperty>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_2383, ::Reflex::BaseOffset< ::extend_interfaces1<IProperty>, ::IProperty >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19272, type_19273), Reflex::Literal("operator="), operator_4153, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces1"), destructor_4156, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces1<IProperty> -------------------
void __extend_interfaces1_IProperty__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces1<IProperty> -------------------
void __extend_interfaces1_IProperty__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class extend_interfaces2<IService,IAuditor> -------------------------------
static  void operator_4157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::extend_interfaces2<IService,IAuditor>*)o)->operator=)(*(const ::extend_interfaces2<IService,IAuditor>*)arg[0]);
  else   (((::extend_interfaces2<IService,IAuditor>*)o)->operator=)(*(const ::extend_interfaces2<IService,IAuditor>*)arg[0]);
}

static void destructor_4160(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces2<IService,IAuditor>*)o)->::extend_interfaces2<IService,IAuditor>::~extend_interfaces2)();
}
static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::extend_interfaces2<IService,IAuditor>,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::extend_interfaces2<IService,IAuditor>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces2<IService,IAuditor>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAuditor")), ::Reflex::BaseOffset< ::extend_interfaces2<IService,IAuditor>,::IAuditor >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces2<IService,IAuditor> -------------------------------
void __extend_interfaces2_IService_IAuditor__db_datamem(Reflex::Class*);
void __extend_interfaces2_IService_IAuditor__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces2_IService_IAuditor__datamem_bld(&__extend_interfaces2_IService_IAuditor__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces2_IService_IAuditor__funcmem_bld(&__extend_interfaces2_IService_IAuditor__db_funcmem);
void __extend_interfaces2_IService_IAuditor__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces2<IService,IAuditor>"), typeid(::extend_interfaces2<IService,IAuditor>), sizeof(::extend_interfaces2<IService,IAuditor>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_934, ::Reflex::BaseOffset< ::extend_interfaces2<IService,IAuditor>, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_1590, ::Reflex::BaseOffset< ::extend_interfaces2<IService,IAuditor>, ::IAuditor >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19274, type_19275), Reflex::Literal("operator="), operator_4157, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces2"), destructor_4160, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces2<IService,IAuditor> -------------------
void __extend_interfaces2_IService_IAuditor__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces2<IService,IAuditor> -------------------
void __extend_interfaces2_IService_IAuditor__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class GaudiHandleBase -------------------------------
static  void operator_4240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiHandleBase*)o)->operator=)(*(const ::GaudiHandleBase*)arg[0]);
  else   (((::GaudiHandleBase*)o)->operator=)(*(const ::GaudiHandleBase*)arg[0]);
}

static void constructor_4241( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiHandleBase(*(const ::GaudiHandleBase*)arg[0]);
  else ::new(mem) ::GaudiHandleBase(*(const ::GaudiHandleBase*)arg[0]);
}

static  void method_4243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleBase*)o)->typeAndName)());
  else   (((const ::GaudiHandleBase*)o)->typeAndName)();
}

static  void method_4244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleBase*)o)->type)());
  else   (((const ::GaudiHandleBase*)o)->type)();
}

static  void method_4245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleBase*)o)->name)());
  else   (((const ::GaudiHandleBase*)o)->name)();
}

static  void method_4246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GaudiHandleBase*)o)->empty)());
  else   (((const ::GaudiHandleBase*)o)->empty)();
}

static  void method_4247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiHandleBase*)o)->setTypeAndName)(*(const ::std::string*)arg[0]);
}

static  void method_4248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiHandleBase*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_4249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleBase*)o)->pythonPropertyClassName)());
  else   (((const ::GaudiHandleBase*)o)->pythonPropertyClassName)();
}

static  void method_4250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleBase*)o)->messageName)());
  else   (((const ::GaudiHandleBase*)o)->messageName)();
}

static  void method_4251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleBase*)o)->pythonRepr)());
  else   (((const ::GaudiHandleBase*)o)->pythonRepr)();
}

static void destructor_4252(void*, void * o, const std::vector<void*>&, void *) {
(((::GaudiHandleBase*)o)->::GaudiHandleBase::~GaudiHandleBase)();
}
static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("GaudiHandleInfo")), ::Reflex::BaseOffset< ::GaudiHandleBase,::GaudiHandleInfo >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GaudiHandleBase -------------------------------
void __GaudiHandleBase_db_datamem(Reflex::Class*);
void __GaudiHandleBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GaudiHandleBase_datamem_bld(&__GaudiHandleBase_db_datamem);
Reflex::GenreflexMemberBuilder __GaudiHandleBase_funcmem_bld(&__GaudiHandleBase_db_funcmem);
void __GaudiHandleBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GaudiHandleBase"), typeid(::GaudiHandleBase), sizeof(::GaudiHandleBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_133, ::Reflex::BaseOffset< ::GaudiHandleBase, ::GaudiHandleInfo >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19420, type_19421), Reflex::Literal("operator="), operator_4240, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19421), Reflex::Literal("GaudiHandleBase"), constructor_4241, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GaudiHandleBase"), destructor_4252, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GaudiHandleBase_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GaudiHandleBase_funcmem_bld);
}

//------Delayed data member builder for class GaudiHandleBase -------------------
void __GaudiHandleBase_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3236, Reflex::Literal("m_typeAndName"), OffsetOf(__shadow__::__GaudiHandleBase, m_typeAndName), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GaudiHandleBase -------------------
void __GaudiHandleBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("typeAndName"), method_4243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("type"), method_4244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("name"), method_4245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_4246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setTypeAndName"), method_4247, 0, "myTypeAndName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setName"), method_4248, 0, "myName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236c), Reflex::Literal("pythonPropertyClassName"), method_4249, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236c), Reflex::Literal("messageName"), method_4250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236c), Reflex::Literal("pythonRepr"), method_4251, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class GaudiHandleInfo -------------------------------
static  void operator_4257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiHandleInfo*)o)->operator=)(*(const ::GaudiHandleInfo*)arg[0]);
  else   (((::GaudiHandleInfo*)o)->operator=)(*(const ::GaudiHandleInfo*)arg[0]);
}

static void destructor_4260(void*, void * o, const std::vector<void*>&, void *) {
(((::GaudiHandleInfo*)o)->::GaudiHandleInfo::~GaudiHandleInfo)();
}
static  void method_4261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GaudiHandleInfo*)o)->componentType)();
  else   (((const ::GaudiHandleInfo*)o)->componentType)();
}

static  void method_4262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GaudiHandleInfo*)o)->propertyName)();
  else   (((const ::GaudiHandleInfo*)o)->propertyName)();
}

static  void method_4263( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GaudiHandleInfo*)o)->setPropertyName)(*(const ::std::string*)arg[0]);
}

static  void method_4264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GaudiHandleInfo*)o)->parentName)();
  else   (((const ::GaudiHandleInfo*)o)->parentName)();
}

static  void method_4265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleInfo*)o)->pythonPropertyClassName)());
  else   (((const ::GaudiHandleInfo*)o)->pythonPropertyClassName)();
}

static  void method_4266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleInfo*)o)->pythonRepr)());
  else   (((const ::GaudiHandleInfo*)o)->pythonRepr)();
}

//------Dictionary for class GaudiHandleInfo -------------------------------
void __GaudiHandleInfo_db_datamem(Reflex::Class*);
void __GaudiHandleInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GaudiHandleInfo_datamem_bld(&__GaudiHandleInfo_db_datamem);
Reflex::GenreflexMemberBuilder __GaudiHandleInfo_funcmem_bld(&__GaudiHandleInfo_db_funcmem);
void __GaudiHandleInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GaudiHandleInfo"), typeid(::GaudiHandleInfo), sizeof(::GaudiHandleInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19423, type_7833), Reflex::Literal("operator="), operator_4257, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GaudiHandleInfo"), destructor_4260, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__GaudiHandleInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GaudiHandleInfo_funcmem_bld);
}

//------Delayed data member builder for class GaudiHandleInfo -------------------
void __GaudiHandleInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3236, Reflex::Literal("m_componentType"), OffsetOf(__shadow__::__GaudiHandleInfo, m_componentType), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_propertyName"), OffsetOf(__shadow__::__GaudiHandleInfo, m_propertyName), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_parentName"), OffsetOf(__shadow__::__GaudiHandleInfo, m_parentName), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GaudiHandleInfo -------------------
void __GaudiHandleInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("componentType"), method_4261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("propertyName"), method_4262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setPropertyName"), method_4263, 0, "propName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("parentName"), method_4264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236c), Reflex::Literal("pythonPropertyClassName"), method_4265, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236c), Reflex::Literal("pythonRepr"), method_4266, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class Incident -------------------------------
static  void operator_4292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Incident*)o)->operator=)(*(const ::Incident*)arg[0]);
  else   (((::Incident*)o)->operator=)(*(const ::Incident*)arg[0]);
}

static void constructor_4293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Incident(*(const ::Incident*)arg[0]);
  else ::new(mem) ::Incident(*(const ::Incident*)arg[0]);
}

static void constructor_4294( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Incident(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::Incident(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
}

static void destructor_4295(void*, void * o, const std::vector<void*>&, void *) {
(((::Incident*)o)->::Incident::~Incident)();
}
static  void method_4296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Incident*)o)->type)();
  else   (((const ::Incident*)o)->type)();
}

static  void method_4297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Incident*)o)->source)();
  else   (((const ::Incident*)o)->source)();
}

//------Dictionary for class Incident -------------------------------
void __Incident_db_datamem(Reflex::Class*);
void __Incident_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Incident_datamem_bld(&__Incident_db_datamem);
Reflex::GenreflexMemberBuilder __Incident_funcmem_bld(&__Incident_db_funcmem);
void __Incident_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Incident"), typeid(::Incident), sizeof(::Incident), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19432, type_19433), Reflex::Literal("operator="), operator_4292, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19433), Reflex::Literal("Incident"), constructor_4293, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134, type_6134), Reflex::Literal("Incident"), constructor_4294, 0, "source;type", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Incident"), destructor_4295, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__Incident_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Incident_funcmem_bld);
}

//------Delayed data member builder for class Incident -------------------
void __Incident_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3236, Reflex::Literal("m_source"), OffsetOf(__shadow__::__Incident, m_source), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_type"), OffsetOf(__shadow__::__Incident, m_type), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Incident -------------------
void __Incident_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("type"), method_4296, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("source"), method_4297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class InterfaceID -------------------------------
static  void operator_4301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::InterfaceID*)o)->operator=)(*(const ::InterfaceID*)arg[0]);
  else   (((::InterfaceID*)o)->operator=)(*(const ::InterfaceID*)arg[0]);
}

static void constructor_4302( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::InterfaceID(*(const ::InterfaceID*)arg[0]);
  else ::new(mem) ::InterfaceID(*(const ::InterfaceID*)arg[0]);
}

static void constructor_4303( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::InterfaceID(*(unsigned long*)arg[0]);
  else ::new(mem) ::InterfaceID(*(unsigned long*)arg[0]);
}

static void constructor_4304( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::InterfaceID(*(unsigned long*)arg[0],
      *(unsigned long*)arg[1]);
  else ::new(mem) ::InterfaceID(*(unsigned long*)arg[0],
      *(unsigned long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::InterfaceID(*(unsigned long*)arg[0],
      *(unsigned long*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::InterfaceID(*(unsigned long*)arg[0],
      *(unsigned long*)arg[1],
      *(unsigned long*)arg[2]);
  }
}

static void constructor_4305( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::InterfaceID((const char*)arg[0],
      *(unsigned long*)arg[1]);
  else ::new(mem) ::InterfaceID((const char*)arg[0],
      *(unsigned long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::InterfaceID((const char*)arg[0],
      *(unsigned long*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::InterfaceID((const char*)arg[0],
      *(unsigned long*)arg[1],
      *(unsigned long*)arg[2]);
  }
}

static void destructor_4306(void*, void * o, const std::vector<void*>&, void *) {
(((::InterfaceID*)o)->::InterfaceID::~InterfaceID)();
}
static  void converter_4307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::InterfaceID*)o)->operator unsigned long)());
  else   (((const ::InterfaceID*)o)->operator unsigned long)();
}

static  void method_4308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::InterfaceID*)o)->id)());
  else   (((const ::InterfaceID*)o)->id)();
}

static  void method_4309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::InterfaceID*)o)->majorVersion)());
  else   (((const ::InterfaceID*)o)->majorVersion)();
}

static  void method_4310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::InterfaceID*)o)->minorVersion)());
  else   (((const ::InterfaceID*)o)->minorVersion)();
}

static  void method_4311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::InterfaceID*)o)->versionMatch)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::InterfaceID*)o)->versionMatch)(*(const ::InterfaceID*)arg[0]);
}

static  void method_4312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::InterfaceID*)o)->fullMatch)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::InterfaceID*)o)->fullMatch)(*(const ::InterfaceID*)arg[0]);
}

static  void operator_4313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::InterfaceID*)o)->operator==)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::InterfaceID*)o)->operator==)(*(const ::InterfaceID*)arg[0]);
}

static  void method_4314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::InterfaceID*)o)->hash32)((const char*)arg[0]));
  else   (((::InterfaceID*)o)->hash32)((const char*)arg[0]);
}

//------Dictionary for class InterfaceID -------------------------------
void __InterfaceID_db_datamem(Reflex::Class*);
void __InterfaceID_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __InterfaceID_datamem_bld(&__InterfaceID_db_datamem);
Reflex::GenreflexMemberBuilder __InterfaceID_funcmem_bld(&__InterfaceID_db_funcmem);
void __InterfaceID_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("InterfaceID"), typeid(::InterfaceID), sizeof(::InterfaceID), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19434, type_7851), Reflex::Literal("operator="), operator_4301, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7851), Reflex::Literal("InterfaceID"), constructor_4302, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_502), Reflex::Literal("InterfaceID"), constructor_4303, 0, "lid", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_502, type_502, type_502), Reflex::Literal("InterfaceID"), constructor_4304, 0, "id;major;minor=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4095, type_502, type_502), Reflex::Literal("InterfaceID"), constructor_4305, 0, "name;major;minor=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~InterfaceID"), destructor_4306, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__InterfaceID_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__InterfaceID_funcmem_bld);
}

//------Delayed data member builder for class InterfaceID -------------------
void __InterfaceID_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_id"), OffsetOf(__shadow__::__InterfaceID, m_id), ::Reflex::PRIVATE)
  .AddDataMember(type_502, Reflex::Literal("m_major_ver"), OffsetOf(__shadow__::__InterfaceID, m_major_ver), ::Reflex::PRIVATE)
  .AddDataMember(type_502, Reflex::Literal("m_minor_ver"), OffsetOf(__shadow__::__InterfaceID, m_minor_ver), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class InterfaceID -------------------
void __InterfaceID_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("operator unsigned long"), converter_4307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("id"), method_4308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("majorVersion"), method_4309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("minorVersion"), method_4310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7851), Reflex::Literal("versionMatch"), method_4311, 0, "iid", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7851), Reflex::Literal("fullMatch"), method_4312, 0, "iid", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7851), Reflex::Literal("operator=="), operator_4313, 0, "iid", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_203, type_4095), Reflex::Literal("hash32"), method_4314, 0, "key", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IUpdateable -------------------------------
static  void operator_4322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IUpdateable*)o)->operator=)(*(const ::IUpdateable*)arg[0]);
  else   (((::IUpdateable*)o)->operator=)(*(const ::IUpdateable*)arg[0]);
}

static void destructor_4325(void*, void * o, const std::vector<void*>&, void *) {
(((::IUpdateable*)o)->::IUpdateable::~IUpdateable)();
}
static  void method_4326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IUpdateable*)o)->update)(*(int*)arg[0]));
  else   (((::IUpdateable*)o)->update)(*(int*)arg[0]);
}

//------Dictionary for class IUpdateable -------------------------------
void __IUpdateable_db_datamem(Reflex::Class*);
void __IUpdateable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IUpdateable_datamem_bld(&__IUpdateable_db_datamem);
Reflex::GenreflexMemberBuilder __IUpdateable_funcmem_bld(&__IUpdateable_db_funcmem);
void __IUpdateable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IUpdateable"), typeid(::IUpdateable), sizeof(::IUpdateable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19436, type_19437), Reflex::Literal("operator="), operator_4322, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IUpdateable"), destructor_4325, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IUpdateable_funcmem_bld);
}

//------Delayed data member builder for class IUpdateable -------------------
void __IUpdateable_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IUpdateable -------------------
void __IUpdateable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_142), Reflex::Literal("update"), method_4326, 0, "flag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class extends1<AlgTool,IDataStreamTool> -------------------------------
static  void method_4333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::extends1<AlgTool,IDataStreamTool>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::extends1<AlgTool,IDataStreamTool>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]);
}

static  void method_4334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::extends1<AlgTool,IDataStreamTool>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::extends1<AlgTool,IDataStreamTool>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static  void method_4335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::extends1<AlgTool,IDataStreamTool>*)o)->getInterfaceNames)());
  else   (((const ::extends1<AlgTool,IDataStreamTool>*)o)->getInterfaceNames)();
}

static void destructor_4336(void*, void * o, const std::vector<void*>&, void *) {
(((::extends1<AlgTool,IDataStreamTool>*)o)->::extends1<AlgTool,IDataStreamTool>::~extends1)();
}
static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("AlgTool")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::AlgTool >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("implements3<IAlgTool,IProperty,IStateful>")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::implements3<IAlgTool,IProperty,IStateful> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IAlgTool,IProperty,IStateful>")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::extend_interfaces3<IAlgTool,IProperty,IStateful> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces1<IDataStreamTool>")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::extend_interfaces1<IDataStreamTool> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IDataStreamTool")), ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>,::IDataStreamTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extends1<AlgTool,IDataStreamTool> -------------------------------
void __extends1_AlgTool_IDataStreamTool__db_datamem(Reflex::Class*);
void __extends1_AlgTool_IDataStreamTool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extends1_AlgTool_IDataStreamTool__datamem_bld(&__extends1_AlgTool_IDataStreamTool__db_datamem);
Reflex::GenreflexMemberBuilder __extends1_AlgTool_IDataStreamTool__funcmem_bld(&__extends1_AlgTool_IDataStreamTool__db_funcmem);
void __extends1_AlgTool_IDataStreamTool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extends1<AlgTool,IDataStreamTool>"), typeid(::extends1<AlgTool,IDataStreamTool>), sizeof(::extends1<AlgTool,IDataStreamTool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extends*<*>")
  .AddBase(type_1234, ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>, ::AlgTool >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_45, ::Reflex::BaseOffset< ::extends1<AlgTool,IDataStreamTool>, ::extend_interfaces1<IDataStreamTool> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_45, Reflex::Literal("extends1<AlgTool,IDataStreamTool>::extend_interfaces_base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extends1"), destructor_4336, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__extends1_AlgTool_IDataStreamTool__funcmem_bld);
}

//------Delayed data member builder for class extends1<AlgTool,IDataStreamTool> -------------------
void __extends1_AlgTool_IDataStreamTool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extends1<AlgTool,IDataStreamTool> -------------------
void __extends1_AlgTool_IDataStreamTool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7851), Reflex::Literal("i_cast"), method_4333, 0, "tid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_4334, 0, "ti;pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getInterfaceNames"), method_4335, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class DataObject -------------------------------
static  void operator_4378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DataObject*)o)->operator=)(*(const ::DataObject*)arg[0]);
  else   (((::DataObject*)o)->operator=)(*(const ::DataObject*)arg[0]);
}

static void constructor_4379( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DataObject();
  else ::new(mem) ::DataObject();
}

static void constructor_4380( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DataObject(*(const ::DataObject*)arg[0]);
  else ::new(mem) ::DataObject(*(const ::DataObject*)arg[0]);
}

static void destructor_4381(void*, void * o, const std::vector<void*>&, void *) {
(((::DataObject*)o)->::DataObject::~DataObject)();
}
static  void method_4382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::DataObject*)o)->addRef)());
  else   (((::DataObject*)o)->addRef)();
}

static  void method_4383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::DataObject*)o)->release)());
  else   (((::DataObject*)o)->release)();
}

static  void method_4384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::DataObject*)o)->clID)();
  else   (((const ::DataObject*)o)->clID)();
}

static  void method_4385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DataObject*)o)->classID)();
  else   (((::DataObject*)o)->classID)();
}

static  void method_4386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::DataObject*)o)->name)();
  else   (((const ::DataObject*)o)->name)();
}

static  void method_4387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::DataObject*)o)->update)());
  else   (((::DataObject*)o)->update)();
}

static  void method_4388( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DataObject*)o)->setRegistry)((::IRegistry*)arg[0]);
}

static  void method_4389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DataObject*)o)->registry)());
  else   (((const ::DataObject*)o)->registry)();
}

static  void method_4390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DataObject*)o)->linkMgr)());
  else   (((const ::DataObject*)o)->linkMgr)();
}

static  void method_4391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned char)((((const ::DataObject*)o)->version)());
  else   (((const ::DataObject*)o)->version)();
}

static  void method_4392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DataObject*)o)->setVersion)(*(unsigned char*)arg[0]);
}

static  void method_4393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::DataObject*)o)->refCount)());
  else   (((const ::DataObject*)o)->refCount)();
}

static  void method_4394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::DataObject*)o)->fillStream)(*(::std::ostream*)arg[0]);
  else   (((const ::DataObject*)o)->fillStream)(*(::std::ostream*)arg[0]);
}

static void method_newdel_303( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DataObject >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DataObject >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DataObject >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DataObject >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DataObject >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DataObject -------------------------------
void __DataObject_db_datamem(Reflex::Class*);
void __DataObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DataObject_datamem_bld(&__DataObject_db_datamem);
Reflex::GenreflexMemberBuilder __DataObject_funcmem_bld(&__DataObject_db_funcmem);
void __DataObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DataObject"), typeid(::DataObject), sizeof(::DataObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00000001-0000-0000-0000-000000000000")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19455, type_7853), Reflex::Literal("operator="), operator_4378, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DataObject"), constructor_4379, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7853), Reflex::Literal("DataObject"), constructor_4380, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DataObject"), destructor_4381, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_303, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DataObject_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DataObject_funcmem_bld);
}

//------Delayed data member builder for class DataObject -------------------
void __DataObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__DataObject, m_refCount), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_278, Reflex::Literal("m_version"), OffsetOf(__shadow__::__DataObject, m_version), ::Reflex::PRIVATE)
  .AddDataMember(type_10115, Reflex::Literal("m_pRegistry"), OffsetOf(__shadow__::__DataObject, m_pRegistry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_19454, Reflex::Literal("m_pLinkMgr"), OffsetOf(__shadow__::__DataObject, m_pLinkMgr), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class DataObject -------------------
void __DataObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_4382, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_4383, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_4384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("classID"), method_4385, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_4386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("update"), method_4387, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10115), Reflex::Literal("setRegistry"), method_4388, 0, "pRegistry", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10115), Reflex::Literal("registry"), method_4389, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19454), Reflex::Literal("linkMgr"), method_4390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("version"), method_4391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_278), Reflex::Literal("setVersion"), method_4392, 0, "vsn", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_4393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7831, type_7831), Reflex::Literal("fillStream"), method_4394, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class IDetDataSvc -------------------------------
static  void operator_4421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDetDataSvc*)o)->operator=)(*(const ::IDetDataSvc*)arg[0]);
  else   (((::IDetDataSvc*)o)->operator=)(*(const ::IDetDataSvc*)arg[0]);
}

static  void method_4424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDetDataSvc*)o)->interfaceID)();
  else   (((::IDetDataSvc*)o)->interfaceID)();
}

static  void method_4425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IDetDataSvc*)o)->validEventTime)());
  else   (((const ::IDetDataSvc*)o)->validEventTime)();
}

static  void method_4426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IDetDataSvc*)o)->eventTime)();
  else   (((const ::IDetDataSvc*)o)->eventTime)();
}

static  void method_4427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IDetDataSvc*)o)->setEventTime)(*(const ::Gaudi::Time*)arg[0]);
}

static void destructor_4428(void*, void * o, const std::vector<void*>&, void *) {
(((::IDetDataSvc*)o)->::IDetDataSvc::~IDetDataSvc)();
}
static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IDetDataSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IDetDataSvc -------------------------------
void __IDetDataSvc_db_datamem(Reflex::Class*);
void __IDetDataSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IDetDataSvc_datamem_bld(&__IDetDataSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IDetDataSvc_funcmem_bld(&__IDetDataSvc_db_funcmem);
void __IDetDataSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IDetDataSvc"), typeid(::IDetDataSvc), sizeof(::IDetDataSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IDetDataSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19465, type_19466), Reflex::Literal("operator="), operator_4421, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDetDataSvc"), destructor_4428, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IDetDataSvc_funcmem_bld);
}

//------Delayed data member builder for class IDetDataSvc -------------------
void __IDetDataSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDetDataSvc -------------------
void __IDetDataSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4424, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("validEventTime"), method_4425, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4403), Reflex::Literal("eventTime"), method_4426, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4403), Reflex::Literal("setEventTime"), method_4427, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IClassManager -------------------------------
static  void operator_4492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IClassManager*)o)->operator=)(*(const ::IClassManager*)arg[0]);
  else   (((::IClassManager*)o)->operator=)(*(const ::IClassManager*)arg[0]);
}

static  void method_4495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IClassManager*)o)->interfaceID)();
  else   (((::IClassManager*)o)->interfaceID)();
}

static  void method_4496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::IClassManager*)o)->loadModule)(*(const ::std::string*)arg[0]));
    else     (((::IClassManager*)o)->loadModule)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IClassManager*)o)->loadModule)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]));
    else     (((::IClassManager*)o)->loadModule)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
}

static void destructor_4497(void*, void * o, const std::vector<void*>&, void *) {
(((::IClassManager*)o)->::IClassManager::~IClassManager)();
}
static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IClassManager,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IClassManager -------------------------------
void __IClassManager_db_datamem(Reflex::Class*);
void __IClassManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IClassManager_datamem_bld(&__IClassManager_db_datamem);
Reflex::GenreflexMemberBuilder __IClassManager_funcmem_bld(&__IClassManager_db_funcmem);
void __IClassManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IClassManager"), typeid(::IClassManager), sizeof(::IClassManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IClassManager, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19488, type_19489), Reflex::Literal("operator="), operator_4492, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IClassManager"), destructor_4497, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IClassManager_funcmem_bld);
}

//------Delayed data member builder for class IClassManager -------------------
void __IClassManager_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IClassManager -------------------
void __IClassManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4495, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_4206), Reflex::Literal("loadModule"), method_4496, 0, "module;fireIncident=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class implements1<IInterface> -------------------------------
static  void method_4512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::implements1<IInterface>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::implements1<IInterface>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]);
}

static  void method_4513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::implements1<IInterface>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::implements1<IInterface>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static  void method_4514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::implements1<IInterface>*)o)->getInterfaceNames)());
  else   (((const ::implements1<IInterface>*)o)->getInterfaceNames)();
}

static void constructor_4515( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::implements1<IInterface>();
  else ::new(mem) ::implements1<IInterface>();
}

static void constructor_4516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::implements1<IInterface>(*(const ::implements1<IInterface>*)arg[0]);
  else ::new(mem) ::implements1<IInterface>(*(const ::implements1<IInterface>*)arg[0]);
}

static  void operator_4517( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::implements1<IInterface>*)o)->operator=)(*(const ::implements1<IInterface>*)arg[0]);
  else   (((::implements1<IInterface>*)o)->operator=)(*(const ::implements1<IInterface>*)arg[0]);
}

static void destructor_4518(void*, void * o, const std::vector<void*>&, void *) {
(((::implements1<IInterface>*)o)->::implements1<IInterface>::~implements1)();
}
static  void method_4519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements1<IInterface>*)o)->addRef)());
  else   (((::implements1<IInterface>*)o)->addRef)();
}

static  void method_4520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements1<IInterface>*)o)->release)());
  else   (((::implements1<IInterface>*)o)->release)();
}

static  void method_4521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::implements1<IInterface>*)o)->refCount)());
  else   (((const ::implements1<IInterface>*)o)->refCount)();
}

static void method_newdel_489( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::implements1<IInterface> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::implements1<IInterface> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::implements1<IInterface> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::implements1<IInterface> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::implements1<IInterface> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces1<IInterface>")), ::Reflex::BaseOffset< ::implements1<IInterface>,::extend_interfaces1<IInterface> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::implements1<IInterface>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class implements1<IInterface> -------------------------------
void __implements1_IInterface__db_datamem(Reflex::Class*);
void __implements1_IInterface__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __implements1_IInterface__datamem_bld(&__implements1_IInterface__db_datamem);
Reflex::GenreflexMemberBuilder __implements1_IInterface__funcmem_bld(&__implements1_IInterface__db_funcmem);
void __implements1_IInterface__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("implements1<IInterface>"), typeid(::implements1<IInterface>), sizeof(::implements1<IInterface>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "implements*<*>")
  .AddBase(type_44, ::Reflex::BaseOffset< ::implements1<IInterface>, ::extend_interfaces1<IInterface> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_44, Reflex::Literal("implements1<IInterface>::extend_interfaces_base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("implements1"), constructor_4515, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19493), Reflex::Literal("implements1"), constructor_4516, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~implements1"), destructor_4518, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_489, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__implements1_IInterface__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__implements1_IInterface__funcmem_bld);
}

//------Delayed data member builder for class implements1<IInterface> -------------------
void __implements1_IInterface__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__implements1_IInterface_, m_refCount), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class implements1<IInterface> -------------------
void __implements1_IInterface__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7851), Reflex::Literal("i_cast"), method_4512, 0, "tid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_4513, 0, "ti;pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getInterfaceNames"), method_4514, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19494, type_19493), Reflex::Literal("operator="), operator_4517, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_4519, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_4520, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_4521, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class implements1<IProperty> -------------------------------
static  void method_4524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::implements1<IProperty>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::implements1<IProperty>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]);
}

static  void method_4525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::implements1<IProperty>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::implements1<IProperty>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static  void method_4526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::implements1<IProperty>*)o)->getInterfaceNames)());
  else   (((const ::implements1<IProperty>*)o)->getInterfaceNames)();
}

static  void operator_4529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::implements1<IProperty>*)o)->operator=)(*(const ::implements1<IProperty>*)arg[0]);
  else   (((::implements1<IProperty>*)o)->operator=)(*(const ::implements1<IProperty>*)arg[0]);
}

static void destructor_4530(void*, void * o, const std::vector<void*>&, void *) {
(((::implements1<IProperty>*)o)->::implements1<IProperty>::~implements1)();
}
static  void method_4531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements1<IProperty>*)o)->addRef)());
  else   (((::implements1<IProperty>*)o)->addRef)();
}

static  void method_4532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements1<IProperty>*)o)->release)());
  else   (((::implements1<IProperty>*)o)->release)();
}

static  void method_4533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::implements1<IProperty>*)o)->refCount)());
  else   (((const ::implements1<IProperty>*)o)->refCount)();
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces1<IProperty>")), ::Reflex::BaseOffset< ::implements1<IProperty>,::extend_interfaces1<IProperty> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::implements1<IProperty>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::implements1<IProperty>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class implements1<IProperty> -------------------------------
void __implements1_IProperty__db_datamem(Reflex::Class*);
void __implements1_IProperty__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __implements1_IProperty__datamem_bld(&__implements1_IProperty__db_datamem);
Reflex::GenreflexMemberBuilder __implements1_IProperty__funcmem_bld(&__implements1_IProperty__db_funcmem);
void __implements1_IProperty__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("implements1<IProperty>"), typeid(::implements1<IProperty>), sizeof(::implements1<IProperty>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "implements*<*>")
  .AddBase(type_46, ::Reflex::BaseOffset< ::implements1<IProperty>, ::extend_interfaces1<IProperty> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_46, Reflex::Literal("implements1<IProperty>::extend_interfaces_base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~implements1"), destructor_4530, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__implements1_IProperty__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__implements1_IProperty__funcmem_bld);
}

//------Delayed data member builder for class implements1<IProperty> -------------------
void __implements1_IProperty__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__implements1_IProperty_, m_refCount), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class implements1<IProperty> -------------------
void __implements1_IProperty__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7851), Reflex::Literal("i_cast"), method_4524, 0, "tid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_4525, 0, "ti;pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getInterfaceNames"), method_4526, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19496, type_19495), Reflex::Literal("operator="), operator_4529, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_4531, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_4532, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_4533, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class IClassInfo -------------------------------
static  void operator_4541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IClassInfo*)o)->operator=)(*(const ::IClassInfo*)arg[0]);
  else   (((::IClassInfo*)o)->operator=)(*(const ::IClassInfo*)arg[0]);
}

static void destructor_4544(void*, void * o, const std::vector<void*>&, void *) {
(((::IClassInfo*)o)->::IClassInfo::~IClassInfo)();
}
static  void method_4545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IClassInfo*)o)->clID)();
  else   (((const ::IClassInfo*)o)->clID)();
}

//------Dictionary for class IClassInfo -------------------------------
void __IClassInfo_db_datamem(Reflex::Class*);
void __IClassInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IClassInfo_datamem_bld(&__IClassInfo_db_datamem);
Reflex::GenreflexMemberBuilder __IClassInfo_funcmem_bld(&__IClassInfo_db_funcmem);
void __IClassInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IClassInfo"), typeid(::IClassInfo), sizeof(::IClassInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19499, type_19500), Reflex::Literal("operator="), operator_4541, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IClassInfo"), destructor_4544, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IClassInfo_funcmem_bld);
}

//------Delayed data member builder for class IClassInfo -------------------
void __IClassInfo_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IClassInfo -------------------
void __IClassInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_4545, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IAlgorithm -------------------------------
static  void operator_4575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAlgorithm*)o)->operator=)(*(const ::IAlgorithm*)arg[0]);
  else   (((::IAlgorithm*)o)->operator=)(*(const ::IAlgorithm*)arg[0]);
}

static  void method_4578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAlgorithm*)o)->interfaceID)();
  else   (((::IAlgorithm*)o)->interfaceID)();
}

static  void method_4579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IAlgorithm*)o)->version)();
  else   (((const ::IAlgorithm*)o)->version)();
}

static  void method_4580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->execute)());
  else   (((::IAlgorithm*)o)->execute)();
}

static  void method_4581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IAlgorithm*)o)->isInitialized)());
  else   (((const ::IAlgorithm*)o)->isInitialized)();
}

static  void method_4582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IAlgorithm*)o)->isFinalized)());
  else   (((const ::IAlgorithm*)o)->isFinalized)();
}

static  void method_4583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IAlgorithm*)o)->isExecuted)());
  else   (((const ::IAlgorithm*)o)->isExecuted)();
}

static  void method_4584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->configure)());
  else   (((::IAlgorithm*)o)->configure)();
}

static  void method_4585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->initialize)());
  else   (((::IAlgorithm*)o)->initialize)();
}

static  void method_4586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->start)());
  else   (((::IAlgorithm*)o)->start)();
}

static  void method_4587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->stop)());
  else   (((::IAlgorithm*)o)->stop)();
}

static  void method_4588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->finalize)());
  else   (((::IAlgorithm*)o)->finalize)();
}

static  void method_4589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->terminate)());
  else   (((::IAlgorithm*)o)->terminate)();
}

static  void method_4590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->reinitialize)());
  else   (((::IAlgorithm*)o)->reinitialize)();
}

static  void method_4591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->restart)());
  else   (((::IAlgorithm*)o)->restart)();
}

static  void method_4592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IAlgorithm*)o)->FSMState)());
  else   (((const ::IAlgorithm*)o)->FSMState)();
}

static  void method_4593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysInitialize)());
  else   (((::IAlgorithm*)o)->sysInitialize)();
}

static  void method_4594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysStart)());
  else   (((::IAlgorithm*)o)->sysStart)();
}

static  void method_4595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysReinitialize)());
  else   (((::IAlgorithm*)o)->sysReinitialize)();
}

static  void method_4596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysRestart)());
  else   (((::IAlgorithm*)o)->sysRestart)();
}

static  void method_4597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysExecute)());
  else   (((::IAlgorithm*)o)->sysExecute)();
}

static  void method_4598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysStop)());
  else   (((::IAlgorithm*)o)->sysStop)();
}

static  void method_4599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysFinalize)());
  else   (((::IAlgorithm*)o)->sysFinalize)();
}

static  void method_4600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysBeginRun)());
  else   (((::IAlgorithm*)o)->sysBeginRun)();
}

static  void method_4601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->sysEndRun)());
  else   (((::IAlgorithm*)o)->sysEndRun)();
}

static  void method_4602( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IAlgorithm*)o)->resetExecuted)();
}

static  void method_4603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->beginRun)());
  else   (((::IAlgorithm*)o)->beginRun)();
}

static  void method_4604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgorithm*)o)->endRun)());
  else   (((::IAlgorithm*)o)->endRun)();
}

static  void method_4605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAlgorithm*)o)->setExecuted)(*(bool*)arg[0]);
}

static  void method_4606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IAlgorithm*)o)->isEnabled)());
  else   (((const ::IAlgorithm*)o)->isEnabled)();
}

static  void method_4607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IAlgorithm*)o)->filterPassed)());
  else   (((const ::IAlgorithm*)o)->filterPassed)();
}

static  void method_4608( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAlgorithm*)o)->setFilterPassed)(*(bool*)arg[0]);
}

static void destructor_4609(void*, void * o, const std::vector<void*>&, void *) {
(((::IAlgorithm*)o)->::IAlgorithm::~IAlgorithm)();
}
static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IAlgorithm,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAlgorithm,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAlgorithm -------------------------------
void __IAlgorithm_db_datamem(Reflex::Class*);
void __IAlgorithm_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAlgorithm_datamem_bld(&__IAlgorithm_db_datamem);
Reflex::GenreflexMemberBuilder __IAlgorithm_funcmem_bld(&__IAlgorithm_db_funcmem);
void __IAlgorithm_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAlgorithm"), typeid(::IAlgorithm), sizeof(::IAlgorithm), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2776, ::Reflex::BaseOffset< ::IAlgorithm, ::INamedInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19507, type_19508), Reflex::Literal("operator="), operator_4575, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IAlgorithm"), destructor_4609, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAlgorithm_funcmem_bld);
}

//------Delayed data member builder for class IAlgorithm -------------------
void __IAlgorithm_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAlgorithm -------------------
void __IAlgorithm_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4578, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("version"), method_4579, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("execute"), method_4580, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isInitialized"), method_4581, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isFinalized"), method_4582, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isExecuted"), method_4583, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_4584, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_4585, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_4586, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_4587, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_4588, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_4589, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_4590, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_4591, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_4592, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysInitialize"), method_4593, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStart"), method_4594, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysReinitialize"), method_4595, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysRestart"), method_4596, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysExecute"), method_4597, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStop"), method_4598, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysFinalize"), method_4599, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysBeginRun"), method_4600, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysEndRun"), method_4601, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("resetExecuted"), method_4602, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("beginRun"), method_4603, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("endRun"), method_4604, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4206), Reflex::Literal("setExecuted"), method_4605, 0, "state", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isEnabled"), method_4606, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("filterPassed"), method_4607, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4206), Reflex::Literal("setFilterPassed"), method_4608, 0, "state", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IIncidentListener -------------------------------
static  void operator_4617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IIncidentListener*)o)->operator=)(*(const ::IIncidentListener*)arg[0]);
  else   (((::IIncidentListener*)o)->operator=)(*(const ::IIncidentListener*)arg[0]);
}

static  void method_4620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IIncidentListener*)o)->interfaceID)();
  else   (((::IIncidentListener*)o)->interfaceID)();
}

static  void method_4621( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IIncidentListener*)o)->handle)(*(const ::Incident*)arg[0]);
}

static void destructor_4622(void*, void * o, const std::vector<void*>&, void *) {
(((::IIncidentListener*)o)->::IIncidentListener::~IIncidentListener)();
}
static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IIncidentListener,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IIncidentListener -------------------------------
void __IIncidentListener_db_datamem(Reflex::Class*);
void __IIncidentListener_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IIncidentListener_datamem_bld(&__IIncidentListener_db_datamem);
Reflex::GenreflexMemberBuilder __IIncidentListener_funcmem_bld(&__IIncidentListener_db_funcmem);
void __IIncidentListener_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IIncidentListener"), typeid(::IIncidentListener), sizeof(::IIncidentListener), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IIncidentListener, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19513, type_19514), Reflex::Literal("operator="), operator_4617, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IIncidentListener"), destructor_4622, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IIncidentListener_funcmem_bld);
}

//------Delayed data member builder for class IIncidentListener -------------------
void __IIncidentListener_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IIncidentListener -------------------
void __IIncidentListener_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4620, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19433), Reflex::Literal("handle"), method_4621, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IStatusCodeSvc -------------------------------
static  void operator_4629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStatusCodeSvc*)o)->operator=)(*(const ::IStatusCodeSvc*)arg[0]);
  else   (((::IStatusCodeSvc*)o)->operator=)(*(const ::IStatusCodeSvc*)arg[0]);
}

static  void method_4632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStatusCodeSvc*)o)->interfaceID)();
  else   (((::IStatusCodeSvc*)o)->interfaceID)();
}

static  void method_4633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IStatusCodeSvc*)o)->regFnc)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_4634( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::IStatusCodeSvc*)o)->list)();
}

static  void method_4635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IStatusCodeSvc*)o)->suppressCheck)());
  else   (((const ::IStatusCodeSvc*)o)->suppressCheck)();
}

static void destructor_4636(void*, void * o, const std::vector<void*>&, void *) {
(((::IStatusCodeSvc*)o)->::IStatusCodeSvc::~IStatusCodeSvc)();
}
static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IStatusCodeSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IStatusCodeSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IStatusCodeSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IStatusCodeSvc -------------------------------
void __IStatusCodeSvc_db_datamem(Reflex::Class*);
void __IStatusCodeSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IStatusCodeSvc_datamem_bld(&__IStatusCodeSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IStatusCodeSvc_funcmem_bld(&__IStatusCodeSvc_db_funcmem);
void __IStatusCodeSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IStatusCodeSvc"), typeid(::IStatusCodeSvc), sizeof(::IStatusCodeSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::IStatusCodeSvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19517, type_19518), Reflex::Literal("operator="), operator_4629, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IStatusCodeSvc"), destructor_4636, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IStatusCodeSvc_funcmem_bld);
}

//------Delayed data member builder for class IStatusCodeSvc -------------------
void __IStatusCodeSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IStatusCodeSvc -------------------
void __IStatusCodeSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4632, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_6134), Reflex::Literal("regFnc"), method_4633, 0, "fnc;lib", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("list"), method_4634, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("suppressCheck"), method_4635, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class ISerialize -------------------------------
static  void operator_4637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISerialize*)o)->operator=)(*(const ::ISerialize*)arg[0]);
  else   (((::ISerialize*)o)->operator=)(*(const ::ISerialize*)arg[0]);
}

static  void method_4640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISerialize*)o)->interfaceID)();
  else   (((::ISerialize*)o)->interfaceID)();
}

static  void method_4641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISerialize*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::ISerialize*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_4642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ISerialize*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::ISerialize*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void destructor_4643(void*, void * o, const std::vector<void*>&, void *) {
(((::ISerialize*)o)->::ISerialize::~ISerialize)();
}
static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::ISerialize,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ISerialize -------------------------------
void __ISerialize_db_datamem(Reflex::Class*);
void __ISerialize_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ISerialize_datamem_bld(&__ISerialize_db_datamem);
Reflex::GenreflexMemberBuilder __ISerialize_funcmem_bld(&__ISerialize_db_funcmem);
void __ISerialize_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ISerialize"), typeid(::ISerialize), sizeof(::ISerialize), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::ISerialize, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19519, type_19520), Reflex::Literal("operator="), operator_4637, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ISerialize"), destructor_4643, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ISerialize_funcmem_bld);
}

//------Delayed data member builder for class ISerialize -------------------
void __ISerialize_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ISerialize -------------------
void __ISerialize_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4640, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_4641, 0, "str", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_4642, 0, "str", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IExceptionSvc -------------------------------
static  void operator_4686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IExceptionSvc*)o)->operator=)(*(const ::IExceptionSvc*)arg[0]);
  else   (((::IExceptionSvc*)o)->operator=)(*(const ::IExceptionSvc*)arg[0]);
}

static  void method_4689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IExceptionSvc*)o)->interfaceID)();
  else   (((::IExceptionSvc*)o)->interfaceID)();
}

static  void method_4690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IExceptionSvc*)o)->handle)(*(const ::INamedInterface*)arg[0],
    *(const ::GaudiException*)arg[1]));
  else   (((const ::IExceptionSvc*)o)->handle)(*(const ::INamedInterface*)arg[0],
    *(const ::GaudiException*)arg[1]);
}

static  void method_4691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IExceptionSvc*)o)->handle)(*(const ::INamedInterface*)arg[0],
    *(const ::std::exception*)arg[1]));
  else   (((const ::IExceptionSvc*)o)->handle)(*(const ::INamedInterface*)arg[0],
    *(const ::std::exception*)arg[1]);
}

static  void method_4692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IExceptionSvc*)o)->handle)(*(const ::INamedInterface*)arg[0]));
  else   (((const ::IExceptionSvc*)o)->handle)(*(const ::INamedInterface*)arg[0]);
}

static  void method_4693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IExceptionSvc*)o)->handleErr)(*(const ::INamedInterface*)arg[0],
    *(const ::StatusCode*)arg[1]));
  else   (((const ::IExceptionSvc*)o)->handleErr)(*(const ::INamedInterface*)arg[0],
    *(const ::StatusCode*)arg[1]);
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IExceptionSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IExceptionSvc -------------------------------
void __IExceptionSvc_db_datamem(Reflex::Class*);
void __IExceptionSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IExceptionSvc_datamem_bld(&__IExceptionSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IExceptionSvc_funcmem_bld(&__IExceptionSvc_db_funcmem);
void __IExceptionSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IExceptionSvc"), typeid(::IExceptionSvc), sizeof(::IExceptionSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IExceptionSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19758, type_19759), Reflex::Literal("operator="), operator_4686, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IExceptionSvc_funcmem_bld);
}

//------Delayed data member builder for class IExceptionSvc -------------------
void __IExceptionSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IExceptionSvc -------------------
void __IExceptionSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4689, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19469, type_7838), Reflex::Literal("handle"), method_4690, 0, "o;e", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19469, type_19760), Reflex::Literal("handle"), method_4691, 0, "o;e", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19469), Reflex::Literal("handle"), method_4692, 0, "o", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19469, type_7461), Reflex::Literal("handleErr"), method_4693, 0, "o;s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class ObjectContainerBase -------------------------------
static  void operator_4696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectContainerBase*)o)->operator=)(*(const ::ObjectContainerBase*)arg[0]);
  else   (((::ObjectContainerBase*)o)->operator=)(*(const ::ObjectContainerBase*)arg[0]);
}

static  void method_4700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::ObjectContainerBase*)o)->index)((const ::ContainedObject*)arg[0]));
  else   (((const ::ObjectContainerBase*)o)->index)((const ::ContainedObject*)arg[0]);
}

static  void method_4701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::ObjectContainerBase*)o)->containedObject)(*(long*)arg[0]));
  else   (((const ::ObjectContainerBase*)o)->containedObject)(*(long*)arg[0]);
}

static  void method_4702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectContainerBase*)o)->numberOfObjects)());
  else   (((const ::ObjectContainerBase*)o)->numberOfObjects)();
}

static  void method_4703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::ObjectContainerBase*)o)->add)((::ContainedObject*)arg[0]));
  else   (((::ObjectContainerBase*)o)->add)((::ContainedObject*)arg[0]);
}

static  void method_4704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::ObjectContainerBase*)o)->remove)((::ContainedObject*)arg[0]));
  else   (((::ObjectContainerBase*)o)->remove)((::ContainedObject*)arg[0]);
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::ObjectContainerBase,::DataObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ObjectContainerBase -------------------------------
void __ObjectContainerBase_db_datamem(Reflex::Class*);
void __ObjectContainerBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ObjectContainerBase_datamem_bld(&__ObjectContainerBase_db_datamem);
Reflex::GenreflexMemberBuilder __ObjectContainerBase_funcmem_bld(&__ObjectContainerBase_db_funcmem);
void __ObjectContainerBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ObjectContainerBase"), typeid(::ObjectContainerBase), sizeof(::ObjectContainerBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_303, ::Reflex::BaseOffset< ::ObjectContainerBase, ::DataObject >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2023, Reflex::Literal("ObjectContainerBase::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19761, type_19762), Reflex::Literal("operator="), operator_4696, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ObjectContainerBase_funcmem_bld);
}

//------Delayed data member builder for class ObjectContainerBase -------------------
void __ObjectContainerBase_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ObjectContainerBase -------------------
void __ObjectContainerBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26, type_10234), Reflex::Literal("index"), method_4700, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10166, type_26), Reflex::Literal("containedObject"), method_4701, 0, "dist", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("numberOfObjects"), method_4702, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26, type_10166), Reflex::Literal("add"), method_4703, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26, type_10166), Reflex::Literal("remove"), method_4704, 0, "value", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartDataObjectPtr -------------------------------
static void constructor_4742( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataObjectPtr(Reflex::VoidPtrToFunc< ::DataObject*(*)(SmartDataObjectPtr*) >(arg[0]),
      (::IDataProviderSvc*)arg[1],
      (::IRegistry*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::SmartDataObjectPtr(Reflex::VoidPtrToFunc< ::DataObject*(*)(SmartDataObjectPtr*) >(arg[0]),
      (::IDataProviderSvc*)arg[1],
      (::IRegistry*)arg[2],
      *(const ::std::string*)arg[3]);
}

static void constructor_4743( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataObjectPtr(*(const ::SmartDataObjectPtr*)arg[0]);
  else ::new(mem) ::SmartDataObjectPtr(*(const ::SmartDataObjectPtr*)arg[0]);
}

static void destructor_4744(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartDataObjectPtr*)o)->::SmartDataObjectPtr::~SmartDataObjectPtr)();
}
static  void operator_4745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataObjectPtr*)o)->operator=)(*(const ::SmartDataObjectPtr*)arg[0]);
  else   (((::SmartDataObjectPtr*)o)->operator=)(*(const ::SmartDataObjectPtr*)arg[0]);
}

static  void converter_4746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->operator IRegistry*)());
  else   (((::SmartDataObjectPtr*)o)->operator IRegistry*)();
}

static  void method_4747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartDataObjectPtr*)o)->path)();
  else   (((const ::SmartDataObjectPtr*)o)->path)();
}

static  void method_4748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->directory)());
  else   (((::SmartDataObjectPtr*)o)->directory)();
}

static  void method_4749( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartDataObjectPtr*)o)->setService)((::IDataProviderSvc*)arg[0]);
}

static  void method_4750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->service)());
  else   (((::SmartDataObjectPtr*)o)->service)();
}

static  void method_4751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::SmartDataObjectPtr*)o)->getLastError)());
  else   (((const ::SmartDataObjectPtr*)o)->getLastError)();
}

static  void method_4752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->accessData)());
  else   (((::SmartDataObjectPtr*)o)->accessData)();
}

static  void method_4753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->retrieve)((::SmartDataObjectPtr*)arg[0]));
  else   (((::SmartDataObjectPtr*)o)->retrieve)((::SmartDataObjectPtr*)arg[0]);
}

static  void method_4754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->find)((::SmartDataObjectPtr*)arg[0]));
  else   (((::SmartDataObjectPtr*)o)->find)((::SmartDataObjectPtr*)arg[0]);
}

static  void method_4755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->update)((::SmartDataObjectPtr*)arg[0]));
  else   (((::SmartDataObjectPtr*)o)->update)((::SmartDataObjectPtr*)arg[0]);
}

static  void method_4756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->retrieveObject)());
  else   (((::SmartDataObjectPtr*)o)->retrieveObject)();
}

static  void method_4757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->findObject)());
  else   (((::SmartDataObjectPtr*)o)->findObject)();
}

static  void method_4758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr*)o)->updateObject)());
  else   (((::SmartDataObjectPtr*)o)->updateObject)();
}

//------Dictionary for class SmartDataObjectPtr -------------------------------
void __SmartDataObjectPtr_db_datamem(Reflex::Class*);
void __SmartDataObjectPtr_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartDataObjectPtr_datamem_bld(&__SmartDataObjectPtr_db_datamem);
Reflex::GenreflexMemberBuilder __SmartDataObjectPtr_funcmem_bld(&__SmartDataObjectPtr_db_funcmem);
void __SmartDataObjectPtr_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartDataObjectPtr"), typeid(::SmartDataObjectPtr), sizeof(::SmartDataObjectPtr), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartData*")
  .AddTypedef(type_4738, Reflex::Literal("SmartDataObjectPtr::AccessFunction"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4738, type_19780, type_10115, type_6134), Reflex::Literal("SmartDataObjectPtr"), constructor_4742, 0, "access;pService;pDir;path", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19792), Reflex::Literal("SmartDataObjectPtr"), constructor_4743, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartDataObjectPtr"), destructor_4744, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__SmartDataObjectPtr_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartDataObjectPtr_funcmem_bld);
}

//------Delayed data member builder for class SmartDataObjectPtr -------------------
void __SmartDataObjectPtr_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19780, Reflex::Literal("m_dataProvider"), OffsetOf(__shadow__::__SmartDataObjectPtr, m_dataProvider), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_10115, Reflex::Literal("m_pRegistry"), OffsetOf(__shadow__::__SmartDataObjectPtr, m_pRegistry), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_2872, Reflex::Literal("m_status"), OffsetOf(__shadow__::__SmartDataObjectPtr, m_status), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_3236, Reflex::Literal("m_path"), OffsetOf(__shadow__::__SmartDataObjectPtr, m_path), ::Reflex::PROTECTED)
  .AddDataMember(type_4738, Reflex::Literal("m_accessFunc"), OffsetOf(__shadow__::__SmartDataObjectPtr, m_accessFunc), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class SmartDataObjectPtr -------------------
void __SmartDataObjectPtr_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19793, type_19792), Reflex::Literal("operator="), operator_4745, 0, "copy", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10115), Reflex::Literal("operator IRegistry*"), converter_4746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("path"), method_4747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10115), Reflex::Literal("directory"), method_4748, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19780), Reflex::Literal("setService"), method_4749, 0, "svc", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("service"), method_4750, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("getLastError"), method_4751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("accessData"), method_4752, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429, type_19794), Reflex::Literal("retrieve"), method_4753, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429, type_19794), Reflex::Literal("find"), method_4754, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429, type_19794), Reflex::Literal("update"), method_4755, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("retrieveObject"), method_4756, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("findObject"), method_4757, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("updateObject"), method_4758, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class extend_interfaces3<IAlgTool,IProperty,IStateful> -------------------------------
static void destructor_4775(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces3<IAlgTool,IProperty,IStateful>*)o)->::extend_interfaces3<IAlgTool,IProperty,IStateful>::~extend_interfaces3)();
}
static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces3<IAlgTool,IProperty,IStateful> -------------------------------
void __extend_interfaces3_IAlgTool_IProperty_IStateful__db_datamem(Reflex::Class*);
void __extend_interfaces3_IAlgTool_IProperty_IStateful__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IAlgTool_IProperty_IStateful__datamem_bld(&__extend_interfaces3_IAlgTool_IProperty_IStateful__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IAlgTool_IProperty_IStateful__funcmem_bld(&__extend_interfaces3_IAlgTool_IProperty_IStateful__db_funcmem);
void __extend_interfaces3_IAlgTool_IProperty_IStateful__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces3<IAlgTool,IProperty,IStateful>"), typeid(::extend_interfaces3<IAlgTool,IProperty,IStateful>), sizeof(::extend_interfaces3<IAlgTool,IProperty,IStateful>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_813, ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>, ::IAlgTool >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_2383, ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>, ::IProperty >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_2654, ::Reflex::BaseOffset< ::extend_interfaces3<IAlgTool,IProperty,IStateful>, ::IStateful >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces3"), destructor_4775, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces3<IAlgTool,IProperty,IStateful> -------------------
void __extend_interfaces3_IAlgTool_IProperty_IStateful__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces3<IAlgTool,IProperty,IStateful> -------------------
void __extend_interfaces3_IAlgTool_IProperty_IStateful__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class extend_interfaces3<IService,IProperty,IStateful> -------------------------------
static  void operator_4776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::extend_interfaces3<IService,IProperty,IStateful>*)o)->operator=)(*(const ::extend_interfaces3<IService,IProperty,IStateful>*)arg[0]);
  else   (((::extend_interfaces3<IService,IProperty,IStateful>*)o)->operator=)(*(const ::extend_interfaces3<IService,IProperty,IStateful>*)arg[0]);
}

static void destructor_4779(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces3<IService,IProperty,IStateful>*)o)->::extend_interfaces3<IService,IProperty,IStateful>::~extend_interfaces3)();
}
static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces3<IService,IProperty,IStateful> -------------------------------
void __extend_interfaces3_IService_IProperty_IStateful__db_datamem(Reflex::Class*);
void __extend_interfaces3_IService_IProperty_IStateful__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IService_IProperty_IStateful__datamem_bld(&__extend_interfaces3_IService_IProperty_IStateful__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IService_IProperty_IStateful__funcmem_bld(&__extend_interfaces3_IService_IProperty_IStateful__db_funcmem);
void __extend_interfaces3_IService_IProperty_IStateful__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces3<IService,IProperty,IStateful>"), typeid(::extend_interfaces3<IService,IProperty,IStateful>), sizeof(::extend_interfaces3<IService,IProperty,IStateful>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_934, ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_2383, ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>, ::IProperty >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_2654, ::Reflex::BaseOffset< ::extend_interfaces3<IService,IProperty,IStateful>, ::IStateful >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19801, type_19802), Reflex::Literal("operator="), operator_4776, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces3"), destructor_4779, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces3<IService,IProperty,IStateful> -------------------
void __extend_interfaces3_IService_IProperty_IStateful__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces3<IService,IProperty,IStateful> -------------------
void __extend_interfaces3_IService_IProperty_IStateful__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class extend_interfaces3<IAlgorithm,IProperty,IStateful> -------------------------------
static  void operator_4780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::extend_interfaces3<IAlgorithm,IProperty,IStateful>*)o)->operator=)(*(const ::extend_interfaces3<IAlgorithm,IProperty,IStateful>*)arg[0]);
  else   (((::extend_interfaces3<IAlgorithm,IProperty,IStateful>*)o)->operator=)(*(const ::extend_interfaces3<IAlgorithm,IProperty,IStateful>*)arg[0]);
}

static void destructor_4783(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces3<IAlgorithm,IProperty,IStateful>*)o)->::extend_interfaces3<IAlgorithm,IProperty,IStateful>::~extend_interfaces3)();
}
static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgorithm")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>,::IAlgorithm >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces3<IAlgorithm,IProperty,IStateful> -------------------------------
void __extend_interfaces3_IAlgorithm_IProperty_IStateful__db_datamem(Reflex::Class*);
void __extend_interfaces3_IAlgorithm_IProperty_IStateful__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IAlgorithm_IProperty_IStateful__datamem_bld(&__extend_interfaces3_IAlgorithm_IProperty_IStateful__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IAlgorithm_IProperty_IStateful__funcmem_bld(&__extend_interfaces3_IAlgorithm_IProperty_IStateful__db_funcmem);
void __extend_interfaces3_IAlgorithm_IProperty_IStateful__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces3<IAlgorithm,IProperty,IStateful>"), typeid(::extend_interfaces3<IAlgorithm,IProperty,IStateful>), sizeof(::extend_interfaces3<IAlgorithm,IProperty,IStateful>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_549, ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>, ::IAlgorithm >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_2383, ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>, ::IProperty >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_2654, ::Reflex::BaseOffset< ::extend_interfaces3<IAlgorithm,IProperty,IStateful>, ::IStateful >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19803, type_19804), Reflex::Literal("operator="), operator_4780, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces3"), destructor_4783, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces3<IAlgorithm,IProperty,IStateful> -------------------
void __extend_interfaces3_IAlgorithm_IProperty_IStateful__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces3<IAlgorithm,IProperty,IStateful> -------------------
void __extend_interfaces3_IAlgorithm_IProperty_IStateful__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class extend_interfaces3<IService,IChronoSvc,IStatSvc> -------------------------------
static  void operator_4784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::extend_interfaces3<IService,IChronoSvc,IStatSvc>*)o)->operator=)(*(const ::extend_interfaces3<IService,IChronoSvc,IStatSvc>*)arg[0]);
  else   (((::extend_interfaces3<IService,IChronoSvc,IStatSvc>*)o)->operator=)(*(const ::extend_interfaces3<IService,IChronoSvc,IStatSvc>*)arg[0]);
}

static void destructor_4787(void*, void * o, const std::vector<void*>&, void *) {
(((::extend_interfaces3<IService,IChronoSvc,IStatSvc>*)o)->::extend_interfaces3<IService,IChronoSvc,IStatSvc>::~extend_interfaces3)();
}
static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IChronoSvc")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>,::IChronoSvc >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStatSvc")), ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>,::IStatSvc >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class extend_interfaces3<IService,IChronoSvc,IStatSvc> -------------------------------
void __extend_interfaces3_IService_IChronoSvc_IStatSvc__db_datamem(Reflex::Class*);
void __extend_interfaces3_IService_IChronoSvc_IStatSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IService_IChronoSvc_IStatSvc__datamem_bld(&__extend_interfaces3_IService_IChronoSvc_IStatSvc__db_datamem);
Reflex::GenreflexMemberBuilder __extend_interfaces3_IService_IChronoSvc_IStatSvc__funcmem_bld(&__extend_interfaces3_IService_IChronoSvc_IStatSvc__db_funcmem);
void __extend_interfaces3_IService_IChronoSvc_IStatSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("extend_interfaces3<IService,IChronoSvc,IStatSvc>"), typeid(::extend_interfaces3<IService,IChronoSvc,IStatSvc>), sizeof(::extend_interfaces3<IService,IChronoSvc,IStatSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "extend_interfaces*<*>")
  .AddBase(type_934, ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_2244, ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>, ::IChronoSvc >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddBase(type_1763, ::Reflex::BaseOffset< ::extend_interfaces3<IService,IChronoSvc,IStatSvc>, ::IStatSvc >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19805, type_19806), Reflex::Literal("operator="), operator_4784, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~extend_interfaces3"), destructor_4787, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class extend_interfaces3<IService,IChronoSvc,IStatSvc> -------------------
void __extend_interfaces3_IService_IChronoSvc_IStatSvc__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class extend_interfaces3<IService,IChronoSvc,IStatSvc> -------------------
void __extend_interfaces3_IService_IChronoSvc_IStatSvc__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IDataStoreAgent -------------------------------
static  void operator_4788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataStoreAgent*)o)->operator=)(*(const ::IDataStoreAgent*)arg[0]);
  else   (((::IDataStoreAgent*)o)->operator=)(*(const ::IDataStoreAgent*)arg[0]);
}

static void destructor_4791(void*, void * o, const std::vector<void*>&, void *) {
(((::IDataStoreAgent*)o)->::IDataStoreAgent::~IDataStoreAgent)();
}
static  void method_4792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::IDataStoreAgent*)o)->analyse)((::IRegistry*)arg[0],
    *(int*)arg[1]));
  else   (((::IDataStoreAgent*)o)->analyse)((::IRegistry*)arg[0],
    *(int*)arg[1]);
}

//------Dictionary for class IDataStoreAgent -------------------------------
void __IDataStoreAgent_db_datamem(Reflex::Class*);
void __IDataStoreAgent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IDataStoreAgent_datamem_bld(&__IDataStoreAgent_db_datamem);
Reflex::GenreflexMemberBuilder __IDataStoreAgent_funcmem_bld(&__IDataStoreAgent_db_funcmem);
void __IDataStoreAgent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IDataStoreAgent"), typeid(::IDataStoreAgent), sizeof(::IDataStoreAgent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19807, type_19808), Reflex::Literal("operator="), operator_4788, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDataStoreAgent"), destructor_4791, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IDataStoreAgent_funcmem_bld);
}

//------Delayed data member builder for class IDataStoreAgent -------------------
void __IDataStoreAgent_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDataStoreAgent -------------------
void __IDataStoreAgent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10115, type_142), Reflex::Literal("analyse"), method_4792, 0, "pObject;level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class GaudiHandleArrayBase -------------------------------
static  void operator_4860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiHandleArrayBase*)o)->operator=)(*(const ::GaudiHandleArrayBase*)arg[0]);
  else   (((::GaudiHandleArrayBase*)o)->operator=)(*(const ::GaudiHandleArrayBase*)arg[0]);
}

static  void method_4863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GaudiHandleArrayBase*)o)->setTypesAndNames)(*(const ::std::vector<std::basic_string<char> >*)arg[0]));
  else   (((::GaudiHandleArrayBase*)o)->setTypesAndNames)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_4864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::GaudiHandleArrayBase*)o)->typesAndNames)());
  else   (((const ::GaudiHandleArrayBase*)o)->typesAndNames)();
}

static  void method_4865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::GaudiHandleArrayBase*)o)->types)());
  else   (((const ::GaudiHandleArrayBase*)o)->types)();
}

static  void method_4866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::GaudiHandleArrayBase*)o)->names)());
  else   (((const ::GaudiHandleArrayBase*)o)->names)();
}

static  void method_4867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::GaudiHandleArrayBase*)o)->getBaseInfos)(*(::std::string(::GaudiHandleBase::**)(void) const)arg[0]));
  else   (((const ::GaudiHandleArrayBase*)o)->getBaseInfos)(*(::std::string(::GaudiHandleBase::**)(void) const)arg[0]);
}

static  void method_4868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleArrayBase*)o)->pythonPropertyClassName)());
  else   (((const ::GaudiHandleArrayBase*)o)->pythonPropertyClassName)();
}

static  void method_4869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleArrayBase*)o)->pythonRepr)());
  else   (((const ::GaudiHandleArrayBase*)o)->pythonRepr)();
}

static  void method_4870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GaudiHandleArrayBase*)o)->push_back)(*(const ::std::string*)arg[0]));
  else   (((::GaudiHandleArrayBase*)o)->push_back)(*(const ::std::string*)arg[0]);
}

static  void method_4871( void*, void* o, const std::vector<void*>&, void*)
{
  (((::GaudiHandleArrayBase*)o)->clear)();
}

static  void method_4872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GaudiHandleArrayBase*)o)->empty)());
  else   (((const ::GaudiHandleArrayBase*)o)->empty)();
}

static  void method_4873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<const GaudiHandleBase*>)((((const ::GaudiHandleArrayBase*)o)->getBaseArray)());
  else   (((const ::GaudiHandleArrayBase*)o)->getBaseArray)();
}

static  void method_4874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<GaudiHandleBase*>)((((::GaudiHandleArrayBase*)o)->getBaseArray)());
  else   (((::GaudiHandleArrayBase*)o)->getBaseArray)();
}

static void destructor_4875(void*, void * o, const std::vector<void*>&, void *) {
(((::GaudiHandleArrayBase*)o)->::GaudiHandleArrayBase::~GaudiHandleArrayBase)();
}
static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("GaudiHandleInfo")), ::Reflex::BaseOffset< ::GaudiHandleArrayBase,::GaudiHandleInfo >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GaudiHandleArrayBase -------------------------------
void __GaudiHandleArrayBase_db_datamem(Reflex::Class*);
void __GaudiHandleArrayBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GaudiHandleArrayBase_datamem_bld(&__GaudiHandleArrayBase_db_datamem);
Reflex::GenreflexMemberBuilder __GaudiHandleArrayBase_funcmem_bld(&__GaudiHandleArrayBase_db_funcmem);
void __GaudiHandleArrayBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GaudiHandleArrayBase"), typeid(::GaudiHandleArrayBase), sizeof(::GaudiHandleArrayBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_133, ::Reflex::BaseOffset< ::GaudiHandleArrayBase, ::GaudiHandleInfo >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3176, Reflex::Literal("GaudiHandleArrayBase::BaseHandleArray"))
  .AddTypedef(type_3175, Reflex::Literal("GaudiHandleArrayBase::ConstBaseHandleArray"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828, type_19829), Reflex::Literal("operator="), operator_4860, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GaudiHandleArrayBase"), destructor_4875, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__GaudiHandleArrayBase_funcmem_bld);
}

//------Delayed data member builder for class GaudiHandleArrayBase -------------------
void __GaudiHandleArrayBase_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class GaudiHandleArrayBase -------------------
void __GaudiHandleArrayBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_12573), Reflex::Literal("setTypesAndNames"), method_4863, 0, "myTypesAndNamesList", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165c), Reflex::Literal("typesAndNames"), method_4864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165c), Reflex::Literal("types"), method_4865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165c), Reflex::Literal("names"), method_4866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165c, type_19831), Reflex::Literal("getBaseInfos"), method_4867, 0, "pMemFunc", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236c), Reflex::Literal("pythonPropertyClassName"), method_4868, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236c), Reflex::Literal("pythonRepr"), method_4869, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_6134), Reflex::Literal("push_back"), method_4870, 0, "myHandleTypeAndName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_4871, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_4872, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3175), Reflex::Literal("getBaseArray"), method_4873, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3176), Reflex::Literal("getBaseArray"), method_4874, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IConversionSvc -------------------------------
static  void operator_4877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IConversionSvc*)o)->operator=)(*(const ::IConversionSvc*)arg[0]);
  else   (((::IConversionSvc*)o)->operator=)(*(const ::IConversionSvc*)arg[0]);
}

static  void method_4880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IConversionSvc*)o)->interfaceID)();
  else   (((::IConversionSvc*)o)->interfaceID)();
}

static  void method_4881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConversionSvc*)o)->addConverter)((::IConverter*)arg[0]));
  else   (((::IConversionSvc*)o)->addConverter)((::IConverter*)arg[0]);
}

static  void method_4882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConversionSvc*)o)->addConverter)(*(const ::CLID*)arg[0]));
  else   (((::IConversionSvc*)o)->addConverter)(*(const ::CLID*)arg[0]);
}

static  void method_4883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConversionSvc*)o)->removeConverter)(*(const ::CLID*)arg[0]));
  else   (((::IConversionSvc*)o)->removeConverter)(*(const ::CLID*)arg[0]);
}

static  void method_4884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IConversionSvc*)o)->converter)(*(const ::CLID*)arg[0]));
  else   (((::IConversionSvc*)o)->converter)(*(const ::CLID*)arg[0]);
}

static  void method_4885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConversionSvc*)o)->connectOutput)(*(const ::std::string*)arg[0]));
  else   (((::IConversionSvc*)o)->connectOutput)(*(const ::std::string*)arg[0]);
}

static  void method_4886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConversionSvc*)o)->connectOutput)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IConversionSvc*)o)->connectOutput)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_4887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConversionSvc*)o)->commitOutput)(*(const ::std::string*)arg[0],
    *(bool*)arg[1]));
  else   (((::IConversionSvc*)o)->commitOutput)(*(const ::std::string*)arg[0],
    *(bool*)arg[1]);
}

static void destructor_4888(void*, void * o, const std::vector<void*>&, void *) {
(((::IConversionSvc*)o)->::IConversionSvc::~IConversionSvc)();
}
static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IConverter")), ::Reflex::BaseOffset< ::IConversionSvc,::IConverter >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IConversionSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IConversionSvc -------------------------------
void __IConversionSvc_db_datamem(Reflex::Class*);
void __IConversionSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IConversionSvc_datamem_bld(&__IConversionSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IConversionSvc_funcmem_bld(&__IConversionSvc_db_funcmem);
void __IConversionSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IConversionSvc"), typeid(::IConversionSvc), sizeof(::IConversionSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1044, ::Reflex::BaseOffset< ::IConversionSvc, ::IConverter >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("IConversionSvc::Status"), Reflex::Literal("CONVERSIONSVC_NO_ERROR=11;NO_CONVERTER=12"), &typeid(IConversionSvc::Status), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19832, type_19833), Reflex::Literal("operator="), operator_4877, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IConversionSvc"), destructor_4888, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IConversionSvc_funcmem_bld);
}

//------Delayed data member builder for class IConversionSvc -------------------
void __IConversionSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IConversionSvc -------------------
void __IConversionSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4880, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19834), Reflex::Literal("addConverter"), method_4881, 0, "pConverter", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19456), Reflex::Literal("addConverter"), method_4882, 0, "clid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19456), Reflex::Literal("removeConverter"), method_4883, 0, "clid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19834, type_19456), Reflex::Literal("converter"), method_4884, 0, "clid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("connectOutput"), method_4885, 0, "outputFile", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("connectOutput"), method_4886, 0, "outputFile;openMode", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_4206), Reflex::Literal("commitOutput"), method_4887, 0, "outputFile;do_commit", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IPersistencySvc -------------------------------
static  void operator_4892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IPersistencySvc*)o)->operator=)(*(const ::IPersistencySvc*)arg[0]);
  else   (((::IPersistencySvc*)o)->operator=)(*(const ::IPersistencySvc*)arg[0]);
}

static  void method_4895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IPersistencySvc*)o)->interfaceID)();
  else   (((::IPersistencySvc*)o)->interfaceID)();
}

static  void method_4896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPersistencySvc*)o)->setDefaultCnvService)(*(long*)arg[0]));
  else   (((::IPersistencySvc*)o)->setDefaultCnvService)(*(long*)arg[0]);
}

static  void method_4897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPersistencySvc*)o)->addCnvService)((::IConversionSvc*)arg[0]));
  else   (((::IPersistencySvc*)o)->addCnvService)((::IConversionSvc*)arg[0]);
}

static  void method_4898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPersistencySvc*)o)->removeCnvService)(*(long*)arg[0]));
  else   (((::IPersistencySvc*)o)->removeCnvService)(*(long*)arg[0]);
}

static  void method_4899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPersistencySvc*)o)->getService)(*(long*)arg[0],
    *(::IConversionSvc**)arg[1]));
  else   (((::IPersistencySvc*)o)->getService)(*(long*)arg[0],
    *(::IConversionSvc**)arg[1]);
}

static  void method_4900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPersistencySvc*)o)->getService)(*(const ::std::string*)arg[0],
    *(::IConversionSvc**)arg[1]));
  else   (((::IPersistencySvc*)o)->getService)(*(const ::std::string*)arg[0],
    *(::IConversionSvc**)arg[1]);
}

static void destructor_4901(void*, void * o, const std::vector<void*>&, void *) {
(((::IPersistencySvc*)o)->::IPersistencySvc::~IPersistencySvc)();
}
static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IPersistencySvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IPersistencySvc -------------------------------
void __IPersistencySvc_db_datamem(Reflex::Class*);
void __IPersistencySvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IPersistencySvc_datamem_bld(&__IPersistencySvc_db_datamem);
Reflex::GenreflexMemberBuilder __IPersistencySvc_funcmem_bld(&__IPersistencySvc_db_funcmem);
void __IPersistencySvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IPersistencySvc"), typeid(::IPersistencySvc), sizeof(::IPersistencySvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IPersistencySvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19839, type_19840), Reflex::Literal("operator="), operator_4892, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IPersistencySvc"), destructor_4901, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IPersistencySvc_funcmem_bld);
}

//------Delayed data member builder for class IPersistencySvc -------------------
void __IPersistencySvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IPersistencySvc -------------------
void __IPersistencySvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4895, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_26), Reflex::Literal("setDefaultCnvService"), method_4896, 0, "type", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19841), Reflex::Literal("addCnvService"), method_4897, 0, "service", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_26), Reflex::Literal("removeCnvService"), method_4898, 0, "type", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_26, type_19842), Reflex::Literal("getService"), method_4899, 0, "service_type;refpSvc", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19842), Reflex::Literal("getService"), method_4900, 0, "service_type;refpSvc", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IMessageSvc -------------------------------
static  void operator_4915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IMessageSvc*)o)->operator=)(*(const ::IMessageSvc*)arg[0]);
  else   (((::IMessageSvc*)o)->operator=)(*(const ::IMessageSvc*)arg[0]);
}

static  void method_4918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IMessageSvc*)o)->interfaceID)();
  else   (((::IMessageSvc*)o)->interfaceID)();
}

static  void method_4919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->reportMessage)(*(const ::Message*)arg[0],
    *(int*)arg[1]);
}

static  void method_4920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->reportMessage)(*(const ::Message*)arg[0]);
}

static  void method_4921( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::IMessageSvc*)o)->reportMessage)(*(const ::StatusCode*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::IMessageSvc*)o)->reportMessage)(*(const ::StatusCode*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_4922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->reportMessage)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2]);
}

static  void method_4923( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::IMessageSvc*)o)->reportMessage)((const char*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::IMessageSvc*)o)->reportMessage)((const char*)arg[0],
      *(int*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_4924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->insertMessage)(*(const ::StatusCode*)arg[0],
    *(const ::Message*)arg[1]);
}

static  void method_4925( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IMessageSvc*)o)->eraseMessage)();
}

static  void method_4926( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->eraseMessage)(*(const ::StatusCode*)arg[0]);
}

static  void method_4927( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->eraseMessage)(*(const ::StatusCode*)arg[0],
    *(const ::Message*)arg[1]);
}

static  void method_4928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->insertStream)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    (::std::ostream*)arg[2]);
}

static  void method_4929( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IMessageSvc*)o)->eraseStream)();
}

static  void method_4930( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->eraseStream)(*(int*)arg[0]);
}

static  void method_4931( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->eraseStream)(*(int*)arg[0],
    (::std::ostream*)arg[1]);
}

static  void method_4932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->eraseStream)((::std::ostream*)arg[0]);
}

static  void method_4933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IMessageSvc*)o)->defaultStream)());
  else   (((const ::IMessageSvc*)o)->defaultStream)();
}

static  void method_4934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->setDefaultStream)((::std::ostream*)arg[0]);
}

static  void method_4935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IMessageSvc*)o)->outputLevel)());
  else   (((const ::IMessageSvc*)o)->outputLevel)();
}

static  void method_4936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IMessageSvc*)o)->outputLevel)(*(const ::std::string*)arg[0]));
  else   (((const ::IMessageSvc*)o)->outputLevel)(*(const ::std::string*)arg[0]);
}

static  void method_4937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->setOutputLevel)(*(int*)arg[0]);
}

static  void method_4938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMessageSvc*)o)->setOutputLevel)(*(const ::std::string*)arg[0],
    *(int*)arg[1]);
}

static  void method_4939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IMessageSvc*)o)->useColor)());
  else   (((const ::IMessageSvc*)o)->useColor)();
}

static  void method_4940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::IMessageSvc*)o)->getLogColor)(*(int*)arg[0]));
  else   (((const ::IMessageSvc*)o)->getLogColor)(*(int*)arg[0]);
}

static  void method_4941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IMessageSvc*)o)->messageCount)(*(::MSG::Level*)arg[0]));
  else   (((const ::IMessageSvc*)o)->messageCount)(*(::MSG::Level*)arg[0]);
}

static void destructor_4942(void*, void * o, const std::vector<void*>&, void *) {
(((::IMessageSvc*)o)->::IMessageSvc::~IMessageSvc)();
}
static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IMessageSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IMessageSvc -------------------------------
void __IMessageSvc_db_datamem(Reflex::Class*);
void __IMessageSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IMessageSvc_datamem_bld(&__IMessageSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IMessageSvc_funcmem_bld(&__IMessageSvc_db_funcmem);
void __IMessageSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IMessageSvc"), typeid(::IMessageSvc), sizeof(::IMessageSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IMessageSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19846, type_19847), Reflex::Literal("operator="), operator_4915, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IMessageSvc"), destructor_4942, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IMessageSvc_funcmem_bld);
}

//------Delayed data member builder for class IMessageSvc -------------------
void __IMessageSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IMessageSvc -------------------
void __IMessageSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4918, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19848, type_142), Reflex::Literal("reportMessage"), method_4919, 0, "msg;outputLevel", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19848), Reflex::Literal("reportMessage"), method_4920, 0, "message", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7461, type_6134), Reflex::Literal("reportMessage"), method_4921, 0, "code;source=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_142, type_6134), Reflex::Literal("reportMessage"), method_4922, 0, "source;type;message", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4095, type_142, type_4095), Reflex::Literal("reportMessage"), method_4923, 0, "source;type;message=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7461, type_19848), Reflex::Literal("insertMessage"), method_4924, 0, "code;message", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("eraseMessage"), method_4925, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7461), Reflex::Literal("eraseMessage"), method_4926, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7461, type_19848), Reflex::Literal("eraseMessage"), method_4927, 0, "code;message", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_142, type_6134, type_19849), Reflex::Literal("insertStream"), method_4928, 0, "type;name;stream", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("eraseStream"), method_4929, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_142), Reflex::Literal("eraseStream"), method_4930, 0, "message_type", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_142, type_19849), Reflex::Literal("eraseStream"), method_4931, 0, "type;stream", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19849), Reflex::Literal("eraseStream"), method_4932, 0, "stream", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19849), Reflex::Literal("defaultStream"), method_4933, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19849), Reflex::Literal("setDefaultStream"), method_4934, 0, "stream", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142), Reflex::Literal("outputLevel"), method_4935, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_6134), Reflex::Literal("outputLevel"), method_4936, 0, "source", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_142), Reflex::Literal("setOutputLevel"), method_4937, 0, "new_level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_142), Reflex::Literal("setOutputLevel"), method_4938, 0, "source;new_level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("useColor"), method_4939, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236, type_142), Reflex::Literal("getLogColor"), method_4940, 0, "logLevel", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4106), Reflex::Literal("messageCount"), method_4941, 0, "level", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IMonitorSvc -------------------------------
static  void operator_4943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IMonitorSvc*)o)->operator=)(*(const ::IMonitorSvc*)arg[0]);
  else   (((::IMonitorSvc*)o)->operator=)(*(const ::IMonitorSvc*)arg[0]);
}

static  void method_4946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IMonitorSvc*)o)->interfaceID)();
  else   (((::IMonitorSvc*)o)->interfaceID)();
}

static  void method_4947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const bool*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4948( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const int*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4949( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const long*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4950( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const double*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4951( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4952( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const ::std::pair<double,double>*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4953( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    (const ::AIDA::IBaseHistogram*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const ::StatEntity*)arg[1],
    *(const ::std::string*)arg[2],
    (const ::IInterface*)arg[3]);
}

static  void method_4955( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (const void*)arg[2],
    *(int*)arg[3],
    *(const ::std::string*)arg[4],
    (const ::IInterface*)arg[5]);
}

static  void method_4956( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->undeclareInfo)(*(const ::std::string*)arg[0],
    (const ::IInterface*)arg[1]);
}

static  void method_4957( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IMonitorSvc*)o)->undeclareAll)((const ::IInterface*)arg[0]);
}

static  void method_4958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IMonitorSvc*)o)->getInfos)());
    else     (((::IMonitorSvc*)o)->getInfos)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IMonitorSvc*)o)->getInfos)((const ::IInterface*)arg[0]));
    else     (((::IMonitorSvc*)o)->getInfos)((const ::IInterface*)arg[0]);
  }
}

static void destructor_4959(void*, void * o, const std::vector<void*>&, void *) {
(((::IMonitorSvc*)o)->::IMonitorSvc::~IMonitorSvc)();
}
static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IMonitorSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IMonitorSvc -------------------------------
void __IMonitorSvc_db_datamem(Reflex::Class*);
void __IMonitorSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IMonitorSvc_datamem_bld(&__IMonitorSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IMonitorSvc_funcmem_bld(&__IMonitorSvc_db_funcmem);
void __IMonitorSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IMonitorSvc"), typeid(::IMonitorSvc), sizeof(::IMonitorSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IMonitorSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19850, type_19851), Reflex::Literal("operator="), operator_4943, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IMonitorSvc"), destructor_4959, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IMonitorSvc_funcmem_bld);
}

//------Delayed data member builder for class IMonitorSvc -------------------
void __IMonitorSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IMonitorSvc -------------------
void __IMonitorSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4946, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_17505, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4947, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_12039, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4948, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_10901, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4949, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_10968, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4950, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_6134, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4951, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_12439, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4952, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_19853, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4953, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_7460, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4954, 0, "name;var;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_6134, type_4284, type_142, type_6134, type_19852), Reflex::Literal("declareInfo"), method_4955, 0, "name;format;var;size;desc;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_19852), Reflex::Literal("undeclareInfo"), method_4956, 0, "name;owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19852), Reflex::Literal("undeclareAll"), method_4957, 0, "owner", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19854, type_19852), Reflex::Literal("getInfos"), method_4958, 0, "owner=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IDataStoreLeaves -------------------------------
static  void operator_4961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataStoreLeaves*)o)->operator=)(*(const ::IDataStoreLeaves*)arg[0]);
  else   (((::IDataStoreLeaves*)o)->operator=)(*(const ::IDataStoreLeaves*)arg[0]);
}

static  void method_4964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataStoreLeaves*)o)->interfaceID)();
  else   (((::IDataStoreLeaves*)o)->interfaceID)();
}

static  void method_4965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IDataStoreLeaves*)o)->leaves)();
  else   (((const ::IDataStoreLeaves*)o)->leaves)();
}

static void destructor_4966(void*, void * o, const std::vector<void*>&, void *) {
(((::IDataStoreLeaves*)o)->::IDataStoreLeaves::~IDataStoreLeaves)();
}
static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::IDataStoreLeaves,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IDataStoreLeaves,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IDataStoreLeaves,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IDataStoreLeaves -------------------------------
void __IDataStoreLeaves_db_datamem(Reflex::Class*);
void __IDataStoreLeaves_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IDataStoreLeaves_datamem_bld(&__IDataStoreLeaves_db_datamem);
Reflex::GenreflexMemberBuilder __IDataStoreLeaves_funcmem_bld(&__IDataStoreLeaves_db_funcmem);
void __IDataStoreLeaves_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IDataStoreLeaves"), typeid(::IDataStoreLeaves), sizeof(::IDataStoreLeaves), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_813, ::Reflex::BaseOffset< ::IDataStoreLeaves, ::IAlgTool >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_1822, Reflex::Literal("IDataStoreLeaves::LeavesList"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19855, type_19856), Reflex::Literal("operator="), operator_4961, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDataStoreLeaves"), destructor_4966, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IDataStoreLeaves_funcmem_bld);
}

//------Delayed data member builder for class IDataStoreLeaves -------------------
void __IDataStoreLeaves_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDataStoreLeaves -------------------
void __IDataStoreLeaves_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4964, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19857), Reflex::Literal("leaves"), method_4965, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class INTupleSvc -------------------------------
static  void operator_4967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::INTupleSvc*)o)->operator=)(*(const ::INTupleSvc*)arg[0]);
  else   (((::INTupleSvc*)o)->operator=)(*(const ::INTupleSvc*)arg[0]);
}

static  void method_4970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::INTupleSvc*)o)->interfaceID)();
  else   (((::INTupleSvc*)o)->interfaceID)();
}

static  void method_4971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->create)(*(const ::CLID*)arg[0],
    *(const ::std::string*)arg[1],
    *(::NTuple::Tuple**)arg[2]));
  else   (((::INTupleSvc*)o)->create)(*(const ::CLID*)arg[0],
    *(const ::std::string*)arg[1],
    *(::NTuple::Tuple**)arg[2]);
}

static  void method_4972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::CLID*)arg[1],
    *(const ::std::string*)arg[2]));
  else   (((::INTupleSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::CLID*)arg[1],
    *(const ::std::string*)arg[2]);
}

static  void method_4973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]));
  else   (((::INTupleSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]);
}

static  void method_4974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(long*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]));
  else   (((::INTupleSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(long*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]);
}

static  void method_4975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]));
  else   (((::INTupleSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]);
}

static  void method_4976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->book)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]));
  else   (((::INTupleSvc*)o)->book)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(const ::CLID*)arg[2],
    *(const ::std::string*)arg[3]);
}

static  void method_4977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->createDirectory)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::INTupleSvc*)o)->createDirectory)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_4978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->createDirectory)((::DataObject*)arg[0],
    *(long*)arg[1]));
  else   (((::INTupleSvc*)o)->createDirectory)((::DataObject*)arg[0],
    *(long*)arg[1]);
}

static  void method_4979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->createDirectory)(*(const ::std::string*)arg[0],
    *(long*)arg[1]));
  else   (((::INTupleSvc*)o)->createDirectory)(*(const ::std::string*)arg[0],
    *(long*)arg[1]);
}

static  void method_4980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->createDirectory)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::INTupleSvc*)o)->createDirectory)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_4981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->createDirectory)(*(const ::std::string*)arg[0]));
  else   (((::INTupleSvc*)o)->createDirectory)(*(const ::std::string*)arg[0]);
}

static  void method_4982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTupleSvc*)o)->access)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::INTupleSvc*)o)->access)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_4983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->save)(*(const ::std::string*)arg[0]));
  else   (((::INTupleSvc*)o)->save)(*(const ::std::string*)arg[0]);
}

static  void method_4984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->save)((::NTuple::Tuple*)arg[0]));
  else   (((::INTupleSvc*)o)->save)((::NTuple::Tuple*)arg[0]);
}

static  void method_4985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->save)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::INTupleSvc*)o)->save)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_4986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->writeRecord)((::NTuple::Tuple*)arg[0]));
  else   (((::INTupleSvc*)o)->writeRecord)((::NTuple::Tuple*)arg[0]);
}

static  void method_4987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->writeRecord)(*(const ::std::string*)arg[0]));
  else   (((::INTupleSvc*)o)->writeRecord)(*(const ::std::string*)arg[0]);
}

static  void method_4988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->writeRecord)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::INTupleSvc*)o)->writeRecord)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_4989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->readRecord)((::NTuple::Tuple*)arg[0]));
  else   (((::INTupleSvc*)o)->readRecord)((::NTuple::Tuple*)arg[0]);
}

static  void method_4990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->readRecord)(*(const ::std::string*)arg[0]));
  else   (((::INTupleSvc*)o)->readRecord)(*(const ::std::string*)arg[0]);
}

static  void method_4991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTupleSvc*)o)->readRecord)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::INTupleSvc*)o)->readRecord)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void destructor_4992(void*, void * o, const std::vector<void*>&, void *) {
(((::INTupleSvc*)o)->::INTupleSvc::~INTupleSvc)();
}
static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IDataProviderSvc")), ::Reflex::BaseOffset< ::INTupleSvc,::IDataProviderSvc >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::INTupleSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class INTupleSvc -------------------------------
void __INTupleSvc_db_datamem(Reflex::Class*);
void __INTupleSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __INTupleSvc_datamem_bld(&__INTupleSvc_db_datamem);
Reflex::GenreflexMemberBuilder __INTupleSvc_funcmem_bld(&__INTupleSvc_db_funcmem);
void __INTupleSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("INTupleSvc"), typeid(::INTupleSvc), sizeof(::INTupleSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1414, ::Reflex::BaseOffset< ::INTupleSvc, ::IDataProviderSvc >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19858, type_19859), Reflex::Literal("operator="), operator_4967, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~INTupleSvc"), destructor_4992, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__INTupleSvc_funcmem_bld);
}

//------Delayed data member builder for class INTupleSvc -------------------
void __INTupleSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class INTupleSvc -------------------
void __INTupleSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4970, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19456, type_6134, type_19860), Reflex::Literal("create"), method_4971, 0, "typ;title;refpTuple", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19861, type_6134, type_19456, type_6134), Reflex::Literal("book"), method_4972, 0, "fullPath;type;title", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19861, type_6134, type_6134, type_19456, type_6134), Reflex::Literal("book"), method_4973, 0, "dirPath;relPath;type;title", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19861, type_6134, type_26, type_19456, type_6134), Reflex::Literal("book"), method_4974, 0, "dirPath;id;type;title", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19861, type_19429, type_6134, type_19456, type_6134), Reflex::Literal("book"), method_4975, 0, "pParent;relPath;type;title", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19861, type_19429, type_26, type_19456, type_6134), Reflex::Literal("book"), method_4976, 0, "pParent;id;type;title", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19862, type_19429, type_6134), Reflex::Literal("createDirectory"), method_4977, 0, "pParent;title", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19862, type_19429, type_26), Reflex::Literal("createDirectory"), method_4978, 0, "pParent;id", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19862, type_6134, type_26), Reflex::Literal("createDirectory"), method_4979, 0, "dirPath;id", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19862, type_6134, type_6134), Reflex::Literal("createDirectory"), method_4980, 0, "dirPath;title", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19862, type_6134), Reflex::Literal("createDirectory"), method_4981, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19861, type_6134, type_6134), Reflex::Literal("access"), method_4982, 0, "fullPath;filename", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("save"), method_4983, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19861), Reflex::Literal("save"), method_4984, 0, "tuple", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134), Reflex::Literal("save"), method_4985, 0, "pParent;relPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19861), Reflex::Literal("writeRecord"), method_4986, 0, "tuple", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("writeRecord"), method_4987, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134), Reflex::Literal("writeRecord"), method_4988, 0, "pParent;relPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19861), Reflex::Literal("readRecord"), method_4989, 0, "tuple", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("readRecord"), method_4990, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134), Reflex::Literal("readRecord"), method_4991, 0, "pParent;relPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IAlgTool -------------------------------
static  void method_4996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAlgTool*)o)->interfaceID)();
  else   (((::IAlgTool*)o)->interfaceID)();
}

static void destructor_4997(void*, void * o, const std::vector<void*>&, void *) {
(((::IAlgTool*)o)->::IAlgTool::~IAlgTool)();
}
static  void method_4998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IAlgTool*)o)->type)();
  else   (((const ::IAlgTool*)o)->type)();
}

static  void method_4999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IAlgTool*)o)->parent)());
  else   (((const ::IAlgTool*)o)->parent)();
}

static  void method_5000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->configure)());
  else   (((::IAlgTool*)o)->configure)();
}

static  void method_5001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->initialize)());
  else   (((::IAlgTool*)o)->initialize)();
}

static  void method_5002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->start)());
  else   (((::IAlgTool*)o)->start)();
}

static  void method_5003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->stop)());
  else   (((::IAlgTool*)o)->stop)();
}

static  void method_5004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->finalize)());
  else   (((::IAlgTool*)o)->finalize)();
}

static  void method_5005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->terminate)());
  else   (((::IAlgTool*)o)->terminate)();
}

static  void method_5006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->reinitialize)());
  else   (((::IAlgTool*)o)->reinitialize)();
}

static  void method_5007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->restart)());
  else   (((::IAlgTool*)o)->restart)();
}

static  void method_5008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IAlgTool*)o)->FSMState)());
  else   (((const ::IAlgTool*)o)->FSMState)();
}

static  void method_5009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->sysInitialize)());
  else   (((::IAlgTool*)o)->sysInitialize)();
}

static  void method_5010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->sysStart)());
  else   (((::IAlgTool*)o)->sysStart)();
}

static  void method_5011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->sysStop)());
  else   (((::IAlgTool*)o)->sysStop)();
}

static  void method_5012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->sysFinalize)());
  else   (((::IAlgTool*)o)->sysFinalize)();
}

static  void method_5013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->sysReinitialize)());
  else   (((::IAlgTool*)o)->sysReinitialize)();
}

static  void method_5014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgTool*)o)->sysRestart)());
  else   (((::IAlgTool*)o)->sysRestart)();
}

static  void method_5015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::IAlgTool*)o)->refCount)());
  else   (((const ::IAlgTool*)o)->refCount)();
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IAlgTool,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAlgTool,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAlgTool -------------------------------
void __IAlgTool_db_datamem(Reflex::Class*);
void __IAlgTool_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAlgTool_datamem_bld(&__IAlgTool_db_datamem);
Reflex::GenreflexMemberBuilder __IAlgTool_funcmem_bld(&__IAlgTool_db_funcmem);
void __IAlgTool_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAlgTool"), typeid(::IAlgTool), sizeof(::IAlgTool), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2776, ::Reflex::BaseOffset< ::IAlgTool, ::INamedInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IAlgTool"), destructor_4997, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAlgTool_funcmem_bld);
}

//------Delayed data member builder for class IAlgTool -------------------
void __IAlgTool_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAlgTool -------------------
void __IAlgTool_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_4996, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("type"), method_4998, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19852), Reflex::Literal("parent"), method_4999, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_5000, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_5001, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_5002, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_5003, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_5004, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_5005, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_5006, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_5007, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_5008, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysInitialize"), method_5009, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStart"), method_5010, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStop"), method_5011, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysFinalize"), method_5012, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysReinitialize"), method_5013, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysRestart"), method_5014, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_5015, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IRndmEngine -------------------------------
static  void operator_5053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRndmEngine*)o)->operator=)(*(const ::IRndmEngine*)arg[0]);
  else   (((::IRndmEngine*)o)->operator=)(*(const ::IRndmEngine*)arg[0]);
}

static  void method_5056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRndmEngine*)o)->interfaceID)();
  else   (((::IRndmEngine*)o)->interfaceID)();
}

static  void method_5057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::IRndmEngine*)o)->rndm)());
  else   (((const ::IRndmEngine*)o)->rndm)();
}

static  void method_5058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((const ::IRndmEngine*)o)->rndmArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1]));
    else     (((const ::IRndmEngine*)o)->rndmArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((const ::IRndmEngine*)o)->rndmArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]));
    else     (((const ::IRndmEngine*)o)->rndmArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
}

static  void method_5059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IRndmEngine*)o)->setSeeds)(*(const ::std::vector<long>*)arg[0]));
  else   (((::IRndmEngine*)o)->setSeeds)(*(const ::std::vector<long>*)arg[0]);
}

static  void method_5060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IRndmEngine*)o)->seeds)(*(::std::vector<long>*)arg[0]));
  else   (((const ::IRndmEngine*)o)->seeds)(*(::std::vector<long>*)arg[0]);
}

static void destructor_5061(void*, void * o, const std::vector<void*>&, void *) {
(((::IRndmEngine*)o)->::IRndmEngine::~IRndmEngine)();
}
static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IRndmEngine,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IRndmEngine -------------------------------
void __IRndmEngine_db_datamem(Reflex::Class*);
void __IRndmEngine_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IRndmEngine_datamem_bld(&__IRndmEngine_db_datamem);
Reflex::GenreflexMemberBuilder __IRndmEngine_funcmem_bld(&__IRndmEngine_db_funcmem);
void __IRndmEngine_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IRndmEngine"), typeid(::IRndmEngine), sizeof(::IRndmEngine), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IRndmEngine, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19907, type_19908), Reflex::Literal("operator="), operator_5053, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRndmEngine"), destructor_5061, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IRndmEngine_funcmem_bld);
}

//------Delayed data member builder for class IRndmEngine -------------------
void __IRndmEngine_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRndmEngine -------------------
void __IRndmEngine_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5056, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("rndm"), method_5057, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_12638, type_26, type_26), Reflex::Literal("rndmArray"), method_5058, 0, "array;howmany;start=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19909), Reflex::Literal("setSeeds"), method_5059, 0, "seeds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19910), Reflex::Literal("seeds"), method_5060, 0, "seeds", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IService -------------------------------
static  void operator_5073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IService*)o)->operator=)(*(const ::IService*)arg[0]);
  else   (((::IService*)o)->operator=)(*(const ::IService*)arg[0]);
}

static  void method_5076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IService*)o)->interfaceID)();
  else   (((::IService*)o)->interfaceID)();
}

static  void method_5077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->sysInitialize)());
  else   (((::IService*)o)->sysInitialize)();
}

static  void method_5078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->sysStart)());
  else   (((::IService*)o)->sysStart)();
}

static  void method_5079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->sysStop)());
  else   (((::IService*)o)->sysStop)();
}

static  void method_5080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->sysFinalize)());
  else   (((::IService*)o)->sysFinalize)();
}

static  void method_5081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->sysReinitialize)());
  else   (((::IService*)o)->sysReinitialize)();
}

static  void method_5082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->sysRestart)());
  else   (((::IService*)o)->sysRestart)();
}

static  void method_5083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->configure)());
  else   (((::IService*)o)->configure)();
}

static  void method_5084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->initialize)());
  else   (((::IService*)o)->initialize)();
}

static  void method_5085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->start)());
  else   (((::IService*)o)->start)();
}

static  void method_5086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->stop)());
  else   (((::IService*)o)->stop)();
}

static  void method_5087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->finalize)());
  else   (((::IService*)o)->finalize)();
}

static  void method_5088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->terminate)());
  else   (((::IService*)o)->terminate)();
}

static  void method_5089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->reinitialize)());
  else   (((::IService*)o)->reinitialize)();
}

static  void method_5090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IService*)o)->restart)());
  else   (((::IService*)o)->restart)();
}

static  void method_5091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IService*)o)->FSMState)());
  else   (((const ::IService*)o)->FSMState)();
}

static  void method_5092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IService*)o)->targetFSMState)());
  else   (((const ::IService*)o)->targetFSMState)();
}

static void destructor_5093(void*, void * o, const std::vector<void*>&, void *) {
(((::IService*)o)->::IService::~IService)();
}
static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IService,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IService,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IService -------------------------------
void __IService_db_datamem(Reflex::Class*);
void __IService_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IService_datamem_bld(&__IService_db_datamem);
Reflex::GenreflexMemberBuilder __IService_funcmem_bld(&__IService_db_funcmem);
void __IService_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IService"), typeid(::IService), sizeof(::IService), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2776, ::Reflex::BaseOffset< ::IService, ::INamedInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19913, type_19914), Reflex::Literal("operator="), operator_5073, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IService"), destructor_5093, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IService_funcmem_bld);
}

//------Delayed data member builder for class IService -------------------
void __IService_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IService -------------------
void __IService_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5076, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysInitialize"), method_5077, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStart"), method_5078, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStop"), method_5079, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysFinalize"), method_5080, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysReinitialize"), method_5081, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysRestart"), method_5082, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_5083, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_5084, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_5085, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_5086, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_5087, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_5088, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_5089, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_5090, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_5091, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("targetFSMState"), method_5092, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class GenericAddress -------------------------------
static  void operator_5104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenericAddress*)o)->operator=)(*(const ::GenericAddress*)arg[0]);
  else   (((::GenericAddress*)o)->operator=)(*(const ::GenericAddress*)arg[0]);
}

static void constructor_5105( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenericAddress();
  else ::new(mem) ::GenericAddress();
}

static void constructor_5106( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenericAddress(*(const ::GenericAddress*)arg[0]);
  else ::new(mem) ::GenericAddress(*(const ::GenericAddress*)arg[0]);
}

static void constructor_5107( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1]);
  else ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(unsigned long*)arg[4]);
  else ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(unsigned long*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(unsigned long*)arg[4],
      *(unsigned long*)arg[5]);
  else ::new(mem) ::GenericAddress(*(long*)arg[0],
      *(const ::CLID*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(unsigned long*)arg[4],
      *(unsigned long*)arg[5]);
  }
}

static void destructor_5108(void*, void * o, const std::vector<void*>&, void *) {
(((::GenericAddress*)o)->::GenericAddress::~GenericAddress)();
}
static  void method_5109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::GenericAddress*)o)->addRef)());
  else   (((::GenericAddress*)o)->addRef)();
}

static  void method_5110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::GenericAddress*)o)->release)());
  else   (((::GenericAddress*)o)->release)();
}

static  void method_5111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenericAddress*)o)->registry)());
  else   (((const ::GenericAddress*)o)->registry)();
}

static  void method_5112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenericAddress*)o)->setRegistry)((::IRegistry*)arg[0]);
}

static  void method_5113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenericAddress*)o)->clID)();
  else   (((const ::GenericAddress*)o)->clID)();
}

static  void method_5114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenericAddress*)o)->setClID)(*(const ::CLID*)arg[0]);
}

static  void method_5115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::GenericAddress*)o)->svcType)());
  else   (((const ::GenericAddress*)o)->svcType)();
}

static  void method_5116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenericAddress*)o)->setSvcType)(*(long*)arg[0]);
}

static  void method_5117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenericAddress*)o)->par)());
  else   (((const ::GenericAddress*)o)->par)();
}

static  void method_5118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenericAddress*)o)->ipar)());
  else   (((const ::GenericAddress*)o)->ipar)();
}

static void method_newdel_995( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenericAddress >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenericAddress >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenericAddress >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenericAddress >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenericAddress >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IOpaqueAddress")), ::Reflex::BaseOffset< ::GenericAddress,::IOpaqueAddress >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GenericAddress -------------------------------
void __GenericAddress_db_datamem(Reflex::Class*);
void __GenericAddress_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenericAddress_datamem_bld(&__GenericAddress_db_datamem);
Reflex::GenreflexMemberBuilder __GenericAddress_funcmem_bld(&__GenericAddress_db_funcmem);
void __GenericAddress_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenericAddress"), typeid(::GenericAddress), sizeof(::GenericAddress), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2811, ::Reflex::BaseOffset< ::GenericAddress, ::IOpaqueAddress >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19923, type_19924), Reflex::Literal("operator="), operator_5104, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenericAddress"), constructor_5105, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19924), Reflex::Literal("GenericAddress"), constructor_5106, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_19456, type_6134, type_6134, type_502, type_502), Reflex::Literal("GenericAddress"), constructor_5107, 0, "svc;clid;p1=\"\";p2=\"\";ip1=0;ip2=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenericAddress"), destructor_5108, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenericAddress_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenericAddress_funcmem_bld);
}

//------Delayed data member builder for class GenericAddress -------------------
void __GenericAddress_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__GenericAddress, m_refCount), ::Reflex::PROTECTED)
  .AddDataMember(type_26, Reflex::Literal("m_svcType"), OffsetOf(__shadow__::__GenericAddress, m_svcType), ::Reflex::PROTECTED)
  .AddDataMember(type_1849, Reflex::Literal("m_clID"), OffsetOf(__shadow__::__GenericAddress, m_clID), ::Reflex::PROTECTED)
  .AddDataMember(type_19921, Reflex::Literal("m_par"), OffsetOf(__shadow__::__GenericAddress, m_par), ::Reflex::PROTECTED)
  .AddDataMember(type_19922, Reflex::Literal("m_ipar"), OffsetOf(__shadow__::__GenericAddress, m_ipar), ::Reflex::PROTECTED)
  .AddDataMember(type_10115, Reflex::Literal("m_pRegistry"), OffsetOf(__shadow__::__GenericAddress, m_pRegistry), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class GenericAddress -------------------
void __GenericAddress_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_5109, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_5110, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10115), Reflex::Literal("registry"), method_5111, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10115), Reflex::Literal("setRegistry"), method_5112, 0, "pRegistry", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_5113, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19456), Reflex::Literal("setClID"), method_5114, 0, "clid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("svcType"), method_5115, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26), Reflex::Literal("setSvcType"), method_5116, 0, "typ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19925), Reflex::Literal("par"), method_5117, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11902), Reflex::Literal("ipar"), method_5118, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class IssueSeverity -------------------------------
static void constructor_5149( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IssueSeverity();
  else ::new(mem) ::IssueSeverity();
}

static void constructor_5150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}

static void constructor_5151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0]);
  else ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::IssueSeverity(*(const ::IssueSeverity::Level*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static void constructor_5152( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IssueSeverity(*(const ::IssueSeverity*)arg[0]);
  else ::new(mem) ::IssueSeverity(*(const ::IssueSeverity*)arg[0]);
}

static void constructor_5153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IssueSeverity((::IssueSeverity*)arg[0]);
  else ::new(mem) ::IssueSeverity((::IssueSeverity*)arg[0]);
}

static  void operator_5154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IssueSeverity*)o)->operator=)(*(const ::IssueSeverity*)arg[0]);
  else   (((::IssueSeverity*)o)->operator=)(*(const ::IssueSeverity*)arg[0]);
}

static void destructor_5155(void*, void * o, const std::vector<void*>&, void *) {
(((::IssueSeverity*)o)->::IssueSeverity::~IssueSeverity)();
}
static  void method_5156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IssueSeverity*)o)->setLevel)(*(const ::IssueSeverity::Level*)arg[0]);
}

static  void method_5157( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IssueSeverity*)o)->setMsg)(*(const ::std::string*)arg[0]);
}

static  void method_5158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IssueSeverity*)o)->getLevel)());
  else   (((const ::IssueSeverity*)o)->getLevel)();
}

static  void method_5159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::IssueSeverity*)o)->getMsg)());
  else   (((const ::IssueSeverity*)o)->getMsg)();
}

static  void method_5160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::IssueSeverity*)o)->getOrigin)());
  else   (((const ::IssueSeverity*)o)->getOrigin)();
}

static  void method_5161( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IssueSeverity*)o)->report)();
}

static  void converter_5162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IssueSeverity*)o)->operator StatusCode)());
  else   (((const ::IssueSeverity*)o)->operator StatusCode)();
}

static void method_newdel_1006( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IssueSeverity >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IssueSeverity >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IssueSeverity >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IssueSeverity >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IssueSeverity >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class IssueSeverity -------------------------------
void __IssueSeverity_db_datamem(Reflex::Class*);
void __IssueSeverity_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IssueSeverity_datamem_bld(&__IssueSeverity_db_datamem);
Reflex::GenreflexMemberBuilder __IssueSeverity_funcmem_bld(&__IssueSeverity_db_funcmem);
void __IssueSeverity_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IssueSeverity"), typeid(::IssueSeverity), sizeof(::IssueSeverity), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("IssueSeverity::Level"), Reflex::Literal("NIL=0;VERBOSE=1;DEBUG=2;DEBUG1=3;DEBUG2=4;DEBUG3=5;INFO=6;WARNING=7;RECOVERABLE=8;ERROR=9;FATAL=10;ALWAYS=11;NUM_LEVELS=12"), &typeid(IssueSeverity::Level), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IssueSeverity"), constructor_5149, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19932, type_142, type_6134, type_6134), Reflex::Literal("IssueSeverity"), constructor_5150, 0, "level;line;file;msg=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19932, type_6134), Reflex::Literal("IssueSeverity"), constructor_5151, 0, "level;msg=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7854), Reflex::Literal("IssueSeverity"), constructor_5152, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8738), Reflex::Literal("IssueSeverity"), constructor_5153, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IssueSeverity"), destructor_5155, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1006, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IssueSeverity_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IssueSeverity_funcmem_bld);
}

//------Delayed data member builder for class IssueSeverity -------------------
void __IssueSeverity_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_142, Reflex::Literal("m_line"), OffsetOf(__shadow__::__IssueSeverity, m_line), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_file"), OffsetOf(__shadow__::__IssueSeverity, m_file), ::Reflex::PRIVATE)
  .AddDataMember(type_5148, Reflex::Literal("m_level"), OffsetOf(__shadow__::__IssueSeverity, m_level), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_msg"), OffsetOf(__shadow__::__IssueSeverity, m_msg), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_reported"), OffsetOf(__shadow__::__IssueSeverity, m_reported), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class IssueSeverity -------------------
void __IssueSeverity_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19933, type_7854), Reflex::Literal("operator="), operator_5154, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19932), Reflex::Literal("setLevel"), method_5156, 0, "l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setMsg"), method_5157, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5148), Reflex::Literal("getLevel"), method_5158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("getMsg"), method_5159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("getOrigin"), method_5160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("report"), method_5161, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("operator StatusCode"), converter_5162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class IConverter -------------------------------
static  void operator_5170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IConverter*)o)->operator=)(*(const ::IConverter*)arg[0]);
  else   (((::IConverter*)o)->operator=)(*(const ::IConverter*)arg[0]);
}

static  void method_5173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IConverter*)o)->interfaceID)();
  else   (((::IConverter*)o)->interfaceID)();
}

static  void method_5174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->initialize)());
  else   (((::IConverter*)o)->initialize)();
}

static  void method_5175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->finalize)());
  else   (((::IConverter*)o)->finalize)();
}

static  void method_5176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IConverter*)o)->objType)();
  else   (((const ::IConverter*)o)->objType)();
}

static  void method_5177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::IConverter*)o)->repSvcType)());
  else   (((const ::IConverter*)o)->repSvcType)();
}

static  void method_5178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->setDataProvider)((::IDataProviderSvc*)arg[0]));
  else   (((::IConverter*)o)->setDataProvider)((::IDataProviderSvc*)arg[0]);
}

static  void method_5179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IConverter*)o)->dataProvider)();
  else   (((const ::IConverter*)o)->dataProvider)();
}

static  void method_5180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->setConversionSvc)((::IConversionSvc*)arg[0]));
  else   (((::IConverter*)o)->setConversionSvc)((::IConversionSvc*)arg[0]);
}

static  void method_5181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IConverter*)o)->conversionSvc)();
  else   (((const ::IConverter*)o)->conversionSvc)();
}

static  void method_5182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->setAddressCreator)((::IAddressCreator*)arg[0]));
  else   (((::IConverter*)o)->setAddressCreator)((::IAddressCreator*)arg[0]);
}

static  void method_5183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IConverter*)o)->addressCreator)();
  else   (((const ::IConverter*)o)->addressCreator)();
}

static  void method_5184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->createObj)((::IOpaqueAddress*)arg[0],
    *(::DataObject**)arg[1]));
  else   (((::IConverter*)o)->createObj)((::IOpaqueAddress*)arg[0],
    *(::DataObject**)arg[1]);
}

static  void method_5185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->fillObjRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IConverter*)o)->fillObjRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_5186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->updateObj)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IConverter*)o)->updateObj)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_5187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->updateObjRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IConverter*)o)->updateObjRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_5188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->createRep)((::DataObject*)arg[0],
    *(::IOpaqueAddress**)arg[1]));
  else   (((::IConverter*)o)->createRep)((::DataObject*)arg[0],
    *(::IOpaqueAddress**)arg[1]);
}

static  void method_5189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->fillRepRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IConverter*)o)->fillRepRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_5190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->updateRep)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IConverter*)o)->updateRep)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_5191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IConverter*)o)->updateRepRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IConverter*)o)->updateRepRefs)((::IOpaqueAddress*)arg[0],
    (::DataObject*)arg[1]);
}

static void destructor_5192(void*, void * o, const std::vector<void*>&, void *) {
(((::IConverter*)o)->::IConverter::~IConverter)();
}
static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IConverter,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IConverter -------------------------------
void __IConverter_db_datamem(Reflex::Class*);
void __IConverter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IConverter_datamem_bld(&__IConverter_db_datamem);
Reflex::GenreflexMemberBuilder __IConverter_funcmem_bld(&__IConverter_db_funcmem);
void __IConverter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IConverter"), typeid(::IConverter), sizeof(::IConverter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IConverter, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("IConverter::Status"), Reflex::Literal("INVALID_ADDRESS=5;INVALID_OBJECT=6;NO_MEMORY=7;BAD_STORAGE_TYPE=8;NO_SOURCE_OBJECT=9;ICONVERSIONSVC_LAST_ERROR=10"), &typeid(IConverter::Status), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19935, type_19936), Reflex::Literal("operator="), operator_5170, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IConverter"), destructor_5192, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IConverter_funcmem_bld);
}

//------Delayed data member builder for class IConverter -------------------
void __IConverter_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IConverter -------------------
void __IConverter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5173, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_5174, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_5175, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("objType"), method_5176, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("repSvcType"), method_5177, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19780), Reflex::Literal("setDataProvider"), method_5178, 0, "pService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937), Reflex::Literal("dataProvider"), method_5179, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19841), Reflex::Literal("setConversionSvc"), method_5180, 0, "pService", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19938), Reflex::Literal("conversionSvc"), method_5181, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19939), Reflex::Literal("setAddressCreator"), method_5182, 0, "creator", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19940), Reflex::Literal("addressCreator"), method_5183, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19941, type_19795), Reflex::Literal("createObj"), method_5184, 0, "pAddress;refpObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19941, type_19429), Reflex::Literal("fillObjRefs"), method_5185, 0, "pAddress;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19941, type_19429), Reflex::Literal("updateObj"), method_5186, 0, "pAddress;refpObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19941, type_19429), Reflex::Literal("updateObjRefs"), method_5187, 0, "pAddress;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_19942), Reflex::Literal("createRep"), method_5188, 0, "pObject;refpAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19941, type_19429), Reflex::Literal("fillRepRefs"), method_5189, 0, "pAddress;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19941, type_19429), Reflex::Literal("updateRep"), method_5190, 0, "pAddress;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19941, type_19429), Reflex::Literal("updateRepRefs"), method_5191, 0, "pAddress;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IEvtSelector -------------------------------
static  void operator_5194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IEvtSelector*)o)->operator=)(*(const ::IEvtSelector*)arg[0]);
  else   (((::IEvtSelector*)o)->operator=)(*(const ::IEvtSelector*)arg[0]);
}

static  void method_5197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IEvtSelector*)o)->interfaceID)();
  else   (((::IEvtSelector*)o)->interfaceID)();
}

static  void method_5198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->createContext)(*(::IEvtSelector::Context**)arg[0]));
  else   (((const ::IEvtSelector*)o)->createContext)(*(::IEvtSelector::Context**)arg[0]);
}

static  void method_5199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->next)(*(::IEvtSelector::Context*)arg[0]));
  else   (((const ::IEvtSelector*)o)->next)(*(::IEvtSelector::Context*)arg[0]);
}

static  void method_5200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->next)(*(::IEvtSelector::Context*)arg[0],
    *(int*)arg[1]));
  else   (((const ::IEvtSelector*)o)->next)(*(::IEvtSelector::Context*)arg[0],
    *(int*)arg[1]);
}

static  void method_5201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->previous)(*(::IEvtSelector::Context*)arg[0]));
  else   (((const ::IEvtSelector*)o)->previous)(*(::IEvtSelector::Context*)arg[0]);
}

static  void method_5202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->previous)(*(::IEvtSelector::Context*)arg[0],
    *(int*)arg[1]));
  else   (((const ::IEvtSelector*)o)->previous)(*(::IEvtSelector::Context*)arg[0],
    *(int*)arg[1]);
}

static  void method_5203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->last)(*(::IEvtSelector::Context*)arg[0]));
  else   (((const ::IEvtSelector*)o)->last)(*(::IEvtSelector::Context*)arg[0]);
}

static  void method_5204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->rewind)(*(::IEvtSelector::Context*)arg[0]));
  else   (((const ::IEvtSelector*)o)->rewind)(*(::IEvtSelector::Context*)arg[0]);
}

static  void method_5205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->createAddress)(*(const ::IEvtSelector::Context*)arg[0],
    *(::IOpaqueAddress**)arg[1]));
  else   (((const ::IEvtSelector*)o)->createAddress)(*(const ::IEvtSelector::Context*)arg[0],
    *(::IOpaqueAddress**)arg[1]);
}

static  void method_5206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->releaseContext)(*(::IEvtSelector::Context**)arg[0]));
  else   (((const ::IEvtSelector*)o)->releaseContext)(*(::IEvtSelector::Context**)arg[0]);
}

static  void method_5207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IEvtSelector*)o)->resetCriteria)(*(const ::std::string*)arg[0],
    *(::IEvtSelector::Context*)arg[1]));
  else   (((const ::IEvtSelector*)o)->resetCriteria)(*(const ::std::string*)arg[0],
    *(::IEvtSelector::Context*)arg[1]);
}

static void destructor_5208(void*, void * o, const std::vector<void*>&, void *) {
(((::IEvtSelector*)o)->::IEvtSelector::~IEvtSelector)();
}
static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IEvtSelector,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IEvtSelector -------------------------------
void __IEvtSelector_db_datamem(Reflex::Class*);
void __IEvtSelector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IEvtSelector_datamem_bld(&__IEvtSelector_db_datamem);
Reflex::GenreflexMemberBuilder __IEvtSelector_funcmem_bld(&__IEvtSelector_db_funcmem);
void __IEvtSelector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IEvtSelector"), typeid(::IEvtSelector), sizeof(::IEvtSelector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IEvtSelector, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19948, type_19949), Reflex::Literal("operator="), operator_5194, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IEvtSelector"), destructor_5208, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IEvtSelector_funcmem_bld);
}

//------Delayed data member builder for class IEvtSelector -------------------
void __IEvtSelector_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IEvtSelector -------------------
void __IEvtSelector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5197, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19950), Reflex::Literal("createContext"), method_5198, 0, "c", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19951), Reflex::Literal("next"), method_5199, 0, "c", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19951, type_142), Reflex::Literal("next"), method_5200, 0, "c;jump", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19951), Reflex::Literal("previous"), method_5201, 0, "c", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19951, type_142), Reflex::Literal("previous"), method_5202, 0, "c;jump", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19951), Reflex::Literal("last"), method_5203, 0, "refContext", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19951), Reflex::Literal("rewind"), method_5204, 0, "c", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19952, type_19942), Reflex::Literal("createAddress"), method_5205, 0, "c;iop", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19950), Reflex::Literal("releaseContext"), method_5206, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19951), Reflex::Literal("resetCriteria"), method_5207, 0, "cr;c", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> -------------------------------
static  void operator_5298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
}

static void constructor_5299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
  else ::new(mem) ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
}

static void constructor_5300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  else ::new(mem) ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
}

static void constructor_5301( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataObjectPtr*)arg[0]);
  else ::new(mem) ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataObjectPtr*)arg[0]);
}

static void destructor_5302(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>::~SmartDataStorePtr)();
}
static  void operator_5303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((::DataObject*)arg[0]);
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((::DataObject*)arg[0]);
}

static  void operator_5304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((const ::DataObject*)arg[0]);
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((const ::DataObject*)arg[0]);
}

static  void operator_5305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataObjectPtr*)arg[0]);
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataObjectPtr*)arg[0]);
}

static  void method_5306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->ptr)());
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->ptr)();
}

static  void operator_5307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator->)());
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator->)();
}

static  void operator_5308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator*)();
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator*)();
}

static  void converter_5309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator ObjectContainerBase*)());
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator ObjectContainerBase*)();
}

static  void converter_5310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator ObjectContainerBase&)();
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator ObjectContainerBase&)();
}

static  void converter_5311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator int)());
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator int)();
}

static  void operator_5312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator!)());
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->operator!)();
}

static  void method_5313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->accessTypeSafeData)());
  else   (((::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>*)o)->accessTypeSafeData)();
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("SmartDataObjectPtr")), ::Reflex::BaseOffset< ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>,::SmartDataObjectPtr >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> -------------------------------
void __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__db_datamem(Reflex::Class*);
void __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__datamem_bld(&__SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__db_datamem);
Reflex::GenreflexMemberBuilder __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__funcmem_bld(&__SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__db_funcmem);
void __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>"), typeid(::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>), sizeof(::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartData*")
  .AddBase(type_654, ::Reflex::BaseOffset< ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>, ::SmartDataObjectPtr >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19996, type_19997), Reflex::Literal("operator="), operator_5298, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19997), Reflex::Literal("SmartDataStorePtr"), constructor_5299, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_10115, type_7844), Reflex::Literal("SmartDataStorePtr"), constructor_5300, 0, "pService;pRegistry;path", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19792), Reflex::Literal("SmartDataStorePtr"), constructor_5301, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartDataStorePtr"), destructor_5302, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__funcmem_bld);
}

//------Delayed data member builder for class SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> -------------------
void __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19995, Reflex::Literal("m_pObject"), OffsetOf(__shadow__::__SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader_, m_pObject), ::Reflex::PROTECTED | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> -------------------
void __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19996, type_19429), Reflex::Literal("operator="), operator_5303, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19996, type_19998), Reflex::Literal("operator="), operator_5304, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19996, type_19792), Reflex::Literal("operator="), operator_5305, 0, "copy", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("ptr"), method_5306, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("operator->"), operator_5307, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19761), Reflex::Literal("operator*"), operator_5308, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("operator ObjectContainerBase*"), converter_5309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19761), Reflex::Literal("operator ObjectContainerBase&"), converter_5310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142), Reflex::Literal("operator int"), converter_5311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("operator!"), operator_5312, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("accessTypeSafeData"), method_5313, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> -------------------------------
static  void operator_5315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
}

static void constructor_5316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
  else ::new(mem) ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)arg[0]);
}

static void constructor_5317( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  else ::new(mem) ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
}

static void constructor_5318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataObjectPtr*)arg[0]);
  else ::new(mem) ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>(*(const ::SmartDataObjectPtr*)arg[0]);
}

static void destructor_5319(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>::~SmartDataStorePtr)();
}
static  void operator_5320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((::DataObject*)arg[0]);
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((::DataObject*)arg[0]);
}

static  void operator_5321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((const ::DataObject*)arg[0]);
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)((const ::DataObject*)arg[0]);
}

static  void operator_5322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataObjectPtr*)arg[0]);
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator=)(*(const ::SmartDataObjectPtr*)arg[0]);
}

static  void method_5323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->ptr)());
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->ptr)();
}

static  void operator_5324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator->)());
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator->)();
}

static  void operator_5325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator*)();
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator*)();
}

static  void converter_5326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator DataObject*)());
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator DataObject*)();
}

static  void converter_5327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator DataObject&)();
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator DataObject&)();
}

static  void converter_5328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator int)());
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator int)();
}

static  void operator_5329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator!)());
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->operator!)();
}

static  void method_5330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->accessTypeSafeData)());
  else   (((::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>*)o)->accessTypeSafeData)();
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("SmartDataObjectPtr")), ::Reflex::BaseOffset< ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>,::SmartDataObjectPtr >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> -------------------------------
void __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__db_datamem(Reflex::Class*);
void __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__datamem_bld(&__SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__db_datamem);
Reflex::GenreflexMemberBuilder __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__funcmem_bld(&__SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__db_funcmem);
void __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>"), typeid(::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>), sizeof(::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartData*")
  .AddBase(type_654, ::Reflex::BaseOffset< ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>, ::SmartDataObjectPtr >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19999, type_20000), Reflex::Literal("operator="), operator_5315, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20000), Reflex::Literal("SmartDataStorePtr"), constructor_5316, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_10115, type_7844), Reflex::Literal("SmartDataStorePtr"), constructor_5317, 0, "pService;pRegistry;path", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19792), Reflex::Literal("SmartDataStorePtr"), constructor_5318, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartDataStorePtr"), destructor_5319, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__funcmem_bld);
}

//------Delayed data member builder for class SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> -------------------
void __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19429, Reflex::Literal("m_pObject"), OffsetOf(__shadow__::__SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader_, m_pObject), ::Reflex::PROTECTED | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> -------------------
void __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19999, type_19429), Reflex::Literal("operator="), operator_5320, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19999, type_19998), Reflex::Literal("operator="), operator_5321, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19999, type_19792), Reflex::Literal("operator="), operator_5322, 0, "copy", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("ptr"), method_5323, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("operator->"), operator_5324, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19455), Reflex::Literal("operator*"), operator_5325, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("operator DataObject*"), converter_5326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19455), Reflex::Literal("operator DataObject&"), converter_5327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142), Reflex::Literal("operator int"), converter_5328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("operator!"), operator_5329, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("accessTypeSafeData"), method_5330, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class GaudiHandleProperty -------------------------------
static  void operator_5355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiHandleProperty*)o)->operator=)(*(const ::GaudiHandleProperty*)arg[0]);
  else   (((::GaudiHandleProperty*)o)->operator=)(*(const ::GaudiHandleProperty*)arg[0]);
}

static void constructor_5356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiHandleProperty(*(const ::GaudiHandleProperty*)arg[0]);
  else ::new(mem) ::GaudiHandleProperty(*(const ::GaudiHandleProperty*)arg[0]);
}

static void constructor_5357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiHandleProperty(*(const ::std::string*)arg[0],
      *(::GaudiHandleBase*)arg[1]);
  else ::new(mem) ::GaudiHandleProperty(*(const ::std::string*)arg[0],
      *(::GaudiHandleBase*)arg[1]);
}

static  void operator_5358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiHandleProperty*)o)->operator=)(*(const ::GaudiHandleBase*)arg[0]);
  else   (((::GaudiHandleProperty*)o)->operator=)(*(const ::GaudiHandleBase*)arg[0]);
}

static  void method_5359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GaudiHandleProperty*)o)->clone)());
  else   (((const ::GaudiHandleProperty*)o)->clone)();
}

static  void method_5360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GaudiHandleProperty*)o)->load)(*(::Property*)arg[0]));
  else   (((const ::GaudiHandleProperty*)o)->load)(*(::Property*)arg[0]);
}

static  void method_5361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GaudiHandleProperty*)o)->assign)(*(const ::Property*)arg[0]));
  else   (((::GaudiHandleProperty*)o)->assign)(*(const ::Property*)arg[0]);
}

static  void method_5362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleProperty*)o)->toString)());
  else   (((const ::GaudiHandleProperty*)o)->toString)();
}

static  void method_5363( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::GaudiHandleProperty*)o)->toStream)(*(::std::ostream*)arg[0]);
}

static  void method_5364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::GaudiHandleProperty*)o)->fromString)(*(const ::std::string*)arg[0]));
  else   (((::GaudiHandleProperty*)o)->fromString)(*(const ::std::string*)arg[0]);
}

static  void method_5365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GaudiHandleProperty*)o)->value)();
  else   (((const ::GaudiHandleProperty*)o)->value)();
}

static  void method_5366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GaudiHandleProperty*)o)->setValue)(*(const ::GaudiHandleBase*)arg[0]));
  else   (((::GaudiHandleProperty*)o)->setValue)(*(const ::GaudiHandleBase*)arg[0]);
}

static void destructor_5367(void*, void * o, const std::vector<void*>&, void *) {
(((::GaudiHandleProperty*)o)->::GaudiHandleProperty::~GaudiHandleProperty)();
}
static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Property")), ::Reflex::BaseOffset< ::GaudiHandleProperty,::Property >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GaudiHandleProperty -------------------------------
void __GaudiHandleProperty_db_datamem(Reflex::Class*);
void __GaudiHandleProperty_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GaudiHandleProperty_datamem_bld(&__GaudiHandleProperty_db_datamem);
Reflex::GenreflexMemberBuilder __GaudiHandleProperty_funcmem_bld(&__GaudiHandleProperty_db_funcmem);
void __GaudiHandleProperty_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GaudiHandleProperty"), typeid(::GaudiHandleProperty), sizeof(::GaudiHandleProperty), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2061, ::Reflex::BaseOffset< ::GaudiHandleProperty, ::Property >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20007, type_20008), Reflex::Literal("operator="), operator_5355, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20008), Reflex::Literal("GaudiHandleProperty"), constructor_5356, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134, type_19420), Reflex::Literal("GaudiHandleProperty"), constructor_5357, 0, "name;ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GaudiHandleProperty"), destructor_5367, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GaudiHandleProperty_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GaudiHandleProperty_funcmem_bld);
}

//------Delayed data member builder for class GaudiHandleProperty -------------------
void __GaudiHandleProperty_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11360, Reflex::Literal("m_pValue"), OffsetOf(__shadow__::__GaudiHandleProperty, m_pValue), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GaudiHandleProperty -------------------
void __GaudiHandleProperty_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20007, type_19421), Reflex::Literal("operator="), operator_5358, 0, "value", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20009), Reflex::Literal("clone"), method_5359, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19969), Reflex::Literal("load"), method_5360, 0, "destination", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7834), Reflex::Literal("assign"), method_5361, 0, "source", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("toString"), method_5362, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7831), Reflex::Literal("toStream"), method_5363, 0, "out", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("fromString"), method_5364, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19421), Reflex::Literal("value"), method_5365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19421), Reflex::Literal("setValue"), method_5366, 0, "value", ::Reflex::PUBLIC);
}
//------Stub functions for class IUpdateManagerSvc -------------------------------
static  void operator_5406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IUpdateManagerSvc*)o)->operator=)(*(const ::IUpdateManagerSvc*)arg[0]);
  else   (((::IUpdateManagerSvc*)o)->operator=)(*(const ::IUpdateManagerSvc*)arg[0]);
}

static  void method_5409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IUpdateManagerSvc*)o)->interfaceID)();
  else   (((::IUpdateManagerSvc*)o)->interfaceID)();
}

static  void method_5410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IUpdateManagerSvc*)o)->dataProvider)());
  else   (((const ::IUpdateManagerSvc*)o)->dataProvider)();
}

static  void method_5411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IUpdateManagerSvc*)o)->detDataSvc)());
  else   (((const ::IUpdateManagerSvc*)o)->detDataSvc)();
}

static  void method_5412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (bool)((((::IUpdateManagerSvc*)o)->getValidity)(*(const ::std::string*)arg[0],
      *(::Gaudi::Time*)arg[1],
      *(::Gaudi::Time*)arg[2]));
    else     (((::IUpdateManagerSvc*)o)->getValidity)(*(const ::std::string*)arg[0],
      *(::Gaudi::Time*)arg[1],
      *(::Gaudi::Time*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (bool)((((::IUpdateManagerSvc*)o)->getValidity)(*(const ::std::string*)arg[0],
      *(::Gaudi::Time*)arg[1],
      *(::Gaudi::Time*)arg[2],
      *(bool*)arg[3]));
    else     (((::IUpdateManagerSvc*)o)->getValidity)(*(const ::std::string*)arg[0],
      *(::Gaudi::Time*)arg[1],
      *(::Gaudi::Time*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_5413( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    (((::IUpdateManagerSvc*)o)->setValidity)(*(const ::std::string*)arg[0],
      *(const ::Gaudi::Time*)arg[1],
      *(const ::Gaudi::Time*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::IUpdateManagerSvc*)o)->setValidity)(*(const ::std::string*)arg[0],
      *(const ::Gaudi::Time*)arg[1],
      *(const ::Gaudi::Time*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_5414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IUpdateManagerSvc*)o)->newEvent)());
  else   (((::IUpdateManagerSvc*)o)->newEvent)();
}

static  void method_5415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IUpdateManagerSvc*)o)->newEvent)(*(const ::Gaudi::Time*)arg[0]));
  else   (((::IUpdateManagerSvc*)o)->newEvent)(*(const ::Gaudi::Time*)arg[0]);
}

static  void method_5416( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IUpdateManagerSvc*)o)->dump)();
}

static  void method_5417( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IUpdateManagerSvc*)o)->acquireLock)();
}

static  void method_5418( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IUpdateManagerSvc*)o)->releaseLock)();
}

static  void method_5419( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IUpdateManagerSvc*)o)->purge)();
}

static void destructor_5425(void*, void * o, const std::vector<void*>&, void *) {
(((::IUpdateManagerSvc*)o)->::IUpdateManagerSvc::~IUpdateManagerSvc)();
}
static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IUpdateManagerSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IUpdateManagerSvc -------------------------------
void __IUpdateManagerSvc_db_datamem(Reflex::Class*);
void __IUpdateManagerSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IUpdateManagerSvc_datamem_bld(&__IUpdateManagerSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IUpdateManagerSvc_funcmem_bld(&__IUpdateManagerSvc_db_funcmem);
void __IUpdateManagerSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IUpdateManagerSvc"), typeid(::IUpdateManagerSvc), sizeof(::IUpdateManagerSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IUpdateManagerSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20021, type_20022), Reflex::Literal("operator="), operator_5406, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IUpdateManagerSvc"), destructor_5425, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IUpdateManagerSvc_funcmem_bld);
}

//------Delayed data member builder for class IUpdateManagerSvc -------------------
void __IUpdateManagerSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IUpdateManagerSvc -------------------
void __IUpdateManagerSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5409, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("dataProvider"), method_5410, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20023), Reflex::Literal("detDataSvc"), method_5411, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_3236c, type_5663, type_5663, type_4206), Reflex::Literal("getValidity"), method_5412, 0, "path;since;until;path_to_db=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3236c, type_4403, type_4403, type_4206), Reflex::Literal("setValidity"), method_5413, 0, "path;since;until;path_to_db=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("newEvent"), method_5414, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_4403), Reflex::Literal("newEvent"), method_5415, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("dump"), method_5416, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("acquireLock"), method_5417, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("releaseLock"), method_5418, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("purge"), method_5419, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IPartitionControl -------------------------------
static  void operator_5427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IPartitionControl*)o)->operator=)(*(const ::IPartitionControl*)arg[0]);
  else   (((::IPartitionControl*)o)->operator=)(*(const ::IPartitionControl*)arg[0]);
}

static  void method_5430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IPartitionControl*)o)->interfaceID)();
  else   (((::IPartitionControl*)o)->interfaceID)();
}

static  void method_5431( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPartitionControl*)o)->create)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IPartitionControl*)o)->create)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPartitionControl*)o)->create)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::IInterface**)arg[2]));
  else   (((::IPartitionControl*)o)->create)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::IInterface**)arg[2]);
}

static  void method_5433( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPartitionControl*)o)->drop)(*(const ::std::string*)arg[0]));
  else   (((::IPartitionControl*)o)->drop)(*(const ::std::string*)arg[0]);
}

static  void method_5434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPartitionControl*)o)->drop)((::IInterface*)arg[0]));
  else   (((::IPartitionControl*)o)->drop)((::IInterface*)arg[0]);
}

static  void method_5435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPartitionControl*)o)->activate)(*(const ::std::string*)arg[0]));
  else   (((::IPartitionControl*)o)->activate)(*(const ::std::string*)arg[0]);
}

static  void method_5436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IPartitionControl*)o)->activate)((::IInterface*)arg[0]));
  else   (((::IPartitionControl*)o)->activate)((::IInterface*)arg[0]);
}

static  void method_5437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IPartitionControl*)o)->get)(*(const ::std::string*)arg[0],
    *(::IInterface**)arg[1]));
  else   (((const ::IPartitionControl*)o)->get)(*(const ::std::string*)arg[0],
    *(::IInterface**)arg[1]);
}

static  void method_5438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IPartitionControl*)o)->activePartition)(*(::std::string*)arg[0],
    *(::IInterface**)arg[1]));
  else   (((const ::IPartitionControl*)o)->activePartition)(*(::std::string*)arg[0],
    *(::IInterface**)arg[1]);
}

static void destructor_5439(void*, void * o, const std::vector<void*>&, void *) {
(((::IPartitionControl*)o)->::IPartitionControl::~IPartitionControl)();
}
static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IPartitionControl,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IPartitionControl -------------------------------
void __IPartitionControl_db_datamem(Reflex::Class*);
void __IPartitionControl_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IPartitionControl_datamem_bld(&__IPartitionControl_db_datamem);
Reflex::GenreflexMemberBuilder __IPartitionControl_funcmem_bld(&__IPartitionControl_db_funcmem);
void __IPartitionControl_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IPartitionControl"), typeid(::IPartitionControl), sizeof(::IPartitionControl), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IPartitionControl, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_100"), Reflex::Literal("PARTITION_NOT_PRESENT=2;PARTITION_EXISTS=4;NO_ACTIVE_PARTITION=6"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20025, type_20026), Reflex::Literal("operator="), operator_5427, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IPartitionControl"), destructor_5439, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IPartitionControl_funcmem_bld);
}

//------Delayed data member builder for class IPartitionControl -------------------
void __IPartitionControl_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IPartitionControl -------------------
void __IPartitionControl_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5430, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("create"), method_5431, 0, "name;type", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_20027), Reflex::Literal("create"), method_5432, 0, "name;type;pPartition", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("drop"), method_5433, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19539), Reflex::Literal("drop"), method_5434, 0, "pPartition", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("activate"), method_5435, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19539), Reflex::Literal("activate"), method_5436, 0, "pPartition", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20027), Reflex::Literal("get"), method_5437, 0, "name;pPartition", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19991, type_20027), Reflex::Literal("activePartition"), method_5438, 0, "name;pPartition", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class ISvcLocator -------------------------------
static  void operator_5506( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISvcLocator*)o)->operator=)(*(const ::ISvcLocator*)arg[0]);
  else   (((::ISvcLocator*)o)->operator=)(*(const ::ISvcLocator*)arg[0]);
}

static  void method_5509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISvcLocator*)o)->interfaceID)();
  else   (((::ISvcLocator*)o)->interfaceID)();
}

static  void method_5510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::ISvcLocator*)o)->getService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(::IService**)arg[1]));
    else     (((::ISvcLocator*)o)->getService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(::IService**)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ISvcLocator*)o)->getService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(::IService**)arg[1],
      *(const bool*)arg[2]));
    else     (((::ISvcLocator*)o)->getService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(::IService**)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_5511( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcLocator*)o)->getService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
    *(const ::InterfaceID*)arg[1],
    *(::IInterface**)arg[2]));
  else   (((::ISvcLocator*)o)->getService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
    *(const ::InterfaceID*)arg[1],
    *(::IInterface**)arg[2]);
}

static  void method_5512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ISvcLocator*)o)->getServices)();
  else   (((const ::ISvcLocator*)o)->getServices)();
}

static  void method_5513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ISvcLocator*)o)->existsService)(*(const ::std::string*)arg[0]));
  else   (((const ::ISvcLocator*)o)->existsService)(*(const ::std::string*)arg[0]);
}

static  void method_5514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::ISvcLocator*)o)->service)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]);
    else     (((::ISvcLocator*)o)->service)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::ISvcLocator*)o)->service)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(const bool*)arg[1]);
    else     (((::ISvcLocator*)o)->service)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(const bool*)arg[1]);
  }
}

static void destructor_5515(void*, void * o, const std::vector<void*>&, void *) {
(((::ISvcLocator*)o)->::ISvcLocator::~ISvcLocator)();
}
static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::ISvcLocator,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ISvcLocator -------------------------------
void __ISvcLocator_db_datamem(Reflex::Class*);
void __ISvcLocator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ISvcLocator_datamem_bld(&__ISvcLocator_db_datamem);
Reflex::GenreflexMemberBuilder __ISvcLocator_funcmem_bld(&__ISvcLocator_db_funcmem);
void __ISvcLocator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ISvcLocator"), typeid(::ISvcLocator), sizeof(::ISvcLocator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::ISvcLocator, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19467, type_20038), Reflex::Literal("operator="), operator_5506, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ISvcLocator"), destructor_5515, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ISvcLocator_funcmem_bld);
}

//------Delayed data member builder for class ISvcLocator -------------------
void __ISvcLocator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ISvcLocator -------------------
void __ISvcLocator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5509, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20039, type_20040, type_4206c), Reflex::Literal("getService"), method_5510, 0, "typeName;svc;createIf=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20039, type_7851, type_20027), Reflex::Literal("getService"), method_5511, 0, "typeName;iid;pinterface", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20041), Reflex::Literal("getServices"), method_5512, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_6134), Reflex::Literal("existsService"), method_5513, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042, type_20039, type_4206c), Reflex::Literal("service"), method_5514, 0, "typeName;createIf=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IAuditorSvc -------------------------------
static  void operator_5516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAuditorSvc*)o)->operator=)(*(const ::IAuditorSvc*)arg[0]);
  else   (((::IAuditorSvc*)o)->operator=)(*(const ::IAuditorSvc*)arg[0]);
}

static  void method_5519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAuditorSvc*)o)->interfaceID)();
  else   (((::IAuditorSvc*)o)->interfaceID)();
}

static  void method_5520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IAuditorSvc*)o)->getAuditor)(*(const ::std::string*)arg[0]));
  else   (((::IAuditorSvc*)o)->getAuditor)(*(const ::std::string*)arg[0]);
}

static void destructor_5521(void*, void * o, const std::vector<void*>&, void *) {
(((::IAuditorSvc*)o)->::IAuditorSvc::~IAuditorSvc)();
}
static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces2<IService,IAuditor>")), ::Reflex::BaseOffset< ::IAuditorSvc,::extend_interfaces2<IService,IAuditor> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IAuditorSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IAuditorSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAuditorSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAuditor")), ::Reflex::BaseOffset< ::IAuditorSvc,::IAuditor >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAuditorSvc -------------------------------
void __IAuditorSvc_db_datamem(Reflex::Class*);
void __IAuditorSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAuditorSvc_datamem_bld(&__IAuditorSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IAuditorSvc_funcmem_bld(&__IAuditorSvc_db_funcmem);
void __IAuditorSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAuditorSvc"), typeid(::IAuditorSvc), sizeof(::IAuditorSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_47, ::Reflex::BaseOffset< ::IAuditorSvc, ::extend_interfaces2<IService,IAuditor> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20043, type_20044), Reflex::Literal("operator="), operator_5516, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IAuditorSvc"), destructor_5521, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAuditorSvc_funcmem_bld);
}

//------Delayed data member builder for class IAuditorSvc -------------------
void __IAuditorSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAuditorSvc -------------------
void __IAuditorSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5519, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20045, type_6134), Reflex::Literal("getAuditor"), method_5520, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class GaudiHandleArrayProperty -------------------------------
static  void operator_5523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiHandleArrayProperty*)o)->operator=)(*(const ::GaudiHandleArrayProperty*)arg[0]);
  else   (((::GaudiHandleArrayProperty*)o)->operator=)(*(const ::GaudiHandleArrayProperty*)arg[0]);
}

static void constructor_5524( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiHandleArrayProperty(*(const ::GaudiHandleArrayProperty*)arg[0]);
  else ::new(mem) ::GaudiHandleArrayProperty(*(const ::GaudiHandleArrayProperty*)arg[0]);
}

static void constructor_5525( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GaudiHandleArrayProperty(*(const ::std::string*)arg[0],
      *(::GaudiHandleArrayBase*)arg[1]);
  else ::new(mem) ::GaudiHandleArrayProperty(*(const ::std::string*)arg[0],
      *(::GaudiHandleArrayBase*)arg[1]);
}

static  void operator_5526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GaudiHandleArrayProperty*)o)->operator=)(*(const ::GaudiHandleArrayBase*)arg[0]);
  else   (((::GaudiHandleArrayProperty*)o)->operator=)(*(const ::GaudiHandleArrayBase*)arg[0]);
}

static  void method_5527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GaudiHandleArrayProperty*)o)->clone)());
  else   (((const ::GaudiHandleArrayProperty*)o)->clone)();
}

static  void method_5528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GaudiHandleArrayProperty*)o)->load)(*(::Property*)arg[0]));
  else   (((const ::GaudiHandleArrayProperty*)o)->load)(*(::Property*)arg[0]);
}

static  void method_5529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GaudiHandleArrayProperty*)o)->assign)(*(const ::Property*)arg[0]));
  else   (((::GaudiHandleArrayProperty*)o)->assign)(*(const ::Property*)arg[0]);
}

static  void method_5530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GaudiHandleArrayProperty*)o)->toString)());
  else   (((const ::GaudiHandleArrayProperty*)o)->toString)();
}

static  void method_5531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::GaudiHandleArrayProperty*)o)->toStream)(*(::std::ostream*)arg[0]);
}

static  void method_5532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::GaudiHandleArrayProperty*)o)->fromString)(*(const ::std::string*)arg[0]));
  else   (((::GaudiHandleArrayProperty*)o)->fromString)(*(const ::std::string*)arg[0]);
}

static  void method_5533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GaudiHandleArrayProperty*)o)->value)();
  else   (((const ::GaudiHandleArrayProperty*)o)->value)();
}

static  void method_5534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GaudiHandleArrayProperty*)o)->setValue)(*(const ::GaudiHandleArrayBase*)arg[0]));
  else   (((::GaudiHandleArrayProperty*)o)->setValue)(*(const ::GaudiHandleArrayBase*)arg[0]);
}

static void destructor_5535(void*, void * o, const std::vector<void*>&, void *) {
(((::GaudiHandleArrayProperty*)o)->::GaudiHandleArrayProperty::~GaudiHandleArrayProperty)();
}
static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Property")), ::Reflex::BaseOffset< ::GaudiHandleArrayProperty,::Property >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GaudiHandleArrayProperty -------------------------------
void __GaudiHandleArrayProperty_db_datamem(Reflex::Class*);
void __GaudiHandleArrayProperty_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GaudiHandleArrayProperty_datamem_bld(&__GaudiHandleArrayProperty_db_datamem);
Reflex::GenreflexMemberBuilder __GaudiHandleArrayProperty_funcmem_bld(&__GaudiHandleArrayProperty_db_funcmem);
void __GaudiHandleArrayProperty_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GaudiHandleArrayProperty"), typeid(::GaudiHandleArrayProperty), sizeof(::GaudiHandleArrayProperty), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2061, ::Reflex::BaseOffset< ::GaudiHandleArrayProperty, ::Property >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20047, type_20048), Reflex::Literal("operator="), operator_5523, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20048), Reflex::Literal("GaudiHandleArrayProperty"), constructor_5524, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134, type_19828), Reflex::Literal("GaudiHandleArrayProperty"), constructor_5525, 0, "name;ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GaudiHandleArrayProperty"), destructor_5535, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GaudiHandleArrayProperty_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GaudiHandleArrayProperty_funcmem_bld);
}

//------Delayed data member builder for class GaudiHandleArrayProperty -------------------
void __GaudiHandleArrayProperty_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20046, Reflex::Literal("m_pValue"), OffsetOf(__shadow__::__GaudiHandleArrayProperty, m_pValue), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GaudiHandleArrayProperty -------------------
void __GaudiHandleArrayProperty_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20047, type_19829), Reflex::Literal("operator="), operator_5526, 0, "value", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20049), Reflex::Literal("clone"), method_5527, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19969), Reflex::Literal("load"), method_5528, 0, "destination", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7834), Reflex::Literal("assign"), method_5529, 0, "source", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("toString"), method_5530, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7831), Reflex::Literal("toStream"), method_5531, 0, "out", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("fromString"), method_5532, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19829), Reflex::Literal("value"), method_5533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19829), Reflex::Literal("setValue"), method_5534, 0, "value", ::Reflex::PUBLIC);
}
//------Stub functions for class AlgTool -------------------------------
static void constructor_5561( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlgTool(*(const ::AlgTool*)arg[0]);
  else ::new(mem) ::AlgTool(*(const ::AlgTool*)arg[0]);
}

static  void method_5562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::AlgTool*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static  void method_5563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::AlgTool*)o)->name)();
  else   (((const ::AlgTool*)o)->name)();
}

static  void method_5564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::AlgTool*)o)->type)();
  else   (((const ::AlgTool*)o)->type)();
}

static  void method_5565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->parent)());
  else   (((const ::AlgTool*)o)->parent)();
}

static  void method_5566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->configure)());
  else   (((::AlgTool*)o)->configure)();
}

static  void method_5567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->initialize)());
  else   (((::AlgTool*)o)->initialize)();
}

static  void method_5568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->start)());
  else   (((::AlgTool*)o)->start)();
}

static  void method_5569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->stop)());
  else   (((::AlgTool*)o)->stop)();
}

static  void method_5570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->finalize)());
  else   (((::AlgTool*)o)->finalize)();
}

static  void method_5571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->terminate)());
  else   (((::AlgTool*)o)->terminate)();
}

static  void method_5572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->reinitialize)());
  else   (((::AlgTool*)o)->reinitialize)();
}

static  void method_5573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->restart)());
  else   (((::AlgTool*)o)->restart)();
}

static  void method_5574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::AlgTool*)o)->FSMState)());
  else   (((const ::AlgTool*)o)->FSMState)();
}

static  void method_5575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::AlgTool*)o)->targetFSMState)());
  else   (((const ::AlgTool*)o)->targetFSMState)();
}

static  void method_5576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->sysInitialize)());
  else   (((::AlgTool*)o)->sysInitialize)();
}

static  void method_5577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->sysStart)());
  else   (((::AlgTool*)o)->sysStart)();
}

static  void method_5578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->sysStop)());
  else   (((::AlgTool*)o)->sysStop)();
}

static  void method_5579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->sysFinalize)());
  else   (((::AlgTool*)o)->sysFinalize)();
}

static  void method_5580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->sysReinitialize)());
  else   (((::AlgTool*)o)->sysReinitialize)();
}

static  void method_5581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->sysRestart)());
  else   (((::AlgTool*)o)->sysRestart)();
}

static  void method_5582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->setProperty)(*(const ::Property*)arg[0]));
  else   (((::AlgTool*)o)->setProperty)(*(const ::Property*)arg[0]);
}

static  void method_5583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->setProperty)(*(const ::std::string*)arg[0]));
  else   (((::AlgTool*)o)->setProperty)(*(const ::std::string*)arg[0]);
}

static  void method_5584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::AlgTool*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::AlgTool*)o)->getProperty)((::Property*)arg[0]));
  else   (((const ::AlgTool*)o)->getProperty)((::Property*)arg[0]);
}

static  void method_5586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::AlgTool*)o)->getProperty)(*(const ::std::string*)arg[0]);
  else   (((const ::AlgTool*)o)->getProperty)(*(const ::std::string*)arg[0]);
}

static  void method_5587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::AlgTool*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::AlgTool*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_5588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::AlgTool*)o)->getProperties)();
  else   (((const ::AlgTool*)o)->getProperties)();
}

static  void method_5589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::AlgTool*)o)->getPropertyMgr)());
  else   (((::AlgTool*)o)->getPropertyMgr)();
}

static void constructor_5590( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlgTool(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::IInterface*)arg[2]);
  else ::new(mem) ::AlgTool(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::IInterface*)arg[2]);
}

static  void method_5591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->serviceLocator)());
  else   (((const ::AlgTool*)o)->serviceLocator)();
}

static  void method_5592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->svcLoc)());
  else   (((const ::AlgTool*)o)->svcLoc)();
}

static  void method_5593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->msgSvc)());
  else   (((const ::AlgTool*)o)->msgSvc)();
}

static  void method_5594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->toolSvc)());
  else   (((const ::AlgTool*)o)->toolSvc)();
}

static  void method_5595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::AlgTool*)o)->setProperties)());
  else   (((::AlgTool*)o)->setProperties)();
}

static  void method_5596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (SmartIF<IService>)((((const ::AlgTool*)o)->service)(*(const ::std::string*)arg[0]));
    else     (((const ::AlgTool*)o)->service)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (SmartIF<IService>)((((const ::AlgTool*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::AlgTool*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (SmartIF<IService>)((((const ::AlgTool*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::AlgTool*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_5597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlgTool*)o)->declInterface)(*(const ::InterfaceID*)arg[0],
    (void*)arg[1]);
}

static  void method_5598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1]));
    else     (((const ::AlgTool*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::AlgTool*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_5599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->auditorSvc)());
  else   (((const ::AlgTool*)o)->auditorSvc)();
}

static  void method_5600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::AlgTool*)o)->monitorSvc)());
  else   (((const ::AlgTool*)o)->monitorSvc)();
}

static  void method_5601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::AlgTool*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (const void*)arg[2],
    *(int*)arg[3],
    *(const ::std::string*)arg[4]);
}

static void method_x47( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("implements3<IAlgTool,IProperty,IStateful>")), ::Reflex::BaseOffset< ::AlgTool,::implements3<IAlgTool,IProperty,IStateful> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IAlgTool,IProperty,IStateful>")), ::Reflex::BaseOffset< ::AlgTool,::extend_interfaces3<IAlgTool,IProperty,IStateful> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::AlgTool,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::AlgTool,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::AlgTool,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::AlgTool,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::AlgTool,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class AlgTool -------------------------------
void __AlgTool_db_datamem(Reflex::Class*);
void __AlgTool_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __AlgTool_datamem_bld(&__AlgTool_db_datamem);
Reflex::GenreflexMemberBuilder __AlgTool_funcmem_bld(&__AlgTool_db_funcmem);
void __AlgTool_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("AlgTool"), typeid(::AlgTool), sizeof(::AlgTool), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1915, ::Reflex::BaseOffset< ::AlgTool, ::implements3<IAlgTool,IProperty,IStateful> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_5558, Reflex::Literal("AlgTool::Factory"))
  .AddTypedef(type_2986, Reflex::Literal("AlgTool::InterfaceList"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20054), Reflex::Literal("AlgTool"), constructor_5561, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134, type_6134, type_19852), Reflex::Literal("AlgTool"), constructor_5590, 0, "type;name;parent", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x47, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__AlgTool_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__AlgTool_funcmem_bld);
}

//------Delayed data member builder for class AlgTool -------------------
void __AlgTool_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2896, Reflex::Literal("m_outputLevel"), OffsetOf(__shadow__::__AlgTool, m_outputLevel), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_type"), OffsetOf(__shadow__::__AlgTool, m_type), ::Reflex::PRIVATE)
  .AddDataMember(type_3236c, Reflex::Literal("m_name"), OffsetOf(__shadow__::__AlgTool, m_name), ::Reflex::PRIVATE | ::Reflex::CONST)
  .AddDataMember(type_19852, Reflex::Literal("m_parent"), OffsetOf(__shadow__::__AlgTool, m_parent), ::Reflex::PRIVATE)
  .AddDataMember(type_19445, Reflex::Literal("m_svcLocator"), OffsetOf(__shadow__::__AlgTool, m_svcLocator), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_20028, Reflex::Literal("m_messageSvc"), OffsetOf(__shadow__::__AlgTool, m_messageSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_20050, Reflex::Literal("m_ptoolSvc"), OffsetOf(__shadow__::__AlgTool, m_ptoolSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_20051, Reflex::Literal("m_pMonitorSvc"), OffsetOf(__shadow__::__AlgTool, m_pMonitorSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_3236, Reflex::Literal("m_monitorSvcName"), OffsetOf(__shadow__::__AlgTool, m_monitorSvcName), ::Reflex::PRIVATE)
  .AddDataMember(type_20052, Reflex::Literal("m_propertyMgr"), OffsetOf(__shadow__::__AlgTool, m_propertyMgr), ::Reflex::PRIVATE)
  .AddDataMember(type_2986, Reflex::Literal("m_interfaceList"), OffsetOf(__shadow__::__AlgTool, m_interfaceList), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_threadID"), OffsetOf(__shadow__::__AlgTool, m_threadID), ::Reflex::PRIVATE)
  .AddDataMember(type_20053, Reflex::Literal("m_pAuditorSvc"), OffsetOf(__shadow__::__AlgTool, m_pAuditorSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_586, Reflex::Literal("m_auditInit"), OffsetOf(__shadow__::__AlgTool, m_auditInit), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorInitialize"), OffsetOf(__shadow__::__AlgTool, m_auditorInitialize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorStart"), OffsetOf(__shadow__::__AlgTool, m_auditorStart), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorStop"), OffsetOf(__shadow__::__AlgTool, m_auditorStop), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorFinalize"), OffsetOf(__shadow__::__AlgTool, m_auditorFinalize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorReinitialize"), OffsetOf(__shadow__::__AlgTool, m_auditorReinitialize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorRestart"), OffsetOf(__shadow__::__AlgTool, m_auditorRestart), ::Reflex::PRIVATE)
  .AddDataMember(type_19509, Reflex::Literal("m_state"), OffsetOf(__shadow__::__AlgTool, m_state), ::Reflex::PRIVATE)
  .AddDataMember(type_19509, Reflex::Literal("m_targetState"), OffsetOf(__shadow__::__AlgTool, m_targetState), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class AlgTool -------------------
void __AlgTool_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_5562, 0, "riid;ppvUnknown", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_5563, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("type"), method_5564, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19852), Reflex::Literal("parent"), method_5565, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_5566, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_5567, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_5568, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_5569, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_5570, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_5571, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_5572, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_5573, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_5574, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("targetFSMState"), method_5575, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysInitialize"), method_5576, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStart"), method_5577, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStop"), method_5578, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysFinalize"), method_5579, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysReinitialize"), method_5580, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysRestart"), method_5581, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7834), Reflex::Literal("setProperty"), method_5582, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("setProperty"), method_5583, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("setProperty"), method_5584, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_11428), Reflex::Literal("getProperty"), method_5585, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7834, type_6134), Reflex::Literal("getProperty"), method_5586, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19991), Reflex::Literal("getProperty"), method_5587, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19992), Reflex::Literal("getProperties"), method_5588, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20052), Reflex::Literal("getPropertyMgr"), method_5589, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19445), Reflex::Literal("serviceLocator"), method_5591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19445), Reflex::Literal("svcLoc"), method_5592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20028), Reflex::Literal("msgSvc"), method_5593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20050), Reflex::Literal("toolSvc"), method_5594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("setProperties"), method_5595, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1593, type_6134, type_4206c, type_4206c), Reflex::Literal("service"), method_5596, 0, "name;createIf=true;quiet=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7851, type_1454), Reflex::Literal("declInterface"), method_5597, 0, ";", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11428, type_6134, type_19990, type_6134), Reflex::Literal("declareRemoteProperty"), method_5598, 0, "name;rsvc;rname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20053), Reflex::Literal("auditorSvc"), method_5599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20051), Reflex::Literal("monitorSvc"), method_5600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_6134, type_4284, type_142, type_6134), Reflex::Literal("declareInfo"), method_5601, 0, "name;format;var;size;desc", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ContainedObject -------------------------------
static  void operator_5609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ContainedObject*)o)->operator=)(*(const ::ContainedObject*)arg[0]);
  else   (((::ContainedObject*)o)->operator=)(*(const ::ContainedObject*)arg[0]);
}

static  void method_5613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ContainedObject*)o)->clID)();
  else   (((const ::ContainedObject*)o)->clID)();
}

static  void method_5614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ContainedObject*)o)->classID)();
  else   (((::ContainedObject*)o)->classID)();
}

static  void method_5615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::ContainedObject*)o)->parent)());
  else   (((const ::ContainedObject*)o)->parent)();
}

static  void method_5616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ContainedObject*)o)->setParent)((::ObjectContainerBase*)arg[0]);
}

static  void method_5617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::ContainedObject*)o)->index)());
  else   (((const ::ContainedObject*)o)->index)();
}

static  void method_5618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ContainedObject*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::ContainedObject*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_5619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ContainedObject*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::ContainedObject*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_5620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ContainedObject*)o)->fillStream)(*(::std::ostream*)arg[0]);
  else   (((const ::ContainedObject*)o)->fillStream)(*(::std::ostream*)arg[0]);
}

//------Dictionary for class ContainedObject -------------------------------
void __ContainedObject_db_datamem(Reflex::Class*);
void __ContainedObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ContainedObject_datamem_bld(&__ContainedObject_db_datamem);
Reflex::GenreflexMemberBuilder __ContainedObject_funcmem_bld(&__ContainedObject_db_funcmem);
void __ContainedObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ContainedObject"), typeid(::ContainedObject), sizeof(::ContainedObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "000000BE-0000-0000-0000-000000000000")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20056, type_7852), Reflex::Literal("operator="), operator_5609, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddOnDemandDataMemberBuilder(&__ContainedObject_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ContainedObject_funcmem_bld);
}

//------Delayed data member builder for class ContainedObject -------------------
void __ContainedObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19995, Reflex::Literal("m_parent"), OffsetOf(__shadow__::__ContainedObject, m_parent), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class ContainedObject -------------------
void __ContainedObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_5613, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("classID"), method_5614, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20057), Reflex::Literal("parent"), method_5615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19995), Reflex::Literal("setParent"), method_5616, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("index"), method_5617, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5618, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5619, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7831, type_7831), Reflex::Literal("fillStream"), method_5620, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class IInspector -------------------------------
static  void operator_5667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IInspector*)o)->operator=)(*(const ::IInspector*)arg[0]);
  else   (((::IInspector*)o)->operator=)(*(const ::IInspector*)arg[0]);
}

static  void method_5670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IInspector*)o)->interfaceID)();
  else   (((::IInspector*)o)->interfaceID)();
}

static void destructor_5675(void*, void * o, const std::vector<void*>&, void *) {
(((::IInspector*)o)->::IInspector::~IInspector)();
}
static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IInspector,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IInspector -------------------------------
void __IInspector_db_datamem(Reflex::Class*);
void __IInspector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IInspector_datamem_bld(&__IInspector_db_datamem);
Reflex::GenreflexMemberBuilder __IInspector_funcmem_bld(&__IInspector_db_funcmem);
void __IInspector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IInspector"), typeid(::IInspector), sizeof(::IInspector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IInspector, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_99"), Reflex::Literal("MUTABLE=2;CONST=4"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20098, type_20099), Reflex::Literal("operator="), operator_5667, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IInspector"), destructor_5675, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IInspector_funcmem_bld);
}

//------Delayed data member builder for class IInspector -------------------
void __IInspector_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IInspector -------------------
void __IInspector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5670, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Service -------------------------------
static  void operator_5706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Service*)o)->operator=)(*(::Service*)arg[0]);
  else   (((::Service*)o)->operator=)(*(::Service*)arg[0]);
}

static void constructor_5707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Service(*(::Service*)arg[0]);
  else ::new(mem) ::Service(*(::Service*)arg[0]);
}

static  void method_5708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::Service*)o)->release)());
  else   (((::Service*)o)->release)();
}

static  void method_5709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Service*)o)->name)();
  else   (((const ::Service*)o)->name)();
}

static  void method_5710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->configure)());
  else   (((::Service*)o)->configure)();
}

static  void method_5711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->initialize)());
  else   (((::Service*)o)->initialize)();
}

static  void method_5712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->start)());
  else   (((::Service*)o)->start)();
}

static  void method_5713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->stop)());
  else   (((::Service*)o)->stop)();
}

static  void method_5714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->finalize)());
  else   (((::Service*)o)->finalize)();
}

static  void method_5715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->terminate)());
  else   (((::Service*)o)->terminate)();
}

static  void method_5716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Service*)o)->FSMState)());
  else   (((const ::Service*)o)->FSMState)();
}

static  void method_5717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Service*)o)->targetFSMState)());
  else   (((const ::Service*)o)->targetFSMState)();
}

static  void method_5718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->reinitialize)());
  else   (((::Service*)o)->reinitialize)();
}

static  void method_5719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->restart)());
  else   (((::Service*)o)->restart)();
}

static  void method_5720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->sysInitialize)());
  else   (((::Service*)o)->sysInitialize)();
}

static  void method_5721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->sysStart)());
  else   (((::Service*)o)->sysStart)();
}

static  void method_5722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->sysStop)());
  else   (((::Service*)o)->sysStop)();
}

static  void method_5723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->sysFinalize)());
  else   (((::Service*)o)->sysFinalize)();
}

static  void method_5724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->sysReinitialize)());
  else   (((::Service*)o)->sysReinitialize)();
}

static  void method_5725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->sysRestart)());
  else   (((::Service*)o)->sysRestart)();
}

static  void method_5726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->setProperty)(*(const ::Property*)arg[0]));
  else   (((::Service*)o)->setProperty)(*(const ::Property*)arg[0]);
}

static  void method_5727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->setProperty)(*(const ::std::string*)arg[0]));
  else   (((::Service*)o)->setProperty)(*(const ::std::string*)arg[0]);
}

static  void method_5728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::Service*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::Service*)o)->getProperty)((::Property*)arg[0]));
  else   (((const ::Service*)o)->getProperty)((::Property*)arg[0]);
}

static  void method_5730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Service*)o)->getProperty)(*(const ::std::string*)arg[0]);
  else   (((const ::Service*)o)->getProperty)(*(const ::std::string*)arg[0]);
}

static  void method_5731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::Service*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::Service*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_5732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Service*)o)->getProperties)();
  else   (((const ::Service*)o)->getProperties)();
}

static void constructor_5733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Service(*(const ::std::string*)arg[0],
      (::ISvcLocator*)arg[1]);
  else ::new(mem) ::Service(*(const ::std::string*)arg[0],
      (::ISvcLocator*)arg[1]);
}

static  void method_5734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Service*)o)->serviceLocator)();
  else   (((const ::Service*)o)->serviceLocator)();
}

static  void method_5735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Service*)o)->setProperties)());
  else   (((::Service*)o)->setProperties)();
}

static  void method_5736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Service*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1]));
    else     (((const ::Service*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Service*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::Service*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_5737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Service*)o)->auditorSvc)();
  else   (((const ::Service*)o)->auditorSvc)();
}

static void method_x49( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("CommonMessaging<implements3<IService,IProperty,IStateful> >")), ::Reflex::BaseOffset< ::Service,::CommonMessaging<implements3<IService,IProperty,IStateful> > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("implements3<IService,IProperty,IStateful>")), ::Reflex::BaseOffset< ::Service,::implements3<IService,IProperty,IStateful> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IService,IProperty,IStateful>")), ::Reflex::BaseOffset< ::Service,::extend_interfaces3<IService,IProperty,IStateful> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::Service,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::Service,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::Service,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::Service,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::Service,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Service -------------------------------
void __Service_db_datamem(Reflex::Class*);
void __Service_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Service_datamem_bld(&__Service_db_datamem);
Reflex::GenreflexMemberBuilder __Service_funcmem_bld(&__Service_db_funcmem);
void __Service_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Service"), typeid(::Service), sizeof(::Service), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2566, ::Reflex::BaseOffset< ::Service, ::CommonMessaging<implements3<IService,IProperty,IStateful> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_5704, Reflex::Literal("Service::Factory"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20107, type_20107), Reflex::Literal("operator="), operator_5706, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20107), Reflex::Literal("Service"), constructor_5707, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134, type_19445), Reflex::Literal("Service"), constructor_5733, 0, "name;svcloc", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x49, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Service_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Service_funcmem_bld);
}

//------Delayed data member builder for class Service -------------------
void __Service_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2896, Reflex::Literal("m_outputLevel"), OffsetOf(__shadow__::__Service, m_outputLevel), ::Reflex::PROTECTED)
  .AddDataMember(type_19509, Reflex::Literal("m_state"), OffsetOf(__shadow__::__Service, m_state), ::Reflex::PROTECTED)
  .AddDataMember(type_19509, Reflex::Literal("m_targetState"), OffsetOf(__shadow__::__Service, m_targetState), ::Reflex::PROTECTED)
  .AddDataMember(type_3236, Reflex::Literal("m_name"), OffsetOf(__shadow__::__Service, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_1596, Reflex::Literal("m_svcLocator"), OffsetOf(__shadow__::__Service, m_svcLocator), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1595, Reflex::Literal("m_svcManager"), OffsetOf(__shadow__::__Service, m_svcManager), ::Reflex::PRIVATE)
  .AddDataMember(type_20052, Reflex::Literal("m_propertyMgr"), OffsetOf(__shadow__::__Service, m_propertyMgr), ::Reflex::PRIVATE)
  .AddDataMember(type_1594, Reflex::Literal("m_pAuditorSvc"), OffsetOf(__shadow__::__Service, m_pAuditorSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_586, Reflex::Literal("m_auditInit"), OffsetOf(__shadow__::__Service, m_auditInit), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorInitialize"), OffsetOf(__shadow__::__Service, m_auditorInitialize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorStart"), OffsetOf(__shadow__::__Service, m_auditorStart), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorStop"), OffsetOf(__shadow__::__Service, m_auditorStop), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorFinalize"), OffsetOf(__shadow__::__Service, m_auditorFinalize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorReinitialize"), OffsetOf(__shadow__::__Service, m_auditorReinitialize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorRestart"), OffsetOf(__shadow__::__Service, m_auditorRestart), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Service -------------------
void __Service_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_5708, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_5709, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_5710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_5711, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_5712, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_5713, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_5714, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_5715, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_5716, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("targetFSMState"), method_5717, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_5718, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_5719, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysInitialize"), method_5720, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStart"), method_5721, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStop"), method_5722, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysFinalize"), method_5723, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysReinitialize"), method_5724, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysRestart"), method_5725, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7834), Reflex::Literal("setProperty"), method_5726, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("setProperty"), method_5727, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("setProperty"), method_5728, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_11428), Reflex::Literal("getProperty"), method_5729, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7834, type_6134), Reflex::Literal("getProperty"), method_5730, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19991), Reflex::Literal("getProperty"), method_5731, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19992), Reflex::Literal("getProperties"), method_5732, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20108), Reflex::Literal("serviceLocator"), method_5734, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("setProperties"), method_5735, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11428, type_6134, type_19990, type_6134), Reflex::Literal("declareRemoteProperty"), method_5736, 0, "name;rsvc;rname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20109), Reflex::Literal("auditorSvc"), method_5737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IDataSourceMgr -------------------------------
static  void operator_5744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataSourceMgr*)o)->operator=)(*(const ::IDataSourceMgr*)arg[0]);
  else   (((::IDataSourceMgr*)o)->operator=)(*(const ::IDataSourceMgr*)arg[0]);
}

static  void method_5747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataSourceMgr*)o)->interfaceID)();
  else   (((::IDataSourceMgr*)o)->interfaceID)();
}

static  void method_5748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IDataSourceMgr*)o)->isConnected)(*(const ::std::string*)arg[0]));
  else   (((const ::IDataSourceMgr*)o)->isConnected)(*(const ::std::string*)arg[0]);
}

static  void method_5749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataSourceMgr*)o)->connect)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]));
  else   (((::IDataSourceMgr*)o)->connect)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_5750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataSourceMgr*)o)->connect)(*(const ::std::string*)arg[0]));
  else   (((::IDataSourceMgr*)o)->connect)(*(const ::std::string*)arg[0]);
}

static  void method_5751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataSourceMgr*)o)->disconnect)(*(const ::std::string*)arg[0]));
  else   (((::IDataSourceMgr*)o)->disconnect)(*(const ::std::string*)arg[0]);
}

static  void method_5752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataSourceMgr*)o)->disconnectAll)());
  else   (((::IDataSourceMgr*)o)->disconnectAll)();
}

static void destructor_5753(void*, void * o, const std::vector<void*>&, void *) {
(((::IDataSourceMgr*)o)->::IDataSourceMgr::~IDataSourceMgr)();
}
static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IDataSourceMgr,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IDataSourceMgr -------------------------------
void __IDataSourceMgr_db_datamem(Reflex::Class*);
void __IDataSourceMgr_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IDataSourceMgr_datamem_bld(&__IDataSourceMgr_db_datamem);
Reflex::GenreflexMemberBuilder __IDataSourceMgr_funcmem_bld(&__IDataSourceMgr_db_funcmem);
void __IDataSourceMgr_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IDataSourceMgr"), typeid(::IDataSourceMgr), sizeof(::IDataSourceMgr), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IDataSourceMgr, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20110, type_20111), Reflex::Literal("operator="), operator_5744, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDataSourceMgr"), destructor_5753, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IDataSourceMgr_funcmem_bld);
}

//------Delayed data member builder for class IDataSourceMgr -------------------
void __IDataSourceMgr_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDataSourceMgr -------------------
void __IDataSourceMgr_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5747, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_6134), Reflex::Literal("isConnected"), method_5748, 0, "identifier", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19991), Reflex::Literal("connect"), method_5749, 0, "logon;identifier", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("connect"), method_5750, 0, "logon", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("disconnect"), method_5751, 0, "identifier", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("disconnectAll"), method_5752, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IDataProviderSvc -------------------------------
static  void operator_5764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataProviderSvc*)o)->operator=)(*(const ::IDataProviderSvc*)arg[0]);
  else   (((::IDataProviderSvc*)o)->operator=)(*(const ::IDataProviderSvc*)arg[0]);
}

static  void method_5767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataProviderSvc*)o)->interfaceID)();
  else   (((::IDataProviderSvc*)o)->interfaceID)();
}

static  void method_5768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IDataProviderSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_5769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]));
  else   (((::IDataProviderSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]);
}

static  void method_5770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    (::DataObject*)arg[2]));
  else   (((::IDataProviderSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    (::DataObject*)arg[2]);
}

static  void method_5771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]));
  else   (((::IDataProviderSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]);
}

static  void method_5772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    (::DataObject*)arg[2]));
  else   (((::IDataProviderSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    (::DataObject*)arg[2]);
}

static  void method_5773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unregisterObject)(*(const ::std::string*)arg[0]));
  else   (((::IDataProviderSvc*)o)->unregisterObject)(*(const ::std::string*)arg[0]);
}

static  void method_5774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unregisterObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataProviderSvc*)o)->unregisterObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unregisterObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1]));
  else   (((::IDataProviderSvc*)o)->unregisterObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1]);
}

static  void method_5776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unregisterObject)((::DataObject*)arg[0]));
  else   (((::IDataProviderSvc*)o)->unregisterObject)((::DataObject*)arg[0]);
}

static  void method_5777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unregisterObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataProviderSvc*)o)->unregisterObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unregisterObject)((::DataObject*)arg[0],
    *(int*)arg[1]));
  else   (((::IDataProviderSvc*)o)->unregisterObject)((::DataObject*)arg[0],
    *(int*)arg[1]);
}

static  void method_5779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::DataObject**)arg[1]));
  else   (((::IDataProviderSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::DataObject**)arg[1]);
}

static  void method_5781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::DataObject**)arg[1]));
  else   (((::IDataProviderSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::DataObject**)arg[1]);
}

static  void method_5787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]));
  else   (((::IDataProviderSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::DataObject**)arg[2]);
}

static  void method_5791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->updateObject)((::IRegistry*)arg[0]));
  else   (((::IDataProviderSvc*)o)->updateObject)((::IRegistry*)arg[0]);
}

static  void method_5792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->updateObject)(*(const ::std::string*)arg[0]));
  else   (((::IDataProviderSvc*)o)->updateObject)(*(const ::std::string*)arg[0]);
}

static  void method_5793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->updateObject)((::DataObject*)arg[0]));
  else   (((::IDataProviderSvc*)o)->updateObject)((::DataObject*)arg[0]);
}

static  void method_5794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->updateObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataProviderSvc*)o)->updateObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->updateObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataProviderSvc*)o)->updateObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->addPreLoadItem)(*(const ::DataStoreItem*)arg[0]));
  else   (((::IDataProviderSvc*)o)->addPreLoadItem)(*(const ::DataStoreItem*)arg[0]);
}

static  void method_5797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->addPreLoadItem)(*(const ::std::string*)arg[0]));
  else   (((::IDataProviderSvc*)o)->addPreLoadItem)(*(const ::std::string*)arg[0]);
}

static  void method_5798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->removePreLoadItem)(*(const ::DataStoreItem*)arg[0]));
  else   (((::IDataProviderSvc*)o)->removePreLoadItem)(*(const ::DataStoreItem*)arg[0]);
}

static  void method_5799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->removePreLoadItem)(*(const ::std::string*)arg[0]));
  else   (((::IDataProviderSvc*)o)->removePreLoadItem)(*(const ::std::string*)arg[0]);
}

static  void method_5800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->resetPreLoad)());
  else   (((::IDataProviderSvc*)o)->resetPreLoad)();
}

static  void method_5801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->preLoad)());
  else   (((::IDataProviderSvc*)o)->preLoad)();
}

static  void method_5802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->linkObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]));
  else   (((::IDataProviderSvc*)o)->linkObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]);
}

static  void method_5803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->linkObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]));
  else   (((::IDataProviderSvc*)o)->linkObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]);
}

static  void method_5804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->linkObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]));
  else   (((::IDataProviderSvc*)o)->linkObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::DataObject*)arg[2]);
}

static  void method_5805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->linkObject)(*(const ::std::string*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IDataProviderSvc*)o)->linkObject)(*(const ::std::string*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_5806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unlinkObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataProviderSvc*)o)->unlinkObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unlinkObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataProviderSvc*)o)->unlinkObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unlinkObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataProviderSvc*)o)->unlinkObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_5809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataProviderSvc*)o)->unlinkObject)(*(const ::std::string*)arg[0]));
  else   (((::IDataProviderSvc*)o)->unlinkObject)(*(const ::std::string*)arg[0]);
}

static void destructor_5810(void*, void * o, const std::vector<void*>&, void *) {
(((::IDataProviderSvc*)o)->::IDataProviderSvc::~IDataProviderSvc)();
}
static void method_x51( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IDataProviderSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IDataProviderSvc -------------------------------
void __IDataProviderSvc_db_datamem(Reflex::Class*);
void __IDataProviderSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IDataProviderSvc_datamem_bld(&__IDataProviderSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IDataProviderSvc_funcmem_bld(&__IDataProviderSvc_db_funcmem);
void __IDataProviderSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IDataProviderSvc"), typeid(::IDataProviderSvc), sizeof(::IDataProviderSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IDataProviderSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_95"), Reflex::Literal("SEPARATOR=47"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("IDataProviderSvc::Status"), Reflex::Literal("IDataProviderSvc_NO_ERROR=1;DOUBL_OBJ_PATH=2;INVALID_OBJ_PATH=3;INVALID_ROOT=4;INVALID_OBJECT=5;INVALID_PARENT=6;OBJ_NOT_LOADED=7;NO_DATA_LOADER=8;INVALID_OBJ_ADDR=9;DIR_NOT_EMPTY=10;NO_MORE_LEVELS=11;NO_ACCESS=12;LAST=13"), &typeid(IDataProviderSvc::Status), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20115, type_20116), Reflex::Literal("operator="), operator_5764, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDataProviderSvc"), destructor_5810, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x51, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IDataProviderSvc_funcmem_bld);
}

//------Delayed data member builder for class IDataProviderSvc -------------------
void __IDataProviderSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDataProviderSvc -------------------
void __IDataProviderSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_5767, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19429), Reflex::Literal("registerObject"), method_5768, 0, "fullPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_19429), Reflex::Literal("registerObject"), method_5769, 0, "parentPath;objectPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_19429), Reflex::Literal("registerObject"), method_5770, 0, "parentPath;item;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_19429), Reflex::Literal("registerObject"), method_5771, 0, "parentObj;objectPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_19429), Reflex::Literal("registerObject"), method_5772, 0, "parentObj;item;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("unregisterObject"), method_5773, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("unregisterObject"), method_5774, 0, "parentPath;objPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142), Reflex::Literal("unregisterObject"), method_5775, 0, "parentPath;item", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429), Reflex::Literal("unregisterObject"), method_5776, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134), Reflex::Literal("unregisterObject"), method_5777, 0, "pParent;objPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142), Reflex::Literal("unregisterObject"), method_5778, 0, "pParent;item", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_19795), Reflex::Literal("retrieveObject"), method_5779, 0, "pDirectory;path;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19795), Reflex::Literal("retrieveObject"), method_5780, 0, "fullPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_19795), Reflex::Literal("retrieveObject"), method_5781, 0, "parentPath;objectPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_19795), Reflex::Literal("retrieveObject"), method_5782, 0, "parentPath;item;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_19795), Reflex::Literal("retrieveObject"), method_5783, 0, "parentObj;objectPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_19795), Reflex::Literal("retrieveObject"), method_5784, 0, "parentObj;item;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_19795), Reflex::Literal("findObject"), method_5785, 0, "pDirectory;path;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19795), Reflex::Literal("findObject"), method_5786, 0, "fullPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_19795), Reflex::Literal("findObject"), method_5787, 0, "parentPath;objectPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_19795), Reflex::Literal("findObject"), method_5788, 0, "parentPath;item;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_19795), Reflex::Literal("findObject"), method_5789, 0, "pNode;objectPath;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_19795), Reflex::Literal("findObject"), method_5790, 0, "parentObj;item;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115), Reflex::Literal("updateObject"), method_5791, 0, "pDirectory", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("updateObject"), method_5792, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429), Reflex::Literal("updateObject"), method_5793, 0, "toUpdate", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("updateObject"), method_5794, 0, "parentPath;updatePath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134), Reflex::Literal("updateObject"), method_5795, 0, "pParent;updatePath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20117), Reflex::Literal("addPreLoadItem"), method_5796, 0, "item", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("addPreLoadItem"), method_5797, 0, "itemPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20117), Reflex::Literal("removePreLoadItem"), method_5798, 0, "item", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("removePreLoadItem"), method_5799, 0, "itemPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("resetPreLoad"), method_5800, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("preLoad"), method_5801, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_19429), Reflex::Literal("linkObject"), method_5802, 0, "from;objPath;toObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_19429), Reflex::Literal("linkObject"), method_5803, 0, "fromPath;objPath;toObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_19429), Reflex::Literal("linkObject"), method_5804, 0, "fromObj;objPath;toObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19429), Reflex::Literal("linkObject"), method_5805, 0, "fullPath;toObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134), Reflex::Literal("unlinkObject"), method_5806, 0, "from;objPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("unlinkObject"), method_5807, 0, "fromPath;objPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134), Reflex::Literal("unlinkObject"), method_5808, 0, "fromObj;objPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("unlinkObject"), method_5809, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class KeyedObject<long unsigned int> -------------------------------
static  void operator_5825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<unsigned long>*)o)->operator=)(*(const ::KeyedObject<unsigned long>*)arg[0]);
  else   (((::KeyedObject<unsigned long>*)o)->operator=)(*(const ::KeyedObject<unsigned long>*)arg[0]);
}

static void constructor_5829( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<unsigned long>();
  else ::new(mem) ::KeyedObject<unsigned long>();
}

static void constructor_5830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<unsigned long>(*(const unsigned long*)arg[0]);
  else ::new(mem) ::KeyedObject<unsigned long>(*(const unsigned long*)arg[0]);
}

static void destructor_5831(void*, void * o, const std::vector<void*>&, void *) {
(((::KeyedObject<unsigned long>*)o)->::KeyedObject<unsigned long>::~KeyedObject)();
}
static  void method_5832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<unsigned long>*)o)->key)();
  else   (((const ::KeyedObject<unsigned long>*)o)->key)();
}

static  void method_5833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::KeyedObject<unsigned long>*)o)->hasKey)());
  else   (((const ::KeyedObject<unsigned long>*)o)->hasKey)();
}

static  void method_5834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::KeyedObject<unsigned long>*)o)->index)());
  else   (((const ::KeyedObject<unsigned long>*)o)->index)();
}

static  void method_5835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<unsigned long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::KeyedObject<unsigned long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_5836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<unsigned long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::KeyedObject<unsigned long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_1450( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x53( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject")), ::Reflex::BaseOffset< ::KeyedObject<unsigned long>,::ContainedObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class KeyedObject<long unsigned int> -------------------------------
void __KeyedObject_unsignedslong__db_datamem(Reflex::Class*);
void __KeyedObject_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __KeyedObject_unsignedslong__datamem_bld(&__KeyedObject_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __KeyedObject_unsignedslong__funcmem_bld(&__KeyedObject_unsignedslong__db_funcmem);
void __KeyedObject_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("KeyedObject<unsigned long>"), typeid(::KeyedObject<unsigned long>), sizeof(::KeyedObject<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1249, ::Reflex::BaseOffset< ::KeyedObject<unsigned long>, ::ContainedObject >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_502, Reflex::Literal("KeyedObject<unsigned long>::key_type"))
  .AddTypedef(type_4844, Reflex::Literal("KeyedObject<unsigned long>::traits"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20139, type_20140), Reflex::Literal("operator="), operator_5825, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("KeyedObject"), constructor_5829, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7841), Reflex::Literal("KeyedObject"), constructor_5830, 0, "kval", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~KeyedObject"), destructor_5831, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x53, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__KeyedObject_unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__KeyedObject_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class KeyedObject<long unsigned int> -------------------
void __KeyedObject_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_key"), OffsetOf(__shadow__::__KeyedObject_unsignedslong_, m_key), ::Reflex::PROTECTED)
  .AddDataMember(type_26, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__KeyedObject_unsignedslong_, m_refCount), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_4206, Reflex::Literal("m_hasKey"), OffsetOf(__shadow__::__KeyedObject_unsignedslong_, m_hasKey), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class KeyedObject<long unsigned int> -------------------
void __KeyedObject_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7841), Reflex::Literal("key"), method_5832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("hasKey"), method_5833, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("index"), method_5834, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5835, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5836, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class KeyedObject<long int> -------------------------------
static  void operator_5843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<long>*)o)->operator=)(*(const ::KeyedObject<long>*)arg[0]);
  else   (((::KeyedObject<long>*)o)->operator=)(*(const ::KeyedObject<long>*)arg[0]);
}

static void constructor_5847( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<long>();
  else ::new(mem) ::KeyedObject<long>();
}

static void constructor_5848( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<long>(*(const long*)arg[0]);
  else ::new(mem) ::KeyedObject<long>(*(const long*)arg[0]);
}

static void destructor_5849(void*, void * o, const std::vector<void*>&, void *) {
(((::KeyedObject<long>*)o)->::KeyedObject<long>::~KeyedObject)();
}
static  void method_5850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<long>*)o)->key)();
  else   (((const ::KeyedObject<long>*)o)->key)();
}

static  void method_5851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::KeyedObject<long>*)o)->hasKey)());
  else   (((const ::KeyedObject<long>*)o)->hasKey)();
}

static  void method_5852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::KeyedObject<long>*)o)->index)());
  else   (((const ::KeyedObject<long>*)o)->index)();
}

static  void method_5853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::KeyedObject<long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_5854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::KeyedObject<long>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_1451( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::KeyedObject<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::KeyedObject<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::KeyedObject<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::KeyedObject<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::KeyedObject<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject")), ::Reflex::BaseOffset< ::KeyedObject<long>,::ContainedObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class KeyedObject<long int> -------------------------------
void __KeyedObject_long__db_datamem(Reflex::Class*);
void __KeyedObject_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __KeyedObject_long__datamem_bld(&__KeyedObject_long__db_datamem);
Reflex::GenreflexMemberBuilder __KeyedObject_long__funcmem_bld(&__KeyedObject_long__db_funcmem);
void __KeyedObject_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("KeyedObject<long>"), typeid(::KeyedObject<long>), sizeof(::KeyedObject<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1249, ::Reflex::BaseOffset< ::KeyedObject<long>, ::ContainedObject >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_26, Reflex::Literal("KeyedObject<long>::key_type"))
  .AddTypedef(type_4845, Reflex::Literal("KeyedObject<long>::traits"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20141, type_20142), Reflex::Literal("operator="), operator_5843, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("KeyedObject"), constructor_5847, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10901), Reflex::Literal("KeyedObject"), constructor_5848, 0, "kval", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~KeyedObject"), destructor_5849, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1451, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__KeyedObject_long__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__KeyedObject_long__funcmem_bld);
}

//------Delayed data member builder for class KeyedObject<long int> -------------------
void __KeyedObject_long__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_26, Reflex::Literal("m_key"), OffsetOf(__shadow__::__KeyedObject_long_, m_key), ::Reflex::PROTECTED)
  .AddDataMember(type_26, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__KeyedObject_long_, m_refCount), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_4206, Reflex::Literal("m_hasKey"), OffsetOf(__shadow__::__KeyedObject_long_, m_hasKey), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class KeyedObject<long int> -------------------
void __KeyedObject_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10901), Reflex::Literal("key"), method_5850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("hasKey"), method_5851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("index"), method_5852, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5853, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5854, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class KeyedObject<unsigned int> -------------------------------
static  void operator_5861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<unsigned int>*)o)->operator=)(*(const ::KeyedObject<unsigned int>*)arg[0]);
  else   (((::KeyedObject<unsigned int>*)o)->operator=)(*(const ::KeyedObject<unsigned int>*)arg[0]);
}

static void constructor_5865( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<unsigned int>();
  else ::new(mem) ::KeyedObject<unsigned int>();
}

static void constructor_5866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<unsigned int>(*(const unsigned int*)arg[0]);
  else ::new(mem) ::KeyedObject<unsigned int>(*(const unsigned int*)arg[0]);
}

static void destructor_5867(void*, void * o, const std::vector<void*>&, void *) {
(((::KeyedObject<unsigned int>*)o)->::KeyedObject<unsigned int>::~KeyedObject)();
}
static  void method_5868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<unsigned int>*)o)->key)();
  else   (((const ::KeyedObject<unsigned int>*)o)->key)();
}

static  void method_5869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::KeyedObject<unsigned int>*)o)->hasKey)());
  else   (((const ::KeyedObject<unsigned int>*)o)->hasKey)();
}

static  void method_5870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::KeyedObject<unsigned int>*)o)->index)());
  else   (((const ::KeyedObject<unsigned int>*)o)->index)();
}

static  void method_5871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<unsigned int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::KeyedObject<unsigned int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_5872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<unsigned int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::KeyedObject<unsigned int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_1452( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::KeyedObject<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x57( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject")), ::Reflex::BaseOffset< ::KeyedObject<unsigned int>,::ContainedObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class KeyedObject<unsigned int> -------------------------------
void __KeyedObject_unsignedsint__db_datamem(Reflex::Class*);
void __KeyedObject_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __KeyedObject_unsignedsint__datamem_bld(&__KeyedObject_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __KeyedObject_unsignedsint__funcmem_bld(&__KeyedObject_unsignedsint__db_funcmem);
void __KeyedObject_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("KeyedObject<unsigned int>"), typeid(::KeyedObject<unsigned int>), sizeof(::KeyedObject<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1249, ::Reflex::BaseOffset< ::KeyedObject<unsigned int>, ::ContainedObject >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_203, Reflex::Literal("KeyedObject<unsigned int>::key_type"))
  .AddTypedef(type_4846, Reflex::Literal("KeyedObject<unsigned int>::traits"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20143, type_20144), Reflex::Literal("operator="), operator_5861, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("KeyedObject"), constructor_5865, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11972), Reflex::Literal("KeyedObject"), constructor_5866, 0, "kval", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~KeyedObject"), destructor_5867, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1452, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x57, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__KeyedObject_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__KeyedObject_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class KeyedObject<unsigned int> -------------------
void __KeyedObject_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_203, Reflex::Literal("m_key"), OffsetOf(__shadow__::__KeyedObject_unsignedsint_, m_key), ::Reflex::PROTECTED)
  .AddDataMember(type_26, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__KeyedObject_unsignedsint_, m_refCount), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_4206, Reflex::Literal("m_hasKey"), OffsetOf(__shadow__::__KeyedObject_unsignedsint_, m_hasKey), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class KeyedObject<unsigned int> -------------------
void __KeyedObject_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11972), Reflex::Literal("key"), method_5868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("hasKey"), method_5869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("index"), method_5870, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5871, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5872, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class KeyedObject<int> -------------------------------
static  void operator_5879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<int>*)o)->operator=)(*(const ::KeyedObject<int>*)arg[0]);
  else   (((::KeyedObject<int>*)o)->operator=)(*(const ::KeyedObject<int>*)arg[0]);
}

static void constructor_5883( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<int>();
  else ::new(mem) ::KeyedObject<int>();
}

static void constructor_5884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedObject<int>(*(const int*)arg[0]);
  else ::new(mem) ::KeyedObject<int>(*(const int*)arg[0]);
}

static void destructor_5885(void*, void * o, const std::vector<void*>&, void *) {
(((::KeyedObject<int>*)o)->::KeyedObject<int>::~KeyedObject)();
}
static  void method_5886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<int>*)o)->key)();
  else   (((const ::KeyedObject<int>*)o)->key)();
}

static  void method_5887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::KeyedObject<int>*)o)->hasKey)());
  else   (((const ::KeyedObject<int>*)o)->hasKey)();
}

static  void method_5888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::KeyedObject<int>*)o)->index)());
  else   (((const ::KeyedObject<int>*)o)->index)();
}

static  void method_5889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedObject<int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::KeyedObject<int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_5890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedObject<int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::KeyedObject<int>*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_1453( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::KeyedObject<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::KeyedObject<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::KeyedObject<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::KeyedObject<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::KeyedObject<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x59( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject")), ::Reflex::BaseOffset< ::KeyedObject<int>,::ContainedObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class KeyedObject<int> -------------------------------
void __KeyedObject_int__db_datamem(Reflex::Class*);
void __KeyedObject_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __KeyedObject_int__datamem_bld(&__KeyedObject_int__db_datamem);
Reflex::GenreflexMemberBuilder __KeyedObject_int__funcmem_bld(&__KeyedObject_int__db_funcmem);
void __KeyedObject_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("KeyedObject<int>"), typeid(::KeyedObject<int>), sizeof(::KeyedObject<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1249, ::Reflex::BaseOffset< ::KeyedObject<int>, ::ContainedObject >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_142, Reflex::Literal("KeyedObject<int>::key_type"))
  .AddTypedef(type_4847, Reflex::Literal("KeyedObject<int>::traits"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20145, type_20146), Reflex::Literal("operator="), operator_5879, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("KeyedObject"), constructor_5883, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12039), Reflex::Literal("KeyedObject"), constructor_5884, 0, "kval", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~KeyedObject"), destructor_5885, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1453, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x59, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__KeyedObject_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__KeyedObject_int__funcmem_bld);
}

//------Delayed data member builder for class KeyedObject<int> -------------------
void __KeyedObject_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_142, Reflex::Literal("m_key"), OffsetOf(__shadow__::__KeyedObject_int_, m_key), ::Reflex::PROTECTED)
  .AddDataMember(type_26, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__KeyedObject_int_, m_refCount), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_4206, Reflex::Literal("m_hasKey"), OffsetOf(__shadow__::__KeyedObject_int_, m_hasKey), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class KeyedObject<int> -------------------
void __KeyedObject_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12039), Reflex::Literal("key"), method_5886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("hasKey"), method_5887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("index"), method_5888, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5889, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("serialize"), method_5890, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class ITHistSvc -------------------------------
static  void operator_6099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ITHistSvc*)o)->operator=)(*(const ::ITHistSvc*)arg[0]);
  else   (((::ITHistSvc*)o)->operator=)(*(const ::ITHistSvc*)arg[0]);
}

static  void method_6102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ITHistSvc*)o)->interfaceID)();
  else   (((::ITHistSvc*)o)->interfaceID)();
}

static  void method_6103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0]));
  else   (((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0]);
}

static  void method_6104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0],
    (::TH1*)arg[1]));
  else   (((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0],
    (::TH1*)arg[1]);
}

static  void method_6105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0],
    (::TH2*)arg[1]));
  else   (((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0],
    (::TH2*)arg[1]);
}

static  void method_6106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0],
    (::TH3*)arg[1]));
  else   (((::ITHistSvc*)o)->regHist)(*(const ::std::string*)arg[0],
    (::TH3*)arg[1]);
}

static  void method_6107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getHist)(*(const ::std::string*)arg[0],
    *(::TH1**)arg[1]));
  else   (((const ::ITHistSvc*)o)->getHist)(*(const ::std::string*)arg[0],
    *(::TH1**)arg[1]);
}

static  void method_6108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getHist)(*(const ::std::string*)arg[0],
    *(::TH2**)arg[1]));
  else   (((const ::ITHistSvc*)o)->getHist)(*(const ::std::string*)arg[0],
    *(::TH2**)arg[1]);
}

static  void method_6109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getHist)(*(const ::std::string*)arg[0],
    *(::TH3**)arg[1]));
  else   (((const ::ITHistSvc*)o)->getHist)(*(const ::std::string*)arg[0],
    *(::TH3**)arg[1]);
}

static  void method_6110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regTree)(*(const ::std::string*)arg[0]));
  else   (((::ITHistSvc*)o)->regTree)(*(const ::std::string*)arg[0]);
}

static  void method_6111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regTree)(*(const ::std::string*)arg[0],
    (::TTree*)arg[1]));
  else   (((::ITHistSvc*)o)->regTree)(*(const ::std::string*)arg[0],
    (::TTree*)arg[1]);
}

static  void method_6112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTree)(*(const ::std::string*)arg[0],
    *(::TTree**)arg[1]));
  else   (((const ::ITHistSvc*)o)->getTree)(*(const ::std::string*)arg[0],
    *(::TTree**)arg[1]);
}

static  void method_6113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->deReg)(*(const ::std::string*)arg[0]));
  else   (((::ITHistSvc*)o)->deReg)(*(const ::std::string*)arg[0]);
}

static  void method_6114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->deReg)((::TObject*)arg[0]));
  else   (((::ITHistSvc*)o)->deReg)((::TObject*)arg[0]);
}

static  void method_6115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::ITHistSvc*)o)->getHists)());
  else   (((const ::ITHistSvc*)o)->getHists)();
}

static  void method_6116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::ITHistSvc*)o)->getTrees)());
  else   (((const ::ITHistSvc*)o)->getTrees)();
}

static  void method_6117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::ITHistSvc*)o)->getGraphs)());
  else   (((const ::ITHistSvc*)o)->getGraphs)();
}

static  void method_6118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1]));
    else     (((const ::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((const ::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_6119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]));
    else     (((const ::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((const ::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_6120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1]));
    else     (((::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]));
    else     (((::ITHistSvc*)o)->getTHists)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_6121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]));
    else     (((::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]));
    else     (((::ITHistSvc*)o)->getTHists)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_6122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1]));
    else     (((const ::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((const ::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_6123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]));
    else     (((const ::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((const ::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_6124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1]));
    else     (((::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]));
    else     (((::ITHistSvc*)o)->getTTrees)((::TDirectory*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_6125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]));
    else     (((::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]));
    else     (((::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]));
    else     (((::ITHistSvc*)o)->getTTrees)(*(const ::std::string*)arg[0],
      *(::TList*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_6126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regGraph)(*(const ::std::string*)arg[0]));
  else   (((::ITHistSvc*)o)->regGraph)(*(const ::std::string*)arg[0]);
}

static  void method_6127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ITHistSvc*)o)->regGraph)(*(const ::std::string*)arg[0],
    (::TGraph*)arg[1]));
  else   (((::ITHistSvc*)o)->regGraph)(*(const ::std::string*)arg[0],
    (::TGraph*)arg[1]);
}

static  void method_6128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ITHistSvc*)o)->getGraph)(*(const ::std::string*)arg[0],
    *(::TGraph**)arg[1]));
  else   (((const ::ITHistSvc*)o)->getGraph)(*(const ::std::string*)arg[0],
    *(::TGraph**)arg[1]);
}

static  void method_6129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ITHistSvc*)o)->exists)(*(const ::std::string*)arg[0]));
  else   (((const ::ITHistSvc*)o)->exists)(*(const ::std::string*)arg[0]);
}

static void destructor_6130(void*, void * o, const std::vector<void*>&, void *) {
(((::ITHistSvc*)o)->::ITHistSvc::~ITHistSvc)();
}
static void method_x60( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::ITHistSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::ITHistSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::ITHistSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ITHistSvc -------------------------------
void __ITHistSvc_db_datamem(Reflex::Class*);
void __ITHistSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ITHistSvc_datamem_bld(&__ITHistSvc_db_datamem);
Reflex::GenreflexMemberBuilder __ITHistSvc_funcmem_bld(&__ITHistSvc_db_funcmem);
void __ITHistSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ITHistSvc"), typeid(::ITHistSvc), sizeof(::ITHistSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::ITHistSvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20930, type_20931), Reflex::Literal("operator="), operator_6099, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ITHistSvc"), destructor_6130, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x60, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ITHistSvc_funcmem_bld);
}

//------Delayed data member builder for class ITHistSvc -------------------
void __ITHistSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ITHistSvc -------------------
void __ITHistSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("regHist"), method_6103, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20932), Reflex::Literal("regHist"), method_6104, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20933), Reflex::Literal("regHist"), method_6105, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20934), Reflex::Literal("regHist"), method_6106, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20935), Reflex::Literal("getHist"), method_6107, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20936), Reflex::Literal("getHist"), method_6108, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20937), Reflex::Literal("getHist"), method_6109, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("regTree"), method_6110, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20938), Reflex::Literal("regTree"), method_6111, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20939), Reflex::Literal("getTree"), method_6112, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("deReg"), method_6113, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20940), Reflex::Literal("deReg"), method_6114, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getHists"), method_6115, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getTrees"), method_6116, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getGraphs"), method_6117, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20941, type_20942, type_4206), Reflex::Literal("getTHists"), method_6118, 0, "td;;recurse=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20942, type_4206), Reflex::Literal("getTHists"), method_6119, 0, "name;;recurse=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20941, type_20942, type_4206, type_4206), Reflex::Literal("getTHists"), method_6120, 0, "td;;recurse=false;reg=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20942, type_4206, type_4206), Reflex::Literal("getTHists"), method_6121, 0, "name;;recurse=false;reg=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20941, type_20942, type_4206), Reflex::Literal("getTTrees"), method_6122, 0, "td;;recurse=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20942, type_4206), Reflex::Literal("getTTrees"), method_6123, 0, "name;;recurse=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20941, type_20942, type_4206, type_4206), Reflex::Literal("getTTrees"), method_6124, 0, "td;;recurse=false;reg=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20942, type_4206, type_4206), Reflex::Literal("getTTrees"), method_6125, 0, "name;;recurse=false;reg=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("regGraph"), method_6126, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20943), Reflex::Literal("regGraph"), method_6127, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20944), Reflex::Literal("getGraph"), method_6128, 0, "name;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_6134), Reflex::Literal("exists"), method_6129, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IAuditor -------------------------------
static  void operator_6136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAuditor*)o)->operator=)(*(const ::IAuditor*)arg[0]);
  else   (((::IAuditor*)o)->operator=)(*(const ::IAuditor*)arg[0]);
}

static  void method_6139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAuditor*)o)->interfaceID)();
  else   (((::IAuditor*)o)->interfaceID)();
}

static  void method_6140( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->before)(*(::IAuditor::StandardEventType*)arg[0],
    (::INamedInterface*)arg[1]);
}

static  void method_6141( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->before)(*(::IAuditor::StandardEventType*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->before)(*(const ::std::string*)arg[0],
    (::INamedInterface*)arg[1]);
}

static  void method_6143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->before)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6144( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::IAuditor*)o)->after)(*(::IAuditor::StandardEventType*)arg[0],
      (::INamedInterface*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::IAuditor*)o)->after)(*(::IAuditor::StandardEventType*)arg[0],
      (::INamedInterface*)arg[1],
      *(const ::StatusCode*)arg[2]);
  }
}

static  void method_6145( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::IAuditor*)o)->after)(*(::IAuditor::StandardEventType*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::IAuditor*)o)->after)(*(::IAuditor::StandardEventType*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatusCode*)arg[2]);
  }
}

static  void method_6146( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::IAuditor*)o)->after)(*(const ::std::string*)arg[0],
      (::INamedInterface*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::IAuditor*)o)->after)(*(const ::std::string*)arg[0],
      (::INamedInterface*)arg[1],
      *(const ::StatusCode*)arg[2]);
  }
}

static  void method_6147( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::IAuditor*)o)->after)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::IAuditor*)o)->after)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatusCode*)arg[2]);
  }
}

static  void method_6148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IAuditor*)o)->isEnabled)());
  else   (((const ::IAuditor*)o)->isEnabled)();
}

static  void method_6149( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->beforeInitialize)((::INamedInterface*)arg[0]);
}

static  void method_6150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->afterInitialize)((::INamedInterface*)arg[0]);
}

static  void method_6151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->beforeReinitialize)((::INamedInterface*)arg[0]);
}

static  void method_6152( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->afterReinitialize)((::INamedInterface*)arg[0]);
}

static  void method_6153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->beforeExecute)((::INamedInterface*)arg[0]);
}

static  void method_6154( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->afterExecute)((::INamedInterface*)arg[0],
    *(const ::StatusCode*)arg[1]);
}

static  void method_6155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->beforeBeginRun)((::INamedInterface*)arg[0]);
}

static  void method_6156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->afterBeginRun)((::INamedInterface*)arg[0]);
}

static  void method_6157( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->beforeEndRun)((::INamedInterface*)arg[0]);
}

static  void method_6158( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->afterEndRun)((::INamedInterface*)arg[0]);
}

static  void method_6159( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->beforeFinalize)((::INamedInterface*)arg[0]);
}

static  void method_6160( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IAuditor*)o)->afterFinalize)((::INamedInterface*)arg[0]);
}

static  void method_6161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAuditor*)o)->sysInitialize)());
  else   (((::IAuditor*)o)->sysInitialize)();
}

static  void method_6162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAuditor*)o)->sysFinalize)());
  else   (((::IAuditor*)o)->sysFinalize)();
}

static void destructor_6163(void*, void * o, const std::vector<void*>&, void *) {
(((::IAuditor*)o)->::IAuditor::~IAuditor)();
}
static void method_x61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IAuditor,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAuditor,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAuditor -------------------------------
void __IAuditor_db_datamem(Reflex::Class*);
void __IAuditor_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAuditor_datamem_bld(&__IAuditor_db_datamem);
Reflex::GenreflexMemberBuilder __IAuditor_funcmem_bld(&__IAuditor_db_funcmem);
void __IAuditor_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAuditor"), typeid(::IAuditor), sizeof(::IAuditor), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2776, ::Reflex::BaseOffset< ::IAuditor, ::INamedInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("IAuditor::StandardEventType"), Reflex::Literal("Initialize=0;ReInitialize=1;Execute=2;BeginRun=3;EndRun=4;Finalize=5;Start=6;Stop=7;ReStart=8"), &typeid(IAuditor::StandardEventType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_3236, Reflex::Literal("IAuditor::CustomEventType"))
  .AddTypedef(type_6134, Reflex::Literal("IAuditor::CustomEventTypeRef"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20945, type_20946), Reflex::Literal("operator="), operator_6136, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IAuditor"), destructor_6163, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAuditor_funcmem_bld);
}

//------Delayed data member builder for class IAuditor -------------------
void __IAuditor_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAuditor -------------------
void __IAuditor_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6139, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_5168, type_20947), Reflex::Literal("before"), method_6140, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_5168, type_6134), Reflex::Literal("before"), method_6141, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_20947), Reflex::Literal("before"), method_6142, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_6134), Reflex::Literal("before"), method_6143, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_5168, type_20947, type_7461), Reflex::Literal("after"), method_6144, 0, ";;sc=StatusCode(1ul, 1)", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_5168, type_6134, type_7461), Reflex::Literal("after"), method_6145, 0, ";;sc=StatusCode(1ul, 1)", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_20947, type_7461), Reflex::Literal("after"), method_6146, 0, ";;sc=StatusCode(1ul, 1)", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_6134, type_7461), Reflex::Literal("after"), method_6147, 0, ";;sc=StatusCode(1ul, 1)", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isEnabled"), method_6148, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("beforeInitialize"), method_6149, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("afterInitialize"), method_6150, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("beforeReinitialize"), method_6151, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("afterReinitialize"), method_6152, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("beforeExecute"), method_6153, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947, type_7461), Reflex::Literal("afterExecute"), method_6154, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("beforeBeginRun"), method_6155, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("afterBeginRun"), method_6156, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("beforeEndRun"), method_6157, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("afterEndRun"), method_6158, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("beforeFinalize"), method_6159, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20947), Reflex::Literal("afterFinalize"), method_6160, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysInitialize"), method_6161, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysFinalize"), method_6162, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartIF<IAlgorithm> -------------------------------
static void constructor_6165( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAlgorithm>();
  else ::new(mem) ::SmartIF<IAlgorithm>();
}

static void constructor_6166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAlgorithm>((::IAlgorithm*)arg[0]);
  else ::new(mem) ::SmartIF<IAlgorithm>((::IAlgorithm*)arg[0]);
}

static void constructor_6167( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAlgorithm>(*(const ::SmartIF<IAlgorithm>*)arg[0]);
  else ::new(mem) ::SmartIF<IAlgorithm>(*(const ::SmartIF<IAlgorithm>*)arg[0]);
}

static void destructor_6168(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IAlgorithm>*)o)->::SmartIF<IAlgorithm>::~SmartIF)();
}
static  void method_6169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IAlgorithm>*)o)->isValid)());
  else   (((const ::SmartIF<IAlgorithm>*)o)->isValid)();
}

static  void converter_6170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAlgorithm>*)o)->operator IAlgorithm*)());
  else   (((const ::SmartIF<IAlgorithm>*)o)->operator IAlgorithm*)();
}

static  void operator_6171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAlgorithm>*)o)->operator->)());
  else   (((const ::SmartIF<IAlgorithm>*)o)->operator->)();
}

static  void operator_6172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IAlgorithm>*)o)->operator*)();
  else   (((const ::SmartIF<IAlgorithm>*)o)->operator*)();
}

static  void method_6173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAlgorithm>*)o)->get)());
  else   (((const ::SmartIF<IAlgorithm>*)o)->get)();
}

static  void method_6174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAlgorithm>*)o)->pRef)();
  else   (((::SmartIF<IAlgorithm>*)o)->pRef)();
}

static  void method_6175( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IAlgorithm>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IAlgorithm>*)o)->reset)((::IAlgorithm*)arg[0]);
  }
}

static  void operator_6176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAlgorithm>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IAlgorithm>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAlgorithm>*)o)->operator=)(*(const ::SmartIF<IAlgorithm>*)arg[0]);
  else   (((::SmartIF<IAlgorithm>*)o)->operator=)(*(const ::SmartIF<IAlgorithm>*)arg[0]);
}

static void method_newdel_1591( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgorithm> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgorithm> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgorithm> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgorithm> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgorithm> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IAlgorithm> -------------------------------
void __SmartIF_IAlgorithm__db_datamem(Reflex::Class*);
void __SmartIF_IAlgorithm__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IAlgorithm__datamem_bld(&__SmartIF_IAlgorithm__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IAlgorithm__funcmem_bld(&__SmartIF_IAlgorithm__db_funcmem);
void __SmartIF_IAlgorithm__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IAlgorithm>"), typeid(::SmartIF<IAlgorithm>), sizeof(::SmartIF<IAlgorithm>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6165, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20948), Reflex::Literal("SmartIF"), constructor_6166, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20949), Reflex::Literal("SmartIF"), constructor_6167, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6168, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1591, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IAlgorithm__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IAlgorithm__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IAlgorithm> -------------------
void __SmartIF_IAlgorithm__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20948, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IAlgorithm_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IAlgorithm> -------------------
void __SmartIF_IAlgorithm__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20948), Reflex::Literal("operator IAlgorithm*"), converter_6170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20948), Reflex::Literal("operator->"), operator_6171, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19507), Reflex::Literal("operator*"), operator_6172, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20948), Reflex::Literal("get"), method_6173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20950), Reflex::Literal("pRef"), method_6174, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20948), Reflex::Literal("reset"), method_6175, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20951, type_19539), Reflex::Literal("operator="), operator_6176, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20951, type_20949), Reflex::Literal("operator="), operator_6177, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class IIncidentSvc -------------------------------
static  void operator_6984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IIncidentSvc*)o)->operator=)(*(const ::IIncidentSvc*)arg[0]);
  else   (((::IIncidentSvc*)o)->operator=)(*(const ::IIncidentSvc*)arg[0]);
}

static  void method_6987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IIncidentSvc*)o)->interfaceID)();
  else   (((::IIncidentSvc*)o)->interfaceID)();
}

static  void method_6988( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::IIncidentSvc*)o)->addListener)((::IIncidentListener*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::IIncidentSvc*)o)->addListener)((::IIncidentListener*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::IIncidentSvc*)o)->addListener)((::IIncidentListener*)arg[0],
      *(const ::std::string*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::IIncidentSvc*)o)->addListener)((::IIncidentListener*)arg[0],
      *(const ::std::string*)arg[1],
      *(long*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::IIncidentSvc*)o)->addListener)((::IIncidentListener*)arg[0],
      *(const ::std::string*)arg[1],
      *(long*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
}

static  void method_6989( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::IIncidentSvc*)o)->removeListener)((::IIncidentListener*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::IIncidentSvc*)o)->removeListener)((::IIncidentListener*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_6990( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::IIncidentSvc*)o)->getListeners)(*(::std::vector<IIncidentListener*>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::IIncidentSvc*)o)->getListeners)(*(::std::vector<IIncidentListener*>*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_6991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IIncidentSvc*)o)->fireIncident)(*(const ::Incident*)arg[0]);
}

static void destructor_6992(void*, void * o, const std::vector<void*>&, void *) {
(((::IIncidentSvc*)o)->::IIncidentSvc::~IIncidentSvc)();
}
static void method_x63( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IIncidentSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IIncidentSvc -------------------------------
void __IIncidentSvc_db_datamem(Reflex::Class*);
void __IIncidentSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IIncidentSvc_datamem_bld(&__IIncidentSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IIncidentSvc_funcmem_bld(&__IIncidentSvc_db_funcmem);
void __IIncidentSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IIncidentSvc"), typeid(::IIncidentSvc), sizeof(::IIncidentSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IIncidentSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20954, type_24127), Reflex::Literal("operator="), operator_6984, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IIncidentSvc"), destructor_6992, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x63, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IIncidentSvc_funcmem_bld);
}

//------Delayed data member builder for class IIncidentSvc -------------------
void __IIncidentSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IIncidentSvc -------------------
void __IIncidentSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6987, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24128, type_6134, type_26, type_4206, type_4206), Reflex::Literal("addListener"), method_6988, 0, "lis;type=\"\";priority=0;rethrow=false;singleShot=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24128, type_6134), Reflex::Literal("removeListener"), method_6989, 0, "lis;type=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24129, type_6134), Reflex::Literal("getListeners"), method_6990, 0, "lis;type=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19433), Reflex::Literal("fireIncident"), method_6991, 0, "incident", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartIF<IIncidentSvc> -------------------------------
static void constructor_6179( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IIncidentSvc>();
  else ::new(mem) ::SmartIF<IIncidentSvc>();
}

static void constructor_6180( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IIncidentSvc>((::IIncidentSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IIncidentSvc>((::IIncidentSvc*)arg[0]);
}

static void constructor_6181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IIncidentSvc>(*(const ::SmartIF<IIncidentSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IIncidentSvc>(*(const ::SmartIF<IIncidentSvc>*)arg[0]);
}

static void destructor_6182(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IIncidentSvc>*)o)->::SmartIF<IIncidentSvc>::~SmartIF)();
}
static  void method_6183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IIncidentSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IIncidentSvc>*)o)->isValid)();
}

static  void converter_6184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IIncidentSvc>*)o)->operator IIncidentSvc*)());
  else   (((const ::SmartIF<IIncidentSvc>*)o)->operator IIncidentSvc*)();
}

static  void operator_6185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IIncidentSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IIncidentSvc>*)o)->operator->)();
}

static  void operator_6186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IIncidentSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IIncidentSvc>*)o)->operator*)();
}

static  void method_6187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IIncidentSvc>*)o)->get)());
  else   (((const ::SmartIF<IIncidentSvc>*)o)->get)();
}

static  void method_6188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IIncidentSvc>*)o)->pRef)();
  else   (((::SmartIF<IIncidentSvc>*)o)->pRef)();
}

static  void method_6189( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IIncidentSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IIncidentSvc>*)o)->reset)((::IIncidentSvc*)arg[0]);
  }
}

static  void operator_6190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IIncidentSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IIncidentSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IIncidentSvc>*)o)->operator=)(*(const ::SmartIF<IIncidentSvc>*)arg[0]);
  else   (((::SmartIF<IIncidentSvc>*)o)->operator=)(*(const ::SmartIF<IIncidentSvc>*)arg[0]);
}

static void method_newdel_1592( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IIncidentSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IIncidentSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IIncidentSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IIncidentSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IIncidentSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IIncidentSvc> -------------------------------
void __SmartIF_IIncidentSvc__db_datamem(Reflex::Class*);
void __SmartIF_IIncidentSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IIncidentSvc__datamem_bld(&__SmartIF_IIncidentSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IIncidentSvc__funcmem_bld(&__SmartIF_IIncidentSvc__db_funcmem);
void __SmartIF_IIncidentSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IIncidentSvc>"), typeid(::SmartIF<IIncidentSvc>), sizeof(::SmartIF<IIncidentSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6179, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20952), Reflex::Literal("SmartIF"), constructor_6180, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20953), Reflex::Literal("SmartIF"), constructor_6181, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6182, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1592, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IIncidentSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IIncidentSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IIncidentSvc> -------------------
void __SmartIF_IIncidentSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20952, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IIncidentSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IIncidentSvc> -------------------
void __SmartIF_IIncidentSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20952), Reflex::Literal("operator IIncidentSvc*"), converter_6184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20952), Reflex::Literal("operator->"), operator_6185, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20954), Reflex::Literal("operator*"), operator_6186, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20952), Reflex::Literal("get"), method_6187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20955), Reflex::Literal("pRef"), method_6188, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20952), Reflex::Literal("reset"), method_6189, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20956, type_19539), Reflex::Literal("operator="), operator_6190, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20956, type_20953), Reflex::Literal("operator="), operator_6191, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IService> -------------------------------
static void constructor_6193( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IService>();
  else ::new(mem) ::SmartIF<IService>();
}

static void constructor_6194( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IService>((::IService*)arg[0]);
  else ::new(mem) ::SmartIF<IService>((::IService*)arg[0]);
}

static void constructor_6195( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IService>(*(const ::SmartIF<IService>*)arg[0]);
  else ::new(mem) ::SmartIF<IService>(*(const ::SmartIF<IService>*)arg[0]);
}

static void destructor_6196(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IService>*)o)->::SmartIF<IService>::~SmartIF)();
}
static  void method_6197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IService>*)o)->isValid)());
  else   (((const ::SmartIF<IService>*)o)->isValid)();
}

static  void converter_6198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IService>*)o)->operator IService*)());
  else   (((const ::SmartIF<IService>*)o)->operator IService*)();
}

static  void operator_6199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IService>*)o)->operator->)());
  else   (((const ::SmartIF<IService>*)o)->operator->)();
}

static  void operator_6200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IService>*)o)->operator*)();
  else   (((const ::SmartIF<IService>*)o)->operator*)();
}

static  void method_6201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IService>*)o)->get)());
  else   (((const ::SmartIF<IService>*)o)->get)();
}

static  void method_6202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IService>*)o)->pRef)();
  else   (((::SmartIF<IService>*)o)->pRef)();
}

static  void method_6203( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IService>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IService>*)o)->reset)((::IService*)arg[0]);
  }
}

static  void operator_6204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IService>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IService>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IService>*)o)->operator=)(*(const ::SmartIF<IService>*)arg[0]);
  else   (((::SmartIF<IService>*)o)->operator=)(*(const ::SmartIF<IService>*)arg[0]);
}

static void method_newdel_1593( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IService> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IService> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IService> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IService> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IService> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IService> -------------------------------
void __SmartIF_IService__db_datamem(Reflex::Class*);
void __SmartIF_IService__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IService__datamem_bld(&__SmartIF_IService__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IService__funcmem_bld(&__SmartIF_IService__db_funcmem);
void __SmartIF_IService__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IService>"), typeid(::SmartIF<IService>), sizeof(::SmartIF<IService>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6193, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20957), Reflex::Literal("SmartIF"), constructor_6194, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20958), Reflex::Literal("SmartIF"), constructor_6195, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6196, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1593, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IService__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IService__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IService> -------------------
void __SmartIF_IService__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20957, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IService_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IService> -------------------
void __SmartIF_IService__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20957), Reflex::Literal("operator IService*"), converter_6198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20957), Reflex::Literal("operator->"), operator_6199, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19913), Reflex::Literal("operator*"), operator_6200, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20957), Reflex::Literal("get"), method_6201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20040), Reflex::Literal("pRef"), method_6202, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20957), Reflex::Literal("reset"), method_6203, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042, type_19539), Reflex::Literal("operator="), operator_6204, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042, type_20958), Reflex::Literal("operator="), operator_6205, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IAuditorSvc> -------------------------------
static void constructor_6207( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAuditorSvc>();
  else ::new(mem) ::SmartIF<IAuditorSvc>();
}

static void constructor_6208( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAuditorSvc>((::IAuditorSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IAuditorSvc>((::IAuditorSvc*)arg[0]);
}

static void constructor_6209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAuditorSvc>(*(const ::SmartIF<IAuditorSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IAuditorSvc>(*(const ::SmartIF<IAuditorSvc>*)arg[0]);
}

static void destructor_6210(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IAuditorSvc>*)o)->::SmartIF<IAuditorSvc>::~SmartIF)();
}
static  void method_6211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IAuditorSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IAuditorSvc>*)o)->isValid)();
}

static  void converter_6212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAuditorSvc>*)o)->operator IAuditorSvc*)());
  else   (((const ::SmartIF<IAuditorSvc>*)o)->operator IAuditorSvc*)();
}

static  void operator_6213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAuditorSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IAuditorSvc>*)o)->operator->)();
}

static  void operator_6214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IAuditorSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IAuditorSvc>*)o)->operator*)();
}

static  void method_6215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAuditorSvc>*)o)->get)());
  else   (((const ::SmartIF<IAuditorSvc>*)o)->get)();
}

static  void method_6216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAuditorSvc>*)o)->pRef)();
  else   (((::SmartIF<IAuditorSvc>*)o)->pRef)();
}

static  void method_6217( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IAuditorSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IAuditorSvc>*)o)->reset)((::IAuditorSvc*)arg[0]);
  }
}

static  void operator_6218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAuditorSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IAuditorSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAuditorSvc>*)o)->operator=)(*(const ::SmartIF<IAuditorSvc>*)arg[0]);
  else   (((::SmartIF<IAuditorSvc>*)o)->operator=)(*(const ::SmartIF<IAuditorSvc>*)arg[0]);
}

static void method_newdel_1594( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IAuditorSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IAuditorSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IAuditorSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IAuditorSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IAuditorSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IAuditorSvc> -------------------------------
void __SmartIF_IAuditorSvc__db_datamem(Reflex::Class*);
void __SmartIF_IAuditorSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IAuditorSvc__datamem_bld(&__SmartIF_IAuditorSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IAuditorSvc__funcmem_bld(&__SmartIF_IAuditorSvc__db_funcmem);
void __SmartIF_IAuditorSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IAuditorSvc>"), typeid(::SmartIF<IAuditorSvc>), sizeof(::SmartIF<IAuditorSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6207, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20053), Reflex::Literal("SmartIF"), constructor_6208, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20959), Reflex::Literal("SmartIF"), constructor_6209, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6210, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1594, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IAuditorSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IAuditorSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IAuditorSvc> -------------------
void __SmartIF_IAuditorSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20053, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IAuditorSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IAuditorSvc> -------------------
void __SmartIF_IAuditorSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20053), Reflex::Literal("operator IAuditorSvc*"), converter_6212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20053), Reflex::Literal("operator->"), operator_6213, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20043), Reflex::Literal("operator*"), operator_6214, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20053), Reflex::Literal("get"), method_6215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20960), Reflex::Literal("pRef"), method_6216, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20053), Reflex::Literal("reset"), method_6217, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20109, type_19539), Reflex::Literal("operator="), operator_6218, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20109, type_20959), Reflex::Literal("operator="), operator_6219, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class ISvcManager -------------------------------
static  void operator_6477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISvcManager*)o)->operator=)(*(const ::ISvcManager*)arg[0]);
  else   (((::ISvcManager*)o)->operator=)(*(const ::ISvcManager*)arg[0]);
}

static  void method_6480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISvcManager*)o)->interfaceID)();
  else   (((::ISvcManager*)o)->interfaceID)();
}

static  void method_6481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->addService)((::IService*)arg[0]));
    else     (((::ISvcManager*)o)->addService)((::IService*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->addService)((::IService*)arg[0],
      *(int*)arg[1]));
    else     (((::ISvcManager*)o)->addService)((::IService*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_6482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->addService)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2]));
  else   (((::ISvcManager*)o)->addService)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2]);
}

static  void method_6483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->addService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]));
    else     (((::ISvcManager*)o)->addService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->addService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(int*)arg[1]));
    else     (((::ISvcManager*)o)->addService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_6484( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->removeService)((::IService*)arg[0]));
  else   (((::ISvcManager*)o)->removeService)((::IService*)arg[0]);
}

static  void method_6485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->removeService)(*(const ::std::string*)arg[0]));
  else   (((::ISvcManager*)o)->removeService)(*(const ::std::string*)arg[0]);
}

static  void method_6486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->declareSvcFactory)(*(const ::ISvcFactory*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::ISvcManager*)o)->declareSvcFactory)(*(const ::ISvcFactory*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->declareSvcType)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::ISvcManager*)o)->declareSvcType)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISvcManager*)o)->createService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]);
  else   (((::ISvcManager*)o)->createService)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]);
}

static  void method_6489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->createService)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::IService**)arg[2]));
  else   (((::ISvcManager*)o)->createService)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::IService**)arg[2]);
}

static  void method_6490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ISvcManager*)o)->getFactory)(*(const ::std::string*)arg[0],
    *(const ::ISvcFactory**)arg[1]));
  else   (((const ::ISvcManager*)o)->getFactory)(*(const ::std::string*)arg[0],
    *(const ::ISvcFactory**)arg[1]);
}

static  void method_6491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->initializeServices)());
  else   (((::ISvcManager*)o)->initializeServices)();
}

static  void method_6492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->startServices)());
  else   (((::ISvcManager*)o)->startServices)();
}

static  void method_6493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->stopServices)());
  else   (((::ISvcManager*)o)->stopServices)();
}

static  void method_6494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->finalizeServices)());
  else   (((::ISvcManager*)o)->finalizeServices)();
}

static  void method_6495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->reinitializeServices)());
  else   (((::ISvcManager*)o)->reinitializeServices)();
}

static  void method_6496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->restartServices)());
  else   (((::ISvcManager*)o)->restartServices)();
}

static  void method_6497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::ISvcManager*)o)->getPriority)(*(const ::std::string*)arg[0]));
  else   (((const ::ISvcManager*)o)->getPriority)(*(const ::std::string*)arg[0]);
}

static  void method_6498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ISvcManager*)o)->setPriority)(*(const ::std::string*)arg[0],
    *(int*)arg[1]));
  else   (((::ISvcManager*)o)->setPriority)(*(const ::std::string*)arg[0],
    *(int*)arg[1]);
}

static  void method_6499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ISvcManager*)o)->loopCheckEnabled)());
  else   (((const ::ISvcManager*)o)->loopCheckEnabled)();
}

static  void method_6500( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::ISvcManager*)o)->setLoopCheckEnabled)();
  }
  else if ( arg.size() == 1 ) { 
    (((::ISvcManager*)o)->setLoopCheckEnabled)(*(bool*)arg[0]);
  }
}

static void destructor_6501(void*, void * o, const std::vector<void*>&, void *) {
(((::ISvcManager*)o)->::ISvcManager::~ISvcManager)();
}
static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IComponentManager")), ::Reflex::BaseOffset< ::ISvcManager,::IComponentManager >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::ISvcManager,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::ISvcManager,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ISvcManager -------------------------------
void __ISvcManager_db_datamem(Reflex::Class*);
void __ISvcManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ISvcManager_datamem_bld(&__ISvcManager_db_datamem);
Reflex::GenreflexMemberBuilder __ISvcManager_funcmem_bld(&__ISvcManager_db_funcmem);
void __ISvcManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ISvcManager"), typeid(::ISvcManager), sizeof(::ISvcManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_556, ::Reflex::BaseOffset< ::ISvcManager, ::IComponentManager >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20962, type_21019), Reflex::Literal("operator="), operator_6477, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ISvcManager"), destructor_6501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ISvcManager_funcmem_bld);
}

//------Delayed data member builder for class ISvcManager -------------------
void __ISvcManager_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ISvcManager -------------------
void __ISvcManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6480, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20957, type_142), Reflex::Literal("addService"), method_6481, 0, "svc;prio=ISvcManager::DEFAULT_SVC_PRIORITY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_142), Reflex::Literal("addService"), method_6482, 0, "typ;nam;prio", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20039, type_142), Reflex::Literal("addService"), method_6483, 0, "nametype;prio=ISvcManager::DEFAULT_SVC_PRIORITY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20957), Reflex::Literal("removeService"), method_6484, 0, "svc", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("removeService"), method_6485, 0, "nam", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_21020, type_6134), Reflex::Literal("declareSvcFactory"), method_6486, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("declareSvcType"), method_6487, 0, "svcname;svctype", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042, type_20039), Reflex::Literal("createService"), method_6488, 0, "nametype", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_20040), Reflex::Literal("createService"), method_6489, 0, "svctype;svcname;svc", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_21021), Reflex::Literal("getFactory"), method_6490, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initializeServices"), method_6491, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("startServices"), method_6492, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stopServices"), method_6493, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalizeServices"), method_6494, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitializeServices"), method_6495, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restartServices"), method_6496, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_6134), Reflex::Literal("getPriority"), method_6497, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142), Reflex::Literal("setPriority"), method_6498, 0, "name;pri", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("loopCheckEnabled"), method_6499, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4206), Reflex::Literal("setLoopCheckEnabled"), method_6500, 0, "en=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartIF<ISvcManager> -------------------------------
static void constructor_6221( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<ISvcManager>();
  else ::new(mem) ::SmartIF<ISvcManager>();
}

static void constructor_6222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<ISvcManager>((::ISvcManager*)arg[0]);
  else ::new(mem) ::SmartIF<ISvcManager>((::ISvcManager*)arg[0]);
}

static void constructor_6223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<ISvcManager>(*(const ::SmartIF<ISvcManager>*)arg[0]);
  else ::new(mem) ::SmartIF<ISvcManager>(*(const ::SmartIF<ISvcManager>*)arg[0]);
}

static void destructor_6224(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<ISvcManager>*)o)->::SmartIF<ISvcManager>::~SmartIF)();
}
static  void method_6225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<ISvcManager>*)o)->isValid)());
  else   (((const ::SmartIF<ISvcManager>*)o)->isValid)();
}

static  void converter_6226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<ISvcManager>*)o)->operator ISvcManager*)());
  else   (((const ::SmartIF<ISvcManager>*)o)->operator ISvcManager*)();
}

static  void operator_6227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<ISvcManager>*)o)->operator->)());
  else   (((const ::SmartIF<ISvcManager>*)o)->operator->)();
}

static  void operator_6228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<ISvcManager>*)o)->operator*)();
  else   (((const ::SmartIF<ISvcManager>*)o)->operator*)();
}

static  void method_6229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<ISvcManager>*)o)->get)());
  else   (((const ::SmartIF<ISvcManager>*)o)->get)();
}

static  void method_6230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<ISvcManager>*)o)->pRef)();
  else   (((::SmartIF<ISvcManager>*)o)->pRef)();
}

static  void method_6231( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<ISvcManager>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<ISvcManager>*)o)->reset)((::ISvcManager*)arg[0]);
  }
}

static  void operator_6232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<ISvcManager>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<ISvcManager>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<ISvcManager>*)o)->operator=)(*(const ::SmartIF<ISvcManager>*)arg[0]);
  else   (((::SmartIF<ISvcManager>*)o)->operator=)(*(const ::SmartIF<ISvcManager>*)arg[0]);
}

static void method_newdel_1595( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcManager> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcManager> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcManager> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcManager> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcManager> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<ISvcManager> -------------------------------
void __SmartIF_ISvcManager__db_datamem(Reflex::Class*);
void __SmartIF_ISvcManager__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_ISvcManager__datamem_bld(&__SmartIF_ISvcManager__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_ISvcManager__funcmem_bld(&__SmartIF_ISvcManager__db_funcmem);
void __SmartIF_ISvcManager__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<ISvcManager>"), typeid(::SmartIF<ISvcManager>), sizeof(::SmartIF<ISvcManager>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6221, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19915), Reflex::Literal("SmartIF"), constructor_6222, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20961), Reflex::Literal("SmartIF"), constructor_6223, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6224, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1595, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_ISvcManager__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_ISvcManager__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<ISvcManager> -------------------
void __SmartIF_ISvcManager__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19915, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_ISvcManager_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<ISvcManager> -------------------
void __SmartIF_ISvcManager__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19915), Reflex::Literal("operator ISvcManager*"), converter_6226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19915), Reflex::Literal("operator->"), operator_6227, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20962), Reflex::Literal("operator*"), operator_6228, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19915), Reflex::Literal("get"), method_6229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20963), Reflex::Literal("pRef"), method_6230, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19915), Reflex::Literal("reset"), method_6231, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20964, type_19539), Reflex::Literal("operator="), operator_6232, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20964, type_20961), Reflex::Literal("operator="), operator_6233, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<ISvcLocator> -------------------------------
static void constructor_6235( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<ISvcLocator>();
  else ::new(mem) ::SmartIF<ISvcLocator>();
}

static void constructor_6236( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<ISvcLocator>((::ISvcLocator*)arg[0]);
  else ::new(mem) ::SmartIF<ISvcLocator>((::ISvcLocator*)arg[0]);
}

static void constructor_6237( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<ISvcLocator>(*(const ::SmartIF<ISvcLocator>*)arg[0]);
  else ::new(mem) ::SmartIF<ISvcLocator>(*(const ::SmartIF<ISvcLocator>*)arg[0]);
}

static void destructor_6238(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<ISvcLocator>*)o)->::SmartIF<ISvcLocator>::~SmartIF)();
}
static  void method_6239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<ISvcLocator>*)o)->isValid)());
  else   (((const ::SmartIF<ISvcLocator>*)o)->isValid)();
}

static  void converter_6240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<ISvcLocator>*)o)->operator ISvcLocator*)());
  else   (((const ::SmartIF<ISvcLocator>*)o)->operator ISvcLocator*)();
}

static  void operator_6241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<ISvcLocator>*)o)->operator->)());
  else   (((const ::SmartIF<ISvcLocator>*)o)->operator->)();
}

static  void operator_6242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<ISvcLocator>*)o)->operator*)();
  else   (((const ::SmartIF<ISvcLocator>*)o)->operator*)();
}

static  void method_6243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<ISvcLocator>*)o)->get)());
  else   (((const ::SmartIF<ISvcLocator>*)o)->get)();
}

static  void method_6244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<ISvcLocator>*)o)->pRef)();
  else   (((::SmartIF<ISvcLocator>*)o)->pRef)();
}

static  void method_6245( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<ISvcLocator>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<ISvcLocator>*)o)->reset)((::ISvcLocator*)arg[0]);
  }
}

static  void operator_6246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<ISvcLocator>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<ISvcLocator>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<ISvcLocator>*)o)->operator=)(*(const ::SmartIF<ISvcLocator>*)arg[0]);
  else   (((::SmartIF<ISvcLocator>*)o)->operator=)(*(const ::SmartIF<ISvcLocator>*)arg[0]);
}

static void method_newdel_1596( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcLocator> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcLocator> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcLocator> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcLocator> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<ISvcLocator> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<ISvcLocator> -------------------------------
void __SmartIF_ISvcLocator__db_datamem(Reflex::Class*);
void __SmartIF_ISvcLocator__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_ISvcLocator__datamem_bld(&__SmartIF_ISvcLocator__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_ISvcLocator__funcmem_bld(&__SmartIF_ISvcLocator__db_funcmem);
void __SmartIF_ISvcLocator__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<ISvcLocator>"), typeid(::SmartIF<ISvcLocator>), sizeof(::SmartIF<ISvcLocator>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6235, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19445), Reflex::Literal("SmartIF"), constructor_6236, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20965), Reflex::Literal("SmartIF"), constructor_6237, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6238, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1596, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_ISvcLocator__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_ISvcLocator__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<ISvcLocator> -------------------
void __SmartIF_ISvcLocator__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19445, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_ISvcLocator_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<ISvcLocator> -------------------
void __SmartIF_ISvcLocator__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19445), Reflex::Literal("operator ISvcLocator*"), converter_6240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19445), Reflex::Literal("operator->"), operator_6241, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19467), Reflex::Literal("operator*"), operator_6242, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19445), Reflex::Literal("get"), method_6243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20966), Reflex::Literal("pRef"), method_6244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19445), Reflex::Literal("reset"), method_6245, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20108, type_19539), Reflex::Literal("operator="), operator_6246, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20108, type_20965), Reflex::Literal("operator="), operator_6247, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IMessageSvc> -------------------------------
static void constructor_6249( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IMessageSvc>();
  else ::new(mem) ::SmartIF<IMessageSvc>();
}

static void constructor_6250( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IMessageSvc>((::IMessageSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IMessageSvc>((::IMessageSvc*)arg[0]);
}

static void constructor_6251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IMessageSvc>(*(const ::SmartIF<IMessageSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IMessageSvc>(*(const ::SmartIF<IMessageSvc>*)arg[0]);
}

static void destructor_6252(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IMessageSvc>*)o)->::SmartIF<IMessageSvc>::~SmartIF)();
}
static  void method_6253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IMessageSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IMessageSvc>*)o)->isValid)();
}

static  void converter_6254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IMessageSvc>*)o)->operator IMessageSvc*)());
  else   (((const ::SmartIF<IMessageSvc>*)o)->operator IMessageSvc*)();
}

static  void operator_6255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IMessageSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IMessageSvc>*)o)->operator->)();
}

static  void operator_6256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IMessageSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IMessageSvc>*)o)->operator*)();
}

static  void method_6257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IMessageSvc>*)o)->get)());
  else   (((const ::SmartIF<IMessageSvc>*)o)->get)();
}

static  void method_6258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IMessageSvc>*)o)->pRef)();
  else   (((::SmartIF<IMessageSvc>*)o)->pRef)();
}

static  void method_6259( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IMessageSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IMessageSvc>*)o)->reset)((::IMessageSvc*)arg[0]);
  }
}

static  void operator_6260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IMessageSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IMessageSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IMessageSvc>*)o)->operator=)(*(const ::SmartIF<IMessageSvc>*)arg[0]);
  else   (((::SmartIF<IMessageSvc>*)o)->operator=)(*(const ::SmartIF<IMessageSvc>*)arg[0]);
}

static void method_newdel_1597( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IMessageSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IMessageSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IMessageSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IMessageSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IMessageSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IMessageSvc> -------------------------------
void __SmartIF_IMessageSvc__db_datamem(Reflex::Class*);
void __SmartIF_IMessageSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IMessageSvc__datamem_bld(&__SmartIF_IMessageSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IMessageSvc__funcmem_bld(&__SmartIF_IMessageSvc__db_funcmem);
void __SmartIF_IMessageSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IMessageSvc>"), typeid(::SmartIF<IMessageSvc>), sizeof(::SmartIF<IMessageSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6249, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20028), Reflex::Literal("SmartIF"), constructor_6250, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20967), Reflex::Literal("SmartIF"), constructor_6251, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6252, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1597, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IMessageSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IMessageSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IMessageSvc> -------------------
void __SmartIF_IMessageSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20028, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IMessageSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IMessageSvc> -------------------
void __SmartIF_IMessageSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20028), Reflex::Literal("operator IMessageSvc*"), converter_6254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20028), Reflex::Literal("operator->"), operator_6255, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19846), Reflex::Literal("operator*"), operator_6256, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20028), Reflex::Literal("get"), method_6257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20968), Reflex::Literal("pRef"), method_6258, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20028), Reflex::Literal("reset"), method_6259, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20969, type_19539), Reflex::Literal("operator="), operator_6260, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20969, type_20967), Reflex::Literal("operator="), operator_6261, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IMonitorSvc> -------------------------------
static void constructor_6263( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IMonitorSvc>();
  else ::new(mem) ::SmartIF<IMonitorSvc>();
}

static void constructor_6264( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IMonitorSvc>((::IMonitorSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IMonitorSvc>((::IMonitorSvc*)arg[0]);
}

static void constructor_6265( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IMonitorSvc>(*(const ::SmartIF<IMonitorSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IMonitorSvc>(*(const ::SmartIF<IMonitorSvc>*)arg[0]);
}

static void destructor_6266(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IMonitorSvc>*)o)->::SmartIF<IMonitorSvc>::~SmartIF)();
}
static  void method_6267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IMonitorSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IMonitorSvc>*)o)->isValid)();
}

static  void converter_6268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IMonitorSvc>*)o)->operator IMonitorSvc*)());
  else   (((const ::SmartIF<IMonitorSvc>*)o)->operator IMonitorSvc*)();
}

static  void operator_6269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IMonitorSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IMonitorSvc>*)o)->operator->)();
}

static  void operator_6270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IMonitorSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IMonitorSvc>*)o)->operator*)();
}

static  void method_6271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IMonitorSvc>*)o)->get)());
  else   (((const ::SmartIF<IMonitorSvc>*)o)->get)();
}

static  void method_6272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IMonitorSvc>*)o)->pRef)();
  else   (((::SmartIF<IMonitorSvc>*)o)->pRef)();
}

static  void method_6273( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IMonitorSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IMonitorSvc>*)o)->reset)((::IMonitorSvc*)arg[0]);
  }
}

static  void operator_6274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IMonitorSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IMonitorSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IMonitorSvc>*)o)->operator=)(*(const ::SmartIF<IMonitorSvc>*)arg[0]);
  else   (((::SmartIF<IMonitorSvc>*)o)->operator=)(*(const ::SmartIF<IMonitorSvc>*)arg[0]);
}

static void method_newdel_1598( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IMonitorSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IMonitorSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IMonitorSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IMonitorSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IMonitorSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IMonitorSvc> -------------------------------
void __SmartIF_IMonitorSvc__db_datamem(Reflex::Class*);
void __SmartIF_IMonitorSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IMonitorSvc__datamem_bld(&__SmartIF_IMonitorSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IMonitorSvc__funcmem_bld(&__SmartIF_IMonitorSvc__db_funcmem);
void __SmartIF_IMonitorSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IMonitorSvc>"), typeid(::SmartIF<IMonitorSvc>), sizeof(::SmartIF<IMonitorSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6263, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20051), Reflex::Literal("SmartIF"), constructor_6264, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20970), Reflex::Literal("SmartIF"), constructor_6265, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6266, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1598, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IMonitorSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IMonitorSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IMonitorSvc> -------------------
void __SmartIF_IMonitorSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20051, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IMonitorSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IMonitorSvc> -------------------
void __SmartIF_IMonitorSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20051), Reflex::Literal("operator IMonitorSvc*"), converter_6268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20051), Reflex::Literal("operator->"), operator_6269, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19850), Reflex::Literal("operator*"), operator_6270, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20051), Reflex::Literal("get"), method_6271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20971), Reflex::Literal("pRef"), method_6272, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20051), Reflex::Literal("reset"), method_6273, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20972, type_19539), Reflex::Literal("operator="), operator_6274, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20972, type_20970), Reflex::Literal("operator="), operator_6275, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class IAlgContextSvc -------------------------------
static  void operator_7287( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAlgContextSvc*)o)->operator=)(*(const ::IAlgContextSvc*)arg[0]);
  else   (((::IAlgContextSvc*)o)->operator=)(*(const ::IAlgContextSvc*)arg[0]);
}

static  void method_7290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAlgContextSvc*)o)->interfaceID)();
  else   (((::IAlgContextSvc*)o)->interfaceID)();
}

static  void method_7291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgContextSvc*)o)->setCurrentAlg)((::IAlgorithm*)arg[0]));
  else   (((::IAlgContextSvc*)o)->setCurrentAlg)((::IAlgorithm*)arg[0]);
}

static  void method_7292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgContextSvc*)o)->unSetCurrentAlg)((::IAlgorithm*)arg[0]));
  else   (((::IAlgContextSvc*)o)->unSetCurrentAlg)((::IAlgorithm*)arg[0]);
}

static  void method_7293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IAlgContextSvc*)o)->currentAlg)());
  else   (((const ::IAlgContextSvc*)o)->currentAlg)();
}

static  void method_7294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IAlgContextSvc*)o)->algorithms)();
  else   (((const ::IAlgContextSvc*)o)->algorithms)();
}

static void method_x72( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAlgContextSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAlgContextSvc -------------------------------
void __IAlgContextSvc_db_datamem(Reflex::Class*);
void __IAlgContextSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAlgContextSvc_datamem_bld(&__IAlgContextSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IAlgContextSvc_funcmem_bld(&__IAlgContextSvc_db_funcmem);
void __IAlgContextSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAlgContextSvc"), typeid(::IAlgContextSvc), sizeof(::IAlgContextSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IAlgContextSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_3179, Reflex::Literal("IAlgContextSvc::Algorithms"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20975, type_24215), Reflex::Literal("operator="), operator_7287, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x72, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAlgContextSvc_funcmem_bld);
}

//------Delayed data member builder for class IAlgContextSvc -------------------
void __IAlgContextSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAlgContextSvc -------------------
void __IAlgContextSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7290, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20948), Reflex::Literal("setCurrentAlg"), method_7291, 0, "a", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20948), Reflex::Literal("unSetCurrentAlg"), method_7292, 0, "a", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20948), Reflex::Literal("currentAlg"), method_7293, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24216), Reflex::Literal("algorithms"), method_7294, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class SmartIF<IAlgContextSvc> -------------------------------
static void constructor_6277( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAlgContextSvc>();
  else ::new(mem) ::SmartIF<IAlgContextSvc>();
}

static void constructor_6278( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAlgContextSvc>((::IAlgContextSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IAlgContextSvc>((::IAlgContextSvc*)arg[0]);
}

static void constructor_6279( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IAlgContextSvc>(*(const ::SmartIF<IAlgContextSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IAlgContextSvc>(*(const ::SmartIF<IAlgContextSvc>*)arg[0]);
}

static void destructor_6280(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IAlgContextSvc>*)o)->::SmartIF<IAlgContextSvc>::~SmartIF)();
}
static  void method_6281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IAlgContextSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IAlgContextSvc>*)o)->isValid)();
}

static  void converter_6282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAlgContextSvc>*)o)->operator IAlgContextSvc*)());
  else   (((const ::SmartIF<IAlgContextSvc>*)o)->operator IAlgContextSvc*)();
}

static  void operator_6283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAlgContextSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IAlgContextSvc>*)o)->operator->)();
}

static  void operator_6284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IAlgContextSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IAlgContextSvc>*)o)->operator*)();
}

static  void method_6285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IAlgContextSvc>*)o)->get)());
  else   (((const ::SmartIF<IAlgContextSvc>*)o)->get)();
}

static  void method_6286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAlgContextSvc>*)o)->pRef)();
  else   (((::SmartIF<IAlgContextSvc>*)o)->pRef)();
}

static  void method_6287( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IAlgContextSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IAlgContextSvc>*)o)->reset)((::IAlgContextSvc*)arg[0]);
  }
}

static  void operator_6288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAlgContextSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IAlgContextSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IAlgContextSvc>*)o)->operator=)(*(const ::SmartIF<IAlgContextSvc>*)arg[0]);
  else   (((::SmartIF<IAlgContextSvc>*)o)->operator=)(*(const ::SmartIF<IAlgContextSvc>*)arg[0]);
}

static void method_newdel_1599( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgContextSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgContextSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgContextSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgContextSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IAlgContextSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IAlgContextSvc> -------------------------------
void __SmartIF_IAlgContextSvc__db_datamem(Reflex::Class*);
void __SmartIF_IAlgContextSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IAlgContextSvc__datamem_bld(&__SmartIF_IAlgContextSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IAlgContextSvc__funcmem_bld(&__SmartIF_IAlgContextSvc__db_funcmem);
void __SmartIF_IAlgContextSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IAlgContextSvc>"), typeid(::SmartIF<IAlgContextSvc>), sizeof(::SmartIF<IAlgContextSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6277, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20973), Reflex::Literal("SmartIF"), constructor_6278, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20974), Reflex::Literal("SmartIF"), constructor_6279, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6280, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1599, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IAlgContextSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IAlgContextSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IAlgContextSvc> -------------------
void __SmartIF_IAlgContextSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20973, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IAlgContextSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IAlgContextSvc> -------------------
void __SmartIF_IAlgContextSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20973), Reflex::Literal("operator IAlgContextSvc*"), converter_6282, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20973), Reflex::Literal("operator->"), operator_6283, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20975), Reflex::Literal("operator*"), operator_6284, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20973), Reflex::Literal("get"), method_6285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20976), Reflex::Literal("pRef"), method_6286, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20973), Reflex::Literal("reset"), method_6287, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20977, type_19539), Reflex::Literal("operator="), operator_6288, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20977, type_20974), Reflex::Literal("operator="), operator_6289, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class IToolSvc -------------------------------
static  void operator_7396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IToolSvc*)o)->operator=)(*(const ::IToolSvc*)arg[0]);
  else   (((::IToolSvc*)o)->operator=)(*(const ::IToolSvc*)arg[0]);
}

static  void method_7399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IToolSvc*)o)->interfaceID)();
  else   (((::IToolSvc*)o)->interfaceID)();
}

static  void method_7400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::InterfaceID*)arg[1],
      *(::IAlgTool**)arg[2]));
    else     (((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::InterfaceID*)arg[1],
      *(::IAlgTool**)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::InterfaceID*)arg[1],
      *(::IAlgTool**)arg[2],
      (const ::IInterface*)arg[3]));
    else     (((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::InterfaceID*)arg[1],
      *(::IAlgTool**)arg[2],
      (const ::IInterface*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::InterfaceID*)arg[1],
      *(::IAlgTool**)arg[2],
      (const ::IInterface*)arg[3],
      *(bool*)arg[4]));
    else     (((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::InterfaceID*)arg[1],
      *(::IAlgTool**)arg[2],
      (const ::IInterface*)arg[3],
      *(bool*)arg[4]);
  }
}

static  void method_7401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::InterfaceID*)arg[2],
      *(::IAlgTool**)arg[3]));
    else     (((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::InterfaceID*)arg[2],
      *(::IAlgTool**)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::InterfaceID*)arg[2],
      *(::IAlgTool**)arg[3],
      (const ::IInterface*)arg[4]));
    else     (((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::InterfaceID*)arg[2],
      *(::IAlgTool**)arg[3],
      (const ::IInterface*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::InterfaceID*)arg[2],
      *(::IAlgTool**)arg[3],
      (const ::IInterface*)arg[4],
      *(bool*)arg[5]));
    else     (((::IToolSvc*)o)->retrieve)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::InterfaceID*)arg[2],
      *(::IAlgTool**)arg[3],
      (const ::IInterface*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_7402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::IToolSvc*)o)->getInstances)(*(const ::std::string*)arg[0]));
  else   (((::IToolSvc*)o)->getInstances)(*(const ::std::string*)arg[0]);
}

static  void method_7403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IToolSvc*)o)->releaseTool)((::IAlgTool*)arg[0]));
  else   (((::IToolSvc*)o)->releaseTool)((::IAlgTool*)arg[0]);
}

static  void method_7404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IToolSvc*)o)->registerObserver)((::IToolSvc::Observer*)arg[0]);
}

static  void method_7405( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IToolSvc*)o)->unRegisterObserver)((::IToolSvc::Observer*)arg[0]);
}

static void destructor_7406(void*, void * o, const std::vector<void*>&, void *) {
(((::IToolSvc*)o)->::IToolSvc::~IToolSvc)();
}
static void method_x74( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IToolSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IToolSvc -------------------------------
void __IToolSvc_db_datamem(Reflex::Class*);
void __IToolSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IToolSvc_datamem_bld(&__IToolSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IToolSvc_funcmem_bld(&__IToolSvc_db_funcmem);
void __IToolSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IToolSvc"), typeid(::IToolSvc), sizeof(::IToolSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IToolSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20979, type_24274), Reflex::Literal("operator="), operator_7396, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IToolSvc"), destructor_7406, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x74, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IToolSvc_funcmem_bld);
}

//------Delayed data member builder for class IToolSvc -------------------
void __IToolSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IToolSvc -------------------
void __IToolSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7399, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_7851, type_24275, type_19852, type_4206), Reflex::Literal("retrieve"), method_7400, 0, "type;iid;tool;parent=0;createIf=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_7851, type_24275, type_19852, type_4206), Reflex::Literal("retrieve"), method_7401, 0, "type;name;iid;tool;parent=0;createIf=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165, type_6134), Reflex::Literal("getInstances"), method_7402, 0, "toolType", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24276), Reflex::Literal("releaseTool"), method_7403, 0, "tool", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24277), Reflex::Literal("registerObserver"), method_7404, 0, "obs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24277), Reflex::Literal("unRegisterObserver"), method_7405, 0, "obs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartIF<IToolSvc> -------------------------------
static void constructor_6291( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IToolSvc>();
  else ::new(mem) ::SmartIF<IToolSvc>();
}

static void constructor_6292( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IToolSvc>((::IToolSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IToolSvc>((::IToolSvc*)arg[0]);
}

static void constructor_6293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IToolSvc>(*(const ::SmartIF<IToolSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IToolSvc>(*(const ::SmartIF<IToolSvc>*)arg[0]);
}

static void destructor_6294(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IToolSvc>*)o)->::SmartIF<IToolSvc>::~SmartIF)();
}
static  void method_6295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IToolSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IToolSvc>*)o)->isValid)();
}

static  void converter_6296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IToolSvc>*)o)->operator IToolSvc*)());
  else   (((const ::SmartIF<IToolSvc>*)o)->operator IToolSvc*)();
}

static  void operator_6297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IToolSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IToolSvc>*)o)->operator->)();
}

static  void operator_6298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IToolSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IToolSvc>*)o)->operator*)();
}

static  void method_6299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IToolSvc>*)o)->get)());
  else   (((const ::SmartIF<IToolSvc>*)o)->get)();
}

static  void method_6300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IToolSvc>*)o)->pRef)();
  else   (((::SmartIF<IToolSvc>*)o)->pRef)();
}

static  void method_6301( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IToolSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IToolSvc>*)o)->reset)((::IToolSvc*)arg[0]);
  }
}

static  void operator_6302( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IToolSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IToolSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IToolSvc>*)o)->operator=)(*(const ::SmartIF<IToolSvc>*)arg[0]);
  else   (((::SmartIF<IToolSvc>*)o)->operator=)(*(const ::SmartIF<IToolSvc>*)arg[0]);
}

static void method_newdel_1600( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IToolSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IToolSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IToolSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IToolSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IToolSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IToolSvc> -------------------------------
void __SmartIF_IToolSvc__db_datamem(Reflex::Class*);
void __SmartIF_IToolSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IToolSvc__datamem_bld(&__SmartIF_IToolSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IToolSvc__funcmem_bld(&__SmartIF_IToolSvc__db_funcmem);
void __SmartIF_IToolSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IToolSvc>"), typeid(::SmartIF<IToolSvc>), sizeof(::SmartIF<IToolSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6291, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20050), Reflex::Literal("SmartIF"), constructor_6292, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20978), Reflex::Literal("SmartIF"), constructor_6293, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6294, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1600, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IToolSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IToolSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IToolSvc> -------------------
void __SmartIF_IToolSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20050, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IToolSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IToolSvc> -------------------
void __SmartIF_IToolSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20050), Reflex::Literal("operator IToolSvc*"), converter_6296, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20050), Reflex::Literal("operator->"), operator_6297, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20979), Reflex::Literal("operator*"), operator_6298, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20050), Reflex::Literal("get"), method_6299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20980), Reflex::Literal("pRef"), method_6300, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20050), Reflex::Literal("reset"), method_6301, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20981, type_19539), Reflex::Literal("operator="), operator_6302, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20981, type_20978), Reflex::Literal("operator="), operator_6303, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IExceptionSvc> -------------------------------
static void constructor_6305( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IExceptionSvc>();
  else ::new(mem) ::SmartIF<IExceptionSvc>();
}

static void constructor_6306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IExceptionSvc>((::IExceptionSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IExceptionSvc>((::IExceptionSvc*)arg[0]);
}

static void constructor_6307( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IExceptionSvc>(*(const ::SmartIF<IExceptionSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IExceptionSvc>(*(const ::SmartIF<IExceptionSvc>*)arg[0]);
}

static void destructor_6308(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IExceptionSvc>*)o)->::SmartIF<IExceptionSvc>::~SmartIF)();
}
static  void method_6309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IExceptionSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IExceptionSvc>*)o)->isValid)();
}

static  void converter_6310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IExceptionSvc>*)o)->operator IExceptionSvc*)());
  else   (((const ::SmartIF<IExceptionSvc>*)o)->operator IExceptionSvc*)();
}

static  void operator_6311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IExceptionSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IExceptionSvc>*)o)->operator->)();
}

static  void operator_6312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IExceptionSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IExceptionSvc>*)o)->operator*)();
}

static  void method_6313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IExceptionSvc>*)o)->get)());
  else   (((const ::SmartIF<IExceptionSvc>*)o)->get)();
}

static  void method_6314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IExceptionSvc>*)o)->pRef)();
  else   (((::SmartIF<IExceptionSvc>*)o)->pRef)();
}

static  void method_6315( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IExceptionSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IExceptionSvc>*)o)->reset)((::IExceptionSvc*)arg[0]);
  }
}

static  void operator_6316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IExceptionSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IExceptionSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IExceptionSvc>*)o)->operator=)(*(const ::SmartIF<IExceptionSvc>*)arg[0]);
  else   (((::SmartIF<IExceptionSvc>*)o)->operator=)(*(const ::SmartIF<IExceptionSvc>*)arg[0]);
}

static void method_newdel_1601( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IExceptionSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IExceptionSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IExceptionSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IExceptionSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IExceptionSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IExceptionSvc> -------------------------------
void __SmartIF_IExceptionSvc__db_datamem(Reflex::Class*);
void __SmartIF_IExceptionSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IExceptionSvc__datamem_bld(&__SmartIF_IExceptionSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IExceptionSvc__funcmem_bld(&__SmartIF_IExceptionSvc__db_funcmem);
void __SmartIF_IExceptionSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IExceptionSvc>"), typeid(::SmartIF<IExceptionSvc>), sizeof(::SmartIF<IExceptionSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6305, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20982), Reflex::Literal("SmartIF"), constructor_6306, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20983), Reflex::Literal("SmartIF"), constructor_6307, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6308, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1601, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IExceptionSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IExceptionSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IExceptionSvc> -------------------
void __SmartIF_IExceptionSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20982, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IExceptionSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IExceptionSvc> -------------------
void __SmartIF_IExceptionSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20982), Reflex::Literal("operator IExceptionSvc*"), converter_6310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20982), Reflex::Literal("operator->"), operator_6311, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19758), Reflex::Literal("operator*"), operator_6312, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20982), Reflex::Literal("get"), method_6313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20984), Reflex::Literal("pRef"), method_6314, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20982), Reflex::Literal("reset"), method_6315, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20985, type_19539), Reflex::Literal("operator="), operator_6316, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20985, type_20983), Reflex::Literal("operator="), operator_6317, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class IRndmGenSvc -------------------------------
static  void operator_6564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRndmGenSvc*)o)->operator=)(*(const ::IRndmGenSvc*)arg[0]);
  else   (((::IRndmGenSvc*)o)->operator=)(*(const ::IRndmGenSvc*)arg[0]);
}

static  void method_6567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRndmGenSvc*)o)->interfaceID)();
  else   (((::IRndmGenSvc*)o)->interfaceID)();
}

static  void method_6568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IRndmGenSvc*)o)->engine)());
  else   (((::IRndmGenSvc*)o)->engine)();
}

static  void method_6569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IRndmGenSvc*)o)->generator)(*(const ::IRndmGen::Param*)arg[0],
    *(::IRndmGen**)arg[1]));
  else   (((::IRndmGenSvc*)o)->generator)(*(const ::IRndmGen::Param*)arg[0],
    *(::IRndmGen**)arg[1]);
}

static void destructor_6570(void*, void * o, const std::vector<void*>&, void *) {
(((::IRndmGenSvc*)o)->::IRndmGenSvc::~IRndmGenSvc)();
}
static void method_x77( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IRndmGenSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IRndmGenSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IRndmGenSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IRndmGenSvc -------------------------------
void __IRndmGenSvc_db_datamem(Reflex::Class*);
void __IRndmGenSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IRndmGenSvc_datamem_bld(&__IRndmGenSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IRndmGenSvc_funcmem_bld(&__IRndmGenSvc_db_funcmem);
void __IRndmGenSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IRndmGenSvc"), typeid(::IRndmGenSvc), sizeof(::IRndmGenSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::IRndmGenSvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20988, type_21097), Reflex::Literal("operator="), operator_6564, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRndmGenSvc"), destructor_6570, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x77, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IRndmGenSvc_funcmem_bld);
}

//------Delayed data member builder for class IRndmGenSvc -------------------
void __IRndmGenSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRndmGenSvc -------------------
void __IRndmGenSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6567, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21098), Reflex::Literal("engine"), method_6568, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_21099, type_21100), Reflex::Literal("generator"), method_6569, 0, "par;refpGen", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartIF<IRndmGenSvc> -------------------------------
static void constructor_6319( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IRndmGenSvc>();
  else ::new(mem) ::SmartIF<IRndmGenSvc>();
}

static void constructor_6320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IRndmGenSvc>((::IRndmGenSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IRndmGenSvc>((::IRndmGenSvc*)arg[0]);
}

static void constructor_6321( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IRndmGenSvc>(*(const ::SmartIF<IRndmGenSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IRndmGenSvc>(*(const ::SmartIF<IRndmGenSvc>*)arg[0]);
}

static void destructor_6322(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IRndmGenSvc>*)o)->::SmartIF<IRndmGenSvc>::~SmartIF)();
}
static  void method_6323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IRndmGenSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IRndmGenSvc>*)o)->isValid)();
}

static  void converter_6324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IRndmGenSvc>*)o)->operator IRndmGenSvc*)());
  else   (((const ::SmartIF<IRndmGenSvc>*)o)->operator IRndmGenSvc*)();
}

static  void operator_6325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IRndmGenSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IRndmGenSvc>*)o)->operator->)();
}

static  void operator_6326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IRndmGenSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IRndmGenSvc>*)o)->operator*)();
}

static  void method_6327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IRndmGenSvc>*)o)->get)());
  else   (((const ::SmartIF<IRndmGenSvc>*)o)->get)();
}

static  void method_6328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IRndmGenSvc>*)o)->pRef)();
  else   (((::SmartIF<IRndmGenSvc>*)o)->pRef)();
}

static  void method_6329( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IRndmGenSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IRndmGenSvc>*)o)->reset)((::IRndmGenSvc*)arg[0]);
  }
}

static  void operator_6330( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IRndmGenSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IRndmGenSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IRndmGenSvc>*)o)->operator=)(*(const ::SmartIF<IRndmGenSvc>*)arg[0]);
  else   (((::SmartIF<IRndmGenSvc>*)o)->operator=)(*(const ::SmartIF<IRndmGenSvc>*)arg[0]);
}

static void method_newdel_1602( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IRndmGenSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IRndmGenSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IRndmGenSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IRndmGenSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IRndmGenSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IRndmGenSvc> -------------------------------
void __SmartIF_IRndmGenSvc__db_datamem(Reflex::Class*);
void __SmartIF_IRndmGenSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IRndmGenSvc__datamem_bld(&__SmartIF_IRndmGenSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IRndmGenSvc__funcmem_bld(&__SmartIF_IRndmGenSvc__db_funcmem);
void __SmartIF_IRndmGenSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IRndmGenSvc>"), typeid(::SmartIF<IRndmGenSvc>), sizeof(::SmartIF<IRndmGenSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6319, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20986), Reflex::Literal("SmartIF"), constructor_6320, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20987), Reflex::Literal("SmartIF"), constructor_6321, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6322, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1602, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IRndmGenSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IRndmGenSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IRndmGenSvc> -------------------
void __SmartIF_IRndmGenSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20986, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IRndmGenSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IRndmGenSvc> -------------------
void __SmartIF_IRndmGenSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20986), Reflex::Literal("operator IRndmGenSvc*"), converter_6324, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20986), Reflex::Literal("operator->"), operator_6325, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20988), Reflex::Literal("operator*"), operator_6326, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20986), Reflex::Literal("get"), method_6327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20989), Reflex::Literal("pRef"), method_6328, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20986), Reflex::Literal("reset"), method_6329, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20990, type_19539), Reflex::Literal("operator="), operator_6330, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20990, type_20987), Reflex::Literal("operator="), operator_6331, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class IChronoStatSvc -------------------------------
static  void operator_7473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IChronoStatSvc*)o)->operator=)(*(const ::IChronoStatSvc*)arg[0]);
  else   (((::IChronoStatSvc*)o)->operator=)(*(const ::IChronoStatSvc*)arg[0]);
}

static  void method_7476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IChronoStatSvc*)o)->interfaceID)();
  else   (((::IChronoStatSvc*)o)->interfaceID)();
}

static void method_x79( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IService,IChronoSvc,IStatSvc>")), ::Reflex::BaseOffset< ::IChronoStatSvc,::extend_interfaces3<IService,IChronoSvc,IStatSvc> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IChronoStatSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IChronoStatSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IChronoStatSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IChronoSvc")), ::Reflex::BaseOffset< ::IChronoStatSvc,::IChronoSvc >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStatSvc")), ::Reflex::BaseOffset< ::IChronoStatSvc,::IStatSvc >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IChronoStatSvc -------------------------------
void __IChronoStatSvc_db_datamem(Reflex::Class*);
void __IChronoStatSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IChronoStatSvc_datamem_bld(&__IChronoStatSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IChronoStatSvc_funcmem_bld(&__IChronoStatSvc_db_funcmem);
void __IChronoStatSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IChronoStatSvc"), typeid(::IChronoStatSvc), sizeof(::IChronoStatSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_666, ::Reflex::BaseOffset< ::IChronoStatSvc, ::extend_interfaces3<IService,IChronoSvc,IStatSvc> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20993, type_24310), Reflex::Literal("operator="), operator_7473, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x79, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IChronoStatSvc_funcmem_bld);
}

//------Delayed data member builder for class IChronoStatSvc -------------------
void __IChronoStatSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IChronoStatSvc -------------------
void __IChronoStatSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7476, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SmartIF<IChronoStatSvc> -------------------------------
static void constructor_6333( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IChronoStatSvc>();
  else ::new(mem) ::SmartIF<IChronoStatSvc>();
}

static void constructor_6334( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IChronoStatSvc>((::IChronoStatSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IChronoStatSvc>((::IChronoStatSvc*)arg[0]);
}

static void constructor_6335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IChronoStatSvc>(*(const ::SmartIF<IChronoStatSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IChronoStatSvc>(*(const ::SmartIF<IChronoStatSvc>*)arg[0]);
}

static void destructor_6336(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IChronoStatSvc>*)o)->::SmartIF<IChronoStatSvc>::~SmartIF)();
}
static  void method_6337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IChronoStatSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IChronoStatSvc>*)o)->isValid)();
}

static  void converter_6338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IChronoStatSvc>*)o)->operator IChronoStatSvc*)());
  else   (((const ::SmartIF<IChronoStatSvc>*)o)->operator IChronoStatSvc*)();
}

static  void operator_6339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IChronoStatSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IChronoStatSvc>*)o)->operator->)();
}

static  void operator_6340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IChronoStatSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IChronoStatSvc>*)o)->operator*)();
}

static  void method_6341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IChronoStatSvc>*)o)->get)());
  else   (((const ::SmartIF<IChronoStatSvc>*)o)->get)();
}

static  void method_6342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IChronoStatSvc>*)o)->pRef)();
  else   (((::SmartIF<IChronoStatSvc>*)o)->pRef)();
}

static  void method_6343( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IChronoStatSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IChronoStatSvc>*)o)->reset)((::IChronoStatSvc*)arg[0]);
  }
}

static  void operator_6344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IChronoStatSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IChronoStatSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IChronoStatSvc>*)o)->operator=)(*(const ::SmartIF<IChronoStatSvc>*)arg[0]);
  else   (((::SmartIF<IChronoStatSvc>*)o)->operator=)(*(const ::SmartIF<IChronoStatSvc>*)arg[0]);
}

static void method_newdel_1603( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IChronoStatSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IChronoStatSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IChronoStatSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IChronoStatSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IChronoStatSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IChronoStatSvc> -------------------------------
void __SmartIF_IChronoStatSvc__db_datamem(Reflex::Class*);
void __SmartIF_IChronoStatSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IChronoStatSvc__datamem_bld(&__SmartIF_IChronoStatSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IChronoStatSvc__funcmem_bld(&__SmartIF_IChronoStatSvc__db_funcmem);
void __SmartIF_IChronoStatSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IChronoStatSvc>"), typeid(::SmartIF<IChronoStatSvc>), sizeof(::SmartIF<IChronoStatSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6333, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20991), Reflex::Literal("SmartIF"), constructor_6334, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20992), Reflex::Literal("SmartIF"), constructor_6335, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6336, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1603, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IChronoStatSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IChronoStatSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IChronoStatSvc> -------------------
void __SmartIF_IChronoStatSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20991, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IChronoStatSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IChronoStatSvc> -------------------
void __SmartIF_IChronoStatSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20991), Reflex::Literal("operator IChronoStatSvc*"), converter_6338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20991), Reflex::Literal("operator->"), operator_6339, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20993), Reflex::Literal("operator*"), operator_6340, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20991), Reflex::Literal("get"), method_6341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20994), Reflex::Literal("pRef"), method_6342, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20991), Reflex::Literal("reset"), method_6343, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20995, type_19539), Reflex::Literal("operator="), operator_6344, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20995, type_20992), Reflex::Literal("operator="), operator_6345, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<INTupleSvc> -------------------------------
static void constructor_6347( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<INTupleSvc>();
  else ::new(mem) ::SmartIF<INTupleSvc>();
}

static void constructor_6348( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<INTupleSvc>((::INTupleSvc*)arg[0]);
  else ::new(mem) ::SmartIF<INTupleSvc>((::INTupleSvc*)arg[0]);
}

static void constructor_6349( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<INTupleSvc>(*(const ::SmartIF<INTupleSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<INTupleSvc>(*(const ::SmartIF<INTupleSvc>*)arg[0]);
}

static void destructor_6350(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<INTupleSvc>*)o)->::SmartIF<INTupleSvc>::~SmartIF)();
}
static  void method_6351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<INTupleSvc>*)o)->isValid)());
  else   (((const ::SmartIF<INTupleSvc>*)o)->isValid)();
}

static  void converter_6352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<INTupleSvc>*)o)->operator INTupleSvc*)());
  else   (((const ::SmartIF<INTupleSvc>*)o)->operator INTupleSvc*)();
}

static  void operator_6353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<INTupleSvc>*)o)->operator->)());
  else   (((const ::SmartIF<INTupleSvc>*)o)->operator->)();
}

static  void operator_6354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<INTupleSvc>*)o)->operator*)();
  else   (((const ::SmartIF<INTupleSvc>*)o)->operator*)();
}

static  void method_6355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<INTupleSvc>*)o)->get)());
  else   (((const ::SmartIF<INTupleSvc>*)o)->get)();
}

static  void method_6356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<INTupleSvc>*)o)->pRef)();
  else   (((::SmartIF<INTupleSvc>*)o)->pRef)();
}

static  void method_6357( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<INTupleSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<INTupleSvc>*)o)->reset)((::INTupleSvc*)arg[0]);
  }
}

static  void operator_6358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<INTupleSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<INTupleSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<INTupleSvc>*)o)->operator=)(*(const ::SmartIF<INTupleSvc>*)arg[0]);
  else   (((::SmartIF<INTupleSvc>*)o)->operator=)(*(const ::SmartIF<INTupleSvc>*)arg[0]);
}

static void method_newdel_1604( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<INTupleSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<INTupleSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<INTupleSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<INTupleSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<INTupleSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<INTupleSvc> -------------------------------
void __SmartIF_INTupleSvc__db_datamem(Reflex::Class*);
void __SmartIF_INTupleSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_INTupleSvc__datamem_bld(&__SmartIF_INTupleSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_INTupleSvc__funcmem_bld(&__SmartIF_INTupleSvc__db_funcmem);
void __SmartIF_INTupleSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<INTupleSvc>"), typeid(::SmartIF<INTupleSvc>), sizeof(::SmartIF<INTupleSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6347, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20996), Reflex::Literal("SmartIF"), constructor_6348, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20997), Reflex::Literal("SmartIF"), constructor_6349, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6350, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1604, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_INTupleSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_INTupleSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<INTupleSvc> -------------------
void __SmartIF_INTupleSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20996, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_INTupleSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<INTupleSvc> -------------------
void __SmartIF_INTupleSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20996), Reflex::Literal("operator INTupleSvc*"), converter_6352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20996), Reflex::Literal("operator->"), operator_6353, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19858), Reflex::Literal("operator*"), operator_6354, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20996), Reflex::Literal("get"), method_6355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20998), Reflex::Literal("pRef"), method_6356, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_20996), Reflex::Literal("reset"), method_6357, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20999, type_19539), Reflex::Literal("operator="), operator_6358, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20999, type_20997), Reflex::Literal("operator="), operator_6359, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class IHistogramSvc -------------------------------
static  void operator_7858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IHistogramSvc*)o)->operator=)(*(const ::IHistogramSvc*)arg[0]);
  else   (((::IHistogramSvc*)o)->operator=)(*(const ::IHistogramSvc*)arg[0]);
}

static  void method_7861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IHistogramSvc*)o)->interfaceID)();
  else   (((::IHistogramSvc*)o)->interfaceID)();
}

static  void method_7862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->histogramFactory)());
  else   (((::IHistogramSvc*)o)->histogramFactory)();
}

static  void method_7863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4]);
}

static  void method_7864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]);
}

static  void method_7865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]);
}

static  void method_7866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]);
}

static  void method_7867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5]);
}

static  void method_7868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(const ::std::string*)arg[5]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static  void method_7869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 6 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]);
  }
}

static  void method_7870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 6 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]);
  }
}

static  void method_7871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 6 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]);
  }
}

static  void method_7872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 6 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(const ::std::string*)arg[6]);
  }
}

static  void method_7873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(const ::std::string*)arg[7]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(const ::std::string*)arg[7]);
  }
}

static  void method_7874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static  void method_7875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]));
    else     (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static  void method_7876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static  void method_7877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]));
    else     (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
      *(int*)arg[1],
      *(const ::std::string*)arg[2],
      *(int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static  void method_7878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2]);
}

static  void method_7879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2]);
}

static  void method_7884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(int*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(int*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7]);
}

static  void method_7889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(int*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(int*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7]);
}

static  void method_7894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]));
  else   (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8]);
}

static  void method_7898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2],
    *(::std::vector<double>*)arg[3]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2],
    *(::std::vector<double>*)arg[3]);
}

static  void method_7904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->bookProf)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->bookProf)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(int*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(int*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(int*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(int*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10]);
}

static  void method_7909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]);
}

static  void method_7910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]);
}

static  void method_7911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]);
}

static  void method_7912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(int*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(int*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11]);
}

static  void method_7913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::std::vector<double>*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4]);
}

static  void method_7914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]);
}

static  void method_7915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]);
}

static  void method_7916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]);
}

static  void method_7917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]));
  else   (((::IHistogramSvc*)o)->book)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(const ::std::string*)arg[2],
    *(::std::vector<double>*)arg[3],
    *(::std::vector<double>*)arg[4],
    *(::std::vector<double>*)arg[5]);
}

static  void method_7918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    (::AIDA::IBaseHistogram*)arg[1]));
  else   (((::IHistogramSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    (::AIDA::IBaseHistogram*)arg[1]);
}

static  void method_7919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]));
  else   (((::IHistogramSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]);
}

static  void method_7920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]));
  else   (((::IHistogramSvc*)o)->registerObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]);
}

static  void method_7921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]));
  else   (((::IHistogramSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]);
}

static  void method_7922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->registerObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]));
  else   (((::IHistogramSvc*)o)->registerObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]);
}

static  void method_7923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]));
  else   (((::IHistogramSvc*)o)->registerObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]);
}

static  void method_7924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->registerObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]));
  else   (((::IHistogramSvc*)o)->registerObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    (::AIDA::IBaseHistogram*)arg[2]);
}

static  void method_7925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->unregisterObject)((::AIDA::IBaseHistogram*)arg[0]));
  else   (((::IHistogramSvc*)o)->unregisterObject)((::AIDA::IBaseHistogram*)arg[0]);
}

static  void method_7926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->unregisterObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IHistogramSvc*)o)->unregisterObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->unregisterObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1]));
  else   (((::IHistogramSvc*)o)->unregisterObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1]);
}

static  void method_7928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7929( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7933( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram1D**)arg[1]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram1D**)arg[1]);
}

static  void method_7934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile1D**)arg[1]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile1D**)arg[1]);
}

static  void method_7935( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram2D**)arg[1]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram2D**)arg[1]);
}

static  void method_7936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile2D**)arg[1]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile2D**)arg[1]);
}

static  void method_7937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram3D**)arg[1]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram3D**)arg[1]);
}

static  void method_7938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->retrieveObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram1D**)arg[1]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram1D**)arg[1]);
}

static  void method_7969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile1D**)arg[1]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile1D**)arg[1]);
}

static  void method_7970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram2D**)arg[1]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram2D**)arg[1]);
}

static  void method_7971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile2D**)arg[1]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IProfile2D**)arg[1]);
}

static  void method_7972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram3D**)arg[1]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(::AIDA::IHistogram3D**)arg[1]);
}

static  void method_7973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_7995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_7996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_7997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(const ::std::string*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_7998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_7999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_8000( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_8001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_8002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::DataObject*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_8003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram1D**)arg[2]);
}

static  void method_8004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile1D**)arg[2]);
}

static  void method_8005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram2D**)arg[2]);
}

static  void method_8006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IProfile2D**)arg[2]);
}

static  void method_8007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]));
  else   (((::IHistogramSvc*)o)->findObject)((::AIDA::IBaseHistogram*)arg[0],
    *(int*)arg[1],
    *(::AIDA::IHistogram3D**)arg[2]);
}

static  void method_8008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::IHistogramSvc*)o)->print)((::AIDA::IBaseHistogram*)arg[0]);
    else     (((const ::IHistogramSvc*)o)->print)((::AIDA::IBaseHistogram*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::IHistogramSvc*)o)->print)((::AIDA::IBaseHistogram*)arg[0],
      *(::std::ostream*)arg[1]);
    else     (((const ::IHistogramSvc*)o)->print)((::AIDA::IBaseHistogram*)arg[0],
      *(::std::ostream*)arg[1]);
  }
}

static  void method_8009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::IHistogramSvc*)o)->write)((::AIDA::IBaseHistogram*)arg[0]);
    else     (((const ::IHistogramSvc*)o)->write)((::AIDA::IBaseHistogram*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::IHistogramSvc*)o)->write)((::AIDA::IBaseHistogram*)arg[0],
      *(::std::ostream*)arg[1]);
    else     (((const ::IHistogramSvc*)o)->write)((::AIDA::IBaseHistogram*)arg[0],
      *(::std::ostream*)arg[1]);
  }
}

static  void method_8010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IHistogramSvc*)o)->write)((::AIDA::IBaseHistogram*)arg[0],
    (const char*)arg[1]));
  else   (((const ::IHistogramSvc*)o)->write)((::AIDA::IBaseHistogram*)arg[0],
    (const char*)arg[1]);
}

static  void method_8011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->createPath)(*(const ::std::string*)arg[0]));
  else   (((::IHistogramSvc*)o)->createPath)(*(const ::std::string*)arg[0]);
}

static  void method_8012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistogramSvc*)o)->createDirectory)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IHistogramSvc*)o)->createDirectory)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void destructor_8013(void*, void * o, const std::vector<void*>&, void *) {
(((::IHistogramSvc*)o)->::IHistogramSvc::~IHistogramSvc)();
}
static void method_x82( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IDataProviderSvc")), ::Reflex::BaseOffset< ::IHistogramSvc,::IDataProviderSvc >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IHistogramSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IHistogramSvc -------------------------------
void __IHistogramSvc_db_datamem(Reflex::Class*);
void __IHistogramSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IHistogramSvc_datamem_bld(&__IHistogramSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IHistogramSvc_funcmem_bld(&__IHistogramSvc_db_funcmem);
void __IHistogramSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IHistogramSvc"), typeid(::IHistogramSvc), sizeof(::IHistogramSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1414, ::Reflex::BaseOffset< ::IHistogramSvc, ::IDataProviderSvc >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21002, type_24380), Reflex::Literal("operator="), operator_7858, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IHistogramSvc"), destructor_8013, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x82, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IHistogramSvc_funcmem_bld);
}

//------Delayed data member builder for class IHistogramSvc -------------------
void __IHistogramSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IHistogramSvc -------------------
void __IHistogramSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7861, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24381), Reflex::Literal("histogramFactory"), method_7862, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_6134, type_6134, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7863, 0, "fullPath;title;binsX;lowX;highX", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_6134, type_6134, type_6134, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7864, 0, "dirPath;relPath;title;binsX;lowX;highX", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_6134, type_142, type_6134, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7865, 0, "dirPath;hID;title;binsX;lowX;highX", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_19429, type_6134, type_6134, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7866, 0, "pParent;relPath;title;binsX;lowX;highX", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_19429, type_142, type_6134, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7867, 0, "pParent;hID;title;binsX;lowX;highX", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_6134, type_142, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7868, 0, "fullPath;title;binsX;lowX;highX;opt=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_6134, type_6134, type_142, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7869, 0, "dirPath;relPath;title;binsX;lowX;highX;opt=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_142, type_6134, type_142, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7870, 0, "dirPath;hID;title;binsX;lowX;highX;opt=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_19429, type_6134, type_6134, type_142, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7871, 0, "pParent;relPath;title;binsX;lowX;highX;opt=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_19429, type_142, type_6134, type_142, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7872, 0, "pParent;hID;title;binsX;lowX;highX;opt=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_6134, type_142, type_2603, type_2603, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7873, 0, "fullPath;title;binsX;lowX;highX;lowY;highY;opt=\"s\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_6134, type_6134, type_142, type_2603, type_2603, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7874, 0, "dirPath;relPath;title;binsX;lowX;highX;lowY;highY;opt=\"s\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_142, type_6134, type_142, type_2603, type_2603, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7875, 0, "dirPath;hID;title;binsX;lowX;highX;lowY;highY;opt=\"s\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_19429, type_6134, type_6134, type_142, type_2603, type_2603, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7876, 0, "pParent;relPath;title;binsX;lowX;highX;lowY;highY;opt=\"s\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_19429, type_142, type_6134, type_142, type_2603, type_2603, type_2603, type_2603, type_6134), Reflex::Literal("bookProf"), method_7877, 0, "pParent;hID;title;binsX;lowX;highX;lowY;highY;opt=\"s\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_6134, type_6134, type_3167), Reflex::Literal("book"), method_7878, 0, "fullPath;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_6134, type_6134, type_6134, type_3167), Reflex::Literal("book"), method_7879, 0, "dirPath;relPath;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_6134, type_142, type_6134, type_3167), Reflex::Literal("book"), method_7880, 0, "dirPath;hID;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_19429, type_6134, type_6134, type_3167), Reflex::Literal("book"), method_7881, 0, "pParent;relPath;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24382, type_19429, type_142, type_6134, type_3167), Reflex::Literal("book"), method_7882, 0, "pParent;hID;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_6134, type_3167), Reflex::Literal("bookProf"), method_7883, 0, "fullPath;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_6134, type_6134, type_3167), Reflex::Literal("bookProf"), method_7884, 0, "dirPath;relPath;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_6134, type_142, type_6134, type_3167), Reflex::Literal("bookProf"), method_7885, 0, "dirPath;hID;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_19429, type_6134, type_6134, type_3167), Reflex::Literal("bookProf"), method_7886, 0, "pParent;relPath;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24383, type_19429, type_142, type_6134, type_3167), Reflex::Literal("bookProf"), method_7887, 0, "pParent;hID;title;edges", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7888, 0, "fullPath;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_6134, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7889, 0, "dirPath;relPath;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_6134, type_142, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7890, 0, "dirPath;hID;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_19429, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7891, 0, "pParent;relPath;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_19429, type_142, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7892, 0, "pParent;hID;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("bookProf"), method_7893, 0, "fullPath;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_6134, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("bookProf"), method_7894, 0, "dirPath;relPath;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_6134, type_142, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("bookProf"), method_7895, 0, "dirPath;hID;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_19429, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("bookProf"), method_7896, 0, "pParent;relPath;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_19429, type_142, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("bookProf"), method_7897, 0, "pParent;hID;title;binsX;lowX;highX;binsY;lowY;highY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_6134, type_6134, type_3167, type_3167), Reflex::Literal("book"), method_7898, 0, "fullPath;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_6134, type_6134, type_6134, type_3167, type_3167), Reflex::Literal("book"), method_7899, 0, "dirPath;relPath;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_6134, type_142, type_6134, type_3167, type_3167), Reflex::Literal("book"), method_7900, 0, "dirPath;hID;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_19429, type_6134, type_6134, type_3167, type_3167), Reflex::Literal("book"), method_7901, 0, "pParent;relPath;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24384, type_19429, type_142, type_6134, type_3167, type_3167), Reflex::Literal("book"), method_7902, 0, "pParent;hID;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_6134, type_6134, type_3167, type_3167), Reflex::Literal("bookProf"), method_7903, 0, "fullPath;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_6134, type_6134, type_6134, type_3167, type_3167), Reflex::Literal("bookProf"), method_7904, 0, "dirPath;relPath;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_6134, type_142, type_6134, type_3167, type_3167), Reflex::Literal("bookProf"), method_7905, 0, "dirPath;hID;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_19429, type_6134, type_6134, type_3167, type_3167), Reflex::Literal("bookProf"), method_7906, 0, "pParent;relPath;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24385, type_19429, type_142, type_6134, type_3167, type_3167), Reflex::Literal("bookProf"), method_7907, 0, "pParent;hID;title;edgesX;edgesY", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7908, 0, "fullPath;title;binsX;lowX;highX;binsY;lowY;highY;binsZ;lowZ;highZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_6134, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7909, 0, "dirPath;relPath;title;binsX;lowX;highX;binsY;lowY;highY;binsZ;lowZ;highZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_6134, type_142, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7910, 0, "dirPath;hID;title;binsX;lowX;highX;binsY;lowY;highY;binsZ;lowZ;highZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_19429, type_6134, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7911, 0, "pParent;relPath;title;binsX;lowX;highX;binsY;lowY;highY;binsZ;lowZ;highZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_19429, type_142, type_6134, type_142, type_2603, type_2603, type_142, type_2603, type_2603, type_142, type_2603, type_2603), Reflex::Literal("book"), method_7912, 0, "pParent;hID;title;binsX;lowX;highX;binsY;lowY;highY;binsZ;lowZ;highZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_6134, type_6134, type_3167, type_3167, type_3167), Reflex::Literal("book"), method_7913, 0, "fullPath;title;edgesX;edgesY;edgesZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_6134, type_6134, type_6134, type_3167, type_3167, type_3167), Reflex::Literal("book"), method_7914, 0, "dirPath;relPath;title;edgesX;edgesY;edgesZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_6134, type_142, type_6134, type_3167, type_3167, type_3167), Reflex::Literal("book"), method_7915, 0, "dirPath;hID;title;edgesX;edgesY;edgesZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_19429, type_6134, type_6134, type_3167, type_3167, type_3167), Reflex::Literal("book"), method_7916, 0, "pParent;relPath;title;edgesX;edgesY;edgesZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24386, type_19429, type_142, type_6134, type_3167, type_3167, type_3167), Reflex::Literal("book"), method_7917, 0, "pParent;hID;title;edgesX;edgesY;edgesZ", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24387), Reflex::Literal("registerObject"), method_7918, 0, "fullPath;hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24387), Reflex::Literal("registerObject"), method_7919, 0, "parentPath;objPath;hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24387), Reflex::Literal("registerObject"), method_7920, 0, "parentPath;item;hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24387), Reflex::Literal("registerObject"), method_7921, 0, "parentObj;objPath;hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24387), Reflex::Literal("registerObject"), method_7922, 0, "parentObj;objPath;hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24387), Reflex::Literal("registerObject"), method_7923, 0, "parentObj;item;hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24387), Reflex::Literal("registerObject"), method_7924, 0, "parentObj;item;hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387), Reflex::Literal("unregisterObject"), method_7925, 0, "hObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134), Reflex::Literal("unregisterObject"), method_7926, 0, "hObj;objectPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142), Reflex::Literal("unregisterObject"), method_7927, 0, "hObj;item", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24388), Reflex::Literal("retrieveObject"), method_7928, 0, "pDirectory;path;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24389), Reflex::Literal("retrieveObject"), method_7929, 0, "pDirectory;path;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24390), Reflex::Literal("retrieveObject"), method_7930, 0, "pDirectory;path;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24391), Reflex::Literal("retrieveObject"), method_7931, 0, "pDirectory;path;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24392), Reflex::Literal("retrieveObject"), method_7932, 0, "pDirectory;path;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24388), Reflex::Literal("retrieveObject"), method_7933, 0, "fullPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24389), Reflex::Literal("retrieveObject"), method_7934, 0, "fullPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24390), Reflex::Literal("retrieveObject"), method_7935, 0, "fullPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24391), Reflex::Literal("retrieveObject"), method_7936, 0, "fullPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24392), Reflex::Literal("retrieveObject"), method_7937, 0, "fullPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24388), Reflex::Literal("retrieveObject"), method_7938, 0, "parentPath;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24389), Reflex::Literal("retrieveObject"), method_7939, 0, "parentPath;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24390), Reflex::Literal("retrieveObject"), method_7940, 0, "parentPath;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24391), Reflex::Literal("retrieveObject"), method_7941, 0, "parentPath;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24392), Reflex::Literal("retrieveObject"), method_7942, 0, "parentPath;objPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24388), Reflex::Literal("retrieveObject"), method_7943, 0, "parentPath;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24389), Reflex::Literal("retrieveObject"), method_7944, 0, "parentPath;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24390), Reflex::Literal("retrieveObject"), method_7945, 0, "parentPath;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24391), Reflex::Literal("retrieveObject"), method_7946, 0, "parentPath;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24392), Reflex::Literal("retrieveObject"), method_7947, 0, "parentPath;item;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24388), Reflex::Literal("retrieveObject"), method_7948, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24389), Reflex::Literal("retrieveObject"), method_7949, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24390), Reflex::Literal("retrieveObject"), method_7950, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24391), Reflex::Literal("retrieveObject"), method_7951, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24392), Reflex::Literal("retrieveObject"), method_7952, 0, "parentObj;objPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24388), Reflex::Literal("retrieveObject"), method_7953, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24389), Reflex::Literal("retrieveObject"), method_7954, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24390), Reflex::Literal("retrieveObject"), method_7955, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24391), Reflex::Literal("retrieveObject"), method_7956, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24392), Reflex::Literal("retrieveObject"), method_7957, 0, "parentObj;objPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24388), Reflex::Literal("retrieveObject"), method_7958, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24389), Reflex::Literal("retrieveObject"), method_7959, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24390), Reflex::Literal("retrieveObject"), method_7960, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24391), Reflex::Literal("retrieveObject"), method_7961, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24392), Reflex::Literal("retrieveObject"), method_7962, 0, "parentObj;item;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24388), Reflex::Literal("retrieveObject"), method_7963, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24389), Reflex::Literal("retrieveObject"), method_7964, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24390), Reflex::Literal("retrieveObject"), method_7965, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24391), Reflex::Literal("retrieveObject"), method_7966, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24392), Reflex::Literal("retrieveObject"), method_7967, 0, "parentObj;item;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24388), Reflex::Literal("findObject"), method_7968, 0, "fullPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24389), Reflex::Literal("findObject"), method_7969, 0, "fullPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24390), Reflex::Literal("findObject"), method_7970, 0, "fullPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24391), Reflex::Literal("findObject"), method_7971, 0, "fullPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_24392), Reflex::Literal("findObject"), method_7972, 0, "fullPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24388), Reflex::Literal("findObject"), method_7973, 0, "pDirectory;path;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24389), Reflex::Literal("findObject"), method_7974, 0, "pDirectory;path;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24390), Reflex::Literal("findObject"), method_7975, 0, "pDirectory;path;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24391), Reflex::Literal("findObject"), method_7976, 0, "pDirectory;path;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_24392), Reflex::Literal("findObject"), method_7977, 0, "pDirectory;path;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24388), Reflex::Literal("findObject"), method_7978, 0, "parentPath;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24389), Reflex::Literal("findObject"), method_7979, 0, "parentPath;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24390), Reflex::Literal("findObject"), method_7980, 0, "parentPath;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24391), Reflex::Literal("findObject"), method_7981, 0, "parentPath;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_24392), Reflex::Literal("findObject"), method_7982, 0, "parentPath;objPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24388), Reflex::Literal("findObject"), method_7983, 0, "parentPath;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24389), Reflex::Literal("findObject"), method_7984, 0, "parentPath;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24390), Reflex::Literal("findObject"), method_7985, 0, "parentPath;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24391), Reflex::Literal("findObject"), method_7986, 0, "parentPath;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_24392), Reflex::Literal("findObject"), method_7987, 0, "parentPath;item;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24388), Reflex::Literal("findObject"), method_7988, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24389), Reflex::Literal("findObject"), method_7989, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24390), Reflex::Literal("findObject"), method_7990, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24391), Reflex::Literal("findObject"), method_7991, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_24392), Reflex::Literal("findObject"), method_7992, 0, "parentObj;objPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24388), Reflex::Literal("findObject"), method_7993, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24389), Reflex::Literal("findObject"), method_7994, 0, "parentObj;objPath;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24390), Reflex::Literal("findObject"), method_7995, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24391), Reflex::Literal("findObject"), method_7996, 0, "parentObj;objPath;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_6134, type_24392), Reflex::Literal("findObject"), method_7997, 0, "parentObj;objPath;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24388), Reflex::Literal("findObject"), method_7998, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24389), Reflex::Literal("findObject"), method_7999, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24390), Reflex::Literal("findObject"), method_8000, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24391), Reflex::Literal("findObject"), method_8001, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_142, type_24392), Reflex::Literal("findObject"), method_8002, 0, "parentObj;item;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24388), Reflex::Literal("findObject"), method_8003, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24389), Reflex::Literal("findObject"), method_8004, 0, "parentObj;item;h1dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24390), Reflex::Literal("findObject"), method_8005, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24391), Reflex::Literal("findObject"), method_8006, 0, "parentObj;item;h2dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24387, type_142, type_24392), Reflex::Literal("findObject"), method_8007, 0, "parentObj;item;h3dObj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7831, type_24387, type_7831), Reflex::Literal("print"), method_8008, 0, "h;s=std::cout", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7831, type_24387, type_7831), Reflex::Literal("write"), method_8009, 0, "h;s=std::cout", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_24387, type_4095), Reflex::Literal("write"), method_8010, 0, "h;file_name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429, type_6134), Reflex::Literal("createPath"), method_8011, 0, "newPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429, type_6134, type_6134), Reflex::Literal("createDirectory"), method_8012, 0, "parentDir;subDir", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartIF<IHistogramSvc> -------------------------------
static void constructor_6361( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IHistogramSvc>();
  else ::new(mem) ::SmartIF<IHistogramSvc>();
}

static void constructor_6362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IHistogramSvc>((::IHistogramSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IHistogramSvc>((::IHistogramSvc*)arg[0]);
}

static void constructor_6363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IHistogramSvc>(*(const ::SmartIF<IHistogramSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IHistogramSvc>(*(const ::SmartIF<IHistogramSvc>*)arg[0]);
}

static void destructor_6364(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IHistogramSvc>*)o)->::SmartIF<IHistogramSvc>::~SmartIF)();
}
static  void method_6365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IHistogramSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IHistogramSvc>*)o)->isValid)();
}

static  void converter_6366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IHistogramSvc>*)o)->operator IHistogramSvc*)());
  else   (((const ::SmartIF<IHistogramSvc>*)o)->operator IHistogramSvc*)();
}

static  void operator_6367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IHistogramSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IHistogramSvc>*)o)->operator->)();
}

static  void operator_6368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IHistogramSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IHistogramSvc>*)o)->operator*)();
}

static  void method_6369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IHistogramSvc>*)o)->get)());
  else   (((const ::SmartIF<IHistogramSvc>*)o)->get)();
}

static  void method_6370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IHistogramSvc>*)o)->pRef)();
  else   (((::SmartIF<IHistogramSvc>*)o)->pRef)();
}

static  void method_6371( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IHistogramSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IHistogramSvc>*)o)->reset)((::IHistogramSvc*)arg[0]);
  }
}

static  void operator_6372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IHistogramSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IHistogramSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IHistogramSvc>*)o)->operator=)(*(const ::SmartIF<IHistogramSvc>*)arg[0]);
  else   (((::SmartIF<IHistogramSvc>*)o)->operator=)(*(const ::SmartIF<IHistogramSvc>*)arg[0]);
}

static void method_newdel_1605( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IHistogramSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IHistogramSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IHistogramSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IHistogramSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IHistogramSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IHistogramSvc> -------------------------------
void __SmartIF_IHistogramSvc__db_datamem(Reflex::Class*);
void __SmartIF_IHistogramSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IHistogramSvc__datamem_bld(&__SmartIF_IHistogramSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IHistogramSvc__funcmem_bld(&__SmartIF_IHistogramSvc__db_funcmem);
void __SmartIF_IHistogramSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IHistogramSvc>"), typeid(::SmartIF<IHistogramSvc>), sizeof(::SmartIF<IHistogramSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6361, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21000), Reflex::Literal("SmartIF"), constructor_6362, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21001), Reflex::Literal("SmartIF"), constructor_6363, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6364, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1605, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IHistogramSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IHistogramSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IHistogramSvc> -------------------
void __SmartIF_IHistogramSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_21000, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IHistogramSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IHistogramSvc> -------------------
void __SmartIF_IHistogramSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21000), Reflex::Literal("operator IHistogramSvc*"), converter_6366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21000), Reflex::Literal("operator->"), operator_6367, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21002), Reflex::Literal("operator*"), operator_6368, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21000), Reflex::Literal("get"), method_6369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21003), Reflex::Literal("pRef"), method_6370, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_21000), Reflex::Literal("reset"), method_6371, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21004, type_19539), Reflex::Literal("operator="), operator_6372, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21004, type_21001), Reflex::Literal("operator="), operator_6373, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IConversionSvc> -------------------------------
static void constructor_6375( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IConversionSvc>();
  else ::new(mem) ::SmartIF<IConversionSvc>();
}

static void constructor_6376( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IConversionSvc>((::IConversionSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IConversionSvc>((::IConversionSvc*)arg[0]);
}

static void constructor_6377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IConversionSvc>(*(const ::SmartIF<IConversionSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IConversionSvc>(*(const ::SmartIF<IConversionSvc>*)arg[0]);
}

static void destructor_6378(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IConversionSvc>*)o)->::SmartIF<IConversionSvc>::~SmartIF)();
}
static  void method_6379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IConversionSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IConversionSvc>*)o)->isValid)();
}

static  void converter_6380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IConversionSvc>*)o)->operator IConversionSvc*)());
  else   (((const ::SmartIF<IConversionSvc>*)o)->operator IConversionSvc*)();
}

static  void operator_6381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IConversionSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IConversionSvc>*)o)->operator->)();
}

static  void operator_6382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IConversionSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IConversionSvc>*)o)->operator*)();
}

static  void method_6383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IConversionSvc>*)o)->get)());
  else   (((const ::SmartIF<IConversionSvc>*)o)->get)();
}

static  void method_6384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IConversionSvc>*)o)->pRef)();
  else   (((::SmartIF<IConversionSvc>*)o)->pRef)();
}

static  void method_6385( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IConversionSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IConversionSvc>*)o)->reset)((::IConversionSvc*)arg[0]);
  }
}

static  void operator_6386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IConversionSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IConversionSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IConversionSvc>*)o)->operator=)(*(const ::SmartIF<IConversionSvc>*)arg[0]);
  else   (((::SmartIF<IConversionSvc>*)o)->operator=)(*(const ::SmartIF<IConversionSvc>*)arg[0]);
}

static void method_newdel_1606( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IConversionSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IConversionSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IConversionSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IConversionSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IConversionSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IConversionSvc> -------------------------------
void __SmartIF_IConversionSvc__db_datamem(Reflex::Class*);
void __SmartIF_IConversionSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IConversionSvc__datamem_bld(&__SmartIF_IConversionSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IConversionSvc__funcmem_bld(&__SmartIF_IConversionSvc__db_funcmem);
void __SmartIF_IConversionSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IConversionSvc>"), typeid(::SmartIF<IConversionSvc>), sizeof(::SmartIF<IConversionSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6375, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19841), Reflex::Literal("SmartIF"), constructor_6376, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21005), Reflex::Literal("SmartIF"), constructor_6377, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6378, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1606, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IConversionSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IConversionSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IConversionSvc> -------------------
void __SmartIF_IConversionSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19841, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IConversionSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IConversionSvc> -------------------
void __SmartIF_IConversionSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19841), Reflex::Literal("operator IConversionSvc*"), converter_6380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19841), Reflex::Literal("operator->"), operator_6381, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19832), Reflex::Literal("operator*"), operator_6382, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19841), Reflex::Literal("get"), method_6383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19842), Reflex::Literal("pRef"), method_6384, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19841), Reflex::Literal("reset"), method_6385, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19938, type_19539), Reflex::Literal("operator="), operator_6386, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19938, type_21005), Reflex::Literal("operator="), operator_6387, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IDataProviderSvc> -------------------------------
static void constructor_6389( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IDataProviderSvc>();
  else ::new(mem) ::SmartIF<IDataProviderSvc>();
}

static void constructor_6390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IDataProviderSvc>((::IDataProviderSvc*)arg[0]);
  else ::new(mem) ::SmartIF<IDataProviderSvc>((::IDataProviderSvc*)arg[0]);
}

static void constructor_6391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IDataProviderSvc>(*(const ::SmartIF<IDataProviderSvc>*)arg[0]);
  else ::new(mem) ::SmartIF<IDataProviderSvc>(*(const ::SmartIF<IDataProviderSvc>*)arg[0]);
}

static void destructor_6392(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IDataProviderSvc>*)o)->::SmartIF<IDataProviderSvc>::~SmartIF)();
}
static  void method_6393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IDataProviderSvc>*)o)->isValid)());
  else   (((const ::SmartIF<IDataProviderSvc>*)o)->isValid)();
}

static  void converter_6394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IDataProviderSvc>*)o)->operator IDataProviderSvc*)());
  else   (((const ::SmartIF<IDataProviderSvc>*)o)->operator IDataProviderSvc*)();
}

static  void operator_6395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IDataProviderSvc>*)o)->operator->)());
  else   (((const ::SmartIF<IDataProviderSvc>*)o)->operator->)();
}

static  void operator_6396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IDataProviderSvc>*)o)->operator*)();
  else   (((const ::SmartIF<IDataProviderSvc>*)o)->operator*)();
}

static  void method_6397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IDataProviderSvc>*)o)->get)());
  else   (((const ::SmartIF<IDataProviderSvc>*)o)->get)();
}

static  void method_6398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IDataProviderSvc>*)o)->pRef)();
  else   (((::SmartIF<IDataProviderSvc>*)o)->pRef)();
}

static  void method_6399( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IDataProviderSvc>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IDataProviderSvc>*)o)->reset)((::IDataProviderSvc*)arg[0]);
  }
}

static  void operator_6400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IDataProviderSvc>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IDataProviderSvc>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IDataProviderSvc>*)o)->operator=)(*(const ::SmartIF<IDataProviderSvc>*)arg[0]);
  else   (((::SmartIF<IDataProviderSvc>*)o)->operator=)(*(const ::SmartIF<IDataProviderSvc>*)arg[0]);
}

static void method_newdel_1607( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IDataProviderSvc> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IDataProviderSvc> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IDataProviderSvc> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IDataProviderSvc> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IDataProviderSvc> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IDataProviderSvc> -------------------------------
void __SmartIF_IDataProviderSvc__db_datamem(Reflex::Class*);
void __SmartIF_IDataProviderSvc__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IDataProviderSvc__datamem_bld(&__SmartIF_IDataProviderSvc__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IDataProviderSvc__funcmem_bld(&__SmartIF_IDataProviderSvc__db_funcmem);
void __SmartIF_IDataProviderSvc__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IDataProviderSvc>"), typeid(::SmartIF<IDataProviderSvc>), sizeof(::SmartIF<IDataProviderSvc>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6389, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780), Reflex::Literal("SmartIF"), constructor_6390, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21006), Reflex::Literal("SmartIF"), constructor_6391, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6392, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1607, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IDataProviderSvc__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IDataProviderSvc__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IDataProviderSvc> -------------------
void __SmartIF_IDataProviderSvc__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19780, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IDataProviderSvc_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IDataProviderSvc> -------------------
void __SmartIF_IDataProviderSvc__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("operator IDataProviderSvc*"), converter_6394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("operator->"), operator_6395, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20115), Reflex::Literal("operator*"), operator_6396, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("get"), method_6397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21007), Reflex::Literal("pRef"), method_6398, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19780), Reflex::Literal("reset"), method_6399, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937, type_19539), Reflex::Literal("operator="), operator_6400, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937, type_21006), Reflex::Literal("operator="), operator_6401, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartIF<IProperty> -------------------------------
static void constructor_6403( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IProperty>();
  else ::new(mem) ::SmartIF<IProperty>();
}

static void constructor_6404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IProperty>((::IProperty*)arg[0]);
  else ::new(mem) ::SmartIF<IProperty>((::IProperty*)arg[0]);
}

static void constructor_6405( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartIF<IProperty>(*(const ::SmartIF<IProperty>*)arg[0]);
  else ::new(mem) ::SmartIF<IProperty>(*(const ::SmartIF<IProperty>*)arg[0]);
}

static void destructor_6406(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartIF<IProperty>*)o)->::SmartIF<IProperty>::~SmartIF)();
}
static  void method_6407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartIF<IProperty>*)o)->isValid)());
  else   (((const ::SmartIF<IProperty>*)o)->isValid)();
}

static  void converter_6408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IProperty>*)o)->operator IProperty*)());
  else   (((const ::SmartIF<IProperty>*)o)->operator IProperty*)();
}

static  void operator_6409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IProperty>*)o)->operator->)());
  else   (((const ::SmartIF<IProperty>*)o)->operator->)();
}

static  void operator_6410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartIF<IProperty>*)o)->operator*)();
  else   (((const ::SmartIF<IProperty>*)o)->operator*)();
}

static  void method_6411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartIF<IProperty>*)o)->get)());
  else   (((const ::SmartIF<IProperty>*)o)->get)();
}

static  void method_6412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IProperty>*)o)->pRef)();
  else   (((::SmartIF<IProperty>*)o)->pRef)();
}

static  void method_6413( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::SmartIF<IProperty>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::SmartIF<IProperty>*)o)->reset)((::IProperty*)arg[0]);
  }
}

static  void operator_6414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IProperty>*)o)->operator=)((::IInterface*)arg[0]);
  else   (((::SmartIF<IProperty>*)o)->operator=)((::IInterface*)arg[0]);
}

static  void operator_6415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartIF<IProperty>*)o)->operator=)(*(const ::SmartIF<IProperty>*)arg[0]);
  else   (((::SmartIF<IProperty>*)o)->operator=)(*(const ::SmartIF<IProperty>*)arg[0]);
}

static void method_newdel_1609( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartIF<IProperty> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartIF<IProperty> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartIF<IProperty> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartIF<IProperty> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartIF<IProperty> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartIF<IProperty> -------------------------------
void __SmartIF_IProperty__db_datamem(Reflex::Class*);
void __SmartIF_IProperty__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartIF_IProperty__datamem_bld(&__SmartIF_IProperty__db_datamem);
Reflex::GenreflexMemberBuilder __SmartIF_IProperty__funcmem_bld(&__SmartIF_IProperty__db_funcmem);
void __SmartIF_IProperty__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartIF<IProperty>"), typeid(::SmartIF<IProperty>), sizeof(::SmartIF<IProperty>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartIF<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartIF"), constructor_6403, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19990), Reflex::Literal("SmartIF"), constructor_6404, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21008), Reflex::Literal("SmartIF"), constructor_6405, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartIF"), destructor_6406, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1609, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartIF_IProperty__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartIF_IProperty__funcmem_bld);
}

//------Delayed data member builder for class SmartIF<IProperty> -------------------
void __SmartIF_IProperty__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19990, Reflex::Literal("m_interface"), OffsetOf(__shadow__::__SmartIF_IProperty_, m_interface), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SmartIF<IProperty> -------------------
void __SmartIF_IProperty__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_6407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19990), Reflex::Literal("operator IProperty*"), converter_6408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19990), Reflex::Literal("operator->"), operator_6409, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21009), Reflex::Literal("operator*"), operator_6410, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19990), Reflex::Literal("get"), method_6411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21010), Reflex::Literal("pRef"), method_6412, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19990), Reflex::Literal("reset"), method_6413, 0, "ptr=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21011, type_19539), Reflex::Literal("operator="), operator_6414, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21011, type_21008), Reflex::Literal("operator="), operator_6415, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class SmartRefBase -------------------------------
static void destructor_6457(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefBase*)o)->::SmartRefBase::~SmartRefBase)();
}
static  void operator_6458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefBase*)o)->operator=)(*(const ::SmartRefBase*)arg[0]);
  else   (((::SmartRefBase*)o)->operator=)(*(const ::SmartRefBase*)arg[0]);
}

static void constructor_6459( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefBase(*(const ::SmartRefBase*)arg[0]);
  else ::new(mem) ::SmartRefBase(*(const ::SmartRefBase*)arg[0]);
}

static void constructor_6460( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefBase();
  else ::new(mem) ::SmartRefBase();
}

static  void method_6461( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefBase*)o)->accessData)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRefBase*)o)->accessData)((const ::ContainedObject*)arg[0]);
}

static  void method_6462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefBase*)o)->accessData)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRefBase*)o)->accessData)((const ::DataObject*)arg[0]);
}

static  void method_6463( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRefBase*)o)->isEqualEx)((const ::DataObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]));
  else   (((const ::SmartRefBase*)o)->isEqualEx)((const ::DataObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]);
}

static  void method_6464( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRefBase*)o)->isEqualEx)((const ::ContainedObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]));
  else   (((const ::SmartRefBase*)o)->isEqualEx)((const ::ContainedObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]);
}

static  void method_6465( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRefBase*)o)->isEqual)((const ::ContainedObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]));
  else   (((const ::SmartRefBase*)o)->isEqual)((const ::ContainedObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]);
}

static  void method_6466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRefBase*)o)->isEqual)((const ::DataObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]));
  else   (((const ::SmartRefBase*)o)->isEqual)((const ::DataObject*)arg[0],
    *(const ::SmartRefBase*)arg[1]);
}

static  void method_6467( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::SmartRefBase*)o)->writeObject)((const ::DataObject*)arg[0],
    *(::StreamBuffer*)arg[1]);
}

static  void method_6468( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::SmartRefBase*)o)->writeObject)((const ::ContainedObject*)arg[0],
    *(::StreamBuffer*)arg[1]);
}

static  void method_6469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefBase*)o)->readObject)((const ::DataObject*)arg[0],
    *(::StreamBuffer*)arg[1]));
  else   (((const ::SmartRefBase*)o)->readObject)((const ::DataObject*)arg[0],
    *(::StreamBuffer*)arg[1]);
}

static  void method_6470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefBase*)o)->readObject)((const ::ContainedObject*)arg[0],
    *(::StreamBuffer*)arg[1]));
  else   (((const ::SmartRefBase*)o)->readObject)((const ::ContainedObject*)arg[0],
    *(::StreamBuffer*)arg[1]);
}

static  void method_6471( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::SmartRefBase*)o)->setObjectType)((const ::ContainedObject*)arg[0]);
}

static  void method_6472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::SmartRefBase*)o)->setObjectType)((const ::DataObject*)arg[0]);
}

static  void method_6473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefBase*)o)->path)();
  else   (((const ::SmartRefBase*)o)->path)();
}

static  void method_6474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::SmartRefBase*)o)->objectType)());
  else   (((const ::SmartRefBase*)o)->objectType)();
}

static  void method_6475( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRefBase*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static void method_newdel_1617( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefBase >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefBase >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefBase >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefBase >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefBase >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRefBase -------------------------------
void __SmartRefBase_db_datamem(Reflex::Class*);
void __SmartRefBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefBase_datamem_bld(&__SmartRefBase_db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefBase_funcmem_bld(&__SmartRefBase_db_funcmem);
void __SmartRefBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefBase"), typeid(::SmartRefBase), sizeof(::SmartRefBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_79"), Reflex::Literal("DATAOBJECT=0;CONTAINEDOBJECT=1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefBase"), destructor_6457, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21017, type_21018), Reflex::Literal("operator="), operator_6458, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21018), Reflex::Literal("SmartRefBase"), constructor_6459, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefBase"), constructor_6460, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1617, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefBase_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefBase_funcmem_bld);
}

//------Delayed data member builder for class SmartRefBase -------------------
void __SmartRefBase_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_26, Reflex::Literal("m_hintID"), OffsetOf(__shadow__::__SmartRefBase, m_hintID), ::Reflex::PUBLIC | ::Reflex::MUTABLE)
  .AddDataMember(type_26, Reflex::Literal("m_linkID"), OffsetOf(__shadow__::__SmartRefBase, m_linkID), ::Reflex::PUBLIC | ::Reflex::MUTABLE)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefBase, m_data), ::Reflex::PUBLIC | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefBase, m_contd), ::Reflex::PUBLIC | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_26, Reflex::Literal("m_type"), OffsetOf(__shadow__::__SmartRefBase, m_type), ::Reflex::PUBLIC | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefBase -------------------
void __SmartRefBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234, type_10234), Reflex::Literal("accessData"), method_6461, 0, "typ", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19998, type_19998), Reflex::Literal("accessData"), method_6462, 0, "typ", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998, type_21018), Reflex::Literal("isEqualEx"), method_6463, 0, "pObj;c", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234, type_21018), Reflex::Literal("isEqualEx"), method_6464, 0, "pObj;c", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234, type_21018), Reflex::Literal("isEqual"), method_6465, 0, ";c", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998, type_21018), Reflex::Literal("isEqual"), method_6466, 0, ";c", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19998, type_5648), Reflex::Literal("writeObject"), method_6467, 0, "pObject;s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10234, type_5648), Reflex::Literal("writeObject"), method_6468, 0, "pObject;s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429, type_19998, type_5648), Reflex::Literal("readObject"), method_6469, 0, ";s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10166, type_10234, type_5648), Reflex::Literal("readObject"), method_6470, 0, ";s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10234), Reflex::Literal("setObjectType"), method_6471, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19998), Reflex::Literal("setObjectType"), method_6472, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("path"), method_6473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142), Reflex::Literal("objectType"), method_6474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_6475, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC);
}
//------Stub functions for class ICounterSvc -------------------------------
static  void operator_6519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ICounterSvc*)o)->operator=)(*(const ::ICounterSvc*)arg[0]);
  else   (((::ICounterSvc*)o)->operator=)(*(const ::ICounterSvc*)arg[0]);
}

static  void method_6522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ICounterSvc*)o)->interfaceID)();
  else   (((::ICounterSvc*)o)->interfaceID)();
}

static  void method_6523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::ICounterSvc*)o)->get)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::ICounterSvc*)o)->get)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<Stat>)((((const ::ICounterSvc*)o)->get)(*(const ::std::string*)arg[0]));
  else   (((const ::ICounterSvc*)o)->get)(*(const ::std::string*)arg[0]);
}

static  void method_6525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ICounterSvc*)o)->create)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::longlong*)arg[2],
    *(::StatEntity**)arg[3]));
  else   (((::ICounterSvc*)o)->create)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::longlong*)arg[2],
    *(::StatEntity**)arg[3]);
}

static  void method_6526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Stat)((((::ICounterSvc*)o)->create)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((::ICounterSvc*)o)->create)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Stat)((((::ICounterSvc*)o)->create)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::longlong*)arg[2]));
    else     (((::ICounterSvc*)o)->create)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::longlong*)arg[2]);
  }
}

static  void method_6527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ICounterSvc*)o)->remove)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::ICounterSvc*)o)->remove)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::ICounterSvc*)o)->remove)(*(const ::std::string*)arg[0]));
  else   (((::ICounterSvc*)o)->remove)(*(const ::std::string*)arg[0]);
}

static  void method_6529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ICounterSvc*)o)->print)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::ICounterSvc::Printout*)arg[2]));
  else   (((const ::ICounterSvc*)o)->print)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::ICounterSvc::Printout*)arg[2]);
}

static  void method_6530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ICounterSvc*)o)->print)(*(const ::std::string*)arg[0],
    *(::ICounterSvc::Printout*)arg[1]));
  else   (((const ::ICounterSvc*)o)->print)(*(const ::std::string*)arg[0],
    *(::ICounterSvc::Printout*)arg[1]);
}

static  void method_6531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ICounterSvc*)o)->print)((const ::StatEntity*)arg[0],
    *(::ICounterSvc::Printout*)arg[1]));
  else   (((const ::ICounterSvc*)o)->print)((const ::StatEntity*)arg[0],
    *(::ICounterSvc::Printout*)arg[1]);
}

static  void method_6532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ICounterSvc*)o)->print)(*(const ::Stat*)arg[0],
    *(::ICounterSvc::Printout*)arg[1]));
  else   (((const ::ICounterSvc*)o)->print)(*(const ::Stat*)arg[0],
    *(::ICounterSvc::Printout*)arg[1]);
}

static  void method_6533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ICounterSvc*)o)->print)(*(::ICounterSvc::Printout*)arg[0]));
  else   (((const ::ICounterSvc*)o)->print)(*(::ICounterSvc::Printout*)arg[0]);
}

static  void method_6534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::ICounterSvc*)o)->defaultPrintout)(*(::MsgStream*)arg[0],
    (const ::StatEntity*)arg[1]));
  else   (((const ::ICounterSvc*)o)->defaultPrintout)(*(::MsgStream*)arg[0],
    (const ::StatEntity*)arg[1]);
}

static void method_x88( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::ICounterSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ICounterSvc -------------------------------
void __ICounterSvc_db_datamem(Reflex::Class*);
void __ICounterSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ICounterSvc_datamem_bld(&__ICounterSvc_db_datamem);
Reflex::GenreflexMemberBuilder __ICounterSvc_funcmem_bld(&__ICounterSvc_db_funcmem);
void __ICounterSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ICounterSvc"), typeid(::ICounterSvc), sizeof(::ICounterSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::ICounterSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_2375, Reflex::Literal("ICounterSvc::Counter"))
  .AddTypedef(type_72, Reflex::Literal("ICounterSvc::CountObject"))
  .AddTypedef(type_3172, Reflex::Literal("ICounterSvc::Counters"))
  .AddEnum(Reflex::Literal("_98"), Reflex::Literal("COUNTER_NOT_PRESENT=2;COUNTER_EXISTS=4;COUNTER_REMOVED=3"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21088, type_21089), Reflex::Literal("operator="), operator_6519, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x88, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ICounterSvc_funcmem_bld);
}

//------Delayed data member builder for class ICounterSvc -------------------
void __ICounterSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ICounterSvc -------------------
void __ICounterSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6522, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19281, type_6134, type_6134), Reflex::Literal("get"), method_6523, 0, "group;name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3172, type_6134), Reflex::Literal("get"), method_6524, 0, "group", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_1498, type_21090), Reflex::Literal("create"), method_6525, 0, "group;name;initial_value;refpCounter", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_6134, type_6134, type_1498), Reflex::Literal("create"), method_6526, 0, "group;name;initial_value=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("remove"), method_6527, 0, "group;name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("remove"), method_6528, 0, "group", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_21091), Reflex::Literal("print"), method_6529, 0, "group;name;printer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_21091), Reflex::Literal("print"), method_6530, 0, "group;printer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19286, type_21091), Reflex::Literal("print"), method_6531, 0, "pCounter;printer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7458, type_21091), Reflex::Literal("print"), method_6532, 0, "pCounter;printer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_21091), Reflex::Literal("print"), method_6533, 0, "printer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7148, type_19286), Reflex::Literal("defaultPrintout"), method_6534, 0, "log;pCounter", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IDataManagerSvc -------------------------------
static  void operator_6536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataManagerSvc*)o)->operator=)(*(const ::IDataManagerSvc*)arg[0]);
  else   (((::IDataManagerSvc*)o)->operator=)(*(const ::IDataManagerSvc*)arg[0]);
}

static  void method_6539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IDataManagerSvc*)o)->interfaceID)();
  else   (((::IDataManagerSvc*)o)->interfaceID)();
}

static  void method_6540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (CLID)((((const ::IDataManagerSvc*)o)->rootCLID)());
  else   (((const ::IDataManagerSvc*)o)->rootCLID)();
}

static  void method_6541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::IDataManagerSvc*)o)->rootName)());
  else   (((const ::IDataManagerSvc*)o)->rootName)();
}

static  void method_6542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->setDataLoader)((::IConversionSvc*)arg[0]));
  else   (((::IDataManagerSvc*)o)->setDataLoader)((::IConversionSvc*)arg[0]);
}

static  void method_6543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->objectParent)((const ::DataObject*)arg[0],
    *(::IRegistry**)arg[1]));
  else   (((::IDataManagerSvc*)o)->objectParent)((const ::DataObject*)arg[0],
    *(::IRegistry**)arg[1]);
}

static  void method_6544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->objectParent)((const ::IRegistry*)arg[0],
    *(::IRegistry**)arg[1]));
  else   (((::IDataManagerSvc*)o)->objectParent)((const ::IRegistry*)arg[0],
    *(::IRegistry**)arg[1]);
}

static  void method_6545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->objectLeaves)((const ::DataObject*)arg[0],
    *(::std::vector<IRegistry*>*)arg[1]));
  else   (((::IDataManagerSvc*)o)->objectLeaves)((const ::DataObject*)arg[0],
    *(::std::vector<IRegistry*>*)arg[1]);
}

static  void method_6546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->objectLeaves)((const ::IRegistry*)arg[0],
    *(::std::vector<IRegistry*>*)arg[1]));
  else   (((::IDataManagerSvc*)o)->objectLeaves)((const ::IRegistry*)arg[0],
    *(::std::vector<IRegistry*>*)arg[1]);
}

static  void method_6547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->clearSubTree)(*(const ::std::string*)arg[0]));
  else   (((::IDataManagerSvc*)o)->clearSubTree)(*(const ::std::string*)arg[0]);
}

static  void method_6548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->clearSubTree)((::DataObject*)arg[0]));
  else   (((::IDataManagerSvc*)o)->clearSubTree)((::DataObject*)arg[0]);
}

static  void method_6549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->clearStore)());
  else   (((::IDataManagerSvc*)o)->clearStore)();
}

static  void method_6550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->traverseSubTree)(*(const ::std::string*)arg[0],
    (::IDataStoreAgent*)arg[1]));
  else   (((::IDataManagerSvc*)o)->traverseSubTree)(*(const ::std::string*)arg[0],
    (::IDataStoreAgent*)arg[1]);
}

static  void method_6551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->traverseSubTree)((::DataObject*)arg[0],
    (::IDataStoreAgent*)arg[1]));
  else   (((::IDataManagerSvc*)o)->traverseSubTree)((::DataObject*)arg[0],
    (::IDataStoreAgent*)arg[1]);
}

static  void method_6552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->traverseTree)((::IDataStoreAgent*)arg[0]));
  else   (((::IDataManagerSvc*)o)->traverseTree)((::IDataStoreAgent*)arg[0]);
}

static  void method_6553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->setRoot)(*(const ::std::string*)arg[0],
    (::DataObject*)arg[1]));
  else   (((::IDataManagerSvc*)o)->setRoot)(*(const ::std::string*)arg[0],
    (::DataObject*)arg[1]);
}

static  void method_6554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->setRoot)(*(const ::std::string*)arg[0],
    (::IOpaqueAddress*)arg[1]));
  else   (((::IDataManagerSvc*)o)->setRoot)(*(const ::std::string*)arg[0],
    (::IOpaqueAddress*)arg[1]);
}

static  void method_6555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->registerAddress)(*(const ::std::string*)arg[0],
    (::IOpaqueAddress*)arg[1]));
  else   (((::IDataManagerSvc*)o)->registerAddress)(*(const ::std::string*)arg[0],
    (::IOpaqueAddress*)arg[1]);
}

static  void method_6556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->registerAddress)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::IOpaqueAddress*)arg[2]));
  else   (((::IDataManagerSvc*)o)->registerAddress)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1],
    (::IOpaqueAddress*)arg[2]);
}

static  void method_6557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->registerAddress)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    (::IOpaqueAddress*)arg[2]));
  else   (((::IDataManagerSvc*)o)->registerAddress)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1],
    (::IOpaqueAddress*)arg[2]);
}

static  void method_6558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->unregisterAddress)(*(const ::std::string*)arg[0]));
  else   (((::IDataManagerSvc*)o)->unregisterAddress)(*(const ::std::string*)arg[0]);
}

static  void method_6559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->unregisterAddress)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataManagerSvc*)o)->unregisterAddress)((::DataObject*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IDataManagerSvc*)o)->unregisterAddress)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IDataManagerSvc*)o)->unregisterAddress)((::IRegistry*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void destructor_6561(void*, void * o, const std::vector<void*>&, void *) {
(((::IDataManagerSvc*)o)->::IDataManagerSvc::~IDataManagerSvc)();
}
static void method_x89( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IDataManagerSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IDataManagerSvc -------------------------------
void __IDataManagerSvc_db_datamem(Reflex::Class*);
void __IDataManagerSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IDataManagerSvc_datamem_bld(&__IDataManagerSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IDataManagerSvc_funcmem_bld(&__IDataManagerSvc_db_funcmem);
void __IDataManagerSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IDataManagerSvc"), typeid(::IDataManagerSvc), sizeof(::IDataManagerSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IDataManagerSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21092, type_21093), Reflex::Literal("operator="), operator_6536, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDataManagerSvc"), destructor_6561, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x89, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IDataManagerSvc_funcmem_bld);
}

//------Delayed data member builder for class IDataManagerSvc -------------------
void __IDataManagerSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IDataManagerSvc -------------------
void __IDataManagerSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6539, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1849), Reflex::Literal("rootCLID"), method_6540, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("rootName"), method_6541, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19841), Reflex::Literal("setDataLoader"), method_6542, 0, "svc", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19998, type_11168), Reflex::Literal("objectParent"), method_6543, 0, "pObject;refpParent", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_21094, type_11168), Reflex::Literal("objectParent"), method_6544, 0, "pRegistry;refpParent", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19998, type_21095), Reflex::Literal("objectLeaves"), method_6545, 0, "pObject;refLeaves", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_21094, type_21095), Reflex::Literal("objectLeaves"), method_6546, 0, "pRegistry;refLeaves", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("clearSubTree"), method_6547, 0, "sub_path", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429), Reflex::Literal("clearSubTree"), method_6548, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("clearStore"), method_6549, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_21096), Reflex::Literal("traverseSubTree"), method_6550, 0, "sub_path;pAgent", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_21096), Reflex::Literal("traverseSubTree"), method_6551, 0, "pObject;pAgent", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_21096), Reflex::Literal("traverseTree"), method_6552, 0, "pAgent", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19429), Reflex::Literal("setRoot"), method_6553, 0, "root_name;pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19941), Reflex::Literal("setRoot"), method_6554, 0, "root_path;pRootAddr", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19941), Reflex::Literal("registerAddress"), method_6555, 0, "fullPath;pAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134, type_19941), Reflex::Literal("registerAddress"), method_6556, 0, "parentObj;objectPath;pAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134, type_19941), Reflex::Literal("registerAddress"), method_6557, 0, "parentObj;objectPath;pAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("unregisterAddress"), method_6558, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19429, type_6134), Reflex::Literal("unregisterAddress"), method_6559, 0, "pParent;objPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_10115, type_6134), Reflex::Literal("unregisterAddress"), method_6560, 0, "pParent;objPath", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IPartPropSvc -------------------------------
static  void operator_6571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IPartPropSvc*)o)->operator=)(*(const ::IPartPropSvc*)arg[0]);
  else   (((::IPartPropSvc*)o)->operator=)(*(const ::IPartPropSvc*)arg[0]);
}

static  void method_6574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IPartPropSvc*)o)->interfaceID)();
  else   (((::IPartPropSvc*)o)->interfaceID)();
}

static  void method_6575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IPartPropSvc*)o)->PDT)());
  else   (((::IPartPropSvc*)o)->PDT)();
}

static  void method_6576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IPartPropSvc*)o)->setUnknownParticleHandler)((::HepPDT::ProcessUnknownID*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void destructor_6577(void*, void * o, const std::vector<void*>&, void *) {
(((::IPartPropSvc*)o)->::IPartPropSvc::~IPartPropSvc)();
}
static void method_x90( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IPartPropSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IPartPropSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IPartPropSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IPartPropSvc -------------------------------
void __IPartPropSvc_db_datamem(Reflex::Class*);
void __IPartPropSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IPartPropSvc_datamem_bld(&__IPartPropSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IPartPropSvc_funcmem_bld(&__IPartPropSvc_db_funcmem);
void __IPartPropSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IPartPropSvc"), typeid(::IPartPropSvc), sizeof(::IPartPropSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::IPartPropSvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21101, type_21102), Reflex::Literal("operator="), operator_6571, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IPartPropSvc"), destructor_6577, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x90, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IPartPropSvc_funcmem_bld);
}

//------Delayed data member builder for class IPartPropSvc -------------------
void __IPartPropSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IPartPropSvc -------------------
void __IPartPropSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6574, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21103), Reflex::Literal("PDT"), method_6575, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_21104, type_6134), Reflex::Literal("setUnknownParticleHandler"), method_6576, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IRegistry -------------------------------
static  void operator_6940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRegistry*)o)->operator=)(*(const ::IRegistry*)arg[0]);
  else   (((::IRegistry*)o)->operator=)(*(const ::IRegistry*)arg[0]);
}

static void destructor_6943(void*, void * o, const std::vector<void*>&, void *) {
(((::IRegistry*)o)->::IRegistry::~IRegistry)();
}
static  void method_6944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::IRegistry*)o)->addRef)());
  else   (((::IRegistry*)o)->addRef)();
}

static  void method_6945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::IRegistry*)o)->release)());
  else   (((::IRegistry*)o)->release)();
}

static  void method_6946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IRegistry*)o)->name)();
  else   (((const ::IRegistry*)o)->name)();
}

static  void method_6947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IRegistry*)o)->identifier)();
  else   (((const ::IRegistry*)o)->identifier)();
}

static  void method_6948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IRegistry*)o)->dataSvc)());
  else   (((const ::IRegistry*)o)->dataSvc)();
}

static  void method_6949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IRegistry*)o)->object)());
  else   (((const ::IRegistry*)o)->object)();
}

static  void method_6950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IRegistry*)o)->address)());
  else   (((const ::IRegistry*)o)->address)();
}

static  void method_6951( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IRegistry*)o)->setAddress)((::IOpaqueAddress*)arg[0]);
}

//------Dictionary for class IRegistry -------------------------------
void __IRegistry_db_datamem(Reflex::Class*);
void __IRegistry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IRegistry_datamem_bld(&__IRegistry_db_datamem);
Reflex::GenreflexMemberBuilder __IRegistry_funcmem_bld(&__IRegistry_db_funcmem);
void __IRegistry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IRegistry"), typeid(::IRegistry), sizeof(::IRegistry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_3236, Reflex::Literal("IRegistry::name_type"))
  .AddTypedef(type_3236, Reflex::Literal("IRegistry::id_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24117, type_24118), Reflex::Literal("operator="), operator_6940, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRegistry"), destructor_6943, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IRegistry_funcmem_bld);
}

//------Delayed data member builder for class IRegistry -------------------
void __IRegistry_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRegistry -------------------
void __IRegistry_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_6944, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_6945, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_6946, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("identifier"), method_6947, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("dataSvc"), method_6948, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("object"), method_6949, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19941), Reflex::Literal("address"), method_6950, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19941), Reflex::Literal("setAddress"), method_6951, 0, "pAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IStatSvc -------------------------------
static  void operator_6976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStatSvc*)o)->operator=)(*(const ::IStatSvc*)arg[0]);
  else   (((::IStatSvc*)o)->operator=)(*(const ::IStatSvc*)arg[0]);
}

static  void method_6979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStatSvc*)o)->interfaceID)();
  else   (((::IStatSvc*)o)->interfaceID)();
}

static  void method_6980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IStatSvc*)o)->stat)(*(const ::std::string*)arg[0],
    *(const double*)arg[1]);
}

static  void method_6981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IStatSvc*)o)->statPrint)(*(const ::std::string*)arg[0]);
}

static  void method_6982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IStatSvc*)o)->stat)(*(const ::std::string*)arg[0]));
  else   (((const ::IStatSvc*)o)->stat)(*(const ::std::string*)arg[0]);
}

static void method_x91( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IStatSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IStatSvc -------------------------------
void __IStatSvc_db_datamem(Reflex::Class*);
void __IStatSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IStatSvc_datamem_bld(&__IStatSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IStatSvc_funcmem_bld(&__IStatSvc_db_funcmem);
void __IStatSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IStatSvc"), typeid(::IStatSvc), sizeof(::IStatSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IStatSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_3236, Reflex::Literal("IStatSvc::StatTag"))
  .AddTypedef(type_2603, Reflex::Literal("IStatSvc::StatFlag"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24125, type_24126), Reflex::Literal("operator="), operator_6976, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x91, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IStatSvc_funcmem_bld);
}

//------Delayed data member builder for class IStatSvc -------------------
void __IStatSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IStatSvc -------------------
void __IStatSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6979, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_10968), Reflex::Literal("stat"), method_6980, 0, "t;f", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("statPrint"), method_6981, 0, "t", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19286, type_6134), Reflex::Literal("stat"), method_6982, 0, "t", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IEventProcessor -------------------------------
static  void operator_6993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IEventProcessor*)o)->operator=)(*(const ::IEventProcessor*)arg[0]);
  else   (((::IEventProcessor*)o)->operator=)(*(const ::IEventProcessor*)arg[0]);
}

static  void method_6996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IEventProcessor*)o)->interfaceID)();
  else   (((::IEventProcessor*)o)->interfaceID)();
}

static  void method_6997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::IEventProcessor*)o)->executeEvent)());
    else     (((::IEventProcessor*)o)->executeEvent)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IEventProcessor*)o)->executeEvent)((void*)arg[0]));
    else     (((::IEventProcessor*)o)->executeEvent)((void*)arg[0]);
  }
}

static  void method_6998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IEventProcessor*)o)->executeRun)(*(int*)arg[0]));
  else   (((::IEventProcessor*)o)->executeRun)(*(int*)arg[0]);
}

static  void method_6999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IEventProcessor*)o)->nextEvent)(*(int*)arg[0]));
  else   (((::IEventProcessor*)o)->nextEvent)(*(int*)arg[0]);
}

static  void method_7000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IEventProcessor*)o)->stopRun)());
  else   (((::IEventProcessor*)o)->stopRun)();
}

static void destructor_7001(void*, void * o, const std::vector<void*>&, void *) {
(((::IEventProcessor*)o)->::IEventProcessor::~IEventProcessor)();
}
static void method_x92( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IEventProcessor,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IEventProcessor -------------------------------
void __IEventProcessor_db_datamem(Reflex::Class*);
void __IEventProcessor_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IEventProcessor_datamem_bld(&__IEventProcessor_db_datamem);
Reflex::GenreflexMemberBuilder __IEventProcessor_funcmem_bld(&__IEventProcessor_db_funcmem);
void __IEventProcessor_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IEventProcessor"), typeid(::IEventProcessor), sizeof(::IEventProcessor), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IEventProcessor, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24130, type_24131), Reflex::Literal("operator="), operator_6993, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IEventProcessor"), destructor_7001, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x92, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IEventProcessor_funcmem_bld);
}

//------Delayed data member builder for class IEventProcessor -------------------
void __IEventProcessor_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IEventProcessor -------------------
void __IEventProcessor_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_6996, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_1454), Reflex::Literal("executeEvent"), method_6997, 0, "par=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_142), Reflex::Literal("executeRun"), method_6998, 0, "maxevt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_142), Reflex::Literal("nextEvent"), method_6999, 0, "maxevt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stopRun"), method_7000, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartDataPtr<ObjectContainerBase> -------------------------------
static  void operator_7008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataPtr<ObjectContainerBase>*)o)->operator=)(*(const ::SmartDataPtr<ObjectContainerBase>*)arg[0]);
  else   (((::SmartDataPtr<ObjectContainerBase>*)o)->operator=)(*(const ::SmartDataPtr<ObjectContainerBase>*)arg[0]);
}

static void constructor_7009( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(const ::SmartDataPtr<ObjectContainerBase>*)arg[0]);
  else ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(const ::SmartDataPtr<ObjectContainerBase>*)arg[0]);
}

static void constructor_7010( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<ObjectContainerBase>((::IDataProviderSvc*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::SmartDataPtr<ObjectContainerBase>((::IDataProviderSvc*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void constructor_7011( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<ObjectContainerBase>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1]);
  else ::new(mem) ::SmartDataPtr<ObjectContainerBase>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1]);
}

static void constructor_7012( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<ObjectContainerBase>((::IDataProviderSvc*)arg[0],
      (::DataObject*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  else ::new(mem) ::SmartDataPtr<ObjectContainerBase>((::IDataProviderSvc*)arg[0],
      (::DataObject*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
}

static void constructor_7013( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(::SmartDataObjectPtr*)arg[0],
      (::IRegistry*)arg[1]);
  else ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(::SmartDataObjectPtr*)arg[0],
      (::IRegistry*)arg[1]);
}

static void constructor_7014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(::SmartDataObjectPtr*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(::SmartDataObjectPtr*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void constructor_7015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(const ::SmartDataObjectPtr*)arg[0]);
  else ::new(mem) ::SmartDataPtr<ObjectContainerBase>(*(const ::SmartDataObjectPtr*)arg[0]);
}

static void destructor_7016(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartDataPtr<ObjectContainerBase>*)o)->::SmartDataPtr<ObjectContainerBase>::~SmartDataPtr)();
}
static void method_x93( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader>")), ::Reflex::BaseOffset< ::SmartDataPtr<ObjectContainerBase>,::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("SmartDataObjectPtr")), ::Reflex::BaseOffset< ::SmartDataPtr<ObjectContainerBase>,::SmartDataObjectPtr >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartDataPtr<ObjectContainerBase> -------------------------------
void __SmartDataPtr_ObjectContainerBase__db_datamem(Reflex::Class*);
void __SmartDataPtr_ObjectContainerBase__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartDataPtr_ObjectContainerBase__datamem_bld(&__SmartDataPtr_ObjectContainerBase__db_datamem);
Reflex::GenreflexMemberBuilder __SmartDataPtr_ObjectContainerBase__funcmem_bld(&__SmartDataPtr_ObjectContainerBase__db_funcmem);
void __SmartDataPtr_ObjectContainerBase__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartDataPtr<ObjectContainerBase>"), typeid(::SmartDataPtr<ObjectContainerBase>), sizeof(::SmartDataPtr<ObjectContainerBase>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartData*")
  .AddBase(type_1082, ::Reflex::BaseOffset< ::SmartDataPtr<ObjectContainerBase>, ::SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24135, type_24136), Reflex::Literal("operator="), operator_7008, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24136), Reflex::Literal("SmartDataPtr"), constructor_7009, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_7844), Reflex::Literal("SmartDataPtr"), constructor_7010, 0, "pService;fullPath", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_10115), Reflex::Literal("SmartDataPtr"), constructor_7011, 0, "pService;pDirectory", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_19429, type_7844), Reflex::Literal("SmartDataPtr"), constructor_7012, 0, "pService;pObject;path", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19793, type_10115), Reflex::Literal("SmartDataPtr"), constructor_7013, 0, "refObject;pDirectory", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19793, type_7844), Reflex::Literal("SmartDataPtr"), constructor_7014, 0, "refObject;path", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19792), Reflex::Literal("SmartDataPtr"), constructor_7015, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartDataPtr"), destructor_7016, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x93, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class SmartDataPtr<ObjectContainerBase> -------------------
void __SmartDataPtr_ObjectContainerBase__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class SmartDataPtr<ObjectContainerBase> -------------------
void __SmartDataPtr_ObjectContainerBase__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class SmartDataPtr<DataObject> -------------------------------
static  void operator_7017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataPtr<DataObject>*)o)->operator=)(*(const ::SmartDataPtr<DataObject>*)arg[0]);
  else   (((::SmartDataPtr<DataObject>*)o)->operator=)(*(const ::SmartDataPtr<DataObject>*)arg[0]);
}

static void constructor_7018( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<DataObject>(*(const ::SmartDataPtr<DataObject>*)arg[0]);
  else ::new(mem) ::SmartDataPtr<DataObject>(*(const ::SmartDataPtr<DataObject>*)arg[0]);
}

static void constructor_7019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<DataObject>((::IDataProviderSvc*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::SmartDataPtr<DataObject>((::IDataProviderSvc*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void constructor_7020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<DataObject>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1]);
  else ::new(mem) ::SmartDataPtr<DataObject>((::IDataProviderSvc*)arg[0],
      (::IRegistry*)arg[1]);
}

static void constructor_7021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<DataObject>((::IDataProviderSvc*)arg[0],
      (::DataObject*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  else ::new(mem) ::SmartDataPtr<DataObject>((::IDataProviderSvc*)arg[0],
      (::DataObject*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
}

static void constructor_7022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<DataObject>(*(::SmartDataObjectPtr*)arg[0],
      (::IRegistry*)arg[1]);
  else ::new(mem) ::SmartDataPtr<DataObject>(*(::SmartDataObjectPtr*)arg[0],
      (::IRegistry*)arg[1]);
}

static void constructor_7023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<DataObject>(*(::SmartDataObjectPtr*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::SmartDataPtr<DataObject>(*(::SmartDataObjectPtr*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void constructor_7024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataPtr<DataObject>(*(const ::SmartDataObjectPtr*)arg[0]);
  else ::new(mem) ::SmartDataPtr<DataObject>(*(const ::SmartDataObjectPtr*)arg[0]);
}

static void destructor_7025(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartDataPtr<DataObject>*)o)->::SmartDataPtr<DataObject>::~SmartDataPtr)();
}
static void method_x94( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader>")), ::Reflex::BaseOffset< ::SmartDataPtr<DataObject>,::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("SmartDataObjectPtr")), ::Reflex::BaseOffset< ::SmartDataPtr<DataObject>,::SmartDataObjectPtr >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartDataPtr<DataObject> -------------------------------
void __SmartDataPtr_DataObject__db_datamem(Reflex::Class*);
void __SmartDataPtr_DataObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartDataPtr_DataObject__datamem_bld(&__SmartDataPtr_DataObject__db_datamem);
Reflex::GenreflexMemberBuilder __SmartDataPtr_DataObject__funcmem_bld(&__SmartDataPtr_DataObject__db_funcmem);
void __SmartDataPtr_DataObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartDataPtr<DataObject>"), typeid(::SmartDataPtr<DataObject>), sizeof(::SmartDataPtr<DataObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartData*")
  .AddBase(type_1083, ::Reflex::BaseOffset< ::SmartDataPtr<DataObject>, ::SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24137, type_24138), Reflex::Literal("operator="), operator_7017, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24138), Reflex::Literal("SmartDataPtr"), constructor_7018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_7844), Reflex::Literal("SmartDataPtr"), constructor_7019, 0, "pService;fullPath", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_10115), Reflex::Literal("SmartDataPtr"), constructor_7020, 0, "pService;pDirectory", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19780, type_19429, type_7844), Reflex::Literal("SmartDataPtr"), constructor_7021, 0, "pService;pObject;path", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19793, type_10115), Reflex::Literal("SmartDataPtr"), constructor_7022, 0, "refObject;pDirectory", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19793, type_7844), Reflex::Literal("SmartDataPtr"), constructor_7023, 0, "refObject;path", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19792), Reflex::Literal("SmartDataPtr"), constructor_7024, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartDataPtr"), destructor_7025, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x94, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class SmartDataPtr<DataObject> -------------------
void __SmartDataPtr_DataObject__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class SmartDataPtr<DataObject> -------------------
void __SmartDataPtr_DataObject__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IJobOptionsSvc -------------------------------
static  void operator_7026( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IJobOptionsSvc*)o)->operator=)(*(const ::IJobOptionsSvc*)arg[0]);
  else   (((::IJobOptionsSvc*)o)->operator=)(*(const ::IJobOptionsSvc*)arg[0]);
}

static  void method_7029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IJobOptionsSvc*)o)->interfaceID)();
  else   (((::IJobOptionsSvc*)o)->interfaceID)();
}

static  void method_7030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IJobOptionsSvc*)o)->setMyProperties)(*(const ::std::string*)arg[0],
    (::IProperty*)arg[1]));
  else   (((::IJobOptionsSvc*)o)->setMyProperties)(*(const ::std::string*)arg[0],
    (::IProperty*)arg[1]);
}

static  void method_7031( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IJobOptionsSvc*)o)->addPropertyToCatalogue)(*(const ::std::string*)arg[0],
    *(const ::Property*)arg[1]));
  else   (((::IJobOptionsSvc*)o)->addPropertyToCatalogue)(*(const ::std::string*)arg[0],
    *(const ::Property*)arg[1]);
}

static  void method_7032( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IJobOptionsSvc*)o)->removePropertyFromCatalogue)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::IJobOptionsSvc*)o)->removePropertyFromCatalogue)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7033( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IJobOptionsSvc*)o)->getProperties)(*(const ::std::string*)arg[0]));
  else   (((const ::IJobOptionsSvc*)o)->getProperties)(*(const ::std::string*)arg[0]);
}

static  void method_7034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::IJobOptionsSvc*)o)->getClients)());
  else   (((const ::IJobOptionsSvc*)o)->getClients)();
}

static  void method_7035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::IJobOptionsSvc*)o)->readOptions)(*(const ::std::string*)arg[0]));
    else     (((::IJobOptionsSvc*)o)->readOptions)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IJobOptionsSvc*)o)->readOptions)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((::IJobOptionsSvc*)o)->readOptions)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static void destructor_7036(void*, void * o, const std::vector<void*>&, void *) {
(((::IJobOptionsSvc*)o)->::IJobOptionsSvc::~IJobOptionsSvc)();
}
static void method_x95( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IJobOptionsSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IJobOptionsSvc -------------------------------
void __IJobOptionsSvc_db_datamem(Reflex::Class*);
void __IJobOptionsSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IJobOptionsSvc_datamem_bld(&__IJobOptionsSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IJobOptionsSvc_funcmem_bld(&__IJobOptionsSvc_db_funcmem);
void __IJobOptionsSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IJobOptionsSvc"), typeid(::IJobOptionsSvc), sizeof(::IJobOptionsSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IJobOptionsSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24139, type_24140), Reflex::Literal("operator="), operator_7026, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IJobOptionsSvc"), destructor_7036, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x95, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IJobOptionsSvc_funcmem_bld);
}

//------Delayed data member builder for class IJobOptionsSvc -------------------
void __IJobOptionsSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IJobOptionsSvc -------------------
void __IJobOptionsSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7029, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19990), Reflex::Literal("setMyProperties"), method_7030, 0, "client;me", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_7834), Reflex::Literal("addPropertyToCatalogue"), method_7031, 0, "client;property", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("removePropertyFromCatalogue"), method_7032, 0, "client;name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24141, type_6134), Reflex::Literal("getProperties"), method_7033, 0, "client", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getClients"), method_7034, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("readOptions"), method_7035, 0, "file;path=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class INTuple -------------------------------
static  void operator_7038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::INTuple*)o)->operator=)(*(const ::INTuple*)arg[0]);
  else   (((::INTuple*)o)->operator=)(*(const ::INTuple*)arg[0]);
}

static  void method_7042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::INTuple*)o)->items)();
  else   (((::INTuple*)o)->items)();
}

static  void method_7043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::INTuple*)o)->items)();
  else   (((const ::INTuple*)o)->items)();
}

static  void method_7044( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::INTuple*)o)->setBuffer)((char*)arg[0]);
}

static  void method_7045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::INTuple*)o)->buffer)());
  else   (((const ::INTuple*)o)->buffer)();
}

static  void method_7046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTuple*)o)->buffer)());
  else   (((::INTuple*)o)->buffer)();
}

static  void method_7047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::INTuple*)o)->title)();
  else   (((const ::INTuple*)o)->title)();
}

static  void method_7048( void*, void* o, const std::vector<void*>&, void*)
{
  (((::INTuple*)o)->reset)();
}

static  void method_7049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::INTuple*)o)->find)(*(const ::std::string*)arg[0]));
  else   (((const ::INTuple*)o)->find)(*(const ::std::string*)arg[0]);
}

static  void method_7050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTuple*)o)->find)(*(const ::std::string*)arg[0]));
  else   (((::INTuple*)o)->find)(*(const ::std::string*)arg[0]);
}

static  void method_7051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->add)((::INTupleItem*)arg[0]));
  else   (((::INTuple*)o)->add)((::INTupleItem*)arg[0]);
}

static  void method_7052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->remove)((::INTupleItem*)arg[0]));
  else   (((::INTuple*)o)->remove)((::INTupleItem*)arg[0]);
}

static  void method_7053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->remove)(*(const ::std::string*)arg[0]));
  else   (((::INTuple*)o)->remove)(*(const ::std::string*)arg[0]);
}

static  void method_7054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->attachSelector)((::ISelectStatement*)arg[0]));
  else   (((::INTuple*)o)->attachSelector)((::ISelectStatement*)arg[0]);
}

static  void method_7055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::INTuple*)o)->selector)());
  else   (((::INTuple*)o)->selector)();
}

static  void method_7056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->write)());
  else   (((::INTuple*)o)->write)();
}

static  void method_7057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->writeRecord)());
  else   (((::INTuple*)o)->writeRecord)();
}

static  void method_7058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->read)());
  else   (((::INTuple*)o)->read)();
}

static  void method_7059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->readRecord)());
  else   (((::INTuple*)o)->readRecord)();
}

static  void method_7060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::INTuple*)o)->save)());
  else   (((::INTuple*)o)->save)();
}

static void destructor_7061(void*, void * o, const std::vector<void*>&, void *) {
(((::INTuple*)o)->::INTuple::~INTuple)();
}
//------Dictionary for class INTuple -------------------------------
void __INTuple_db_datamem(Reflex::Class*);
void __INTuple_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __INTuple_datamem_bld(&__INTuple_db_datamem);
Reflex::GenreflexMemberBuilder __INTuple_funcmem_bld(&__INTuple_db_funcmem);
void __INTuple_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("INTuple"), typeid(::INTuple), sizeof(::INTuple), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_3199, Reflex::Literal("INTuple::ItemContainer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24142, type_24143), Reflex::Literal("operator="), operator_7038, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~INTuple"), destructor_7061, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__INTuple_funcmem_bld);
}

//------Delayed data member builder for class INTuple -------------------
void __INTuple_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class INTuple -------------------
void __INTuple_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24144), Reflex::Literal("items"), method_7042, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24145), Reflex::Literal("items"), method_7043, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_158), Reflex::Literal("setBuffer"), method_7044, 0, "buff", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4095), Reflex::Literal("buffer"), method_7045, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_158), Reflex::Literal("buffer"), method_7046, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("title"), method_7047, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("reset"), method_7048, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19929, type_6134), Reflex::Literal("find"), method_7049, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12697, type_6134), Reflex::Literal("find"), method_7050, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_12697), Reflex::Literal("add"), method_7051, 0, "item", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_12697), Reflex::Literal("remove"), method_7052, 0, "item", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("remove"), method_7053, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24146), Reflex::Literal("attachSelector"), method_7054, 0, "sel", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24146), Reflex::Literal("selector"), method_7055, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("write"), method_7056, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("writeRecord"), method_7057, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("read"), method_7058, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("readRecord"), method_7059, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("save"), method_7060, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IParticlePropertySvc -------------------------------
static  void operator_7065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IParticlePropertySvc*)o)->operator=)(*(const ::IParticlePropertySvc*)arg[0]);
  else   (((::IParticlePropertySvc*)o)->operator=)(*(const ::IParticlePropertySvc*)arg[0]);
}

static  void method_7068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IParticlePropertySvc*)o)->interfaceID)();
  else   (((::IParticlePropertySvc*)o)->interfaceID)();
}

static  void method_7069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IParticlePropertySvc*)o)->push_back)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(const ::std::string*)arg[6],
    *(int*)arg[7],
    *(double*)arg[8]));
  else   (((::IParticlePropertySvc*)o)->push_back)(*(const ::std::string*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(const ::std::string*)arg[6],
    *(int*)arg[7],
    *(double*)arg[8]);
}

static  void method_7070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IParticlePropertySvc*)o)->push_back)((::ParticleProperty*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->push_back)((::ParticleProperty*)arg[0]);
}

static  void method_7071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ParticleProperty* const*,std::vector<ParticleProperty*> >)((((const ::IParticlePropertySvc*)o)->begin)());
  else   (((const ::IParticlePropertySvc*)o)->begin)();
}

static  void method_7072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ParticleProperty* const*,std::vector<ParticleProperty*> >)((((const ::IParticlePropertySvc*)o)->end)());
  else   (((const ::IParticlePropertySvc*)o)->end)();
}

static  void method_7073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IParticlePropertySvc*)o)->size)());
  else   (((const ::IParticlePropertySvc*)o)->size)();
}

static  void method_7074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IParticlePropertySvc*)o)->find)(*(int*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->find)(*(int*)arg[0]);
}

static  void method_7075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IParticlePropertySvc*)o)->findByStdHepID)(*(int*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->findByStdHepID)(*(int*)arg[0]);
}

static  void method_7076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IParticlePropertySvc*)o)->find)(*(const ::std::string*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->find)(*(const ::std::string*)arg[0]);
}

static  void method_7077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IParticlePropertySvc*)o)->findByPythiaID)(*(int*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->findByPythiaID)(*(int*)arg[0]);
}

static  void method_7078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IParticlePropertySvc*)o)->erase)(*(int*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->erase)(*(int*)arg[0]);
}

static  void method_7079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IParticlePropertySvc*)o)->erase)(*(const ::std::string*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->erase)(*(const ::std::string*)arg[0]);
}

static  void method_7080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IParticlePropertySvc*)o)->eraseByStdHepID)(*(int*)arg[0]));
  else   (((::IParticlePropertySvc*)o)->eraseByStdHepID)(*(int*)arg[0]);
}

static void destructor_7081(void*, void * o, const std::vector<void*>&, void *) {
(((::IParticlePropertySvc*)o)->::IParticlePropertySvc::~IParticlePropertySvc)();
}
static void method_x96( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IParticlePropertySvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IParticlePropertySvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IParticlePropertySvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IParticlePropertySvc -------------------------------
void __IParticlePropertySvc_db_datamem(Reflex::Class*);
void __IParticlePropertySvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IParticlePropertySvc_datamem_bld(&__IParticlePropertySvc_db_datamem);
Reflex::GenreflexMemberBuilder __IParticlePropertySvc_funcmem_bld(&__IParticlePropertySvc_db_funcmem);
void __IParticlePropertySvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IParticlePropertySvc"), typeid(::IParticlePropertySvc), sizeof(::IParticlePropertySvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::IParticlePropertySvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_3168, Reflex::Literal("IParticlePropertySvc::VectPP"))
  .AddTypedef(type_6698, Reflex::Literal("IParticlePropertySvc::const_iterator"))
  .AddTypedef(type_6697, Reflex::Literal("IParticlePropertySvc::iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24147, type_24148), Reflex::Literal("operator="), operator_7065, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IParticlePropertySvc"), destructor_7081, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x96, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IParticlePropertySvc_funcmem_bld);
}

//------Delayed data member builder for class IParticlePropertySvc -------------------
void __IParticlePropertySvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IParticlePropertySvc -------------------
void __IParticlePropertySvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7068, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_142, type_142, type_2603, type_2603, type_2603, type_6134, type_142, type_2603), Reflex::Literal("push_back"), method_7069, 0, "particle;geantId;jetsetId;charge;mass;tlife;evtName;pythiaId;maxWidth", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_11025), Reflex::Literal("push_back"), method_7070, 0, "pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6698), Reflex::Literal("begin"), method_7071, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6698), Reflex::Literal("end"), method_7072, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142), Reflex::Literal("size"), method_7073, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11025, type_142), Reflex::Literal("find"), method_7074, 0, "geantId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11025, type_142), Reflex::Literal("findByStdHepID"), method_7075, 0, "stdHepID", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11025, type_6134), Reflex::Literal("find"), method_7076, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11025, type_142), Reflex::Literal("findByPythiaID"), method_7077, 0, "pythiaID", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_142), Reflex::Literal("erase"), method_7078, 0, "geantId", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("erase"), method_7079, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_142), Reflex::Literal("eraseByStdHepID"), method_7080, 0, "stdHepID", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class implements3<IAlgTool,IProperty,IStateful> -------------------------------
static  void method_7107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::implements3<IAlgTool,IProperty,IStateful>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::implements3<IAlgTool,IProperty,IStateful>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]);
}

static  void method_7108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::implements3<IAlgTool,IProperty,IStateful>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::implements3<IAlgTool,IProperty,IStateful>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static  void method_7109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::implements3<IAlgTool,IProperty,IStateful>*)o)->getInterfaceNames)());
  else   (((const ::implements3<IAlgTool,IProperty,IStateful>*)o)->getInterfaceNames)();
}

static void destructor_7113(void*, void * o, const std::vector<void*>&, void *) {
(((::implements3<IAlgTool,IProperty,IStateful>*)o)->::implements3<IAlgTool,IProperty,IStateful>::~implements3)();
}
static  void method_7114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements3<IAlgTool,IProperty,IStateful>*)o)->addRef)());
  else   (((::implements3<IAlgTool,IProperty,IStateful>*)o)->addRef)();
}

static  void method_7115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements3<IAlgTool,IProperty,IStateful>*)o)->release)());
  else   (((::implements3<IAlgTool,IProperty,IStateful>*)o)->release)();
}

static  void method_7116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::implements3<IAlgTool,IProperty,IStateful>*)o)->refCount)());
  else   (((const ::implements3<IAlgTool,IProperty,IStateful>*)o)->refCount)();
}

static void method_x97( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IAlgTool,IProperty,IStateful>")), ::Reflex::BaseOffset< ::implements3<IAlgTool,IProperty,IStateful>,::extend_interfaces3<IAlgTool,IProperty,IStateful> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::implements3<IAlgTool,IProperty,IStateful>,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::implements3<IAlgTool,IProperty,IStateful>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::implements3<IAlgTool,IProperty,IStateful>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::implements3<IAlgTool,IProperty,IStateful>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::implements3<IAlgTool,IProperty,IStateful>,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class implements3<IAlgTool,IProperty,IStateful> -------------------------------
void __implements3_IAlgTool_IProperty_IStateful__db_datamem(Reflex::Class*);
void __implements3_IAlgTool_IProperty_IStateful__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __implements3_IAlgTool_IProperty_IStateful__datamem_bld(&__implements3_IAlgTool_IProperty_IStateful__db_datamem);
Reflex::GenreflexMemberBuilder __implements3_IAlgTool_IProperty_IStateful__funcmem_bld(&__implements3_IAlgTool_IProperty_IStateful__db_funcmem);
void __implements3_IAlgTool_IProperty_IStateful__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("implements3<IAlgTool,IProperty,IStateful>"), typeid(::implements3<IAlgTool,IProperty,IStateful>), sizeof(::implements3<IAlgTool,IProperty,IStateful>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "implements*<*>")
  .AddBase(type_663, ::Reflex::BaseOffset< ::implements3<IAlgTool,IProperty,IStateful>, ::extend_interfaces3<IAlgTool,IProperty,IStateful> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_663, Reflex::Literal("implements3<IAlgTool,IProperty,IStateful>::extend_interfaces_base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~implements3"), destructor_7113, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x97, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__implements3_IAlgTool_IProperty_IStateful__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__implements3_IAlgTool_IProperty_IStateful__funcmem_bld);
}

//------Delayed data member builder for class implements3<IAlgTool,IProperty,IStateful> -------------------
void __implements3_IAlgTool_IProperty_IStateful__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__implements3_IAlgTool_IProperty_IStateful_, m_refCount), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class implements3<IAlgTool,IProperty,IStateful> -------------------
void __implements3_IAlgTool_IProperty_IStateful__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7851), Reflex::Literal("i_cast"), method_7107, 0, "tid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_7108, 0, "ti;pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getInterfaceNames"), method_7109, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_7114, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_7115, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_7116, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class implements3<IService,IProperty,IStateful> -------------------------------
static  void method_7119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::implements3<IService,IProperty,IStateful>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::implements3<IService,IProperty,IStateful>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]);
}

static  void method_7120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::implements3<IService,IProperty,IStateful>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::implements3<IService,IProperty,IStateful>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static  void method_7121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::implements3<IService,IProperty,IStateful>*)o)->getInterfaceNames)());
  else   (((const ::implements3<IService,IProperty,IStateful>*)o)->getInterfaceNames)();
}

static  void operator_7124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::implements3<IService,IProperty,IStateful>*)o)->operator=)(*(const ::implements3<IService,IProperty,IStateful>*)arg[0]);
  else   (((::implements3<IService,IProperty,IStateful>*)o)->operator=)(*(const ::implements3<IService,IProperty,IStateful>*)arg[0]);
}

static void destructor_7125(void*, void * o, const std::vector<void*>&, void *) {
(((::implements3<IService,IProperty,IStateful>*)o)->::implements3<IService,IProperty,IStateful>::~implements3)();
}
static  void method_7126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements3<IService,IProperty,IStateful>*)o)->addRef)());
  else   (((::implements3<IService,IProperty,IStateful>*)o)->addRef)();
}

static  void method_7127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements3<IService,IProperty,IStateful>*)o)->release)());
  else   (((::implements3<IService,IProperty,IStateful>*)o)->release)();
}

static  void method_7128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::implements3<IService,IProperty,IStateful>*)o)->refCount)());
  else   (((const ::implements3<IService,IProperty,IStateful>*)o)->refCount)();
}

static void method_x98( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IService,IProperty,IStateful>")), ::Reflex::BaseOffset< ::implements3<IService,IProperty,IStateful>,::extend_interfaces3<IService,IProperty,IStateful> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::implements3<IService,IProperty,IStateful>,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::implements3<IService,IProperty,IStateful>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::implements3<IService,IProperty,IStateful>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::implements3<IService,IProperty,IStateful>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::implements3<IService,IProperty,IStateful>,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class implements3<IService,IProperty,IStateful> -------------------------------
void __implements3_IService_IProperty_IStateful__db_datamem(Reflex::Class*);
void __implements3_IService_IProperty_IStateful__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __implements3_IService_IProperty_IStateful__datamem_bld(&__implements3_IService_IProperty_IStateful__db_datamem);
Reflex::GenreflexMemberBuilder __implements3_IService_IProperty_IStateful__funcmem_bld(&__implements3_IService_IProperty_IStateful__db_funcmem);
void __implements3_IService_IProperty_IStateful__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("implements3<IService,IProperty,IStateful>"), typeid(::implements3<IService,IProperty,IStateful>), sizeof(::implements3<IService,IProperty,IStateful>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "implements*<*>")
  .AddBase(type_664, ::Reflex::BaseOffset< ::implements3<IService,IProperty,IStateful>, ::extend_interfaces3<IService,IProperty,IStateful> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_664, Reflex::Literal("implements3<IService,IProperty,IStateful>::extend_interfaces_base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~implements3"), destructor_7125, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x98, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__implements3_IService_IProperty_IStateful__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__implements3_IService_IProperty_IStateful__funcmem_bld);
}

//------Delayed data member builder for class implements3<IService,IProperty,IStateful> -------------------
void __implements3_IService_IProperty_IStateful__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__implements3_IService_IProperty_IStateful_, m_refCount), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class implements3<IService,IProperty,IStateful> -------------------
void __implements3_IService_IProperty_IStateful__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7851), Reflex::Literal("i_cast"), method_7119, 0, "tid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_7120, 0, "ti;pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getInterfaceNames"), method_7121, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24166, type_24165), Reflex::Literal("operator="), operator_7124, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_7126, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_7127, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_7128, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class implements3<IAlgorithm,IProperty,IStateful> -------------------------------
static  void method_7131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::implements3<IAlgorithm,IProperty,IStateful>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]));
  else   (((const ::implements3<IAlgorithm,IProperty,IStateful>*)o)->i_cast)(*(const ::InterfaceID*)arg[0]);
}

static  void method_7132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::implements3<IAlgorithm,IProperty,IStateful>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]));
  else   (((::implements3<IAlgorithm,IProperty,IStateful>*)o)->queryInterface)(*(const ::InterfaceID*)arg[0],
    (void**)arg[1]);
}

static  void method_7133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::implements3<IAlgorithm,IProperty,IStateful>*)o)->getInterfaceNames)());
  else   (((const ::implements3<IAlgorithm,IProperty,IStateful>*)o)->getInterfaceNames)();
}

static  void operator_7136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::implements3<IAlgorithm,IProperty,IStateful>*)o)->operator=)(*(const ::implements3<IAlgorithm,IProperty,IStateful>*)arg[0]);
  else   (((::implements3<IAlgorithm,IProperty,IStateful>*)o)->operator=)(*(const ::implements3<IAlgorithm,IProperty,IStateful>*)arg[0]);
}

static void destructor_7137(void*, void * o, const std::vector<void*>&, void *) {
(((::implements3<IAlgorithm,IProperty,IStateful>*)o)->::implements3<IAlgorithm,IProperty,IStateful>::~implements3)();
}
static  void method_7138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements3<IAlgorithm,IProperty,IStateful>*)o)->addRef)());
  else   (((::implements3<IAlgorithm,IProperty,IStateful>*)o)->addRef)();
}

static  void method_7139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::implements3<IAlgorithm,IProperty,IStateful>*)o)->release)());
  else   (((::implements3<IAlgorithm,IProperty,IStateful>*)o)->release)();
}

static  void method_7140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::implements3<IAlgorithm,IProperty,IStateful>*)o)->refCount)());
  else   (((const ::implements3<IAlgorithm,IProperty,IStateful>*)o)->refCount)();
}

static void method_x99( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IAlgorithm,IProperty,IStateful>")), ::Reflex::BaseOffset< ::implements3<IAlgorithm,IProperty,IStateful>,::extend_interfaces3<IAlgorithm,IProperty,IStateful> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgorithm")), ::Reflex::BaseOffset< ::implements3<IAlgorithm,IProperty,IStateful>,::IAlgorithm >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::implements3<IAlgorithm,IProperty,IStateful>,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::implements3<IAlgorithm,IProperty,IStateful>,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::implements3<IAlgorithm,IProperty,IStateful>,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::implements3<IAlgorithm,IProperty,IStateful>,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class implements3<IAlgorithm,IProperty,IStateful> -------------------------------
void __implements3_IAlgorithm_IProperty_IStateful__db_datamem(Reflex::Class*);
void __implements3_IAlgorithm_IProperty_IStateful__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __implements3_IAlgorithm_IProperty_IStateful__datamem_bld(&__implements3_IAlgorithm_IProperty_IStateful__db_datamem);
Reflex::GenreflexMemberBuilder __implements3_IAlgorithm_IProperty_IStateful__funcmem_bld(&__implements3_IAlgorithm_IProperty_IStateful__db_funcmem);
void __implements3_IAlgorithm_IProperty_IStateful__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("implements3<IAlgorithm,IProperty,IStateful>"), typeid(::implements3<IAlgorithm,IProperty,IStateful>), sizeof(::implements3<IAlgorithm,IProperty,IStateful>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "implements*<*>")
  .AddBase(type_665, ::Reflex::BaseOffset< ::implements3<IAlgorithm,IProperty,IStateful>, ::extend_interfaces3<IAlgorithm,IProperty,IStateful> >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_665, Reflex::Literal("implements3<IAlgorithm,IProperty,IStateful>::extend_interfaces_base"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~implements3"), destructor_7137, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x99, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__implements3_IAlgorithm_IProperty_IStateful__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__implements3_IAlgorithm_IProperty_IStateful__funcmem_bld);
}

//------Delayed data member builder for class implements3<IAlgorithm,IProperty,IStateful> -------------------
void __implements3_IAlgorithm_IProperty_IStateful__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("m_refCount"), OffsetOf(__shadow__::__implements3_IAlgorithm_IProperty_IStateful_, m_refCount), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class implements3<IAlgorithm,IProperty,IStateful> -------------------
void __implements3_IAlgorithm_IProperty_IStateful__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1454, type_7851), Reflex::Literal("i_cast"), method_7131, 0, "tid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7851, type_4283), Reflex::Literal("queryInterface"), method_7132, 0, "ti;pp", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165), Reflex::Literal("getInterfaceNames"), method_7133, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24168, type_24167), Reflex::Literal("operator="), operator_7136, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_7138, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_7139, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("refCount"), method_7140, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class IEventTimeDecoder -------------------------------
static  void operator_7142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IEventTimeDecoder*)o)->operator=)(*(const ::IEventTimeDecoder*)arg[0]);
  else   (((::IEventTimeDecoder*)o)->operator=)(*(const ::IEventTimeDecoder*)arg[0]);
}

static  void method_7145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IEventTimeDecoder*)o)->interfaceID)();
  else   (((::IEventTimeDecoder*)o)->interfaceID)();
}

static  void method_7146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Gaudi::Time)((((const ::IEventTimeDecoder*)o)->getTime)());
  else   (((const ::IEventTimeDecoder*)o)->getTime)();
}

static void destructor_7147(void*, void * o, const std::vector<void*>&, void *) {
(((::IEventTimeDecoder*)o)->::IEventTimeDecoder::~IEventTimeDecoder)();
}
static void method_x100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgTool")), ::Reflex::BaseOffset< ::IEventTimeDecoder,::IAlgTool >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IEventTimeDecoder,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IEventTimeDecoder,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IEventTimeDecoder -------------------------------
void __IEventTimeDecoder_db_datamem(Reflex::Class*);
void __IEventTimeDecoder_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IEventTimeDecoder_datamem_bld(&__IEventTimeDecoder_db_datamem);
Reflex::GenreflexMemberBuilder __IEventTimeDecoder_funcmem_bld(&__IEventTimeDecoder_db_funcmem);
void __IEventTimeDecoder_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IEventTimeDecoder"), typeid(::IEventTimeDecoder), sizeof(::IEventTimeDecoder), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_813, ::Reflex::BaseOffset< ::IEventTimeDecoder, ::IAlgTool >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24169, type_24170), Reflex::Literal("operator="), operator_7142, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IEventTimeDecoder"), destructor_7147, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IEventTimeDecoder_funcmem_bld);
}

//------Delayed data member builder for class IEventTimeDecoder -------------------
void __IEventTimeDecoder_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IEventTimeDecoder -------------------
void __IEventTimeDecoder_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7145, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4682), Reflex::Literal("getTime"), method_7146, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IStagerSvc -------------------------------
static  void operator_7149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStagerSvc*)o)->operator=)(*(const ::IStagerSvc*)arg[0]);
  else   (((::IStagerSvc*)o)->operator=)(*(const ::IStagerSvc*)arg[0]);
}

static  void method_7152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStagerSvc*)o)->interfaceID)();
  else   (((::IStagerSvc*)o)->interfaceID)();
}

static  void method_7153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStagerSvc*)o)->getStreams)());
  else   (((::IStagerSvc*)o)->getStreams)();
}

static  void method_7154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStagerSvc*)o)->readAhead)());
  else   (((::IStagerSvc*)o)->readAhead)();
}

static  void method_7155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStagerSvc*)o)->initStage)());
  else   (((::IStagerSvc*)o)->initStage)();
}

static void destructor_7156(void*, void * o, const std::vector<void*>&, void *) {
(((::IStagerSvc*)o)->::IStagerSvc::~IStagerSvc)();
}
static void method_x101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IStagerSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IStagerSvc -------------------------------
void __IStagerSvc_db_datamem(Reflex::Class*);
void __IStagerSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IStagerSvc_datamem_bld(&__IStagerSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IStagerSvc_funcmem_bld(&__IStagerSvc_db_funcmem);
void __IStagerSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IStagerSvc"), typeid(::IStagerSvc), sizeof(::IStagerSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IStagerSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24171, type_24172), Reflex::Literal("operator="), operator_7149, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IStagerSvc"), destructor_7156, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IStagerSvc_funcmem_bld);
}

//------Delayed data member builder for class IStagerSvc -------------------
void __IStagerSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IStagerSvc -------------------
void __IStagerSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7152, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("getStreams"), method_7153, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("readAhead"), method_7154, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initStage"), method_7155, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class ICounterSummarySvc -------------------------------
static  void operator_7172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ICounterSummarySvc*)o)->operator=)(*(const ::ICounterSummarySvc*)arg[0]);
  else   (((::ICounterSummarySvc*)o)->operator=)(*(const ::ICounterSummarySvc*)arg[0]);
}

static  void method_7175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ICounterSummarySvc*)o)->interfaceID)();
  else   (((::ICounterSummarySvc*)o)->interfaceID)();
}

static  void method_7176( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    (((::ICounterSummarySvc*)o)->addCounter)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::ICounterSummarySvc*)o)->addCounter)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2],
      *(const ::Gaudi::CounterSummary::SaveType*)arg[3]);
  }
}

static  void method_7177( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    (((::ICounterSummarySvc*)o)->addCounter)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Stat*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::ICounterSummarySvc*)o)->addCounter)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Stat*)arg[2],
      *(const ::Gaudi::CounterSummary::SaveType*)arg[3]);
  }
}

static void destructor_7178(void*, void * o, const std::vector<void*>&, void *) {
(((::ICounterSummarySvc*)o)->::ICounterSummarySvc::~ICounterSummarySvc)();
}
static void method_x102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::ICounterSummarySvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::ICounterSummarySvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::ICounterSummarySvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ICounterSummarySvc -------------------------------
void __ICounterSummarySvc_db_datamem(Reflex::Class*);
void __ICounterSummarySvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ICounterSummarySvc_datamem_bld(&__ICounterSummarySvc_db_datamem);
Reflex::GenreflexMemberBuilder __ICounterSummarySvc_funcmem_bld(&__ICounterSummarySvc_db_funcmem);
void __ICounterSummarySvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ICounterSummarySvc"), typeid(::ICounterSummarySvc), sizeof(::ICounterSummarySvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::ICounterSummarySvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24179, type_24180), Reflex::Literal("operator="), operator_7172, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ICounterSummarySvc"), destructor_7178, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ICounterSummarySvc_funcmem_bld);
}

//------Delayed data member builder for class ICounterSummarySvc -------------------
void __ICounterSummarySvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ICounterSummarySvc -------------------
void __ICounterSummarySvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7175, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3236c, type_3236c, type_7460, type_19632c), Reflex::Literal("addCounter"), method_7176, 0, ";name;;saveType=SaveSimpleCounter", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3236c, type_3236c, type_7458, type_19632c), Reflex::Literal("addCounter"), method_7177, 0, ";name;;saveType=SaveSimpleCounter", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class Property -------------------------------
static  void method_7184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Property*)o)->name)();
  else   (((const ::Property*)o)->name)();
}

static  void method_7185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Property*)o)->documentation)();
  else   (((const ::Property*)o)->documentation)();
}

static  void method_7186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Property*)o)->type_info)());
  else   (((const ::Property*)o)->type_info)();
}

static  void method_7187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::Property*)o)->type)());
  else   (((const ::Property*)o)->type)();
}

static  void method_7188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Property*)o)->load)(*(::Property*)arg[0]));
  else   (((const ::Property*)o)->load)(*(::Property*)arg[0]);
}

static  void method_7189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::Property*)o)->assign)(*(const ::Property*)arg[0]));
  else   (((::Property*)o)->assign)(*(const ::Property*)arg[0]);
}

static  void method_7190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::Property*)o)->toString)());
  else   (((const ::Property*)o)->toString)();
}

static  void method_7191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::Property*)o)->toStream)(*(::std::ostream*)arg[0]);
}

static  void method_7192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Property*)o)->fromString)(*(const ::std::string*)arg[0]));
  else   (((::Property*)o)->fromString)(*(const ::std::string*)arg[0]);
}

static  void method_7193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Property*)o)->readCallBack)());
  else   (((const ::Property*)o)->readCallBack)();
}

static  void method_7194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Property*)o)->updateCallBack)());
  else   (((const ::Property*)o)->updateCallBack)();
}

static  void method_7195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Property*)o)->declareReadHandler)((::PropertyCallbackFunctor*)arg[0]);
}

static  void method_7196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Property*)o)->declareUpdateHandler)((::PropertyCallbackFunctor*)arg[0]);
}

static  void method_7197( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::Property*)o)->useReadHandler)();
}

static  void method_7198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::Property*)o)->useUpdateHandler)());
  else   (((::Property*)o)->useUpdateHandler)();
}

static void destructor_7199(void*, void * o, const std::vector<void*>&, void *) {
(((::Property*)o)->::Property::~Property)();
}
static  void method_7200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Property*)o)->clone)());
  else   (((const ::Property*)o)->clone)();
}

static  void method_7201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Property*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_7202( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Property*)o)->setDocumentation)(*(const ::std::string*)arg[0]);
}

static  void method_7203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Property*)o)->fillStream)(*(::std::ostream*)arg[0]);
  else   (((const ::Property*)o)->fillStream)(*(::std::ostream*)arg[0]);
}

//------Dictionary for class Property -------------------------------
void __Property_db_datamem(Reflex::Class*);
void __Property_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Property_datamem_bld(&__Property_db_datamem);
Reflex::GenreflexMemberBuilder __Property_funcmem_bld(&__Property_db_funcmem);
void __Property_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Property"), typeid(::Property), sizeof(::Property), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Property"), destructor_7199, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__Property_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Property_funcmem_bld);
}

//------Delayed data member builder for class Property -------------------
void __Property_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3236, Reflex::Literal("m_name"), OffsetOf(__shadow__::__Property, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_documentation"), OffsetOf(__shadow__::__Property, m_documentation), ::Reflex::PRIVATE)
  .AddDataMember(type_24182, Reflex::Literal("m_typeinfo"), OffsetOf(__shadow__::__Property, m_typeinfo), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_21026, Reflex::Literal("m_readCallBack"), OffsetOf(__shadow__::__Property, m_readCallBack), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_21026, Reflex::Literal("m_updateCallBack"), OffsetOf(__shadow__::__Property, m_updateCallBack), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Property -------------------
void __Property_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_7184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("documentation"), method_7185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type_info"), method_7186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("type"), method_7187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19969), Reflex::Literal("load"), method_7188, 0, "dest", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7834), Reflex::Literal("assign"), method_7189, 0, "source", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236), Reflex::Literal("toString"), method_7190, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7831), Reflex::Literal("toStream"), method_7191, 0, "out", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("fromString"), method_7192, 0, "value", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21022), Reflex::Literal("readCallBack"), method_7193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21022), Reflex::Literal("updateCallBack"), method_7194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_21026), Reflex::Literal("declareReadHandler"), method_7195, 0, "pf", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_21026), Reflex::Literal("declareUpdateHandler"), method_7196, 0, "pf", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("useReadHandler"), method_7197, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("useUpdateHandler"), method_7198, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11428), Reflex::Literal("clone"), method_7200, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setName"), method_7201, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setDocumentation"), method_7202, 0, "documentation", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7831, type_7831), Reflex::Literal("fillStream"), method_7203, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class IHistorySvc -------------------------------
static  void operator_7242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IHistorySvc*)o)->operator=)(*(const ::IHistorySvc*)arg[0]);
  else   (((::IHistorySvc*)o)->operator=)(*(const ::IHistorySvc*)arg[0]);
}

static  void method_7245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IHistorySvc*)o)->interfaceID)();
  else   (((::IHistorySvc*)o)->interfaceID)();
}

static  void method_7246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistorySvc*)o)->registerJob)());
  else   (((::IHistorySvc*)o)->registerJob)();
}

static  void method_7247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IHistorySvc*)o)->listProperties)());
  else   (((const ::IHistorySvc*)o)->listProperties)();
}

static  void method_7248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IHistorySvc*)o)->getJobHistory)());
  else   (((const ::IHistorySvc*)o)->getJobHistory)();
}

static  void method_7249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistorySvc*)o)->registerSvc)(*(const ::IService*)arg[0]));
  else   (((::IHistorySvc*)o)->registerSvc)(*(const ::IService*)arg[0]);
}

static  void method_7250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IHistorySvc*)o)->listProperties)(*(const ::IService*)arg[0]));
  else   (((const ::IHistorySvc*)o)->listProperties)(*(const ::IService*)arg[0]);
}

static  void method_7251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IHistorySvc*)o)->getServiceHistory)(*(const ::IService*)arg[0]));
  else   (((const ::IHistorySvc*)o)->getServiceHistory)(*(const ::IService*)arg[0]);
}

static  void method_7252( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::IHistorySvc*)o)->getServiceHistory)(*(::std::set<ServiceHistory*>*)arg[0]);
}

static  void method_7253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistorySvc*)o)->registerAlg)(*(const ::Algorithm*)arg[0]));
  else   (((::IHistorySvc*)o)->registerAlg)(*(const ::Algorithm*)arg[0]);
}

static  void method_7254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IHistorySvc*)o)->listProperties)(*(const ::Algorithm*)arg[0]));
  else   (((const ::IHistorySvc*)o)->listProperties)(*(const ::Algorithm*)arg[0]);
}

static  void method_7255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IHistorySvc*)o)->getAlgHistory)(*(const ::Algorithm*)arg[0]));
  else   (((const ::IHistorySvc*)o)->getAlgHistory)(*(const ::Algorithm*)arg[0]);
}

static  void method_7256( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::IHistorySvc*)o)->getAlgHistory)(*(::std::set<AlgorithmHistory*>*)arg[0]);
}

static  void method_7257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IHistorySvc*)o)->registerAlgTool)(*(const ::IAlgTool*)arg[0]));
  else   (((::IHistorySvc*)o)->registerAlgTool)(*(const ::IAlgTool*)arg[0]);
}

static  void method_7258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IHistorySvc*)o)->listProperties)(*(const ::IAlgTool*)arg[0]));
  else   (((const ::IHistorySvc*)o)->listProperties)(*(const ::IAlgTool*)arg[0]);
}

static  void method_7259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IHistorySvc*)o)->getAlgToolHistory)(*(const ::IAlgTool*)arg[0]));
  else   (((const ::IHistorySvc*)o)->getAlgToolHistory)(*(const ::IAlgTool*)arg[0]);
}

static  void method_7260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::IHistorySvc*)o)->getAlgToolHistory)(*(::std::set<AlgToolHistory*>*)arg[0]);
}

static  void method_7261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IHistorySvc*)o)->createDataHistoryObj)(*(const ::CLID*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]));
  else   (((::IHistorySvc*)o)->createDataHistoryObj)(*(const ::CLID*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
}

static  void method_7262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IHistorySvc*)o)->getDataHistory)(*(const ::CLID*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]));
  else   (((const ::IHistorySvc*)o)->getDataHistory)(*(const ::CLID*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
}

static void destructor_7263(void*, void * o, const std::vector<void*>&, void *) {
(((::IHistorySvc*)o)->::IHistorySvc::~IHistorySvc)();
}
static void method_x103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IHistorySvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IHistorySvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IHistorySvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IHistorySvc -------------------------------
void __IHistorySvc_db_datamem(Reflex::Class*);
void __IHistorySvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IHistorySvc_datamem_bld(&__IHistorySvc_db_datamem);
Reflex::GenreflexMemberBuilder __IHistorySvc_funcmem_bld(&__IHistorySvc_db_funcmem);
void __IHistorySvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IHistorySvc"), typeid(::IHistorySvc), sizeof(::IHistorySvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::IHistorySvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24194, type_24195), Reflex::Literal("operator="), operator_7242, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IHistorySvc"), destructor_7263, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IHistorySvc_funcmem_bld);
}

//------Delayed data member builder for class IHistorySvc -------------------
void __IHistorySvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IHistorySvc -------------------
void __IHistorySvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7245, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("registerJob"), method_7246, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("listProperties"), method_7247, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24196), Reflex::Literal("getJobHistory"), method_7248, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19914), Reflex::Literal("registerSvc"), method_7249, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19914), Reflex::Literal("listProperties"), method_7250, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24197, type_19914), Reflex::Literal("getServiceHistory"), method_7251, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24198), Reflex::Literal("getServiceHistory"), method_7252, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24199), Reflex::Literal("registerAlg"), method_7253, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24199), Reflex::Literal("listProperties"), method_7254, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24200, type_24199), Reflex::Literal("getAlgHistory"), method_7255, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24201), Reflex::Literal("getAlgHistory"), method_7256, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19864), Reflex::Literal("registerAlgTool"), method_7257, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_19864), Reflex::Literal("listProperties"), method_7258, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24202, type_19864), Reflex::Literal("getAlgToolHistory"), method_7259, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24203), Reflex::Literal("getAlgToolHistory"), method_7260, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24204, type_19456, type_6134, type_6134), Reflex::Literal("createDataHistoryObj"), method_7261, 0, "id;key;storeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24204, type_19456, type_6134, type_6134), Reflex::Literal("getDataHistory"), method_7262, 0, "id;key;storeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IAlgManager -------------------------------
static  void operator_7265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAlgManager*)o)->operator=)(*(const ::IAlgManager*)arg[0]);
  else   (((::IAlgManager*)o)->operator=)(*(const ::IAlgManager*)arg[0]);
}

static  void method_7268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAlgManager*)o)->interfaceID)();
  else   (((::IAlgManager*)o)->interfaceID)();
}

static  void method_7269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->addAlgorithm)((::IAlgorithm*)arg[0]));
  else   (((::IAlgManager*)o)->addAlgorithm)((::IAlgorithm*)arg[0]);
}

static  void method_7270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->removeAlgorithm)((::IAlgorithm*)arg[0]));
  else   (((::IAlgManager*)o)->removeAlgorithm)((::IAlgorithm*)arg[0]);
}

static  void method_7271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->createAlgorithm)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::IAlgorithm**)arg[2]));
    else     (((::IAlgManager*)o)->createAlgorithm)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::IAlgorithm**)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->createAlgorithm)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::IAlgorithm**)arg[2],
      *(bool*)arg[3]));
    else     (((::IAlgManager*)o)->createAlgorithm)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::IAlgorithm**)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_7272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IAlgManager*)o)->getAlgorithm)(*(const ::std::string*)arg[0],
    *(::IAlgorithm**)arg[1]));
  else   (((const ::IAlgManager*)o)->getAlgorithm)(*(const ::std::string*)arg[0],
    *(::IAlgorithm**)arg[1]);
}

static  void method_7273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IAlgManager*)o)->existsAlgorithm)(*(const ::std::string*)arg[0]));
  else   (((const ::IAlgManager*)o)->existsAlgorithm)(*(const ::std::string*)arg[0]);
}

static  void method_7274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IAlgManager*)o)->getAlgorithms)();
  else   (((const ::IAlgManager*)o)->getAlgorithms)();
}

static  void method_7275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->initializeAlgorithms)());
  else   (((::IAlgManager*)o)->initializeAlgorithms)();
}

static  void method_7276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->startAlgorithms)());
  else   (((::IAlgManager*)o)->startAlgorithms)();
}

static  void method_7277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->stopAlgorithms)());
  else   (((::IAlgManager*)o)->stopAlgorithms)();
}

static  void method_7278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->finalizeAlgorithms)());
  else   (((::IAlgManager*)o)->finalizeAlgorithms)();
}

static  void method_7279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->reinitializeAlgorithms)());
  else   (((::IAlgManager*)o)->reinitializeAlgorithms)();
}

static  void method_7280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAlgManager*)o)->restartAlgorithms)());
  else   (((::IAlgManager*)o)->restartAlgorithms)();
}

static  void method_7281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::IAlgManager*)o)->algorithm)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]);
    else     (((::IAlgManager*)o)->algorithm)(*(const ::Gaudi::Utils::TypeNameString*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::IAlgManager*)o)->algorithm)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(const bool*)arg[1]);
    else     (((::IAlgManager*)o)->algorithm)(*(const ::Gaudi::Utils::TypeNameString*)arg[0],
      *(const bool*)arg[1]);
  }
}

static void destructor_7282(void*, void * o, const std::vector<void*>&, void *) {
(((::IAlgManager*)o)->::IAlgManager::~IAlgManager)();
}
static void method_x104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IComponentManager")), ::Reflex::BaseOffset< ::IAlgManager,::IComponentManager >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::IAlgManager,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAlgManager,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAlgManager -------------------------------
void __IAlgManager_db_datamem(Reflex::Class*);
void __IAlgManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAlgManager_datamem_bld(&__IAlgManager_db_datamem);
Reflex::GenreflexMemberBuilder __IAlgManager_funcmem_bld(&__IAlgManager_db_funcmem);
void __IAlgManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAlgManager"), typeid(::IAlgManager), sizeof(::IAlgManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_556, ::Reflex::BaseOffset< ::IAlgManager, ::IComponentManager >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24205, type_24206), Reflex::Literal("operator="), operator_7265, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IAlgManager"), destructor_7282, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAlgManager_funcmem_bld);
}

//------Delayed data member builder for class IAlgManager -------------------
void __IAlgManager_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAlgManager -------------------
void __IAlgManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7268, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20948), Reflex::Literal("addAlgorithm"), method_7269, 0, "alg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20948), Reflex::Literal("removeAlgorithm"), method_7270, 0, "alg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_20950, type_4206), Reflex::Literal("createAlgorithm"), method_7271, 0, "algtype;algname;alg;managed=false", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_20950), Reflex::Literal("getAlgorithm"), method_7272, 0, "name;alg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_6134), Reflex::Literal("existsAlgorithm"), method_7273, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24207), Reflex::Literal("getAlgorithms"), method_7274, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initializeAlgorithms"), method_7275, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("startAlgorithms"), method_7276, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stopAlgorithms"), method_7277, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalizeAlgorithms"), method_7278, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitializeAlgorithms"), method_7279, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restartAlgorithms"), method_7280, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20951, type_20039, type_4206c), Reflex::Literal("algorithm"), method_7281, 0, "typeName;createIf=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IChronoSvc -------------------------------
static  void operator_7421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IChronoSvc*)o)->operator=)(*(const ::IChronoSvc*)arg[0]);
  else   (((::IChronoSvc*)o)->operator=)(*(const ::IChronoSvc*)arg[0]);
}

static  void method_7424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IChronoSvc*)o)->interfaceID)();
  else   (((::IChronoSvc*)o)->interfaceID)();
}

static  void method_7425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IChronoSvc*)o)->chronoStart)(*(const ::std::string*)arg[0]));
  else   (((::IChronoSvc*)o)->chronoStart)(*(const ::std::string*)arg[0]);
}

static  void method_7426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IChronoSvc*)o)->chronoStop)(*(const ::std::string*)arg[0]));
  else   (((::IChronoSvc*)o)->chronoStop)(*(const ::std::string*)arg[0]);
}

static  void method_7427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::IChronoSvc*)o)->chronoDelta)(*(const ::std::string*)arg[0],
    *(::IChronoSvc::ChronoType*)arg[1]));
  else   (((::IChronoSvc*)o)->chronoDelta)(*(const ::std::string*)arg[0],
    *(::IChronoSvc::ChronoType*)arg[1]);
}

static  void method_7428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IChronoSvc*)o)->chronoPrint)(*(const ::std::string*)arg[0]);
}

static  void method_7429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::IChronoSvc*)o)->chronoStatus)(*(const ::std::string*)arg[0]));
  else   (((::IChronoSvc*)o)->chronoStatus)(*(const ::std::string*)arg[0]);
}

static  void method_7430( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IChronoSvc*)o)->chrono)(*(const ::std::string*)arg[0]));
  else   (((const ::IChronoSvc*)o)->chrono)(*(const ::std::string*)arg[0]);
}

static void method_x105( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IChronoSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IChronoSvc -------------------------------
void __IChronoSvc_db_datamem(Reflex::Class*);
void __IChronoSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IChronoSvc_datamem_bld(&__IChronoSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IChronoSvc_funcmem_bld(&__IChronoSvc_db_funcmem);
void __IChronoSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IChronoSvc"), typeid(::IChronoSvc), sizeof(::IChronoSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IChronoSvc, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddTypedef(type_3236, Reflex::Literal("IChronoSvc::ChronoTag"))
  .AddTypedef(type_2603, Reflex::Literal("IChronoSvc::ChronoTime"))
  .AddEnum(Reflex::Literal("IChronoSvc::ChronoStatus"), Reflex::Literal("UNKNOWN=0;RUNNING=1;STOPPED=2"), &typeid(IChronoSvc::ChronoStatus), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("IChronoSvc::ChronoType"), Reflex::Literal("USER=0;KERNEL=1;ELAPSED=2"), &typeid(IChronoSvc::ChronoType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24293, type_24294), Reflex::Literal("operator="), operator_7421, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IChronoSvc_funcmem_bld);
}

//------Delayed data member builder for class IChronoSvc -------------------
void __IChronoSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IChronoSvc -------------------
void __IChronoSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7424, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24295, type_6134), Reflex::Literal("chronoStart"), method_7425, 0, "t", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24296, type_6134), Reflex::Literal("chronoStop"), method_7426, 0, "t", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603, type_6134, type_7420), Reflex::Literal("chronoDelta"), method_7427, 0, "t;f", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("chronoPrint"), method_7428, 0, "t", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7419, type_6134), Reflex::Literal("chronoStatus"), method_7429, 0, "t", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24296, type_6134), Reflex::Literal("chrono"), method_7430, 0, "t", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class ISelectStatement -------------------------------
static  void operator_7434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISelectStatement*)o)->operator=)(*(const ::ISelectStatement*)arg[0]);
  else   (((::ISelectStatement*)o)->operator=)(*(const ::ISelectStatement*)arg[0]);
}

static  void method_7437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ISelectStatement*)o)->interfaceID)();
  else   (((::ISelectStatement*)o)->interfaceID)();
}

static  void method_7438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::ISelectStatement*)o)->type)());
  else   (((const ::ISelectStatement*)o)->type)();
}

static  void method_7439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ISelectStatement*)o)->criteria)();
  else   (((const ::ISelectStatement*)o)->criteria)();
}

static  void method_7440( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ISelectStatement*)o)->setCriteria)(*(const ::std::string*)arg[0]);
}

static  void method_7441( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::ISelectStatement*)o)->setActive)();
  }
  else if ( arg.size() == 1 ) { 
    (((::ISelectStatement*)o)->setActive)(*(bool*)arg[0]);
  }
}

static  void method_7442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ISelectStatement*)o)->isActive)());
  else   (((const ::ISelectStatement*)o)->isActive)();
}

static  void operator_7443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::ISelectStatement*)o)->operator())((void*)arg[0]));
  else   (((::ISelectStatement*)o)->operator())((void*)arg[0]);
}

static void destructor_7444(void*, void * o, const std::vector<void*>&, void *) {
(((::ISelectStatement*)o)->::ISelectStatement::~ISelectStatement)();
}
static void method_x106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::ISelectStatement,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ISelectStatement -------------------------------
void __ISelectStatement_db_datamem(Reflex::Class*);
void __ISelectStatement_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ISelectStatement_datamem_bld(&__ISelectStatement_db_datamem);
Reflex::GenreflexMemberBuilder __ISelectStatement_funcmem_bld(&__ISelectStatement_db_funcmem);
void __ISelectStatement_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ISelectStatement"), typeid(::ISelectStatement), sizeof(::ISelectStatement), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::ISelectStatement, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("ISelectStatement::SelectType"), Reflex::Literal("FUNCTION=2;STRING=4;FULL=8;OTHER=16"), &typeid(ISelectStatement::SelectType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24297, type_24298), Reflex::Literal("operator="), operator_7434, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ISelectStatement"), destructor_7444, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__ISelectStatement_funcmem_bld);
}

//------Delayed data member builder for class ISelectStatement -------------------
void __ISelectStatement_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ISelectStatement -------------------
void __ISelectStatement_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7437, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("type"), method_7438, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("criteria"), method_7439, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setCriteria"), method_7440, 0, "crit", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4206), Reflex::Literal("setActive"), method_7441, 0, "flag=true", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isActive"), method_7442, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_1454), Reflex::Literal("operator()"), operator_7443, 0, "val", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::OPERATOR);
}
//------Stub functions for class IMagneticFieldSvc -------------------------------
static  void operator_7451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IMagneticFieldSvc*)o)->operator=)(*(const ::IMagneticFieldSvc*)arg[0]);
  else   (((::IMagneticFieldSvc*)o)->operator=)(*(const ::IMagneticFieldSvc*)arg[0]);
}

static  void method_7454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IMagneticFieldSvc*)o)->interfaceID)();
  else   (((::IMagneticFieldSvc*)o)->interfaceID)();
}

static  void method_7455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::IMagneticFieldSvc*)o)->fieldVector)(*(const ::ROOT::Math::XYZPoint*)arg[0],
    *(::ROOT::Math::XYZVector*)arg[1]));
  else   (((const ::IMagneticFieldSvc*)o)->fieldVector)(*(const ::ROOT::Math::XYZPoint*)arg[0],
    *(::ROOT::Math::XYZVector*)arg[1]);
}

static void destructor_7456(void*, void * o, const std::vector<void*>&, void *) {
(((::IMagneticFieldSvc*)o)->::IMagneticFieldSvc::~IMagneticFieldSvc)();
}
static void method_x107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IMagneticFieldSvc,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IMagneticFieldSvc,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IMagneticFieldSvc,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IMagneticFieldSvc -------------------------------
void __IMagneticFieldSvc_db_datamem(Reflex::Class*);
void __IMagneticFieldSvc_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IMagneticFieldSvc_datamem_bld(&__IMagneticFieldSvc_db_datamem);
Reflex::GenreflexMemberBuilder __IMagneticFieldSvc_funcmem_bld(&__IMagneticFieldSvc_db_funcmem);
void __IMagneticFieldSvc_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IMagneticFieldSvc"), typeid(::IMagneticFieldSvc), sizeof(::IMagneticFieldSvc), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::IMagneticFieldSvc, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24301, type_24302), Reflex::Literal("operator="), operator_7451, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IMagneticFieldSvc"), destructor_7456, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IMagneticFieldSvc_funcmem_bld);
}

//------Delayed data member builder for class IMagneticFieldSvc -------------------
void __IMagneticFieldSvc_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IMagneticFieldSvc -------------------
void __IMagneticFieldSvc_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7454, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24303, type_24304), Reflex::Literal("fieldVector"), method_7455, 0, "xyz;fvec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IValidity -------------------------------
static  void operator_7462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IValidity*)o)->operator=)(*(const ::IValidity*)arg[0]);
  else   (((::IValidity*)o)->operator=)(*(const ::IValidity*)arg[0]);
}

static  void method_7465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IValidity*)o)->isValid)());
  else   (((const ::IValidity*)o)->isValid)();
}

static  void method_7466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IValidity*)o)->isValid)(*(const ::Gaudi::Time*)arg[0]));
  else   (((const ::IValidity*)o)->isValid)(*(const ::Gaudi::Time*)arg[0]);
}

static  void method_7467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IValidity*)o)->validSince)();
  else   (((const ::IValidity*)o)->validSince)();
}

static  void method_7468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IValidity*)o)->validTill)();
  else   (((const ::IValidity*)o)->validTill)();
}

static  void method_7469( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IValidity*)o)->setValidity)(*(const ::Gaudi::Time*)arg[0],
    *(const ::Gaudi::Time*)arg[1]);
}

static  void method_7470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IValidity*)o)->setValiditySince)(*(const ::Gaudi::Time*)arg[0]);
}

static  void method_7471( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IValidity*)o)->setValidityTill)(*(const ::Gaudi::Time*)arg[0]);
}

static void destructor_7472(void*, void * o, const std::vector<void*>&, void *) {
(((::IValidity*)o)->::IValidity::~IValidity)();
}
//------Dictionary for class IValidity -------------------------------
void __IValidity_db_datamem(Reflex::Class*);
void __IValidity_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IValidity_datamem_bld(&__IValidity_db_datamem);
Reflex::GenreflexMemberBuilder __IValidity_funcmem_bld(&__IValidity_db_funcmem);
void __IValidity_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IValidity"), typeid(::IValidity), sizeof(::IValidity), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24308, type_24309), Reflex::Literal("operator="), operator_7462, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IValidity"), destructor_7472, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IValidity_funcmem_bld);
}

//------Delayed data member builder for class IValidity -------------------
void __IValidity_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IValidity -------------------
void __IValidity_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isValid"), method_7465, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_4403), Reflex::Literal("isValid"), method_7466, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4403), Reflex::Literal("validSince"), method_7467, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4403), Reflex::Literal("validTill"), method_7468, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4403, type_4403), Reflex::Literal("setValidity"), method_7469, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4403), Reflex::Literal("setValiditySince"), method_7470, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4403), Reflex::Literal("setValidityTill"), method_7471, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IAppMgrUI -------------------------------
static  void operator_7546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAppMgrUI*)o)->operator=)(*(const ::IAppMgrUI*)arg[0]);
  else   (((::IAppMgrUI*)o)->operator=)(*(const ::IAppMgrUI*)arg[0]);
}

static  void method_7549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAppMgrUI*)o)->interfaceID)();
  else   (((::IAppMgrUI*)o)->interfaceID)();
}

static  void method_7550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->run)());
  else   (((::IAppMgrUI*)o)->run)();
}

static  void method_7551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->configure)());
  else   (((::IAppMgrUI*)o)->configure)();
}

static  void method_7552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->terminate)());
  else   (((::IAppMgrUI*)o)->terminate)();
}

static  void method_7553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->initialize)());
  else   (((::IAppMgrUI*)o)->initialize)();
}

static  void method_7554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->finalize)());
  else   (((::IAppMgrUI*)o)->finalize)();
}

static  void method_7555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->nextEvent)(*(int*)arg[0]));
  else   (((::IAppMgrUI*)o)->nextEvent)(*(int*)arg[0]);
}

static  void method_7556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IAppMgrUI*)o)->name)();
  else   (((const ::IAppMgrUI*)o)->name)();
}

static  void method_7557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->start)());
  else   (((::IAppMgrUI*)o)->start)();
}

static  void method_7558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->stop)());
  else   (((::IAppMgrUI*)o)->stop)();
}

static  void method_7559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->reinitialize)());
  else   (((::IAppMgrUI*)o)->reinitialize)();
}

static  void method_7560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAppMgrUI*)o)->restart)());
  else   (((::IAppMgrUI*)o)->restart)();
}

static  void method_7561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IAppMgrUI*)o)->FSMState)());
  else   (((const ::IAppMgrUI*)o)->FSMState)();
}

static void destructor_7562(void*, void * o, const std::vector<void*>&, void *) {
(((::IAppMgrUI*)o)->::IAppMgrUI::~IAppMgrUI)();
}
static void method_x108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAppMgrUI,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAppMgrUI -------------------------------
void __IAppMgrUI_db_datamem(Reflex::Class*);
void __IAppMgrUI_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAppMgrUI_datamem_bld(&__IAppMgrUI_db_datamem);
Reflex::GenreflexMemberBuilder __IAppMgrUI_funcmem_bld(&__IAppMgrUI_db_funcmem);
void __IAppMgrUI_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAppMgrUI"), typeid(::IAppMgrUI), sizeof(::IAppMgrUI), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IAppMgrUI, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24312, type_24313), Reflex::Literal("operator="), operator_7546, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IAppMgrUI"), destructor_7562, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAppMgrUI_funcmem_bld);
}

//------Delayed data member builder for class IAppMgrUI -------------------
void __IAppMgrUI_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAppMgrUI -------------------
void __IAppMgrUI_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7549, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("run"), method_7550, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_7551, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_7552, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_7553, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_7554, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_142), Reflex::Literal("nextEvent"), method_7555, 0, "maxevt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_7556, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_7557, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_7558, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_7559, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_7560, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_7561, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IAddressCreator -------------------------------
static  void operator_7601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAddressCreator*)o)->operator=)(*(const ::IAddressCreator*)arg[0]);
  else   (((::IAddressCreator*)o)->operator=)(*(const ::IAddressCreator*)arg[0]);
}

static  void method_7604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IAddressCreator*)o)->interfaceID)();
  else   (((::IAddressCreator*)o)->interfaceID)();
}

static  void method_7605( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAddressCreator*)o)->createAddress)(*(long*)arg[0],
    *(const ::CLID*)arg[1],
    (const ::std::string*)arg[2],
    (const unsigned long*)arg[3],
    *(::IOpaqueAddress**)arg[4]));
  else   (((::IAddressCreator*)o)->createAddress)(*(long*)arg[0],
    *(const ::CLID*)arg[1],
    (const ::std::string*)arg[2],
    (const unsigned long*)arg[3],
    *(::IOpaqueAddress**)arg[4]);
}

static  void method_7606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAddressCreator*)o)->convertAddress)((const ::IOpaqueAddress*)arg[0],
    *(::std::string*)arg[1]));
  else   (((::IAddressCreator*)o)->convertAddress)((const ::IOpaqueAddress*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_7607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IAddressCreator*)o)->createAddress)(*(long*)arg[0],
    *(const ::CLID*)arg[1],
    *(const ::std::string*)arg[2],
    *(::IOpaqueAddress**)arg[3]));
  else   (((::IAddressCreator*)o)->createAddress)(*(long*)arg[0],
    *(const ::CLID*)arg[1],
    *(const ::std::string*)arg[2],
    *(::IOpaqueAddress**)arg[3]);
}

static void destructor_7608(void*, void * o, const std::vector<void*>&, void *) {
(((::IAddressCreator*)o)->::IAddressCreator::~IAddressCreator)();
}
static void method_x109( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IAddressCreator,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IAddressCreator -------------------------------
void __IAddressCreator_db_datamem(Reflex::Class*);
void __IAddressCreator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IAddressCreator_datamem_bld(&__IAddressCreator_db_datamem);
Reflex::GenreflexMemberBuilder __IAddressCreator_funcmem_bld(&__IAddressCreator_db_funcmem);
void __IAddressCreator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IAddressCreator"), typeid(::IAddressCreator), sizeof(::IAddressCreator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IAddressCreator, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24314, type_24315), Reflex::Literal("operator="), operator_7601, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IAddressCreator"), destructor_7608, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x109, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IAddressCreator_funcmem_bld);
}

//------Delayed data member builder for class IAddressCreator -------------------
void __IAddressCreator_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IAddressCreator -------------------
void __IAddressCreator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7604, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_26, type_19456, type_19925, type_11902, type_19942), Reflex::Literal("createAddress"), method_7605, 0, "svc_type;clid;par;ipar;refpAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_24193, type_19991), Reflex::Literal("convertAddress"), method_7606, 0, "pAddress;refAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_26, type_19456, type_6134, type_19942), Reflex::Literal("createAddress"), method_7607, 0, "svc_type;clid;refAddress;refpAddress", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class SmartRefVector<KeyedObject<long unsigned int> > -------------------------------
static void destructor_7643(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<KeyedObject<unsigned long> >*)o)->::SmartRefVector<KeyedObject<unsigned long> >::~SmartRefVector)();
}
static void constructor_7645( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<unsigned long> >();
  else ::new(mem) ::SmartRefVector<KeyedObject<unsigned long> >();
}

static void constructor_7646( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<unsigned long> >(*(const ::SmartRefVector<KeyedObject<unsigned long> >*)arg[0]);
  else ::new(mem) ::SmartRefVector<KeyedObject<unsigned long> >(*(const ::SmartRefVector<KeyedObject<unsigned long> >*)arg[0]);
}

static  void operator_7647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_7648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_7649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_7650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_7651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<unsigned long> >*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned long> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<unsigned long> >*)arg[0]);
}

static  void method_7652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->type)());
  else   (((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->type)();
}

static  void method_7653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned long> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned long> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_7654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<unsigned long> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2510( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<unsigned long> >,::std::vector<SmartRef<KeyedObject<unsigned long> > > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<unsigned long> >,std::allocator<SmartRef<KeyedObject<unsigned long> > > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<unsigned long> >,::std::_Vector_base<SmartRef<KeyedObject<unsigned long> >,std::allocator<SmartRef<KeyedObject<unsigned long> > > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<KeyedObject<long unsigned int> > -------------------------------
void __SmartRefVector_KeyedObject_unsignedslong_s__db_datamem(Reflex::Class*);
void __SmartRefVector_KeyedObject_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_unsignedslong_s__datamem_bld(&__SmartRefVector_KeyedObject_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_unsignedslong_s__funcmem_bld(&__SmartRefVector_KeyedObject_unsignedslong_s__db_funcmem);
void __SmartRefVector_KeyedObject_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<KeyedObject<unsigned long> >"), typeid(::SmartRefVector<KeyedObject<unsigned long> >), sizeof(::SmartRefVector<KeyedObject<unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3158, ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<unsigned long> >, ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2743, Reflex::Literal("SmartRefVector<KeyedObject<unsigned long> >::_Entry"))
  .AddTypedef(type_3158, Reflex::Literal("SmartRefVector<KeyedObject<unsigned long> >::_Base"))
  .AddTypedef(type_6684, Reflex::Literal("SmartRefVector<KeyedObject<unsigned long> >::_BaseConstIter"))
  .AddTypedef(type_2743, Reflex::Literal("SmartRefVector<KeyedObject<unsigned long> >::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_7643, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_7645, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7819), Reflex::Literal("SmartRefVector"), constructor_7646, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2510, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_KeyedObject_unsignedslong_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_KeyedObject_unsignedslong_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<KeyedObject<long unsigned int> > -------------------
void __SmartRefVector_KeyedObject_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_unsignedslong_s_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_unsignedslong_s_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<KeyedObject<long unsigned int> > -------------------
void __SmartRefVector_KeyedObject_unsignedslong_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5649, type_10166), Reflex::Literal("operator()"), operator_7647, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7819, type_10234), Reflex::Literal("operator()"), operator_7648, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5649, type_19429), Reflex::Literal("operator()"), operator_7649, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7819, type_19998), Reflex::Literal("operator()"), operator_7650, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5649, type_7819), Reflex::Literal("operator="), operator_7651, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_7652, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRefs"), method_7653, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRefs"), method_7654, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<KeyedObject<long int> > -------------------------------
static void destructor_7661(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<KeyedObject<long> >*)o)->::SmartRefVector<KeyedObject<long> >::~SmartRefVector)();
}
static void constructor_7663( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<long> >();
  else ::new(mem) ::SmartRefVector<KeyedObject<long> >();
}

static void constructor_7664( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<long> >(*(const ::SmartRefVector<KeyedObject<long> >*)arg[0]);
  else ::new(mem) ::SmartRefVector<KeyedObject<long> >(*(const ::SmartRefVector<KeyedObject<long> >*)arg[0]);
}

static  void operator_7665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<long> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<long> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_7666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_7667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<long> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<long> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_7668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<long> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<long> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_7669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<long> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<long> >*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<long> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<long> >*)arg[0]);
}

static  void method_7670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<KeyedObject<long> >*)o)->type)());
  else   (((const ::SmartRefVector<KeyedObject<long> >*)o)->type)();
}

static  void method_7671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<long> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<long> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_7672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<long> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<long> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2511( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<long> >,::std::vector<SmartRef<KeyedObject<long> > > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<long> >,std::allocator<SmartRef<KeyedObject<long> > > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<long> >,::std::_Vector_base<SmartRef<KeyedObject<long> >,std::allocator<SmartRef<KeyedObject<long> > > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<KeyedObject<long int> > -------------------------------
void __SmartRefVector_KeyedObject_long_s__db_datamem(Reflex::Class*);
void __SmartRefVector_KeyedObject_long_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_long_s__datamem_bld(&__SmartRefVector_KeyedObject_long_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_long_s__funcmem_bld(&__SmartRefVector_KeyedObject_long_s__db_funcmem);
void __SmartRefVector_KeyedObject_long_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<KeyedObject<long> >"), typeid(::SmartRefVector<KeyedObject<long> >), sizeof(::SmartRefVector<KeyedObject<long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3159, ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<long> >, ::std::vector<SmartRef<KeyedObject<long> > > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2744, Reflex::Literal("SmartRefVector<KeyedObject<long> >::_Entry"))
  .AddTypedef(type_3159, Reflex::Literal("SmartRefVector<KeyedObject<long> >::_Base"))
  .AddTypedef(type_6686, Reflex::Literal("SmartRefVector<KeyedObject<long> >::_BaseConstIter"))
  .AddTypedef(type_2744, Reflex::Literal("SmartRefVector<KeyedObject<long> >::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_7661, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_7663, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7820), Reflex::Literal("SmartRefVector"), constructor_7664, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_KeyedObject_long_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_KeyedObject_long_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<KeyedObject<long int> > -------------------
void __SmartRefVector_KeyedObject_long_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_long_s_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_long_s_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<KeyedObject<long int> > -------------------
void __SmartRefVector_KeyedObject_long_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5650, type_10166), Reflex::Literal("operator()"), operator_7665, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7820, type_10234), Reflex::Literal("operator()"), operator_7666, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5650, type_19429), Reflex::Literal("operator()"), operator_7667, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7820, type_19998), Reflex::Literal("operator()"), operator_7668, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5650, type_7820), Reflex::Literal("operator="), operator_7669, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_7670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRefs"), method_7671, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRefs"), method_7672, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<KeyedObject<unsigned int> > -------------------------------
static void destructor_7679(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<KeyedObject<unsigned int> >*)o)->::SmartRefVector<KeyedObject<unsigned int> >::~SmartRefVector)();
}
static void constructor_7681( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<unsigned int> >();
  else ::new(mem) ::SmartRefVector<KeyedObject<unsigned int> >();
}

static void constructor_7682( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<unsigned int> >(*(const ::SmartRefVector<KeyedObject<unsigned int> >*)arg[0]);
  else ::new(mem) ::SmartRefVector<KeyedObject<unsigned int> >(*(const ::SmartRefVector<KeyedObject<unsigned int> >*)arg[0]);
}

static  void operator_7683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_7684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_7685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_7686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_7687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<unsigned int> >*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned int> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<unsigned int> >*)arg[0]);
}

static  void method_7688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->type)());
  else   (((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->type)();
}

static  void method_7689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<unsigned int> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<unsigned int> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_7690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<unsigned int> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2512( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<unsigned int> >,::std::vector<SmartRef<KeyedObject<unsigned int> > > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<unsigned int> >,::std::_Vector_base<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<KeyedObject<unsigned int> > -------------------------------
void __SmartRefVector_KeyedObject_unsignedsint_s__db_datamem(Reflex::Class*);
void __SmartRefVector_KeyedObject_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_unsignedsint_s__datamem_bld(&__SmartRefVector_KeyedObject_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_unsignedsint_s__funcmem_bld(&__SmartRefVector_KeyedObject_unsignedsint_s__db_funcmem);
void __SmartRefVector_KeyedObject_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<KeyedObject<unsigned int> >"), typeid(::SmartRefVector<KeyedObject<unsigned int> >), sizeof(::SmartRefVector<KeyedObject<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3160, ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<unsigned int> >, ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2745, Reflex::Literal("SmartRefVector<KeyedObject<unsigned int> >::_Entry"))
  .AddTypedef(type_3160, Reflex::Literal("SmartRefVector<KeyedObject<unsigned int> >::_Base"))
  .AddTypedef(type_6688, Reflex::Literal("SmartRefVector<KeyedObject<unsigned int> >::_BaseConstIter"))
  .AddTypedef(type_2745, Reflex::Literal("SmartRefVector<KeyedObject<unsigned int> >::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_7679, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_7681, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7821), Reflex::Literal("SmartRefVector"), constructor_7682, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2512, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_KeyedObject_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_KeyedObject_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<KeyedObject<unsigned int> > -------------------
void __SmartRefVector_KeyedObject_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_unsignedsint_s_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_unsignedsint_s_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<KeyedObject<unsigned int> > -------------------
void __SmartRefVector_KeyedObject_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5651, type_10166), Reflex::Literal("operator()"), operator_7683, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7821, type_10234), Reflex::Literal("operator()"), operator_7684, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5651, type_19429), Reflex::Literal("operator()"), operator_7685, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7821, type_19998), Reflex::Literal("operator()"), operator_7686, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5651, type_7821), Reflex::Literal("operator="), operator_7687, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_7688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRefs"), method_7689, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRefs"), method_7690, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<KeyedObject<int> > -------------------------------
static void destructor_7697(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<KeyedObject<int> >*)o)->::SmartRefVector<KeyedObject<int> >::~SmartRefVector)();
}
static void constructor_7699( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<int> >();
  else ::new(mem) ::SmartRefVector<KeyedObject<int> >();
}

static void constructor_7700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<KeyedObject<int> >(*(const ::SmartRefVector<KeyedObject<int> >*)arg[0]);
  else ::new(mem) ::SmartRefVector<KeyedObject<int> >(*(const ::SmartRefVector<KeyedObject<int> >*)arg[0]);
}

static  void operator_7701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<int> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<int> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_7702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_7703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<int> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<int> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_7704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<int> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<int> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_7705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<int> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<int> >*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<int> >*)o)->operator=)(*(const ::SmartRefVector<KeyedObject<int> >*)arg[0]);
}

static  void method_7706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<KeyedObject<int> >*)o)->type)());
  else   (((const ::SmartRefVector<KeyedObject<int> >*)o)->type)();
}

static  void method_7707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<KeyedObject<int> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<KeyedObject<int> >*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_7708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<KeyedObject<int> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<KeyedObject<int> >*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2513( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<KeyedObject<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<int> >,::std::vector<SmartRef<KeyedObject<int> > > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > >")), ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<int> >,::std::_Vector_base<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<KeyedObject<int> > -------------------------------
void __SmartRefVector_KeyedObject_int_s__db_datamem(Reflex::Class*);
void __SmartRefVector_KeyedObject_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_int_s__datamem_bld(&__SmartRefVector_KeyedObject_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_KeyedObject_int_s__funcmem_bld(&__SmartRefVector_KeyedObject_int_s__db_funcmem);
void __SmartRefVector_KeyedObject_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<KeyedObject<int> >"), typeid(::SmartRefVector<KeyedObject<int> >), sizeof(::SmartRefVector<KeyedObject<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3161, ::Reflex::BaseOffset< ::SmartRefVector<KeyedObject<int> >, ::std::vector<SmartRef<KeyedObject<int> > > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2746, Reflex::Literal("SmartRefVector<KeyedObject<int> >::_Entry"))
  .AddTypedef(type_3161, Reflex::Literal("SmartRefVector<KeyedObject<int> >::_Base"))
  .AddTypedef(type_6690, Reflex::Literal("SmartRefVector<KeyedObject<int> >::_BaseConstIter"))
  .AddTypedef(type_2746, Reflex::Literal("SmartRefVector<KeyedObject<int> >::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_7697, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_7699, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7822), Reflex::Literal("SmartRefVector"), constructor_7700, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2513, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_KeyedObject_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_KeyedObject_int_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<KeyedObject<int> > -------------------
void __SmartRefVector_KeyedObject_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_int_s_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_KeyedObject_int_s_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<KeyedObject<int> > -------------------
void __SmartRefVector_KeyedObject_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5652, type_10166), Reflex::Literal("operator()"), operator_7701, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7822, type_10234), Reflex::Literal("operator()"), operator_7702, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5652, type_19429), Reflex::Literal("operator()"), operator_7703, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7822, type_19998), Reflex::Literal("operator()"), operator_7704, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5652, type_7822), Reflex::Literal("operator="), operator_7705, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_7706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRefs"), method_7707, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRefs"), method_7708, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<ObjectContainerBase> -------------------------------
static void destructor_7715(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<ObjectContainerBase>*)o)->::SmartRefVector<ObjectContainerBase>::~SmartRefVector)();
}
static void constructor_7717( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<ObjectContainerBase>();
  else ::new(mem) ::SmartRefVector<ObjectContainerBase>();
}

static void constructor_7718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<ObjectContainerBase>(*(const ::SmartRefVector<ObjectContainerBase>*)arg[0]);
  else ::new(mem) ::SmartRefVector<ObjectContainerBase>(*(const ::SmartRefVector<ObjectContainerBase>*)arg[0]);
}

static  void operator_7719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ObjectContainerBase>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<ObjectContainerBase>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_7720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<ObjectContainerBase>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<ObjectContainerBase>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_7721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ObjectContainerBase>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<ObjectContainerBase>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_7722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<ObjectContainerBase>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<ObjectContainerBase>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_7723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ObjectContainerBase>*)o)->operator=)(*(const ::SmartRefVector<ObjectContainerBase>*)arg[0]);
  else   (((::SmartRefVector<ObjectContainerBase>*)o)->operator=)(*(const ::SmartRefVector<ObjectContainerBase>*)arg[0]);
}

static  void method_7724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<ObjectContainerBase>*)o)->type)());
  else   (((const ::SmartRefVector<ObjectContainerBase>*)o)->type)();
}

static  void method_7725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ObjectContainerBase>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<ObjectContainerBase>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_7726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<ObjectContainerBase>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<ObjectContainerBase>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2514( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ObjectContainerBase> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ObjectContainerBase> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ObjectContainerBase> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ObjectContainerBase> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ObjectContainerBase> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >")), ::Reflex::BaseOffset< ::SmartRefVector<ObjectContainerBase>,::std::vector<SmartRef<ObjectContainerBase> > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > >")), ::Reflex::BaseOffset< ::SmartRefVector<ObjectContainerBase>,::std::_Vector_base<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<ObjectContainerBase> -------------------------------
void __SmartRefVector_ObjectContainerBase__db_datamem(Reflex::Class*);
void __SmartRefVector_ObjectContainerBase__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_ObjectContainerBase__datamem_bld(&__SmartRefVector_ObjectContainerBase__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_ObjectContainerBase__funcmem_bld(&__SmartRefVector_ObjectContainerBase__db_funcmem);
void __SmartRefVector_ObjectContainerBase__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<ObjectContainerBase>"), typeid(::SmartRefVector<ObjectContainerBase>), sizeof(::SmartRefVector<ObjectContainerBase>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3162, ::Reflex::BaseOffset< ::SmartRefVector<ObjectContainerBase>, ::std::vector<SmartRef<ObjectContainerBase> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2747, Reflex::Literal("SmartRefVector<ObjectContainerBase>::_Entry"))
  .AddTypedef(type_3162, Reflex::Literal("SmartRefVector<ObjectContainerBase>::_Base"))
  .AddTypedef(type_6692, Reflex::Literal("SmartRefVector<ObjectContainerBase>::_BaseConstIter"))
  .AddTypedef(type_2747, Reflex::Literal("SmartRefVector<ObjectContainerBase>::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_7715, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_7717, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7823), Reflex::Literal("SmartRefVector"), constructor_7718, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2514, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_ObjectContainerBase__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_ObjectContainerBase__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<ObjectContainerBase> -------------------
void __SmartRefVector_ObjectContainerBase__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_ObjectContainerBase_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_ObjectContainerBase_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<ObjectContainerBase> -------------------
void __SmartRefVector_ObjectContainerBase__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5653, type_10166), Reflex::Literal("operator()"), operator_7719, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7823, type_10234), Reflex::Literal("operator()"), operator_7720, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5653, type_19429), Reflex::Literal("operator()"), operator_7721, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7823, type_19998), Reflex::Literal("operator()"), operator_7722, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5653, type_7823), Reflex::Literal("operator="), operator_7723, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_7724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRefs"), method_7725, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRefs"), method_7726, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<ContainedObject> -------------------------------
static void destructor_7733(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<ContainedObject>*)o)->::SmartRefVector<ContainedObject>::~SmartRefVector)();
}
static void constructor_7735( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<ContainedObject>();
  else ::new(mem) ::SmartRefVector<ContainedObject>();
}

static void constructor_7736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<ContainedObject>(*(const ::SmartRefVector<ContainedObject>*)arg[0]);
  else ::new(mem) ::SmartRefVector<ContainedObject>(*(const ::SmartRefVector<ContainedObject>*)arg[0]);
}

static  void operator_7737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ContainedObject>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<ContainedObject>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_7738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<ContainedObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<ContainedObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_7739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ContainedObject>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<ContainedObject>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_7740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<ContainedObject>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<ContainedObject>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_7741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ContainedObject>*)o)->operator=)(*(const ::SmartRefVector<ContainedObject>*)arg[0]);
  else   (((::SmartRefVector<ContainedObject>*)o)->operator=)(*(const ::SmartRefVector<ContainedObject>*)arg[0]);
}

static  void method_7742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<ContainedObject>*)o)->type)());
  else   (((const ::SmartRefVector<ContainedObject>*)o)->type)();
}

static  void method_7743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<ContainedObject>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<ContainedObject>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_7744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<ContainedObject>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<ContainedObject>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2515( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ContainedObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ContainedObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ContainedObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ContainedObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<ContainedObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<ContainedObject> >")), ::Reflex::BaseOffset< ::SmartRefVector<ContainedObject>,::std::vector<SmartRef<ContainedObject> > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > >")), ::Reflex::BaseOffset< ::SmartRefVector<ContainedObject>,::std::_Vector_base<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<ContainedObject> -------------------------------
void __SmartRefVector_ContainedObject__db_datamem(Reflex::Class*);
void __SmartRefVector_ContainedObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_ContainedObject__datamem_bld(&__SmartRefVector_ContainedObject__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_ContainedObject__funcmem_bld(&__SmartRefVector_ContainedObject__db_funcmem);
void __SmartRefVector_ContainedObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<ContainedObject>"), typeid(::SmartRefVector<ContainedObject>), sizeof(::SmartRefVector<ContainedObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3163, ::Reflex::BaseOffset< ::SmartRefVector<ContainedObject>, ::std::vector<SmartRef<ContainedObject> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2748, Reflex::Literal("SmartRefVector<ContainedObject>::_Entry"))
  .AddTypedef(type_3163, Reflex::Literal("SmartRefVector<ContainedObject>::_Base"))
  .AddTypedef(type_6694, Reflex::Literal("SmartRefVector<ContainedObject>::_BaseConstIter"))
  .AddTypedef(type_2748, Reflex::Literal("SmartRefVector<ContainedObject>::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_7733, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_7735, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7824), Reflex::Literal("SmartRefVector"), constructor_7736, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2515, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_ContainedObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_ContainedObject__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<ContainedObject> -------------------
void __SmartRefVector_ContainedObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_ContainedObject_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_ContainedObject_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<ContainedObject> -------------------
void __SmartRefVector_ContainedObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5654, type_10166), Reflex::Literal("operator()"), operator_7737, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7824, type_10234), Reflex::Literal("operator()"), operator_7738, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5654, type_19429), Reflex::Literal("operator()"), operator_7739, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7824, type_19998), Reflex::Literal("operator()"), operator_7740, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5654, type_7824), Reflex::Literal("operator="), operator_7741, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_7742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRefs"), method_7743, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRefs"), method_7744, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<DataObject> -------------------------------
static void destructor_7751(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<DataObject>*)o)->::SmartRefVector<DataObject>::~SmartRefVector)();
}
static void constructor_7753( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<DataObject>();
  else ::new(mem) ::SmartRefVector<DataObject>();
}

static void constructor_7754( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<DataObject>(*(const ::SmartRefVector<DataObject>*)arg[0]);
  else ::new(mem) ::SmartRefVector<DataObject>(*(const ::SmartRefVector<DataObject>*)arg[0]);
}

static  void operator_7755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<DataObject>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<DataObject>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_7756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<DataObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<DataObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_7757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<DataObject>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<DataObject>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_7758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<DataObject>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<DataObject>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_7759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<DataObject>*)o)->operator=)(*(const ::SmartRefVector<DataObject>*)arg[0]);
  else   (((::SmartRefVector<DataObject>*)o)->operator=)(*(const ::SmartRefVector<DataObject>*)arg[0]);
}

static  void method_7760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<DataObject>*)o)->type)());
  else   (((const ::SmartRefVector<DataObject>*)o)->type)();
}

static  void method_7761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<DataObject>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<DataObject>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_7762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<DataObject>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<DataObject>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2516( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<DataObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<DataObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<DataObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<DataObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<DataObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<DataObject> >")), ::Reflex::BaseOffset< ::SmartRefVector<DataObject>,::std::vector<SmartRef<DataObject> > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > >")), ::Reflex::BaseOffset< ::SmartRefVector<DataObject>,::std::_Vector_base<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<DataObject> -------------------------------
void __SmartRefVector_DataObject__db_datamem(Reflex::Class*);
void __SmartRefVector_DataObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_DataObject__datamem_bld(&__SmartRefVector_DataObject__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_DataObject__funcmem_bld(&__SmartRefVector_DataObject__db_funcmem);
void __SmartRefVector_DataObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<DataObject>"), typeid(::SmartRefVector<DataObject>), sizeof(::SmartRefVector<DataObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3164, ::Reflex::BaseOffset< ::SmartRefVector<DataObject>, ::std::vector<SmartRef<DataObject> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2749, Reflex::Literal("SmartRefVector<DataObject>::_Entry"))
  .AddTypedef(type_3164, Reflex::Literal("SmartRefVector<DataObject>::_Base"))
  .AddTypedef(type_6696, Reflex::Literal("SmartRefVector<DataObject>::_BaseConstIter"))
  .AddTypedef(type_2749, Reflex::Literal("SmartRefVector<DataObject>::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_7751, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_7753, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7825), Reflex::Literal("SmartRefVector"), constructor_7754, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2516, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_DataObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_DataObject__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<DataObject> -------------------
void __SmartRefVector_DataObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_19998, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_DataObject_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_10234, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_DataObject_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<DataObject> -------------------
void __SmartRefVector_DataObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5655, type_10166), Reflex::Literal("operator()"), operator_7755, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7825, type_10234), Reflex::Literal("operator()"), operator_7756, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5655, type_19429), Reflex::Literal("operator()"), operator_7757, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7825, type_19998), Reflex::Literal("operator()"), operator_7758, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5655, type_7825), Reflex::Literal("operator="), operator_7759, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_7760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRefs"), method_7761, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRefs"), method_7762, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IStateful -------------------------------
static  void operator_7804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStateful*)o)->operator=)(*(const ::IStateful*)arg[0]);
  else   (((::IStateful*)o)->operator=)(*(const ::IStateful*)arg[0]);
}

static  void method_7807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IStateful*)o)->interfaceID)();
  else   (((::IStateful*)o)->interfaceID)();
}

static void destructor_7808(void*, void * o, const std::vector<void*>&, void *) {
(((::IStateful*)o)->::IStateful::~IStateful)();
}
static  void method_7809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->configure)());
  else   (((::IStateful*)o)->configure)();
}

static  void method_7810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->initialize)());
  else   (((::IStateful*)o)->initialize)();
}

static  void method_7811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->start)());
  else   (((::IStateful*)o)->start)();
}

static  void method_7812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->stop)());
  else   (((::IStateful*)o)->stop)();
}

static  void method_7813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->finalize)());
  else   (((::IStateful*)o)->finalize)();
}

static  void method_7814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->terminate)());
  else   (((::IStateful*)o)->terminate)();
}

static  void method_7815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->reinitialize)());
  else   (((::IStateful*)o)->reinitialize)();
}

static  void method_7816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IStateful*)o)->restart)());
  else   (((::IStateful*)o)->restart)();
}

static  void method_7817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IStateful*)o)->FSMState)());
  else   (((const ::IStateful*)o)->FSMState)();
}

static  void method_7818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::IStateful*)o)->targetFSMState)());
  else   (((const ::IStateful*)o)->targetFSMState)();
}

static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IStateful,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IStateful -------------------------------
void __IStateful_db_datamem(Reflex::Class*);
void __IStateful_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IStateful_datamem_bld(&__IStateful_db_datamem);
Reflex::GenreflexMemberBuilder __IStateful_funcmem_bld(&__IStateful_db_funcmem);
void __IStateful_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IStateful"), typeid(::IStateful), sizeof(::IStateful), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IStateful, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24341, type_24342), Reflex::Literal("operator="), operator_7804, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IStateful"), destructor_7808, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IStateful_funcmem_bld);
}

//------Delayed data member builder for class IStateful -------------------
void __IStateful_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IStateful -------------------
void __IStateful_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_7807, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_7809, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_7810, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_7811, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_7812, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_7813, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_7814, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_7815, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_7816, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_7817, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("targetFSMState"), method_7818, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IRndmGen -------------------------------
static  void operator_8015( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRndmGen*)o)->operator=)(*(const ::IRndmGen*)arg[0]);
  else   (((::IRndmGen*)o)->operator=)(*(const ::IRndmGen*)arg[0]);
}

static  void method_8018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRndmGen*)o)->interfaceID)();
  else   (((::IRndmGen*)o)->interfaceID)();
}

static  void method_8019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IRndmGen*)o)->initialize)(*(const ::IRndmGen::Param*)arg[0]));
  else   (((::IRndmGen*)o)->initialize)(*(const ::IRndmGen::Param*)arg[0]);
}

static  void method_8020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IRndmGen*)o)->finalize)());
  else   (((::IRndmGen*)o)->finalize)();
}

static  void method_8021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IRndmGen*)o)->type)();
  else   (((const ::IRndmGen*)o)->type)();
}

static  void method_8022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::IRndmGen*)o)->ID)());
  else   (((const ::IRndmGen*)o)->ID)();
}

static  void method_8023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IRndmGen*)o)->parameters)());
  else   (((const ::IRndmGen*)o)->parameters)();
}

static  void method_8024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::IRndmGen*)o)->shoot)());
  else   (((const ::IRndmGen*)o)->shoot)();
}

static  void method_8025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((const ::IRndmGen*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1]));
    else     (((const ::IRndmGen*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((const ::IRndmGen*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]));
    else     (((const ::IRndmGen*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
}

static void destructor_8026(void*, void * o, const std::vector<void*>&, void *) {
(((::IRndmGen*)o)->::IRndmGen::~IRndmGen)();
}
static void method_x125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IRndmGen,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IRndmGen -------------------------------
void __IRndmGen_db_datamem(Reflex::Class*);
void __IRndmGen_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IRndmGen_datamem_bld(&__IRndmGen_db_datamem);
Reflex::GenreflexMemberBuilder __IRndmGen_funcmem_bld(&__IRndmGen_db_funcmem);
void __IRndmGen_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IRndmGen"), typeid(::IRndmGen), sizeof(::IRndmGen), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IRndmGen, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24399, type_24400), Reflex::Literal("operator="), operator_8015, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRndmGen"), destructor_8026, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IRndmGen_funcmem_bld);
}

//------Delayed data member builder for class IRndmGen -------------------
void __IRndmGen_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRndmGen -------------------
void __IRndmGen_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_8018, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_21099), Reflex::Literal("initialize"), method_8019, 0, "par", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_8020, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("type"), method_8021, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("ID"), method_8022, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24401), Reflex::Literal("parameters"), method_8023, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("shoot"), method_8024, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_12638, type_26, type_26), Reflex::Literal("shootArray"), method_8025, 0, "array;howmany;start=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class SmartRef<KeyedObject<long unsigned int> > -------------------------------
static void destructor_8031(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<KeyedObject<unsigned long> >*)o)->::SmartRef<KeyedObject<unsigned long> >::~SmartRef)();
}
static void constructor_8032( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >();
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >();
}

static void constructor_8033( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((::KeyedObject<unsigned long>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((::KeyedObject<unsigned long>*)arg[0]);
}

static void constructor_8034( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::KeyedObject<unsigned long>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::KeyedObject<unsigned long>*)arg[0]);
}

static void constructor_8035( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]);
}

static void constructor_8036( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned long>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned long>*)arg[2]);
  }
}

static void constructor_8037( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned long>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned long>*)arg[3]);
  }
}

static void constructor_8038( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned long>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned long>*)arg[3]);
  }
}

static void constructor_8039( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned long>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned long>*)arg[2]);
  }
}

static  void method_8040( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_8041( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_8042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->hintID)());
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->hintID)();
}

static  void method_8043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->linkID)());
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->linkID)();
}

static  void method_8044( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<KeyedObject<unsigned long> >*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_8045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->type)());
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->type)();
}

static  void method_8046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned long> >*)o)->data)());
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->data)();
}

static  void method_8047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->data)());
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->data)();
}

static  void method_8048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->target)());
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->target)();
}

static  void method_8049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned long> >*)o)->target)());
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->target)();
}

static  void method_8050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned long> >*)o)->path)();
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->path)();
}

static  void operator_8051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]);
}

static  void operator_8052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]);
}

static  void method_8053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_8054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_8055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_8056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_8057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_8058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_8059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned long> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]);
}

static  void operator_8060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned long> >*)o)->operator=)((::KeyedObject<unsigned long>*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->operator=)((::KeyedObject<unsigned long>*)arg[0]);
}

static  void operator_8061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned long> >*)o)->operator*)();
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->operator*)();
}

static  void operator_8062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator*)();
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator*)();
}

static  void operator_8063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned long> >*)o)->operator->)());
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->operator->)();
}

static  void operator_8064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator->)());
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator->)();
}

static  void converter_8065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator const KeyedObject<unsigned long>*)());
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->operator const KeyedObject<unsigned long>*)();
}

static  void converter_8066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned long> >*)o)->operator KeyedObject<unsigned long>*)());
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->operator KeyedObject<unsigned long>*)();
}

static  void method_8067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned long> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<unsigned long> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_8068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned long> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned long> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2743( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<KeyedObject<long unsigned int> > -------------------------------
void __SmartRef_KeyedObject_unsignedslong_s__db_datamem(Reflex::Class*);
void __SmartRef_KeyedObject_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_unsignedslong_s__datamem_bld(&__SmartRef_KeyedObject_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_unsignedslong_s__funcmem_bld(&__SmartRef_KeyedObject_unsignedslong_s__db_funcmem);
void __SmartRef_KeyedObject_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<KeyedObject<unsigned long> >"), typeid(::SmartRef<KeyedObject<unsigned long> >), sizeof(::SmartRef<KeyedObject<unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1450, Reflex::Literal("SmartRef<KeyedObject<unsigned long> >::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_8031, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_8032, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24403), Reflex::Literal("SmartRef"), constructor_8033, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24402), Reflex::Literal("SmartRef"), constructor_8034, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7826), Reflex::Literal("SmartRef"), constructor_8035, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_26, type_24403), Reflex::Literal("SmartRef"), constructor_8036, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234, type_26, type_26, type_24403), Reflex::Literal("SmartRef"), constructor_8037, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_26, type_24403), Reflex::Literal("SmartRef"), constructor_8038, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_24403), Reflex::Literal("SmartRef"), constructor_8039, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2743, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_KeyedObject_unsignedslong_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_KeyedObject_unsignedslong_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<KeyedObject<long unsigned int> > -------------------
void __SmartRef_KeyedObject_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1617, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_KeyedObject_unsignedslong_s_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_24402, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_KeyedObject_unsignedslong_s_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<KeyedObject<long unsigned int> > -------------------
void __SmartRef_KeyedObject_unsignedslong_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998), Reflex::Literal("shouldFollowLink"), method_8040, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234), Reflex::Literal("shouldFollowLink"), method_8041, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("hintID"), method_8042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("linkID"), method_8043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_8044, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_8045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24403), Reflex::Literal("data"), method_8046, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24402), Reflex::Literal("data"), method_8047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24402), Reflex::Literal("target"), method_8048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24403), Reflex::Literal("target"), method_8049, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7844), Reflex::Literal("path"), method_8050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7826), Reflex::Literal("operator=="), operator_8051, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7826), Reflex::Literal("operator!="), operator_8052, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7826, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8053, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8054, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656, type_10166), Reflex::Literal("operator()"), operator_8055, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7826, type_10234), Reflex::Literal("operator()"), operator_8056, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656, type_19429), Reflex::Literal("operator()"), operator_8057, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7826, type_19998), Reflex::Literal("operator()"), operator_8058, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656, type_7826), Reflex::Literal("operator="), operator_8059, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656, type_24403), Reflex::Literal("operator="), operator_8060, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20139), Reflex::Literal("operator*"), operator_8061, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20140), Reflex::Literal("operator*"), operator_8062, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24403), Reflex::Literal("operator->"), operator_8063, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24402), Reflex::Literal("operator->"), operator_8064, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24402), Reflex::Literal("operator const KeyedObject<unsigned long>*"), converter_8065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24403), Reflex::Literal("operator KeyedObject<unsigned long>*"), converter_8066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRef"), method_8067, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRef"), method_8068, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<KeyedObject<long int> > -------------------------------
static void destructor_8073(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<KeyedObject<long> >*)o)->::SmartRef<KeyedObject<long> >::~SmartRef)();
}
static void constructor_8074( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >();
  else ::new(mem) ::SmartRef<KeyedObject<long> >();
}

static void constructor_8075( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((::KeyedObject<long>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((::KeyedObject<long>*)arg[0]);
}

static void constructor_8076( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((const ::KeyedObject<long>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((const ::KeyedObject<long>*)arg[0]);
}

static void constructor_8077( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >(*(const ::SmartRef<KeyedObject<long> >*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >(*(const ::SmartRef<KeyedObject<long> >*)arg[0]);
}

static void constructor_8078( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<long>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<long>*)arg[2]);
  }
}

static void constructor_8079( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<long>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<long>*)arg[3]);
  }
}

static void constructor_8080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<long>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<long>*)arg[3]);
  }
}

static void constructor_8081( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<long>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<long> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<long>*)arg[2]);
  }
}

static  void method_8082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<long> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_8083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<long> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_8084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<long> >*)o)->hintID)());
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->hintID)();
}

static  void method_8085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<long> >*)o)->linkID)());
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->linkID)();
}

static  void method_8086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<KeyedObject<long> >*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_8087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<long> >*)o)->type)());
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->type)();
}

static  void method_8088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<long> >*)o)->data)());
  else   (((::SmartRef<KeyedObject<long> >*)o)->data)();
}

static  void method_8089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<long> >*)o)->data)());
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->data)();
}

static  void method_8090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<long> >*)o)->target)());
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->target)();
}

static  void method_8091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<long> >*)o)->target)());
  else   (((::SmartRef<KeyedObject<long> >*)o)->target)();
}

static  void method_8092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<long> >*)o)->path)();
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->path)();
}

static  void operator_8093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<long> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<long> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<long> >*)arg[0]);
}

static  void operator_8094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<long> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<long> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<long> >*)arg[0]);
}

static  void method_8095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_8096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<KeyedObject<long> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_8097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<long> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<long> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_8098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_8099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<long> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<long> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_8100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<long> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_8101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<long> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<long> >*)arg[0]);
  else   (((::SmartRef<KeyedObject<long> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<long> >*)arg[0]);
}

static  void operator_8102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<long> >*)o)->operator=)((::KeyedObject<long>*)arg[0]);
  else   (((::SmartRef<KeyedObject<long> >*)o)->operator=)((::KeyedObject<long>*)arg[0]);
}

static  void operator_8103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<long> >*)o)->operator*)();
  else   (((::SmartRef<KeyedObject<long> >*)o)->operator*)();
}

static  void operator_8104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<long> >*)o)->operator*)();
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->operator*)();
}

static  void operator_8105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<long> >*)o)->operator->)());
  else   (((::SmartRef<KeyedObject<long> >*)o)->operator->)();
}

static  void operator_8106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<long> >*)o)->operator->)());
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->operator->)();
}

static  void converter_8107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<long> >*)o)->operator const KeyedObject<long>*)());
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->operator const KeyedObject<long>*)();
}

static  void converter_8108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<long> >*)o)->operator KeyedObject<long>*)());
  else   (((::SmartRef<KeyedObject<long> >*)o)->operator KeyedObject<long>*)();
}

static  void method_8109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<long> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<long> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_8110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<long> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<KeyedObject<long> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2744( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<KeyedObject<long int> > -------------------------------
void __SmartRef_KeyedObject_long_s__db_datamem(Reflex::Class*);
void __SmartRef_KeyedObject_long_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_long_s__datamem_bld(&__SmartRef_KeyedObject_long_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_long_s__funcmem_bld(&__SmartRef_KeyedObject_long_s__db_funcmem);
void __SmartRef_KeyedObject_long_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<KeyedObject<long> >"), typeid(::SmartRef<KeyedObject<long> >), sizeof(::SmartRef<KeyedObject<long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1451, Reflex::Literal("SmartRef<KeyedObject<long> >::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_8073, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_8074, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24405), Reflex::Literal("SmartRef"), constructor_8075, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24404), Reflex::Literal("SmartRef"), constructor_8076, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7827), Reflex::Literal("SmartRef"), constructor_8077, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_26, type_24405), Reflex::Literal("SmartRef"), constructor_8078, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234, type_26, type_26, type_24405), Reflex::Literal("SmartRef"), constructor_8079, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_26, type_24405), Reflex::Literal("SmartRef"), constructor_8080, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_24405), Reflex::Literal("SmartRef"), constructor_8081, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_KeyedObject_long_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_KeyedObject_long_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<KeyedObject<long int> > -------------------
void __SmartRef_KeyedObject_long_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1617, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_KeyedObject_long_s_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_24404, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_KeyedObject_long_s_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<KeyedObject<long int> > -------------------
void __SmartRef_KeyedObject_long_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998), Reflex::Literal("shouldFollowLink"), method_8082, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234), Reflex::Literal("shouldFollowLink"), method_8083, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("hintID"), method_8084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("linkID"), method_8085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_8086, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_8087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24405), Reflex::Literal("data"), method_8088, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24404), Reflex::Literal("data"), method_8089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24404), Reflex::Literal("target"), method_8090, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24405), Reflex::Literal("target"), method_8091, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7844), Reflex::Literal("path"), method_8092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7827), Reflex::Literal("operator=="), operator_8093, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7827), Reflex::Literal("operator!="), operator_8094, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7827, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8095, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8096, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657, type_10166), Reflex::Literal("operator()"), operator_8097, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7827, type_10234), Reflex::Literal("operator()"), operator_8098, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657, type_19429), Reflex::Literal("operator()"), operator_8099, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7827, type_19998), Reflex::Literal("operator()"), operator_8100, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657, type_7827), Reflex::Literal("operator="), operator_8101, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657, type_24405), Reflex::Literal("operator="), operator_8102, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20141), Reflex::Literal("operator*"), operator_8103, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20142), Reflex::Literal("operator*"), operator_8104, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24405), Reflex::Literal("operator->"), operator_8105, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24404), Reflex::Literal("operator->"), operator_8106, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24404), Reflex::Literal("operator const KeyedObject<long>*"), converter_8107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24405), Reflex::Literal("operator KeyedObject<long>*"), converter_8108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRef"), method_8109, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRef"), method_8110, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<KeyedObject<unsigned int> > -------------------------------
static void destructor_8115(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<KeyedObject<unsigned int> >*)o)->::SmartRef<KeyedObject<unsigned int> >::~SmartRef)();
}
static void constructor_8116( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >();
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >();
}

static void constructor_8117( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((::KeyedObject<unsigned int>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((::KeyedObject<unsigned int>*)arg[0]);
}

static void constructor_8118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::KeyedObject<unsigned int>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::KeyedObject<unsigned int>*)arg[0]);
}

static void constructor_8119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]);
}

static void constructor_8120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned int>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned int>*)arg[2]);
  }
}

static void constructor_8121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned int>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned int>*)arg[3]);
  }
}

static void constructor_8122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned int>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<unsigned int>*)arg[3]);
  }
}

static void constructor_8123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned int>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<unsigned int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<unsigned int>*)arg[2]);
  }
}

static  void method_8124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_8125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_8126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->hintID)());
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->hintID)();
}

static  void method_8127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->linkID)());
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->linkID)();
}

static  void method_8128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<KeyedObject<unsigned int> >*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_8129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->type)());
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->type)();
}

static  void method_8130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned int> >*)o)->data)());
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->data)();
}

static  void method_8131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->data)());
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->data)();
}

static  void method_8132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->target)());
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->target)();
}

static  void method_8133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned int> >*)o)->target)());
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->target)();
}

static  void method_8134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned int> >*)o)->path)();
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->path)();
}

static  void operator_8135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]);
}

static  void operator_8136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]);
}

static  void method_8137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_8138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_8139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_8140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_8141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_8142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_8143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned int> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]);
}

static  void operator_8144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned int> >*)o)->operator=)((::KeyedObject<unsigned int>*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->operator=)((::KeyedObject<unsigned int>*)arg[0]);
}

static  void operator_8145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned int> >*)o)->operator*)();
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->operator*)();
}

static  void operator_8146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator*)();
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator*)();
}

static  void operator_8147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned int> >*)o)->operator->)());
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->operator->)();
}

static  void operator_8148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator->)());
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator->)();
}

static  void converter_8149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator const KeyedObject<unsigned int>*)());
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->operator const KeyedObject<unsigned int>*)();
}

static  void converter_8150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<unsigned int> >*)o)->operator KeyedObject<unsigned int>*)());
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->operator KeyedObject<unsigned int>*)();
}

static  void method_8151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<unsigned int> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<unsigned int> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_8152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<unsigned int> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<KeyedObject<unsigned int> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2745( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<KeyedObject<unsigned int> > -------------------------------
void __SmartRef_KeyedObject_unsignedsint_s__db_datamem(Reflex::Class*);
void __SmartRef_KeyedObject_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_unsignedsint_s__datamem_bld(&__SmartRef_KeyedObject_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_unsignedsint_s__funcmem_bld(&__SmartRef_KeyedObject_unsignedsint_s__db_funcmem);
void __SmartRef_KeyedObject_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<KeyedObject<unsigned int> >"), typeid(::SmartRef<KeyedObject<unsigned int> >), sizeof(::SmartRef<KeyedObject<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1452, Reflex::Literal("SmartRef<KeyedObject<unsigned int> >::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_8115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_8116, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24407), Reflex::Literal("SmartRef"), constructor_8117, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24406), Reflex::Literal("SmartRef"), constructor_8118, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7828), Reflex::Literal("SmartRef"), constructor_8119, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_26, type_24407), Reflex::Literal("SmartRef"), constructor_8120, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234, type_26, type_26, type_24407), Reflex::Literal("SmartRef"), constructor_8121, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_26, type_24407), Reflex::Literal("SmartRef"), constructor_8122, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_24407), Reflex::Literal("SmartRef"), constructor_8123, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2745, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_KeyedObject_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_KeyedObject_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<KeyedObject<unsigned int> > -------------------
void __SmartRef_KeyedObject_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1617, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_KeyedObject_unsignedsint_s_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_24406, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_KeyedObject_unsignedsint_s_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<KeyedObject<unsigned int> > -------------------
void __SmartRef_KeyedObject_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998), Reflex::Literal("shouldFollowLink"), method_8124, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234), Reflex::Literal("shouldFollowLink"), method_8125, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("hintID"), method_8126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("linkID"), method_8127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_8128, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_8129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24407), Reflex::Literal("data"), method_8130, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24406), Reflex::Literal("data"), method_8131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24406), Reflex::Literal("target"), method_8132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24407), Reflex::Literal("target"), method_8133, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7844), Reflex::Literal("path"), method_8134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7828), Reflex::Literal("operator=="), operator_8135, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7828), Reflex::Literal("operator!="), operator_8136, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7828, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8137, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8138, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658, type_10166), Reflex::Literal("operator()"), operator_8139, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7828, type_10234), Reflex::Literal("operator()"), operator_8140, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658, type_19429), Reflex::Literal("operator()"), operator_8141, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7828, type_19998), Reflex::Literal("operator()"), operator_8142, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658, type_7828), Reflex::Literal("operator="), operator_8143, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658, type_24407), Reflex::Literal("operator="), operator_8144, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20143), Reflex::Literal("operator*"), operator_8145, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20144), Reflex::Literal("operator*"), operator_8146, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24407), Reflex::Literal("operator->"), operator_8147, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24406), Reflex::Literal("operator->"), operator_8148, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24406), Reflex::Literal("operator const KeyedObject<unsigned int>*"), converter_8149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24407), Reflex::Literal("operator KeyedObject<unsigned int>*"), converter_8150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRef"), method_8151, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRef"), method_8152, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<KeyedObject<int> > -------------------------------
static void destructor_8157(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<KeyedObject<int> >*)o)->::SmartRef<KeyedObject<int> >::~SmartRef)();
}
static void constructor_8158( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >();
  else ::new(mem) ::SmartRef<KeyedObject<int> >();
}

static void constructor_8159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((::KeyedObject<int>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((::KeyedObject<int>*)arg[0]);
}

static void constructor_8160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((const ::KeyedObject<int>*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((const ::KeyedObject<int>*)arg[0]);
}

static void constructor_8161( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >(*(const ::SmartRef<KeyedObject<int> >*)arg[0]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >(*(const ::SmartRef<KeyedObject<int> >*)arg[0]);
}

static void constructor_8162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<int>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >(*(long*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<int>*)arg[2]);
  }
}

static void constructor_8163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<int>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<int>*)arg[3]);
  }
}

static void constructor_8164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<int>*)arg[3]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::KeyedObject<int>*)arg[3]);
  }
}

static void constructor_8165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<int>*)arg[2]);
  else ::new(mem) ::SmartRef<KeyedObject<int> >((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::KeyedObject<int>*)arg[2]);
  }
}

static  void method_8166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<int> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_8167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<int> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_8168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<int> >*)o)->hintID)());
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->hintID)();
}

static  void method_8169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<KeyedObject<int> >*)o)->linkID)());
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->linkID)();
}

static  void method_8170( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<KeyedObject<int> >*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_8171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<int> >*)o)->type)());
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->type)();
}

static  void method_8172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<int> >*)o)->data)());
  else   (((::SmartRef<KeyedObject<int> >*)o)->data)();
}

static  void method_8173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<int> >*)o)->data)());
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->data)();
}

static  void method_8174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<int> >*)o)->target)());
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->target)();
}

static  void method_8175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<int> >*)o)->target)());
  else   (((::SmartRef<KeyedObject<int> >*)o)->target)();
}

static  void method_8176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<int> >*)o)->path)();
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->path)();
}

static  void operator_8177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<int> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<int> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->operator==)(*(const ::SmartRef<KeyedObject<int> >*)arg[0]);
}

static  void operator_8178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<KeyedObject<int> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<int> >*)arg[0]));
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->operator!=)(*(const ::SmartRef<KeyedObject<int> >*)arg[0]);
}

static  void method_8179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_8180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<KeyedObject<int> >*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_8181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<int> >*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<int> >*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_8182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_8183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<int> >*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<KeyedObject<int> >*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_8184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<int> >*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_8185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<int> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<int> >*)arg[0]);
  else   (((::SmartRef<KeyedObject<int> >*)o)->operator=)(*(const ::SmartRef<KeyedObject<int> >*)arg[0]);
}

static  void operator_8186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<int> >*)o)->operator=)((::KeyedObject<int>*)arg[0]);
  else   (((::SmartRef<KeyedObject<int> >*)o)->operator=)((::KeyedObject<int>*)arg[0]);
}

static  void operator_8187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<int> >*)o)->operator*)();
  else   (((::SmartRef<KeyedObject<int> >*)o)->operator*)();
}

static  void operator_8188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<int> >*)o)->operator*)();
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->operator*)();
}

static  void operator_8189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<int> >*)o)->operator->)());
  else   (((::SmartRef<KeyedObject<int> >*)o)->operator->)();
}

static  void operator_8190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<int> >*)o)->operator->)());
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->operator->)();
}

static  void converter_8191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<KeyedObject<int> >*)o)->operator const KeyedObject<int>*)());
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->operator const KeyedObject<int>*)();
}

static  void converter_8192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<KeyedObject<int> >*)o)->operator KeyedObject<int>*)());
  else   (((::SmartRef<KeyedObject<int> >*)o)->operator KeyedObject<int>*)();
}

static  void method_8193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<KeyedObject<int> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<KeyedObject<int> >*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_8194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<KeyedObject<int> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<KeyedObject<int> >*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2746( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<KeyedObject<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<KeyedObject<int> > -------------------------------
void __SmartRef_KeyedObject_int_s__db_datamem(Reflex::Class*);
void __SmartRef_KeyedObject_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_int_s__datamem_bld(&__SmartRef_KeyedObject_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_KeyedObject_int_s__funcmem_bld(&__SmartRef_KeyedObject_int_s__db_funcmem);
void __SmartRef_KeyedObject_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<KeyedObject<int> >"), typeid(::SmartRef<KeyedObject<int> >), sizeof(::SmartRef<KeyedObject<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1453, Reflex::Literal("SmartRef<KeyedObject<int> >::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_8157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_8158, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24409), Reflex::Literal("SmartRef"), constructor_8159, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24408), Reflex::Literal("SmartRef"), constructor_8160, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7829), Reflex::Literal("SmartRef"), constructor_8161, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_26, type_24409), Reflex::Literal("SmartRef"), constructor_8162, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234, type_26, type_26, type_24409), Reflex::Literal("SmartRef"), constructor_8163, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_26, type_24409), Reflex::Literal("SmartRef"), constructor_8164, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_24409), Reflex::Literal("SmartRef"), constructor_8165, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2746, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_KeyedObject_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_KeyedObject_int_s__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<KeyedObject<int> > -------------------
void __SmartRef_KeyedObject_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1617, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_KeyedObject_int_s_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_24408, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_KeyedObject_int_s_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<KeyedObject<int> > -------------------
void __SmartRef_KeyedObject_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998), Reflex::Literal("shouldFollowLink"), method_8166, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234), Reflex::Literal("shouldFollowLink"), method_8167, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("hintID"), method_8168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("linkID"), method_8169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_8170, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_8171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24409), Reflex::Literal("data"), method_8172, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24408), Reflex::Literal("data"), method_8173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24408), Reflex::Literal("target"), method_8174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24409), Reflex::Literal("target"), method_8175, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7844), Reflex::Literal("path"), method_8176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7829), Reflex::Literal("operator=="), operator_8177, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7829), Reflex::Literal("operator!="), operator_8178, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7829, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8179, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8180, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659, type_10166), Reflex::Literal("operator()"), operator_8181, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7829, type_10234), Reflex::Literal("operator()"), operator_8182, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659, type_19429), Reflex::Literal("operator()"), operator_8183, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7829, type_19998), Reflex::Literal("operator()"), operator_8184, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659, type_7829), Reflex::Literal("operator="), operator_8185, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659, type_24409), Reflex::Literal("operator="), operator_8186, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20145), Reflex::Literal("operator*"), operator_8187, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20146), Reflex::Literal("operator*"), operator_8188, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24409), Reflex::Literal("operator->"), operator_8189, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24408), Reflex::Literal("operator->"), operator_8190, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24408), Reflex::Literal("operator const KeyedObject<int>*"), converter_8191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24409), Reflex::Literal("operator KeyedObject<int>*"), converter_8192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRef"), method_8193, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRef"), method_8194, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<ObjectContainerBase> -------------------------------
static void destructor_8199(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<ObjectContainerBase>*)o)->::SmartRef<ObjectContainerBase>::~SmartRef)();
}
static void constructor_8200( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>();
  else ::new(mem) ::SmartRef<ObjectContainerBase>();
}

static void constructor_8201( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((::ObjectContainerBase*)arg[0]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((::ObjectContainerBase*)arg[0]);
}

static void constructor_8202( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((const ::ObjectContainerBase*)arg[0]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((const ::ObjectContainerBase*)arg[0]);
}

static void constructor_8203( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>(*(const ::SmartRef<ObjectContainerBase>*)arg[0]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>(*(const ::SmartRef<ObjectContainerBase>*)arg[0]);
}

static void constructor_8204( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>(*(long*)arg[0],
      *(long*)arg[1],
      (::ObjectContainerBase*)arg[2]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>(*(long*)arg[0],
      *(long*)arg[1],
      (::ObjectContainerBase*)arg[2]);
  }
}

static void constructor_8205( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ObjectContainerBase*)arg[3]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ObjectContainerBase*)arg[3]);
  }
}

static void constructor_8206( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ObjectContainerBase*)arg[3]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ObjectContainerBase*)arg[3]);
  }
}

static void constructor_8207( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::ObjectContainerBase*)arg[2]);
  else ::new(mem) ::SmartRef<ObjectContainerBase>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::ObjectContainerBase*)arg[2]);
  }
}

static  void method_8208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ObjectContainerBase>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_8209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ObjectContainerBase>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_8210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<ObjectContainerBase>*)o)->hintID)());
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->hintID)();
}

static  void method_8211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<ObjectContainerBase>*)o)->linkID)());
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->linkID)();
}

static  void method_8212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<ObjectContainerBase>*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_8213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ObjectContainerBase>*)o)->type)());
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->type)();
}

static  void method_8214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ObjectContainerBase>*)o)->data)());
  else   (((::SmartRef<ObjectContainerBase>*)o)->data)();
}

static  void method_8215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ObjectContainerBase>*)o)->data)());
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->data)();
}

static  void method_8216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ObjectContainerBase>*)o)->target)());
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->target)();
}

static  void method_8217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ObjectContainerBase>*)o)->target)());
  else   (((::SmartRef<ObjectContainerBase>*)o)->target)();
}

static  void method_8218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ObjectContainerBase>*)o)->path)();
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->path)();
}

static  void operator_8219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ObjectContainerBase>*)o)->operator==)(*(const ::SmartRef<ObjectContainerBase>*)arg[0]));
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->operator==)(*(const ::SmartRef<ObjectContainerBase>*)arg[0]);
}

static  void operator_8220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ObjectContainerBase>*)o)->operator!=)(*(const ::SmartRef<ObjectContainerBase>*)arg[0]));
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->operator!=)(*(const ::SmartRef<ObjectContainerBase>*)arg[0]);
}

static  void method_8221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ObjectContainerBase>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_8222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ObjectContainerBase>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<ObjectContainerBase>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_8223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ObjectContainerBase>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<ObjectContainerBase>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_8224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ObjectContainerBase>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_8225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ObjectContainerBase>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<ObjectContainerBase>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_8226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ObjectContainerBase>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_8227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ObjectContainerBase>*)o)->operator=)(*(const ::SmartRef<ObjectContainerBase>*)arg[0]);
  else   (((::SmartRef<ObjectContainerBase>*)o)->operator=)(*(const ::SmartRef<ObjectContainerBase>*)arg[0]);
}

static  void operator_8228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ObjectContainerBase>*)o)->operator=)((::ObjectContainerBase*)arg[0]);
  else   (((::SmartRef<ObjectContainerBase>*)o)->operator=)((::ObjectContainerBase*)arg[0]);
}

static  void operator_8229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ObjectContainerBase>*)o)->operator*)();
  else   (((::SmartRef<ObjectContainerBase>*)o)->operator*)();
}

static  void operator_8230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ObjectContainerBase>*)o)->operator*)();
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->operator*)();
}

static  void operator_8231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ObjectContainerBase>*)o)->operator->)());
  else   (((::SmartRef<ObjectContainerBase>*)o)->operator->)();
}

static  void operator_8232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ObjectContainerBase>*)o)->operator->)());
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->operator->)();
}

static  void converter_8233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ObjectContainerBase>*)o)->operator const ObjectContainerBase*)());
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->operator const ObjectContainerBase*)();
}

static  void converter_8234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ObjectContainerBase>*)o)->operator ObjectContainerBase*)());
  else   (((::SmartRef<ObjectContainerBase>*)o)->operator ObjectContainerBase*)();
}

static  void method_8235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ObjectContainerBase>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<ObjectContainerBase>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_8236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ObjectContainerBase>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<ObjectContainerBase>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2747( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<ObjectContainerBase> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<ObjectContainerBase> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<ObjectContainerBase> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<ObjectContainerBase> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<ObjectContainerBase> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<ObjectContainerBase> -------------------------------
void __SmartRef_ObjectContainerBase__db_datamem(Reflex::Class*);
void __SmartRef_ObjectContainerBase__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_ObjectContainerBase__datamem_bld(&__SmartRef_ObjectContainerBase__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_ObjectContainerBase__funcmem_bld(&__SmartRef_ObjectContainerBase__db_funcmem);
void __SmartRef_ObjectContainerBase__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<ObjectContainerBase>"), typeid(::SmartRef<ObjectContainerBase>), sizeof(::SmartRef<ObjectContainerBase>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_612, Reflex::Literal("SmartRef<ObjectContainerBase>::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_8199, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_8200, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19995), Reflex::Literal("SmartRef"), constructor_8201, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20057), Reflex::Literal("SmartRef"), constructor_8202, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7830), Reflex::Literal("SmartRef"), constructor_8203, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_26, type_19995), Reflex::Literal("SmartRef"), constructor_8204, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234, type_26, type_26, type_19995), Reflex::Literal("SmartRef"), constructor_8205, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_26, type_19995), Reflex::Literal("SmartRef"), constructor_8206, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_19995), Reflex::Literal("SmartRef"), constructor_8207, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2747, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_ObjectContainerBase__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_ObjectContainerBase__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<ObjectContainerBase> -------------------
void __SmartRef_ObjectContainerBase__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1617, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_ObjectContainerBase_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_20057, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_ObjectContainerBase_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<ObjectContainerBase> -------------------
void __SmartRef_ObjectContainerBase__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998), Reflex::Literal("shouldFollowLink"), method_8208, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234), Reflex::Literal("shouldFollowLink"), method_8209, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("hintID"), method_8210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("linkID"), method_8211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_8212, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_8213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("data"), method_8214, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20057), Reflex::Literal("data"), method_8215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20057), Reflex::Literal("target"), method_8216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("target"), method_8217, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7844), Reflex::Literal("path"), method_8218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7830), Reflex::Literal("operator=="), operator_8219, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7830), Reflex::Literal("operator!="), operator_8220, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7830, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8221, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8222, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660, type_10166), Reflex::Literal("operator()"), operator_8223, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7830, type_10234), Reflex::Literal("operator()"), operator_8224, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660, type_19429), Reflex::Literal("operator()"), operator_8225, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7830, type_19998), Reflex::Literal("operator()"), operator_8226, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660, type_7830), Reflex::Literal("operator="), operator_8227, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660, type_19995), Reflex::Literal("operator="), operator_8228, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19761), Reflex::Literal("operator*"), operator_8229, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19762), Reflex::Literal("operator*"), operator_8230, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("operator->"), operator_8231, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20057), Reflex::Literal("operator->"), operator_8232, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20057), Reflex::Literal("operator const ObjectContainerBase*"), converter_8233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19995), Reflex::Literal("operator ObjectContainerBase*"), converter_8234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRef"), method_8235, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRef"), method_8236, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<ContainedObject> -------------------------------
static void destructor_8241(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<ContainedObject>*)o)->::SmartRef<ContainedObject>::~SmartRef)();
}
static void constructor_8242( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>();
  else ::new(mem) ::SmartRef<ContainedObject>();
}

static void constructor_8243( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((::ContainedObject*)arg[0]);
  else ::new(mem) ::SmartRef<ContainedObject>((::ContainedObject*)arg[0]);
}

static void constructor_8244( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((const ::ContainedObject*)arg[0]);
  else ::new(mem) ::SmartRef<ContainedObject>((const ::ContainedObject*)arg[0]);
}

static void constructor_8245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>(*(const ::SmartRef<ContainedObject>*)arg[0]);
  else ::new(mem) ::SmartRef<ContainedObject>(*(const ::SmartRef<ContainedObject>*)arg[0]);
}

static void constructor_8246( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<ContainedObject>(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>(*(long*)arg[0],
      *(long*)arg[1],
      (::ContainedObject*)arg[2]);
  else ::new(mem) ::SmartRef<ContainedObject>(*(long*)arg[0],
      *(long*)arg[1],
      (::ContainedObject*)arg[2]);
  }
}

static void constructor_8247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<ContainedObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ContainedObject*)arg[3]);
  else ::new(mem) ::SmartRef<ContainedObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ContainedObject*)arg[3]);
  }
}

static void constructor_8248( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ContainedObject*)arg[3]);
  else ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::ContainedObject*)arg[3]);
  }
}

static void constructor_8249( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::ContainedObject*)arg[2]);
  else ::new(mem) ::SmartRef<ContainedObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::ContainedObject*)arg[2]);
  }
}

static  void method_8250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ContainedObject>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<ContainedObject>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_8251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ContainedObject>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<ContainedObject>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_8252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<ContainedObject>*)o)->hintID)());
  else   (((const ::SmartRef<ContainedObject>*)o)->hintID)();
}

static  void method_8253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<ContainedObject>*)o)->linkID)());
  else   (((const ::SmartRef<ContainedObject>*)o)->linkID)();
}

static  void method_8254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<ContainedObject>*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_8255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ContainedObject>*)o)->type)());
  else   (((const ::SmartRef<ContainedObject>*)o)->type)();
}

static  void method_8256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ContainedObject>*)o)->data)());
  else   (((::SmartRef<ContainedObject>*)o)->data)();
}

static  void method_8257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ContainedObject>*)o)->data)());
  else   (((const ::SmartRef<ContainedObject>*)o)->data)();
}

static  void method_8258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ContainedObject>*)o)->target)());
  else   (((const ::SmartRef<ContainedObject>*)o)->target)();
}

static  void method_8259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ContainedObject>*)o)->target)());
  else   (((::SmartRef<ContainedObject>*)o)->target)();
}

static  void method_8260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ContainedObject>*)o)->path)();
  else   (((const ::SmartRef<ContainedObject>*)o)->path)();
}

static  void operator_8261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ContainedObject>*)o)->operator==)(*(const ::SmartRef<ContainedObject>*)arg[0]));
  else   (((const ::SmartRef<ContainedObject>*)o)->operator==)(*(const ::SmartRef<ContainedObject>*)arg[0]);
}

static  void operator_8262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<ContainedObject>*)o)->operator!=)(*(const ::SmartRef<ContainedObject>*)arg[0]));
  else   (((const ::SmartRef<ContainedObject>*)o)->operator!=)(*(const ::SmartRef<ContainedObject>*)arg[0]);
}

static  void method_8263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ContainedObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<ContainedObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_8264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ContainedObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<ContainedObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_8265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ContainedObject>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<ContainedObject>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_8266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ContainedObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<ContainedObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_8267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ContainedObject>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<ContainedObject>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_8268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ContainedObject>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<ContainedObject>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_8269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ContainedObject>*)o)->operator=)(*(const ::SmartRef<ContainedObject>*)arg[0]);
  else   (((::SmartRef<ContainedObject>*)o)->operator=)(*(const ::SmartRef<ContainedObject>*)arg[0]);
}

static  void operator_8270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ContainedObject>*)o)->operator=)((::ContainedObject*)arg[0]);
  else   (((::SmartRef<ContainedObject>*)o)->operator=)((::ContainedObject*)arg[0]);
}

static  void operator_8271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ContainedObject>*)o)->operator*)();
  else   (((::SmartRef<ContainedObject>*)o)->operator*)();
}

static  void operator_8272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ContainedObject>*)o)->operator*)();
  else   (((const ::SmartRef<ContainedObject>*)o)->operator*)();
}

static  void operator_8273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ContainedObject>*)o)->operator->)());
  else   (((::SmartRef<ContainedObject>*)o)->operator->)();
}

static  void operator_8274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ContainedObject>*)o)->operator->)());
  else   (((const ::SmartRef<ContainedObject>*)o)->operator->)();
}

static  void converter_8275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<ContainedObject>*)o)->operator const ContainedObject*)());
  else   (((const ::SmartRef<ContainedObject>*)o)->operator const ContainedObject*)();
}

static  void converter_8276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<ContainedObject>*)o)->operator ContainedObject*)());
  else   (((::SmartRef<ContainedObject>*)o)->operator ContainedObject*)();
}

static  void method_8277( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<ContainedObject>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<ContainedObject>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_8278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<ContainedObject>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<ContainedObject>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2748( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<ContainedObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<ContainedObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<ContainedObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<ContainedObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<ContainedObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<ContainedObject> -------------------------------
void __SmartRef_ContainedObject__db_datamem(Reflex::Class*);
void __SmartRef_ContainedObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_ContainedObject__datamem_bld(&__SmartRef_ContainedObject__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_ContainedObject__funcmem_bld(&__SmartRef_ContainedObject__db_funcmem);
void __SmartRef_ContainedObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<ContainedObject>"), typeid(::SmartRef<ContainedObject>), sizeof(::SmartRef<ContainedObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_1249, Reflex::Literal("SmartRef<ContainedObject>::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_8241, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_8242, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10166), Reflex::Literal("SmartRef"), constructor_8243, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234), Reflex::Literal("SmartRef"), constructor_8244, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7835), Reflex::Literal("SmartRef"), constructor_8245, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_26, type_10166), Reflex::Literal("SmartRef"), constructor_8246, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234, type_26, type_26, type_10166), Reflex::Literal("SmartRef"), constructor_8247, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_26, type_10166), Reflex::Literal("SmartRef"), constructor_8248, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_10166), Reflex::Literal("SmartRef"), constructor_8249, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2748, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_ContainedObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_ContainedObject__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<ContainedObject> -------------------
void __SmartRef_ContainedObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1617, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_ContainedObject_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_10234, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_ContainedObject_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<ContainedObject> -------------------
void __SmartRef_ContainedObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998), Reflex::Literal("shouldFollowLink"), method_8250, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234), Reflex::Literal("shouldFollowLink"), method_8251, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("hintID"), method_8252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("linkID"), method_8253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_8254, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_8255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10166), Reflex::Literal("data"), method_8256, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234), Reflex::Literal("data"), method_8257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234), Reflex::Literal("target"), method_8258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10166), Reflex::Literal("target"), method_8259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7844), Reflex::Literal("path"), method_8260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7835), Reflex::Literal("operator=="), operator_8261, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7835), Reflex::Literal("operator!="), operator_8262, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7835, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8263, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8264, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661, type_10166), Reflex::Literal("operator()"), operator_8265, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7835, type_10234), Reflex::Literal("operator()"), operator_8266, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661, type_19429), Reflex::Literal("operator()"), operator_8267, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7835, type_19998), Reflex::Literal("operator()"), operator_8268, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661, type_7835), Reflex::Literal("operator="), operator_8269, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661, type_10166), Reflex::Literal("operator="), operator_8270, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20056), Reflex::Literal("operator*"), operator_8271, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7852), Reflex::Literal("operator*"), operator_8272, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10166), Reflex::Literal("operator->"), operator_8273, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234), Reflex::Literal("operator->"), operator_8274, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234), Reflex::Literal("operator const ContainedObject*"), converter_8275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10166), Reflex::Literal("operator ContainedObject*"), converter_8276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRef"), method_8277, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRef"), method_8278, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<DataObject> -------------------------------
static void destructor_8283(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<DataObject>*)o)->::SmartRef<DataObject>::~SmartRef)();
}
static void constructor_8284( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>();
  else ::new(mem) ::SmartRef<DataObject>();
}

static void constructor_8285( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((::DataObject*)arg[0]);
  else ::new(mem) ::SmartRef<DataObject>((::DataObject*)arg[0]);
}

static void constructor_8286( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0]);
  else ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0]);
}

static void constructor_8287( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>(*(const ::SmartRef<DataObject>*)arg[0]);
  else ::new(mem) ::SmartRef<DataObject>(*(const ::SmartRef<DataObject>*)arg[0]);
}

static void constructor_8288( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<DataObject>(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>(*(long*)arg[0],
      *(long*)arg[1],
      (::DataObject*)arg[2]);
  else ::new(mem) ::SmartRef<DataObject>(*(long*)arg[0],
      *(long*)arg[1],
      (::DataObject*)arg[2]);
  }
}

static void constructor_8289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<DataObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::DataObject*)arg[3]);
  else ::new(mem) ::SmartRef<DataObject>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::DataObject*)arg[3]);
  }
}

static void constructor_8290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::DataObject*)arg[3]);
  else ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::DataObject*)arg[3]);
  }
}

static void constructor_8291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::DataObject*)arg[2]);
  else ::new(mem) ::SmartRef<DataObject>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::DataObject*)arg[2]);
  }
}

static  void method_8292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<DataObject>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<DataObject>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_8293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<DataObject>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<DataObject>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_8294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<DataObject>*)o)->hintID)());
  else   (((const ::SmartRef<DataObject>*)o)->hintID)();
}

static  void method_8295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<DataObject>*)o)->linkID)());
  else   (((const ::SmartRef<DataObject>*)o)->linkID)();
}

static  void method_8296( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<DataObject>*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_8297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<DataObject>*)o)->type)());
  else   (((const ::SmartRef<DataObject>*)o)->type)();
}

static  void method_8298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<DataObject>*)o)->data)());
  else   (((::SmartRef<DataObject>*)o)->data)();
}

static  void method_8299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<DataObject>*)o)->data)());
  else   (((const ::SmartRef<DataObject>*)o)->data)();
}

static  void method_8300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<DataObject>*)o)->target)());
  else   (((const ::SmartRef<DataObject>*)o)->target)();
}

static  void method_8301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<DataObject>*)o)->target)());
  else   (((::SmartRef<DataObject>*)o)->target)();
}

static  void method_8302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<DataObject>*)o)->path)();
  else   (((const ::SmartRef<DataObject>*)o)->path)();
}

static  void operator_8303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<DataObject>*)o)->operator==)(*(const ::SmartRef<DataObject>*)arg[0]));
  else   (((const ::SmartRef<DataObject>*)o)->operator==)(*(const ::SmartRef<DataObject>*)arg[0]);
}

static  void operator_8304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<DataObject>*)o)->operator!=)(*(const ::SmartRef<DataObject>*)arg[0]));
  else   (((const ::SmartRef<DataObject>*)o)->operator!=)(*(const ::SmartRef<DataObject>*)arg[0]);
}

static  void method_8305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<DataObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<DataObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_8306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<DataObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<DataObject>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_8307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<DataObject>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<DataObject>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_8308( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<DataObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<DataObject>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_8309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<DataObject>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<DataObject>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_8310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<DataObject>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<DataObject>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_8311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<DataObject>*)o)->operator=)(*(const ::SmartRef<DataObject>*)arg[0]);
  else   (((::SmartRef<DataObject>*)o)->operator=)(*(const ::SmartRef<DataObject>*)arg[0]);
}

static  void operator_8312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<DataObject>*)o)->operator=)((::DataObject*)arg[0]);
  else   (((::SmartRef<DataObject>*)o)->operator=)((::DataObject*)arg[0]);
}

static  void operator_8313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<DataObject>*)o)->operator*)();
  else   (((::SmartRef<DataObject>*)o)->operator*)();
}

static  void operator_8314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<DataObject>*)o)->operator*)();
  else   (((const ::SmartRef<DataObject>*)o)->operator*)();
}

static  void operator_8315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<DataObject>*)o)->operator->)());
  else   (((::SmartRef<DataObject>*)o)->operator->)();
}

static  void operator_8316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<DataObject>*)o)->operator->)());
  else   (((const ::SmartRef<DataObject>*)o)->operator->)();
}

static  void converter_8317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<DataObject>*)o)->operator const DataObject*)());
  else   (((const ::SmartRef<DataObject>*)o)->operator const DataObject*)();
}

static  void converter_8318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<DataObject>*)o)->operator DataObject*)());
  else   (((::SmartRef<DataObject>*)o)->operator DataObject*)();
}

static  void method_8319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<DataObject>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<DataObject>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_8320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<DataObject>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<DataObject>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2749( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<DataObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<DataObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<DataObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<DataObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<DataObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<DataObject> -------------------------------
void __SmartRef_DataObject__db_datamem(Reflex::Class*);
void __SmartRef_DataObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_DataObject__datamem_bld(&__SmartRef_DataObject__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_DataObject__funcmem_bld(&__SmartRef_DataObject__db_funcmem);
void __SmartRef_DataObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<DataObject>"), typeid(::SmartRef<DataObject>), sizeof(::SmartRef<DataObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_303, Reflex::Literal("SmartRef<DataObject>::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_8283, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_8284, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19429), Reflex::Literal("SmartRef"), constructor_8285, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998), Reflex::Literal("SmartRef"), constructor_8286, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7836), Reflex::Literal("SmartRef"), constructor_8287, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_26, type_19429), Reflex::Literal("SmartRef"), constructor_8288, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10234, type_26, type_26, type_19429), Reflex::Literal("SmartRef"), constructor_8289, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_26, type_19429), Reflex::Literal("SmartRef"), constructor_8290, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19998, type_26, type_19429), Reflex::Literal("SmartRef"), constructor_8291, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2749, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_DataObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_DataObject__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<DataObject> -------------------
void __SmartRef_DataObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1617, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_DataObject_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_19998, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_DataObject_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<DataObject> -------------------
void __SmartRef_DataObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_19998), Reflex::Literal("shouldFollowLink"), method_8292, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_10234), Reflex::Literal("shouldFollowLink"), method_8293, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("hintID"), method_8294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("linkID"), method_8295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19429, type_26, type_26), Reflex::Literal("set"), method_8296, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24182), Reflex::Literal("type"), method_8297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("data"), method_8298, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19998), Reflex::Literal("data"), method_8299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19998), Reflex::Literal("target"), method_8300, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("target"), method_8301, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7844), Reflex::Literal("path"), method_8302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7836), Reflex::Literal("operator=="), operator_8303, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_7836), Reflex::Literal("operator!="), operator_8304, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7836, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8305, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662, type_19998, type_10234), Reflex::Literal("_setEnvironment"), method_8306, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662, type_10166), Reflex::Literal("operator()"), operator_8307, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7836, type_10234), Reflex::Literal("operator()"), operator_8308, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662, type_19429), Reflex::Literal("operator()"), operator_8309, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7836, type_19998), Reflex::Literal("operator()"), operator_8310, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662, type_7836), Reflex::Literal("operator="), operator_8311, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662, type_19429), Reflex::Literal("operator="), operator_8312, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19455), Reflex::Literal("operator*"), operator_8313, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7853), Reflex::Literal("operator*"), operator_8314, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("operator->"), operator_8315, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19998), Reflex::Literal("operator->"), operator_8316, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19998), Reflex::Literal("operator const DataObject*"), converter_8317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("operator DataObject*"), converter_8318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("writeRef"), method_8319, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5648, type_5648), Reflex::Literal("readRef"), method_8320, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class LinkManager -------------------------------
static  void operator_8327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LinkManager*)o)->operator=)(*(const ::LinkManager*)arg[0]);
  else   (((::LinkManager*)o)->operator=)(*(const ::LinkManager*)arg[0]);
}

static void constructor_8328( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LinkManager(*(const ::LinkManager*)arg[0]);
  else ::new(mem) ::LinkManager(*(const ::LinkManager*)arg[0]);
}

static void constructor_8329( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LinkManager();
  else ::new(mem) ::LinkManager();
}

static void destructor_8330(void*, void * o, const std::vector<void*>&, void *) {
(((::LinkManager*)o)->::LinkManager::~LinkManager)();
}
static  void method_8331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LinkManager*)o)->newInstance)());
  else   (((::LinkManager*)o)->newInstance)();
}

static  void method_8332( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LinkManager*)o)->setInstantiator)(Reflex::VoidPtrToFunc< ::LinkManager*(*)(void) >(arg[0]));
}

static  void method_8333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::LinkManager*)o)->size)());
  else   (((const ::LinkManager*)o)->size)();
}

static  void method_8334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LinkManager*)o)->link)(*(long*)arg[0]));
  else   (((::LinkManager*)o)->link)(*(long*)arg[0]);
}

static  void method_8335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LinkManager*)o)->link)((const ::DataObject*)arg[0]));
  else   (((::LinkManager*)o)->link)((const ::DataObject*)arg[0]);
}

static  void method_8336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LinkManager*)o)->link)(*(const ::std::string*)arg[0]));
  else   (((::LinkManager*)o)->link)(*(const ::std::string*)arg[0]);
}

static  void method_8337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::LinkManager*)o)->addLink)(*(const ::std::string*)arg[0],
    (const ::DataObject*)arg[1]));
  else   (((const ::LinkManager*)o)->addLink)(*(const ::std::string*)arg[0],
    (const ::DataObject*)arg[1]);
}

static  void method_8338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::LinkManager*)o)->removeLink)((const ::DataObject*)arg[0]));
  else   (((const ::LinkManager*)o)->removeLink)((const ::DataObject*)arg[0]);
}

static  void method_8339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::LinkManager*)o)->removeLink)(*(const ::std::string*)arg[0]));
  else   (((const ::LinkManager*)o)->removeLink)(*(const ::std::string*)arg[0]);
}

static  void method_8340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::LinkManager*)o)->removeLink)(*(long*)arg[0]));
  else   (((const ::LinkManager*)o)->removeLink)(*(long*)arg[0]);
}

static  void method_8341( void*, void* o, const std::vector<void*>&, void*)
{
  (((::LinkManager*)o)->clearLinks)();
}

static void method_newdel_2759( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LinkManager >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LinkManager >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LinkManager >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LinkManager >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LinkManager >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LinkManager -------------------------------
void __LinkManager_db_datamem(Reflex::Class*);
void __LinkManager_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LinkManager_datamem_bld(&__LinkManager_db_datamem);
Reflex::GenreflexMemberBuilder __LinkManager_funcmem_bld(&__LinkManager_db_funcmem);
void __LinkManager_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LinkManager"), typeid(::LinkManager), sizeof(::LinkManager), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("LinkManager::DirLinkType"), Reflex::Literal("INVALID=0;VALID=1"), &typeid(LinkManager::DirLinkType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_3157, Reflex::Literal("LinkManager::LinkVector"))
  .AddTypedef(type_6758, Reflex::Literal("LinkManager::LinkIterator"))
  .AddTypedef(type_6759, Reflex::Literal("LinkManager::ConstLinkIterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24425, type_24426), Reflex::Literal("operator="), operator_8327, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24426), Reflex::Literal("LinkManager"), constructor_8328, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LinkManager"), constructor_8329, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LinkManager"), destructor_8330, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2759, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LinkManager_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LinkManager_funcmem_bld);
}

//------Delayed data member builder for class LinkManager -------------------
void __LinkManager_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3157, Reflex::Literal("m_linkVector"), OffsetOf(__shadow__::__LinkManager, m_linkVector), ::Reflex::PUBLIC | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class LinkManager -------------------
void __LinkManager_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19454), Reflex::Literal("newInstance"), method_8331, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_24427), Reflex::Literal("setInstantiator"), method_8332, 0, "newInstance", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("size"), method_8333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10302, type_26), Reflex::Literal("link"), method_8334, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10302, type_19998), Reflex::Literal("link"), method_8335, 0, "pObject", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10302, type_6134), Reflex::Literal("link"), method_8336, 0, "path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26, type_6134, type_19998), Reflex::Literal("addLink"), method_8337, 0, "path;pObject", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26, type_19998), Reflex::Literal("removeLink"), method_8338, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26, type_6134), Reflex::Literal("removeLink"), method_8339, 0, "fullPath", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26, type_26), Reflex::Literal("removeLink"), method_8340, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clearLinks"), method_8341, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class INamedInterface -------------------------------
static  void operator_8703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::INamedInterface*)o)->operator=)(*(const ::INamedInterface*)arg[0]);
  else   (((::INamedInterface*)o)->operator=)(*(const ::INamedInterface*)arg[0]);
}

static  void method_8706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::INamedInterface*)o)->interfaceID)();
  else   (((::INamedInterface*)o)->interfaceID)();
}

static  void method_8707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::INamedInterface*)o)->name)();
  else   (((const ::INamedInterface*)o)->name)();
}

static void destructor_8708(void*, void * o, const std::vector<void*>&, void *) {
(((::INamedInterface*)o)->::INamedInterface::~INamedInterface)();
}
static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::INamedInterface,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class INamedInterface -------------------------------
void __INamedInterface_db_datamem(Reflex::Class*);
void __INamedInterface_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __INamedInterface_datamem_bld(&__INamedInterface_db_datamem);
Reflex::GenreflexMemberBuilder __INamedInterface_funcmem_bld(&__INamedInterface_db_funcmem);
void __INamedInterface_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("INamedInterface"), typeid(::INamedInterface), sizeof(::INamedInterface), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::INamedInterface, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26050, type_19469), Reflex::Literal("operator="), operator_8703, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~INamedInterface"), destructor_8708, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__INamedInterface_funcmem_bld);
}

//------Delayed data member builder for class INamedInterface -------------------
void __INamedInterface_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class INamedInterface -------------------
void __INamedInterface_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_8706, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_8707, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IOpaqueAddress -------------------------------
static  void operator_8710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IOpaqueAddress*)o)->operator=)(*(const ::IOpaqueAddress*)arg[0]);
  else   (((::IOpaqueAddress*)o)->operator=)(*(const ::IOpaqueAddress*)arg[0]);
}

static void destructor_8713(void*, void * o, const std::vector<void*>&, void *) {
(((::IOpaqueAddress*)o)->::IOpaqueAddress::~IOpaqueAddress)();
}
static  void method_8714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::IOpaqueAddress*)o)->addRef)());
  else   (((::IOpaqueAddress*)o)->addRef)();
}

static  void method_8715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::IOpaqueAddress*)o)->release)());
  else   (((::IOpaqueAddress*)o)->release)();
}

static  void method_8716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IOpaqueAddress*)o)->clID)();
  else   (((const ::IOpaqueAddress*)o)->clID)();
}

static  void method_8717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::IOpaqueAddress*)o)->svcType)());
  else   (((const ::IOpaqueAddress*)o)->svcType)();
}

static  void method_8718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IOpaqueAddress*)o)->registry)());
  else   (((const ::IOpaqueAddress*)o)->registry)();
}

static  void method_8719( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IOpaqueAddress*)o)->setRegistry)((::IRegistry*)arg[0]);
}

static  void method_8720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IOpaqueAddress*)o)->par)());
  else   (((const ::IOpaqueAddress*)o)->par)();
}

static  void method_8721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IOpaqueAddress*)o)->ipar)());
  else   (((const ::IOpaqueAddress*)o)->ipar)();
}

//------Dictionary for class IOpaqueAddress -------------------------------
void __IOpaqueAddress_db_datamem(Reflex::Class*);
void __IOpaqueAddress_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IOpaqueAddress_datamem_bld(&__IOpaqueAddress_db_datamem);
Reflex::GenreflexMemberBuilder __IOpaqueAddress_funcmem_bld(&__IOpaqueAddress_db_funcmem);
void __IOpaqueAddress_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IOpaqueAddress"), typeid(::IOpaqueAddress), sizeof(::IOpaqueAddress), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26051, type_26052), Reflex::Literal("operator="), operator_8710, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IOpaqueAddress"), destructor_8713, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IOpaqueAddress_funcmem_bld);
}

//------Delayed data member builder for class IOpaqueAddress -------------------
void __IOpaqueAddress_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IOpaqueAddress -------------------
void __IOpaqueAddress_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("addRef"), method_8714, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("release"), method_8715, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_8716, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("svcType"), method_8717, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10115), Reflex::Literal("registry"), method_8718, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10115), Reflex::Literal("setRegistry"), method_8719, 0, "r", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19925), Reflex::Literal("par"), method_8720, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11902), Reflex::Literal("ipar"), method_8721, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IRunable -------------------------------
static  void operator_8722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRunable*)o)->operator=)(*(const ::IRunable*)arg[0]);
  else   (((::IRunable*)o)->operator=)(*(const ::IRunable*)arg[0]);
}

static  void method_8725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IRunable*)o)->interfaceID)();
  else   (((::IRunable*)o)->interfaceID)();
}

static  void method_8726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IRunable*)o)->run)());
  else   (((::IRunable*)o)->run)();
}

static void destructor_8727(void*, void * o, const std::vector<void*>&, void *) {
(((::IRunable*)o)->::IRunable::~IRunable)();
}
static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IRunable,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IRunable -------------------------------
void __IRunable_db_datamem(Reflex::Class*);
void __IRunable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IRunable_datamem_bld(&__IRunable_db_datamem);
Reflex::GenreflexMemberBuilder __IRunable_funcmem_bld(&__IRunable_db_funcmem);
void __IRunable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IRunable"), typeid(::IRunable), sizeof(::IRunable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1730, ::Reflex::BaseOffset< ::IRunable, ::IInterface >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26053, type_26054), Reflex::Literal("operator="), operator_8722, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IRunable"), destructor_8727, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IRunable_funcmem_bld);
}

//------Delayed data member builder for class IRunable -------------------
void __IRunable_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IRunable -------------------
void __IRunable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_8725, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("run"), method_8726, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class StatusCode -------------------------------
static void constructor_8740( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StatusCode();
  else ::new(mem) ::StatusCode();
}

static void constructor_8741( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StatusCode(*(unsigned long*)arg[0],
      *(const ::IssueSeverity*)arg[1]);
  else ::new(mem) ::StatusCode(*(unsigned long*)arg[0],
      *(const ::IssueSeverity*)arg[1]);
}

static void constructor_8742( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::StatusCode(*(unsigned long*)arg[0]);
  else ::new(mem) ::StatusCode(*(unsigned long*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::StatusCode(*(unsigned long*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::StatusCode(*(unsigned long*)arg[0],
      *(bool*)arg[1]);
  }
}

static void constructor_8743( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StatusCode(*(const ::StatusCode*)arg[0]);
  else ::new(mem) ::StatusCode(*(const ::StatusCode*)arg[0]);
}

static void destructor_8744(void*, void * o, const std::vector<void*>&, void *) {
(((::StatusCode*)o)->::StatusCode::~StatusCode)();
}
static  void method_8745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::StatusCode*)o)->isSuccess)());
  else   (((const ::StatusCode*)o)->isSuccess)();
}

static  void method_8746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::StatusCode*)o)->isFailure)());
  else   (((const ::StatusCode*)o)->isFailure)();
}

static  void method_8747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::StatusCode*)o)->isRecoverable)());
  else   (((const ::StatusCode*)o)->isRecoverable)();
}

static  void method_8748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::StatusCode*)o)->getCode)());
  else   (((const ::StatusCode*)o)->getCode)();
}

static  void method_8749( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::StatusCode*)o)->setCode)(*(unsigned long*)arg[0]);
}

static  void method_8750( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::StatusCode*)o)->setChecked)();
}

static  void method_8751( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::StatusCode*)o)->ignore)();
}

static  void converter_8752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::StatusCode*)o)->operator unsigned long)());
  else   (((const ::StatusCode*)o)->operator unsigned long)();
}

static  void method_8753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::StatusCode*)o)->severity)();
  else   (((const ::StatusCode*)o)->severity)();
}

static  void operator_8754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::StatusCode*)o)->operator=)(*(unsigned long*)arg[0]);
  else   (((::StatusCode*)o)->operator=)(*(unsigned long*)arg[0]);
}

static  void operator_8755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::StatusCode*)o)->operator=)(*(const ::StatusCode*)arg[0]);
  else   (((::StatusCode*)o)->operator=)(*(const ::StatusCode*)arg[0]);
}

static  void converter_8756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (IgnoreError)((((const ::StatusCode*)o)->operator IgnoreError)());
  else   (((const ::StatusCode*)o)->operator IgnoreError)();
}

static  void method_8757( void*, void* o, const std::vector<void*>&, void*)
{
  (((::StatusCode*)o)->enableChecking)();
}

static  void method_8758( void*, void* o, const std::vector<void*>&, void*)
{
  (((::StatusCode*)o)->disableChecking)();
}

static void method_newdel_2872( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::StatusCode >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::StatusCode >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::StatusCode >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::StatusCode >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::StatusCode >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class StatusCode -------------------------------
void __StatusCode_db_datamem(Reflex::Class*);
void __StatusCode_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __StatusCode_datamem_bld(&__StatusCode_db_datamem);
Reflex::GenreflexMemberBuilder __StatusCode_funcmem_bld(&__StatusCode_db_funcmem);
void __StatusCode_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("StatusCode"), typeid(::StatusCode), sizeof(::StatusCode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_82"), Reflex::Literal("FAILURE=0;SUCCESS=1;RECOVERABLE=2"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_8738, Reflex::Literal("StatusCode::SeverityPtr"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("StatusCode"), constructor_8740, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_502, type_7854), Reflex::Literal("StatusCode"), constructor_8741, 0, "code;sev", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_502, type_4206), Reflex::Literal("StatusCode"), constructor_8742, 0, "code;checked=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7461), Reflex::Literal("StatusCode"), constructor_8743, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StatusCode"), destructor_8744, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2872, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__StatusCode_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__StatusCode_funcmem_bld);
}

//------Delayed data member builder for class StatusCode -------------------
void __StatusCode_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_502, Reflex::Literal("d_code"), OffsetOf(__shadow__::__StatusCode, d_code), ::Reflex::PROTECTED)
  .AddDataMember(type_4206, Reflex::Literal("m_checked"), OffsetOf(__shadow__::__StatusCode, m_checked), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_8738, Reflex::Literal("m_severity"), OffsetOf(__shadow__::__StatusCode, m_severity), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class StatusCode -------------------
void __StatusCode_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isSuccess"), method_8745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isFailure"), method_8746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isRecoverable"), method_8747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("getCode"), method_8748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_502), Reflex::Literal("setCode"), method_8749, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("setChecked"), method_8750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("ignore"), method_8751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("operator unsigned long"), converter_8752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7854), Reflex::Literal("severity"), method_8753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26057, type_502), Reflex::Literal("operator="), operator_8754, 0, "value", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26057, type_7461), Reflex::Literal("operator="), operator_8755, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2767), Reflex::Literal("operator IgnoreError"), converter_8756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("enableChecking"), method_8757, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("disableChecking"), method_8758, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Algorithm -------------------------------
static void destructor_8805(void*, void * o, const std::vector<void*>&, void *) {
(((::Algorithm*)o)->::Algorithm::~Algorithm)();
}
static  void method_8806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysStart)());
  else   (((::Algorithm*)o)->sysStart)();
}

static  void method_8807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysInitialize)());
  else   (((::Algorithm*)o)->sysInitialize)();
}

static  void method_8808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysReinitialize)());
  else   (((::Algorithm*)o)->sysReinitialize)();
}

static  void method_8809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysRestart)());
  else   (((::Algorithm*)o)->sysRestart)();
}

static  void method_8810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysExecute)());
  else   (((::Algorithm*)o)->sysExecute)();
}

static  void method_8811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysStop)());
  else   (((::Algorithm*)o)->sysStop)();
}

static  void method_8812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysFinalize)());
  else   (((::Algorithm*)o)->sysFinalize)();
}

static  void method_8813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysBeginRun)());
  else   (((::Algorithm*)o)->sysBeginRun)();
}

static  void method_8814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->sysEndRun)());
  else   (((::Algorithm*)o)->sysEndRun)();
}

static  void method_8815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->name)();
  else   (((const ::Algorithm*)o)->name)();
}

static  void method_8816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->version)();
  else   (((const ::Algorithm*)o)->version)();
}

static  void method_8817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->configure)());
  else   (((::Algorithm*)o)->configure)();
}

static  void method_8818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->terminate)());
  else   (((::Algorithm*)o)->terminate)();
}

static  void method_8819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->initialize)());
  else   (((::Algorithm*)o)->initialize)();
}

static  void method_8820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->start)());
  else   (((::Algorithm*)o)->start)();
}

static  void method_8821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->stop)());
  else   (((::Algorithm*)o)->stop)();
}

static  void method_8822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->finalize)());
  else   (((::Algorithm*)o)->finalize)();
}

static  void method_8823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->reinitialize)());
  else   (((::Algorithm*)o)->reinitialize)();
}

static  void method_8824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->restart)());
  else   (((::Algorithm*)o)->restart)();
}

static  void method_8825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Algorithm*)o)->isExecuted)());
  else   (((const ::Algorithm*)o)->isExecuted)();
}

static  void method_8826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Algorithm*)o)->setExecuted)(*(bool*)arg[0]);
}

static  void method_8827( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Algorithm*)o)->resetExecuted)();
}

static  void method_8828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->beginRun)());
  else   (((::Algorithm*)o)->beginRun)();
}

static  void method_8829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->endRun)());
  else   (((::Algorithm*)o)->endRun)();
}

static  void method_8830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Algorithm*)o)->FSMState)());
  else   (((const ::Algorithm*)o)->FSMState)();
}

static  void method_8831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Algorithm*)o)->targetFSMState)());
  else   (((const ::Algorithm*)o)->targetFSMState)();
}

static  void method_8832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Algorithm*)o)->isEnabled)());
  else   (((const ::Algorithm*)o)->isEnabled)();
}

static  void method_8833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Algorithm*)o)->filterPassed)());
  else   (((const ::Algorithm*)o)->filterPassed)();
}

static  void method_8834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Algorithm*)o)->setFilterPassed)(*(bool*)arg[0]);
}

static  void method_8835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (SmartIF<IService>)((((const ::Algorithm*)o)->service)(*(const ::std::string*)arg[0]));
    else     (((const ::Algorithm*)o)->service)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (SmartIF<IService>)((((const ::Algorithm*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1]));
    else     (((const ::Algorithm*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (SmartIF<IService>)((((const ::Algorithm*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]));
    else     (((const ::Algorithm*)o)->service)(*(const ::std::string*)arg[0],
      *(const bool*)arg[1],
      *(const bool*)arg[2]);
  }
}

static  void method_8836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Algorithm*)o)->setOutputLevel)(*(int*)arg[0]);
}

static  void method_8837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->auditorSvc)();
  else   (((const ::Algorithm*)o)->auditorSvc)();
}

static  void method_8838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->chronoSvc)();
  else   (((const ::Algorithm*)o)->chronoSvc)();
}

static  void method_8839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->chronoStatService)();
  else   (((const ::Algorithm*)o)->chronoStatService)();
}

static  void method_8840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->detSvc)();
  else   (((const ::Algorithm*)o)->detSvc)();
}

static  void method_8841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->detDataService)();
  else   (((const ::Algorithm*)o)->detDataService)();
}

static  void method_8842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->detCnvSvc)();
  else   (((const ::Algorithm*)o)->detCnvSvc)();
}

static  void method_8843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->detDataCnvService)();
  else   (((const ::Algorithm*)o)->detDataCnvService)();
}

static  void method_8844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->eventSvc)();
  else   (((const ::Algorithm*)o)->eventSvc)();
}

static  void method_8845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->evtSvc)();
  else   (((const ::Algorithm*)o)->evtSvc)();
}

static  void method_8846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->eventDataService)();
  else   (((const ::Algorithm*)o)->eventDataService)();
}

static  void method_8847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->eventCnvSvc)();
  else   (((const ::Algorithm*)o)->eventCnvSvc)();
}

static  void method_8848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->eventDataCnvService)();
  else   (((const ::Algorithm*)o)->eventDataCnvService)();
}

static  void method_8849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->histoSvc)();
  else   (((const ::Algorithm*)o)->histoSvc)();
}

static  void method_8850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->histogramDataService)();
  else   (((const ::Algorithm*)o)->histogramDataService)();
}

static  void method_8851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->msgSvc)();
  else   (((const ::Algorithm*)o)->msgSvc)();
}

static  void method_8852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->messageService)();
  else   (((const ::Algorithm*)o)->messageService)();
}

static  void method_8853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->ntupleSvc)();
  else   (((const ::Algorithm*)o)->ntupleSvc)();
}

static  void method_8854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->ntupleService)();
  else   (((const ::Algorithm*)o)->ntupleService)();
}

static  void method_8855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->randSvc)();
  else   (((const ::Algorithm*)o)->randSvc)();
}

static  void method_8856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->toolSvc)();
  else   (((const ::Algorithm*)o)->toolSvc)();
}

static  void method_8857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->exceptionSvc)();
  else   (((const ::Algorithm*)o)->exceptionSvc)();
}

static  void method_8858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->contextSvc)();
  else   (((const ::Algorithm*)o)->contextSvc)();
}

static  void method_8859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->serviceLocator)();
  else   (((const ::Algorithm*)o)->serviceLocator)();
}

static  void method_8860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->svcLoc)();
  else   (((const ::Algorithm*)o)->svcLoc)();
}

static  void method_8861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Algorithm*)o)->registerContext)());
  else   (((const ::Algorithm*)o)->registerContext)();
}

static  void method_8862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->createSubAlgorithm)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::Algorithm**)arg[2]));
  else   (((::Algorithm*)o)->createSubAlgorithm)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(::Algorithm**)arg[2]);
}

static  void method_8863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Algorithm*)o)->subAlgorithms)());
  else   (((const ::Algorithm*)o)->subAlgorithms)();
}

static  void method_8864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->setProperty)(*(const ::Property*)arg[0]));
  else   (((::Algorithm*)o)->setProperty)(*(const ::Property*)arg[0]);
}

static  void method_8865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->setProperty)(*(const ::std::string*)arg[0]));
  else   (((::Algorithm*)o)->setProperty)(*(const ::std::string*)arg[0]);
}

static  void method_8866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((::Algorithm*)o)->setProperty)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::Algorithm*)o)->getProperty)((::Property*)arg[0]));
  else   (((const ::Algorithm*)o)->getProperty)((::Property*)arg[0]);
}

static  void method_8868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->getProperty)(*(const ::std::string*)arg[0]);
  else   (((const ::Algorithm*)o)->getProperty)(*(const ::std::string*)arg[0]);
}

static  void method_8869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((const ::Algorithm*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::Algorithm*)o)->getProperty)(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_8870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->getProperties)();
  else   (((const ::Algorithm*)o)->getProperties)();
}

static  void method_8871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Algorithm*)o)->setProperties)());
  else   (((::Algorithm*)o)->setProperties)();
}

static  void method_8872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Algorithm*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1]));
    else     (((const ::Algorithm*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Algorithm*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::Algorithm*)o)->declareRemoteProperty)(*(const ::std::string*)arg[0],
      (::IProperty*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_8873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Algorithm*)o)->monitorSvc)();
  else   (((const ::Algorithm*)o)->monitorSvc)();
}

static  void method_8874( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::Algorithm*)o)->declareInfo)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    (const void*)arg[2],
    *(int*)arg[3],
    *(const ::std::string*)arg[4]);
}

static void method_x137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("implements3<IAlgorithm,IProperty,IStateful>")), ::Reflex::BaseOffset< ::Algorithm,::implements3<IAlgorithm,IProperty,IStateful> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("extend_interfaces3<IAlgorithm,IProperty,IStateful>")), ::Reflex::BaseOffset< ::Algorithm,::extend_interfaces3<IAlgorithm,IProperty,IStateful> >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IAlgorithm")), ::Reflex::BaseOffset< ::Algorithm,::IAlgorithm >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::Algorithm,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::Algorithm,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IProperty")), ::Reflex::BaseOffset< ::Algorithm,::IProperty >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IStateful")), ::Reflex::BaseOffset< ::Algorithm,::IStateful >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Algorithm -------------------------------
void __Algorithm_db_datamem(Reflex::Class*);
void __Algorithm_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Algorithm_datamem_bld(&__Algorithm_db_datamem);
Reflex::GenreflexMemberBuilder __Algorithm_funcmem_bld(&__Algorithm_db_funcmem);
void __Algorithm_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Algorithm"), typeid(::Algorithm), sizeof(::Algorithm), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_1917, ::Reflex::BaseOffset< ::Algorithm, ::implements3<IAlgorithm,IProperty,IStateful> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_8802, Reflex::Literal("Algorithm::Factory"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Algorithm"), destructor_8805, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Algorithm_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Algorithm_funcmem_bld);
}

//------Delayed data member builder for class Algorithm -------------------
void __Algorithm_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3236, Reflex::Literal("m_name"), OffsetOf(__shadow__::__Algorithm, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_version"), OffsetOf(__shadow__::__Algorithm, m_version), ::Reflex::PRIVATE)
  .AddDataMember(type_26063, Reflex::Literal("m_subAlgms"), OffsetOf(__shadow__::__Algorithm, m_subAlgms), ::Reflex::PRIVATE)
  .AddDataMember(type_1597, Reflex::Literal("m_MS"), OffsetOf(__shadow__::__Algorithm, m_MS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1607, Reflex::Literal("m_EDS"), OffsetOf(__shadow__::__Algorithm, m_EDS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1606, Reflex::Literal("m_ECS"), OffsetOf(__shadow__::__Algorithm, m_ECS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1607, Reflex::Literal("m_DDS"), OffsetOf(__shadow__::__Algorithm, m_DDS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1606, Reflex::Literal("m_DCS"), OffsetOf(__shadow__::__Algorithm, m_DCS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1605, Reflex::Literal("m_HDS"), OffsetOf(__shadow__::__Algorithm, m_HDS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1604, Reflex::Literal("m_NTS"), OffsetOf(__shadow__::__Algorithm, m_NTS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1603, Reflex::Literal("m_CSS"), OffsetOf(__shadow__::__Algorithm, m_CSS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1602, Reflex::Literal("m_RGS"), OffsetOf(__shadow__::__Algorithm, m_RGS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1601, Reflex::Literal("m_EXS"), OffsetOf(__shadow__::__Algorithm, m_EXS), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1594, Reflex::Literal("m_pAuditorSvc"), OffsetOf(__shadow__::__Algorithm, m_pAuditorSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1600, Reflex::Literal("m_ptoolSvc"), OffsetOf(__shadow__::__Algorithm, m_ptoolSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1598, Reflex::Literal("m_pMonitorSvc"), OffsetOf(__shadow__::__Algorithm, m_pMonitorSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1599, Reflex::Literal("m_contextSvc"), OffsetOf(__shadow__::__Algorithm, m_contextSvc), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_4206, Reflex::Literal("m_registerContext"), OffsetOf(__shadow__::__Algorithm, m_registerContext), ::Reflex::PRIVATE)
  .AddDataMember(type_3236, Reflex::Literal("m_monitorSvcName"), OffsetOf(__shadow__::__Algorithm, m_monitorSvcName), ::Reflex::PRIVATE)
  .AddDataMember(type_1596, Reflex::Literal("m_pSvcLocator"), OffsetOf(__shadow__::__Algorithm, m_pSvcLocator), ::Reflex::PRIVATE)
  .AddDataMember(type_20052, Reflex::Literal("m_propertyMgr"), OffsetOf(__shadow__::__Algorithm, m_propertyMgr), ::Reflex::PRIVATE)
  .AddDataMember(type_2896, Reflex::Literal("m_outputLevel"), OffsetOf(__shadow__::__Algorithm, m_outputLevel), ::Reflex::PRIVATE)
  .AddDataMember(type_142, Reflex::Literal("m_errorMax"), OffsetOf(__shadow__::__Algorithm, m_errorMax), ::Reflex::PRIVATE)
  .AddDataMember(type_142, Reflex::Literal("m_errorCount"), OffsetOf(__shadow__::__Algorithm, m_errorCount), ::Reflex::PRIVATE)
  .AddDataMember(type_586, Reflex::Literal("m_auditInit"), OffsetOf(__shadow__::__Algorithm, m_auditInit), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorInitialize"), OffsetOf(__shadow__::__Algorithm, m_auditorInitialize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorReinitialize"), OffsetOf(__shadow__::__Algorithm, m_auditorReinitialize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorRestart"), OffsetOf(__shadow__::__Algorithm, m_auditorRestart), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorExecute"), OffsetOf(__shadow__::__Algorithm, m_auditorExecute), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorFinalize"), OffsetOf(__shadow__::__Algorithm, m_auditorFinalize), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorBeginRun"), OffsetOf(__shadow__::__Algorithm, m_auditorBeginRun), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorEndRun"), OffsetOf(__shadow__::__Algorithm, m_auditorEndRun), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorStart"), OffsetOf(__shadow__::__Algorithm, m_auditorStart), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_auditorStop"), OffsetOf(__shadow__::__Algorithm, m_auditorStop), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_filterPassed"), OffsetOf(__shadow__::__Algorithm, m_filterPassed), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_isEnabled"), OffsetOf(__shadow__::__Algorithm, m_isEnabled), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_isExecuted"), OffsetOf(__shadow__::__Algorithm, m_isExecuted), ::Reflex::PRIVATE)
  .AddDataMember(type_19509, Reflex::Literal("m_state"), OffsetOf(__shadow__::__Algorithm, m_state), ::Reflex::PRIVATE)
  .AddDataMember(type_19509, Reflex::Literal("m_targetState"), OffsetOf(__shadow__::__Algorithm, m_targetState), ::Reflex::PRIVATE)
  .AddDataMember(type_4206, Reflex::Literal("m_isFinalized"), OffsetOf(__shadow__::__Algorithm, m_isFinalized), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Algorithm -------------------
void __Algorithm_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStart"), method_8806, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysInitialize"), method_8807, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysReinitialize"), method_8808, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysRestart"), method_8809, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysExecute"), method_8810, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysStop"), method_8811, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysFinalize"), method_8812, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysBeginRun"), method_8813, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("sysEndRun"), method_8814, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_8815, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("version"), method_8816, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("configure"), method_8817, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("terminate"), method_8818, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("initialize"), method_8819, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("start"), method_8820, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("stop"), method_8821, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_8822, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("reinitialize"), method_8823, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("restart"), method_8824, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isExecuted"), method_8825, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4206), Reflex::Literal("setExecuted"), method_8826, 0, "state", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("resetExecuted"), method_8827, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("beginRun"), method_8828, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("endRun"), method_8829, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("FSMState"), method_8830, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19509), Reflex::Literal("targetFSMState"), method_8831, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isEnabled"), method_8832, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("filterPassed"), method_8833, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4206), Reflex::Literal("setFilterPassed"), method_8834, 0, "state", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1593, type_6134, type_4206c, type_4206c), Reflex::Literal("service"), method_8835, 0, "name;createIf=true;quiet=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_142), Reflex::Literal("setOutputLevel"), method_8836, 0, "level", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20109), Reflex::Literal("auditorSvc"), method_8837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20995), Reflex::Literal("chronoSvc"), method_8838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20995), Reflex::Literal("chronoStatService"), method_8839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937), Reflex::Literal("detSvc"), method_8840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937), Reflex::Literal("detDataService"), method_8841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19938), Reflex::Literal("detCnvSvc"), method_8842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19938), Reflex::Literal("detDataCnvService"), method_8843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937), Reflex::Literal("eventSvc"), method_8844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937), Reflex::Literal("evtSvc"), method_8845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19937), Reflex::Literal("eventDataService"), method_8846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19938), Reflex::Literal("eventCnvSvc"), method_8847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19938), Reflex::Literal("eventDataCnvService"), method_8848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21004), Reflex::Literal("histoSvc"), method_8849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21004), Reflex::Literal("histogramDataService"), method_8850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20969), Reflex::Literal("msgSvc"), method_8851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20969), Reflex::Literal("messageService"), method_8852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20999), Reflex::Literal("ntupleSvc"), method_8853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20999), Reflex::Literal("ntupleService"), method_8854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20990), Reflex::Literal("randSvc"), method_8855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20981), Reflex::Literal("toolSvc"), method_8856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20985), Reflex::Literal("exceptionSvc"), method_8857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20977), Reflex::Literal("contextSvc"), method_8858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20108), Reflex::Literal("serviceLocator"), method_8859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20108), Reflex::Literal("svcLoc"), method_8860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("registerContext"), method_8861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134, type_26064), Reflex::Literal("createSubAlgorithm"), method_8862, 0, "type;name;pSubAlg", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26063), Reflex::Literal("subAlgorithms"), method_8863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_7834), Reflex::Literal("setProperty"), method_8864, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134), Reflex::Literal("setProperty"), method_8865, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_6134), Reflex::Literal("setProperty"), method_8866, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_11428), Reflex::Literal("getProperty"), method_8867, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7834, type_6134), Reflex::Literal("getProperty"), method_8868, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19991), Reflex::Literal("getProperty"), method_8869, 0, "n;v", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19992), Reflex::Literal("getProperties"), method_8870, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("setProperties"), method_8871, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11428, type_6134, type_19990, type_6134), Reflex::Literal("declareRemoteProperty"), method_8872, 0, "name;rsvc;rname=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20972), Reflex::Literal("monitorSvc"), method_8873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134, type_6134, type_4284, type_142, type_6134), Reflex::Literal("declareInfo"), method_8874, 0, "name;format;var;size;desc", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class IIssueLogger -------------------------------
static  void operator_8884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IIssueLogger*)o)->operator=)(*(const ::IIssueLogger*)arg[0]);
  else   (((::IIssueLogger*)o)->operator=)(*(const ::IIssueLogger*)arg[0]);
}

static  void method_8887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IIssueLogger*)o)->interfaceID)();
  else   (((::IIssueLogger*)o)->interfaceID)();
}

static  void method_8888( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IIssueLogger*)o)->report)(*(::IssueSeverity::Level*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
}

static  void method_8889( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IIssueLogger*)o)->report)(*(const ::IssueSeverity*)arg[0]);
}

static void destructor_8890(void*, void * o, const std::vector<void*>&, void *) {
(((::IIssueLogger*)o)->::IIssueLogger::~IIssueLogger)();
}
static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IService")), ::Reflex::BaseOffset< ::IIssueLogger,::IService >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INamedInterface")), ::Reflex::BaseOffset< ::IIssueLogger,::INamedInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IInterface")), ::Reflex::BaseOffset< ::IIssueLogger,::IInterface >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IIssueLogger -------------------------------
void __IIssueLogger_db_datamem(Reflex::Class*);
void __IIssueLogger_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IIssueLogger_datamem_bld(&__IIssueLogger_db_datamem);
Reflex::GenreflexMemberBuilder __IIssueLogger_funcmem_bld(&__IIssueLogger_db_funcmem);
void __IIssueLogger_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IIssueLogger"), typeid(::IIssueLogger), sizeof(::IIssueLogger), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_934, ::Reflex::BaseOffset< ::IIssueLogger, ::IService >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26066, type_26067), Reflex::Literal("operator="), operator_8884, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IIssueLogger"), destructor_8890, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IIssueLogger_funcmem_bld);
}

//------Delayed data member builder for class IIssueLogger -------------------
void __IIssueLogger_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IIssueLogger -------------------
void __IIssueLogger_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("interfaceID"), method_8887, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_5148, type_6134, type_6134), Reflex::Literal("report"), method_8888, 0, "level;msg;origin", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7854), Reflex::Literal("report"), method_8889, 0, "err", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class IInspectable -------------------------------
static  void operator_8891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IInspectable*)o)->operator=)(*(const ::IInspectable*)arg[0]);
  else   (((::IInspectable*)o)->operator=)(*(const ::IInspectable*)arg[0]);
}

static void destructor_8894(void*, void * o, const std::vector<void*>&, void *) {
(((::IInspectable*)o)->::IInspectable::~IInspectable)();
}
static  void method_8895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::IInspectable*)o)->acceptInspector)((::IInspector*)arg[0]));
  else   (((::IInspectable*)o)->acceptInspector)((::IInspector*)arg[0]);
}

static  void method_8896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::IInspectable*)o)->acceptInspector)((::IInspector*)arg[0]));
  else   (((const ::IInspectable*)o)->acceptInspector)((::IInspector*)arg[0]);
}

//------Dictionary for class IInspectable -------------------------------
void __IInspectable_db_datamem(Reflex::Class*);
void __IInspectable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IInspectable_datamem_bld(&__IInspectable_db_datamem);
Reflex::GenreflexMemberBuilder __IInspectable_funcmem_bld(&__IInspectable_db_funcmem);
void __IInspectable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IInspectable"), typeid(::IInspectable), sizeof(::IInspectable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26068, type_26069), Reflex::Literal("operator="), operator_8891, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IInspectable"), destructor_8894, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__IInspectable_funcmem_bld);
}

//------Delayed data member builder for class IInspectable -------------------
void __IInspectable_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class IInspectable -------------------
void __IInspectable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_26070), Reflex::Literal("acceptInspector"), method_8895, 0, "pI", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_26070), Reflex::Literal("acceptInspector"), method_8896, 0, "pI", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class vector<ContainedObject*,std::allocator<ContainedObject*> > -------------------------------
static void constructor_10186( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ContainedObject*>();
  else ::new(mem) ::std::vector<ContainedObject*>();
}

static void constructor_10187( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ContainedObject*>(*(const ::std::allocator<ContainedObject*>*)arg[0]);
  else ::new(mem) ::std::vector<ContainedObject*>(*(const ::std::allocator<ContainedObject*>*)arg[0]);
}

static void constructor_10188( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ContainedObject*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<ContainedObject*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ContainedObject*>(*(::std::size_t*)arg[0],
      *(::ContainedObject* const*)arg[1]);
  else ::new(mem) ::std::vector<ContainedObject*>(*(::std::size_t*)arg[0],
      *(::ContainedObject* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ContainedObject*>(*(::std::size_t*)arg[0],
      *(::ContainedObject* const*)arg[1],
      *(const ::std::allocator<ContainedObject*>*)arg[2]);
  else ::new(mem) ::std::vector<ContainedObject*>(*(::std::size_t*)arg[0],
      *(::ContainedObject* const*)arg[1],
      *(const ::std::allocator<ContainedObject*>*)arg[2]);
  }
}

static void constructor_10189( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ContainedObject*>(*(const ::std::vector<ContainedObject*>*)arg[0]);
  else ::new(mem) ::std::vector<ContainedObject*>(*(const ::std::vector<ContainedObject*>*)arg[0]);
}

static void destructor_10190(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<ContainedObject*>*)o)->::std::vector<ContainedObject*>::~vector)();
}
static  void operator_10191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ContainedObject*>*)o)->operator=)(*(const ::std::vector<ContainedObject*>*)arg[0]);
  else   (((::std::vector<ContainedObject*>*)o)->operator=)(*(const ::std::vector<ContainedObject*>*)arg[0]);
}

static  void method_10192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ContainedObject*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::ContainedObject* const*)arg[1]);
}

static  void method_10193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >)((((::std::vector<ContainedObject*>*)o)->begin)());
  else   (((::std::vector<ContainedObject*>*)o)->begin)();
}

static  void method_10194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ContainedObject* const*,std::vector<ContainedObject*> >)((((const ::std::vector<ContainedObject*>*)o)->begin)());
  else   (((const ::std::vector<ContainedObject*>*)o)->begin)();
}

static  void method_10195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >)((((::std::vector<ContainedObject*>*)o)->end)());
  else   (((::std::vector<ContainedObject*>*)o)->end)();
}

static  void method_10196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ContainedObject* const*,std::vector<ContainedObject*> >)((((const ::std::vector<ContainedObject*>*)o)->end)());
  else   (((const ::std::vector<ContainedObject*>*)o)->end)();
}

static  void method_10201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ContainedObject*>*)o)->size)());
  else   (((const ::std::vector<ContainedObject*>*)o)->size)();
}

static  void method_10202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ContainedObject*>*)o)->max_size)());
  else   (((const ::std::vector<ContainedObject*>*)o)->max_size)();
}

static  void method_10203( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<ContainedObject*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<ContainedObject*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::ContainedObject*)arg[1]);
  }
}

static  void method_10204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ContainedObject*>*)o)->capacity)());
  else   (((const ::std::vector<ContainedObject*>*)o)->capacity)();
}

static  void method_10205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<ContainedObject*>*)o)->empty)());
  else   (((const ::std::vector<ContainedObject*>*)o)->empty)();
}

static  void method_10206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ContainedObject*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ContainedObject*>*)o)->front)();
  else   (((::std::vector<ContainedObject*>*)o)->front)();
}

static  void method_10213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ContainedObject*>*)o)->front)();
  else   (((const ::std::vector<ContainedObject*>*)o)->front)();
}

static  void method_10214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ContainedObject*>*)o)->back)();
  else   (((::std::vector<ContainedObject*>*)o)->back)();
}

static  void method_10215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ContainedObject*>*)o)->back)();
  else   (((const ::std::vector<ContainedObject*>*)o)->back)();
}

static  void method_10216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<ContainedObject*>*)o)->data)());
  else   (((::std::vector<ContainedObject*>*)o)->data)();
}

static  void method_10217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<ContainedObject*>*)o)->data)());
  else   (((const ::std::vector<ContainedObject*>*)o)->data)();
}

static  void method_10218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ContainedObject*>*)o)->push_back)(*(::ContainedObject* const*)arg[0]);
}

static  void method_10219( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ContainedObject*>*)o)->pop_back)();
}

static  void method_10220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >)((((::std::vector<ContainedObject*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[0],
    *(::ContainedObject* const*)arg[1]));
  else   (((::std::vector<ContainedObject*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[0],
    *(::ContainedObject* const*)arg[1]);
}

static  void method_10221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ContainedObject*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::ContainedObject* const*)arg[2]);
}

static  void method_10222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >)((((::std::vector<ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[0]));
  else   (((::std::vector<ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[0]);
}

static  void method_10223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >)((((::std::vector<ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[1]));
  else   (((::std::vector<ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ContainedObject**,std::vector<ContainedObject*> >*)arg[1]);
}

static  void method_10224( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ContainedObject*>*)o)->swap)(*(::std::vector<ContainedObject*>*)arg[0]);
}

static  void method_10225( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ContainedObject*>*)o)->clear)();
}

static void method_newdel_3155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<ContainedObject*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<ContainedObject*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<ContainedObject*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<ContainedObject*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<ContainedObject*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ContainedObject*,std::allocator<ContainedObject*> >")), ::Reflex::BaseOffset< ::std::vector<ContainedObject*>,::std::_Vector_base<ContainedObject*,std::allocator<ContainedObject*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<ContainedObject*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<ContainedObject*> >::Generate();
}

//------Dictionary for class vector<ContainedObject*,std::allocator<ContainedObject*> > -------------------------------
void __std__vector_ContainedObjectp__db_datamem(Reflex::Class*);
void __std__vector_ContainedObjectp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_ContainedObjectp__datamem_bld(&__std__vector_ContainedObjectp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_ContainedObjectp__funcmem_bld(&__std__vector_ContainedObjectp__db_funcmem);
void __std__vector_ContainedObjectp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<ContainedObject*>"), typeid(::std::vector<ContainedObject*>), sizeof(::std::vector<ContainedObject*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3113, ::Reflex::BaseOffset< ::std::vector<ContainedObject*>, ::std::_Vector_base<ContainedObject*,std::allocator<ContainedObject*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10166, Reflex::Literal("std::vector<ContainedObject*>::_Alloc_value_type"))
  .AddTypedef(type_3113, Reflex::Literal("std::vector<ContainedObject*>::_Base"))
  .AddTypedef(type_3634, Reflex::Literal("std::vector<ContainedObject*>::_Tp_alloc_type"))
  .AddTypedef(type_6856, Reflex::Literal("std::vector<ContainedObject*>::_Alloc_traits"))
  .AddTypedef(type_10166, Reflex::Literal("std::vector<ContainedObject*>::value_type"))
  .AddTypedef(type_9968, Reflex::Literal("std::vector<ContainedObject*>::pointer"))
  .AddTypedef(type_10173, Reflex::Literal("std::vector<ContainedObject*>::const_pointer"))
  .AddTypedef(type_10175, Reflex::Literal("std::vector<ContainedObject*>::reference"))
  .AddTypedef(type_10177, Reflex::Literal("std::vector<ContainedObject*>::const_reference"))
  .AddTypedef(type_6754, Reflex::Literal("std::vector<ContainedObject*>::iterator"))
  .AddTypedef(type_6755, Reflex::Literal("std::vector<ContainedObject*>::const_iterator"))
  .AddTypedef(type_3932, Reflex::Literal("std::vector<ContainedObject*>::const_reverse_iterator"))
  .AddTypedef(type_3933, Reflex::Literal("std::vector<ContainedObject*>::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<ContainedObject*>::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<ContainedObject*>::difference_type"))
  .AddTypedef(type_3634, Reflex::Literal("std::vector<ContainedObject*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10186, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26589), Reflex::Literal("vector"), constructor_10187, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_10177, type_26589), Reflex::Literal("vector"), constructor_10188, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26682), Reflex::Literal("vector"), constructor_10189, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10190, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_ContainedObjectp__funcmem_bld);
}

//------Delayed data member builder for class vector<ContainedObject*,std::allocator<ContainedObject*> > -------------------
void __std__vector_ContainedObjectp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<ContainedObject*,std::allocator<ContainedObject*> > -------------------
void __std__vector_ContainedObjectp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26683, type_26682), Reflex::Literal("operator="), operator_10191, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_10177), Reflex::Literal("assign"), method_10192, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6754), Reflex::Literal("begin"), method_10193, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6755), Reflex::Literal("begin"), method_10194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6754), Reflex::Literal("end"), method_10195, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6755), Reflex::Literal("end"), method_10196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_10166), Reflex::Literal("resize"), method_10203, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10206, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10175, type_3592), Reflex::Literal("operator[]"), operator_10207, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10177, type_3592), Reflex::Literal("operator[]"), operator_10208, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10175, type_3592), Reflex::Literal("at"), method_10210, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10177, type_3592), Reflex::Literal("at"), method_10211, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10175), Reflex::Literal("front"), method_10212, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10177), Reflex::Literal("front"), method_10213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10175), Reflex::Literal("back"), method_10214, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10177), Reflex::Literal("back"), method_10215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9968), Reflex::Literal("data"), method_10216, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10173), Reflex::Literal("data"), method_10217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10177), Reflex::Literal("push_back"), method_10218, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10219, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6754, type_6754, type_10177), Reflex::Literal("insert"), method_10220, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6754, type_3592, type_10177), Reflex::Literal("insert"), method_10221, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6754, type_6754), Reflex::Literal("erase"), method_10222, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6754, type_6754, type_6754), Reflex::Literal("erase"), method_10223, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26683), Reflex::Literal("swap"), method_10224, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10225, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<const ContainedObject*,std::allocator<const ContainedObject*> > -------------------------------
static void constructor_10254( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const ContainedObject*>();
  else ::new(mem) ::std::vector<const ContainedObject*>();
}

static void constructor_10255( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const ContainedObject*>(*(const ::std::allocator<const ContainedObject*>*)arg[0]);
  else ::new(mem) ::std::vector<const ContainedObject*>(*(const ::std::allocator<const ContainedObject*>*)arg[0]);
}

static void constructor_10256( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const ContainedObject*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<const ContainedObject*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const ContainedObject*>(*(::std::size_t*)arg[0],
      *(const ::ContainedObject* const*)arg[1]);
  else ::new(mem) ::std::vector<const ContainedObject*>(*(::std::size_t*)arg[0],
      *(const ::ContainedObject* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const ContainedObject*>(*(::std::size_t*)arg[0],
      *(const ::ContainedObject* const*)arg[1],
      *(const ::std::allocator<const ContainedObject*>*)arg[2]);
  else ::new(mem) ::std::vector<const ContainedObject*>(*(::std::size_t*)arg[0],
      *(const ::ContainedObject* const*)arg[1],
      *(const ::std::allocator<const ContainedObject*>*)arg[2]);
  }
}

static void constructor_10257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const ContainedObject*>(*(const ::std::vector<const ContainedObject*>*)arg[0]);
  else ::new(mem) ::std::vector<const ContainedObject*>(*(const ::std::vector<const ContainedObject*>*)arg[0]);
}

static void destructor_10258(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<const ContainedObject*>*)o)->::std::vector<const ContainedObject*>::~vector)();
}
static  void operator_10259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const ContainedObject*>*)o)->operator=)(*(const ::std::vector<const ContainedObject*>*)arg[0]);
  else   (((::std::vector<const ContainedObject*>*)o)->operator=)(*(const ::std::vector<const ContainedObject*>*)arg[0]);
}

static  void method_10260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const ContainedObject*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::ContainedObject* const*)arg[1]);
}

static  void method_10261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >)((((::std::vector<const ContainedObject*>*)o)->begin)());
  else   (((::std::vector<const ContainedObject*>*)o)->begin)();
}

static  void method_10262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ContainedObject* const*,std::vector<const ContainedObject*> >)((((const ::std::vector<const ContainedObject*>*)o)->begin)());
  else   (((const ::std::vector<const ContainedObject*>*)o)->begin)();
}

static  void method_10263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >)((((::std::vector<const ContainedObject*>*)o)->end)());
  else   (((::std::vector<const ContainedObject*>*)o)->end)();
}

static  void method_10264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ContainedObject* const*,std::vector<const ContainedObject*> >)((((const ::std::vector<const ContainedObject*>*)o)->end)());
  else   (((const ::std::vector<const ContainedObject*>*)o)->end)();
}

static  void method_10269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const ContainedObject*>*)o)->size)());
  else   (((const ::std::vector<const ContainedObject*>*)o)->size)();
}

static  void method_10270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const ContainedObject*>*)o)->max_size)());
  else   (((const ::std::vector<const ContainedObject*>*)o)->max_size)();
}

static  void method_10271( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<const ContainedObject*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<const ContainedObject*>*)o)->resize)(*(::std::size_t*)arg[0],
      (const ::ContainedObject*)arg[1]);
  }
}

static  void method_10272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const ContainedObject*>*)o)->capacity)());
  else   (((const ::std::vector<const ContainedObject*>*)o)->capacity)();
}

static  void method_10273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<const ContainedObject*>*)o)->empty)());
  else   (((const ::std::vector<const ContainedObject*>*)o)->empty)();
}

static  void method_10274( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const ContainedObject*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const ContainedObject*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const ContainedObject*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const ContainedObject*>*)o)->front)();
  else   (((::std::vector<const ContainedObject*>*)o)->front)();
}

static  void method_10281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const ContainedObject*>*)o)->front)();
  else   (((const ::std::vector<const ContainedObject*>*)o)->front)();
}

static  void method_10282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const ContainedObject*>*)o)->back)();
  else   (((::std::vector<const ContainedObject*>*)o)->back)();
}

static  void method_10283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const ContainedObject*>*)o)->back)();
  else   (((const ::std::vector<const ContainedObject*>*)o)->back)();
}

static  void method_10284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<const ContainedObject*>*)o)->data)());
  else   (((::std::vector<const ContainedObject*>*)o)->data)();
}

static  void method_10285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<const ContainedObject*>*)o)->data)());
  else   (((const ::std::vector<const ContainedObject*>*)o)->data)();
}

static  void method_10286( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const ContainedObject*>*)o)->push_back)(*(const ::ContainedObject* const*)arg[0]);
}

static  void method_10287( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const ContainedObject*>*)o)->pop_back)();
}

static  void method_10288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >)((((::std::vector<const ContainedObject*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[0],
    *(const ::ContainedObject* const*)arg[1]));
  else   (((::std::vector<const ContainedObject*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[0],
    *(const ::ContainedObject* const*)arg[1]);
}

static  void method_10289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const ContainedObject*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::ContainedObject* const*)arg[2]);
}

static  void method_10290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >)((((::std::vector<const ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[0]));
  else   (((::std::vector<const ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[0]);
}

static  void method_10291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >)((((::std::vector<const ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[1]));
  else   (((::std::vector<const ContainedObject*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const ContainedObject**,std::vector<const ContainedObject*> >*)arg[1]);
}

static  void method_10292( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const ContainedObject*>*)o)->swap)(*(::std::vector<const ContainedObject*>*)arg[0]);
}

static  void method_10293( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const ContainedObject*>*)o)->clear)();
}

static void method_newdel_3156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<const ContainedObject*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<const ContainedObject*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<const ContainedObject*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<const ContainedObject*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<const ContainedObject*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const ContainedObject*,std::allocator<const ContainedObject*> >")), ::Reflex::BaseOffset< ::std::vector<const ContainedObject*>,::std::_Vector_base<const ContainedObject*,std::allocator<const ContainedObject*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<const ContainedObject*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<const ContainedObject*> >::Generate();
}

//------Dictionary for class vector<const ContainedObject*,std::allocator<const ContainedObject*> > -------------------------------
void __std__vector_constsContainedObjectp__db_datamem(Reflex::Class*);
void __std__vector_constsContainedObjectp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_constsContainedObjectp__datamem_bld(&__std__vector_constsContainedObjectp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_constsContainedObjectp__funcmem_bld(&__std__vector_constsContainedObjectp__db_funcmem);
void __std__vector_constsContainedObjectp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<const ContainedObject*>"), typeid(::std::vector<const ContainedObject*>), sizeof(::std::vector<const ContainedObject*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3077, ::Reflex::BaseOffset< ::std::vector<const ContainedObject*>, ::std::_Vector_base<const ContainedObject*,std::allocator<const ContainedObject*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10234, Reflex::Literal("std::vector<const ContainedObject*>::_Alloc_value_type"))
  .AddTypedef(type_3077, Reflex::Literal("std::vector<const ContainedObject*>::_Base"))
  .AddTypedef(type_3626, Reflex::Literal("std::vector<const ContainedObject*>::_Tp_alloc_type"))
  .AddTypedef(type_6792, Reflex::Literal("std::vector<const ContainedObject*>::_Alloc_traits"))
  .AddTypedef(type_10234, Reflex::Literal("std::vector<const ContainedObject*>::value_type"))
  .AddTypedef(type_9294, Reflex::Literal("std::vector<const ContainedObject*>::pointer"))
  .AddTypedef(type_10241, Reflex::Literal("std::vector<const ContainedObject*>::const_pointer"))
  .AddTypedef(type_10243, Reflex::Literal("std::vector<const ContainedObject*>::reference"))
  .AddTypedef(type_10245, Reflex::Literal("std::vector<const ContainedObject*>::const_reference"))
  .AddTypedef(type_6681, Reflex::Literal("std::vector<const ContainedObject*>::iterator"))
  .AddTypedef(type_6682, Reflex::Literal("std::vector<const ContainedObject*>::const_iterator"))
  .AddTypedef(type_3828, Reflex::Literal("std::vector<const ContainedObject*>::const_reverse_iterator"))
  .AddTypedef(type_3829, Reflex::Literal("std::vector<const ContainedObject*>::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<const ContainedObject*>::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<const ContainedObject*>::difference_type"))
  .AddTypedef(type_3626, Reflex::Literal("std::vector<const ContainedObject*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10254, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26121), Reflex::Literal("vector"), constructor_10255, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_10245, type_26121), Reflex::Literal("vector"), constructor_10256, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26685), Reflex::Literal("vector"), constructor_10257, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10258, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_constsContainedObjectp__funcmem_bld);
}

//------Delayed data member builder for class vector<const ContainedObject*,std::allocator<const ContainedObject*> > -------------------
void __std__vector_constsContainedObjectp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<const ContainedObject*,std::allocator<const ContainedObject*> > -------------------
void __std__vector_constsContainedObjectp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26686, type_26685), Reflex::Literal("operator="), operator_10259, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_10245), Reflex::Literal("assign"), method_10260, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681), Reflex::Literal("begin"), method_10261, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6682), Reflex::Literal("begin"), method_10262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681), Reflex::Literal("end"), method_10263, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6682), Reflex::Literal("end"), method_10264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_10234), Reflex::Literal("resize"), method_10271, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10274, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10243, type_3592), Reflex::Literal("operator[]"), operator_10275, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10245, type_3592), Reflex::Literal("operator[]"), operator_10276, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10243, type_3592), Reflex::Literal("at"), method_10278, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10245, type_3592), Reflex::Literal("at"), method_10279, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10243), Reflex::Literal("front"), method_10280, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10245), Reflex::Literal("front"), method_10281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10243), Reflex::Literal("back"), method_10282, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10245), Reflex::Literal("back"), method_10283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9294), Reflex::Literal("data"), method_10284, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10241), Reflex::Literal("data"), method_10285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10245), Reflex::Literal("push_back"), method_10286, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10287, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681, type_6681, type_10245), Reflex::Literal("insert"), method_10288, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6681, type_3592, type_10245), Reflex::Literal("insert"), method_10289, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681, type_6681), Reflex::Literal("erase"), method_10290, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681, type_6681, type_6681), Reflex::Literal("erase"), method_10291, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26686), Reflex::Literal("swap"), method_10292, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10293, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<LinkManager::Link*,std::allocator<LinkManager::Link*> > -------------------------------
static void constructor_10322( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LinkManager::Link*>();
  else ::new(mem) ::std::vector<LinkManager::Link*>();
}

static void constructor_10323( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LinkManager::Link*>(*(const ::std::allocator<LinkManager::Link*>*)arg[0]);
  else ::new(mem) ::std::vector<LinkManager::Link*>(*(const ::std::allocator<LinkManager::Link*>*)arg[0]);
}

static void constructor_10324( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LinkManager::Link*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<LinkManager::Link*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LinkManager::Link*>(*(::std::size_t*)arg[0],
      *(::LinkManager::Link* const*)arg[1]);
  else ::new(mem) ::std::vector<LinkManager::Link*>(*(::std::size_t*)arg[0],
      *(::LinkManager::Link* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LinkManager::Link*>(*(::std::size_t*)arg[0],
      *(::LinkManager::Link* const*)arg[1],
      *(const ::std::allocator<LinkManager::Link*>*)arg[2]);
  else ::new(mem) ::std::vector<LinkManager::Link*>(*(::std::size_t*)arg[0],
      *(::LinkManager::Link* const*)arg[1],
      *(const ::std::allocator<LinkManager::Link*>*)arg[2]);
  }
}

static void constructor_10325( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LinkManager::Link*>(*(const ::std::vector<LinkManager::Link*>*)arg[0]);
  else ::new(mem) ::std::vector<LinkManager::Link*>(*(const ::std::vector<LinkManager::Link*>*)arg[0]);
}

static void destructor_10326(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<LinkManager::Link*>*)o)->::std::vector<LinkManager::Link*>::~vector)();
}
static  void operator_10327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LinkManager::Link*>*)o)->operator=)(*(const ::std::vector<LinkManager::Link*>*)arg[0]);
  else   (((::std::vector<LinkManager::Link*>*)o)->operator=)(*(const ::std::vector<LinkManager::Link*>*)arg[0]);
}

static  void method_10328( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LinkManager::Link*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::LinkManager::Link* const*)arg[1]);
}

static  void method_10329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >)((((::std::vector<LinkManager::Link*>*)o)->begin)());
  else   (((::std::vector<LinkManager::Link*>*)o)->begin)();
}

static  void method_10330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LinkManager::Link* const*,std::vector<LinkManager::Link*> >)((((const ::std::vector<LinkManager::Link*>*)o)->begin)());
  else   (((const ::std::vector<LinkManager::Link*>*)o)->begin)();
}

static  void method_10331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >)((((::std::vector<LinkManager::Link*>*)o)->end)());
  else   (((::std::vector<LinkManager::Link*>*)o)->end)();
}

static  void method_10332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LinkManager::Link* const*,std::vector<LinkManager::Link*> >)((((const ::std::vector<LinkManager::Link*>*)o)->end)());
  else   (((const ::std::vector<LinkManager::Link*>*)o)->end)();
}

static  void method_10337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<LinkManager::Link*>*)o)->size)());
  else   (((const ::std::vector<LinkManager::Link*>*)o)->size)();
}

static  void method_10338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<LinkManager::Link*>*)o)->max_size)());
  else   (((const ::std::vector<LinkManager::Link*>*)o)->max_size)();
}

static  void method_10339( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<LinkManager::Link*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<LinkManager::Link*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::LinkManager::Link*)arg[1]);
  }
}

static  void method_10340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<LinkManager::Link*>*)o)->capacity)());
  else   (((const ::std::vector<LinkManager::Link*>*)o)->capacity)();
}

static  void method_10341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<LinkManager::Link*>*)o)->empty)());
  else   (((const ::std::vector<LinkManager::Link*>*)o)->empty)();
}

static  void method_10342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LinkManager::Link*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LinkManager::Link*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<LinkManager::Link*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LinkManager::Link*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<LinkManager::Link*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LinkManager::Link*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<LinkManager::Link*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LinkManager::Link*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<LinkManager::Link*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LinkManager::Link*>*)o)->front)();
  else   (((::std::vector<LinkManager::Link*>*)o)->front)();
}

static  void method_10349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LinkManager::Link*>*)o)->front)();
  else   (((const ::std::vector<LinkManager::Link*>*)o)->front)();
}

static  void method_10350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LinkManager::Link*>*)o)->back)();
  else   (((::std::vector<LinkManager::Link*>*)o)->back)();
}

static  void method_10351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LinkManager::Link*>*)o)->back)();
  else   (((const ::std::vector<LinkManager::Link*>*)o)->back)();
}

static  void method_10352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<LinkManager::Link*>*)o)->data)());
  else   (((::std::vector<LinkManager::Link*>*)o)->data)();
}

static  void method_10353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<LinkManager::Link*>*)o)->data)());
  else   (((const ::std::vector<LinkManager::Link*>*)o)->data)();
}

static  void method_10354( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LinkManager::Link*>*)o)->push_back)(*(::LinkManager::Link* const*)arg[0]);
}

static  void method_10355( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<LinkManager::Link*>*)o)->pop_back)();
}

static  void method_10356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >)((((::std::vector<LinkManager::Link*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[0],
    *(::LinkManager::Link* const*)arg[1]));
  else   (((::std::vector<LinkManager::Link*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[0],
    *(::LinkManager::Link* const*)arg[1]);
}

static  void method_10357( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LinkManager::Link*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::LinkManager::Link* const*)arg[2]);
}

static  void method_10358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >)((((::std::vector<LinkManager::Link*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[0]));
  else   (((::std::vector<LinkManager::Link*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[0]);
}

static  void method_10359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >)((((::std::vector<LinkManager::Link*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[1]));
  else   (((::std::vector<LinkManager::Link*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<LinkManager::Link**,std::vector<LinkManager::Link*> >*)arg[1]);
}

static  void method_10360( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LinkManager::Link*>*)o)->swap)(*(::std::vector<LinkManager::Link*>*)arg[0]);
}

static  void method_10361( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<LinkManager::Link*>*)o)->clear)();
}

static void method_newdel_3157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<LinkManager::Link*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<LinkManager::Link*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<LinkManager::Link*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<LinkManager::Link*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<LinkManager::Link*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<LinkManager::Link*,std::allocator<LinkManager::Link*> >")), ::Reflex::BaseOffset< ::std::vector<LinkManager::Link*>,::std::_Vector_base<LinkManager::Link*,std::allocator<LinkManager::Link*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<LinkManager::Link*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<LinkManager::Link*> >::Generate();
}

//------Dictionary for class vector<LinkManager::Link*,std::allocator<LinkManager::Link*> > -------------------------------
void __std__vector_LinkManager__Linkp__db_datamem(Reflex::Class*);
void __std__vector_LinkManager__Linkp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_LinkManager__Linkp__datamem_bld(&__std__vector_LinkManager__Linkp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_LinkManager__Linkp__funcmem_bld(&__std__vector_LinkManager__Linkp__db_funcmem);
void __std__vector_LinkManager__Linkp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<LinkManager::Link*>"), typeid(::std::vector<LinkManager::Link*>), sizeof(::std::vector<LinkManager::Link*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3115, ::Reflex::BaseOffset< ::std::vector<LinkManager::Link*>, ::std::_Vector_base<LinkManager::Link*,std::allocator<LinkManager::Link*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10302, Reflex::Literal("std::vector<LinkManager::Link*>::_Alloc_value_type"))
  .AddTypedef(type_3115, Reflex::Literal("std::vector<LinkManager::Link*>::_Base"))
  .AddTypedef(type_3635, Reflex::Literal("std::vector<LinkManager::Link*>::_Tp_alloc_type"))
  .AddTypedef(type_6858, Reflex::Literal("std::vector<LinkManager::Link*>::_Alloc_traits"))
  .AddTypedef(type_10302, Reflex::Literal("std::vector<LinkManager::Link*>::value_type"))
  .AddTypedef(type_10005, Reflex::Literal("std::vector<LinkManager::Link*>::pointer"))
  .AddTypedef(type_10309, Reflex::Literal("std::vector<LinkManager::Link*>::const_pointer"))
  .AddTypedef(type_10311, Reflex::Literal("std::vector<LinkManager::Link*>::reference"))
  .AddTypedef(type_10313, Reflex::Literal("std::vector<LinkManager::Link*>::const_reference"))
  .AddTypedef(type_6758, Reflex::Literal("std::vector<LinkManager::Link*>::iterator"))
  .AddTypedef(type_6759, Reflex::Literal("std::vector<LinkManager::Link*>::const_iterator"))
  .AddTypedef(type_3936, Reflex::Literal("std::vector<LinkManager::Link*>::const_reverse_iterator"))
  .AddTypedef(type_3937, Reflex::Literal("std::vector<LinkManager::Link*>::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<LinkManager::Link*>::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<LinkManager::Link*>::difference_type"))
  .AddTypedef(type_3635, Reflex::Literal("std::vector<LinkManager::Link*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10322, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26615), Reflex::Literal("vector"), constructor_10323, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_10313, type_26615), Reflex::Literal("vector"), constructor_10324, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26688), Reflex::Literal("vector"), constructor_10325, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10326, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_LinkManager__Linkp__funcmem_bld);
}

//------Delayed data member builder for class vector<LinkManager::Link*,std::allocator<LinkManager::Link*> > -------------------
void __std__vector_LinkManager__Linkp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<LinkManager::Link*,std::allocator<LinkManager::Link*> > -------------------
void __std__vector_LinkManager__Linkp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26689, type_26688), Reflex::Literal("operator="), operator_10327, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_10313), Reflex::Literal("assign"), method_10328, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6758), Reflex::Literal("begin"), method_10329, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6759), Reflex::Literal("begin"), method_10330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6758), Reflex::Literal("end"), method_10331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6759), Reflex::Literal("end"), method_10332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_10302), Reflex::Literal("resize"), method_10339, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10340, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10342, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10311, type_3592), Reflex::Literal("operator[]"), operator_10343, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10313, type_3592), Reflex::Literal("operator[]"), operator_10344, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10311, type_3592), Reflex::Literal("at"), method_10346, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10313, type_3592), Reflex::Literal("at"), method_10347, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10311), Reflex::Literal("front"), method_10348, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10313), Reflex::Literal("front"), method_10349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10311), Reflex::Literal("back"), method_10350, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10313), Reflex::Literal("back"), method_10351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10005), Reflex::Literal("data"), method_10352, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10309), Reflex::Literal("data"), method_10353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10313), Reflex::Literal("push_back"), method_10354, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10355, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6758, type_6758, type_10313), Reflex::Literal("insert"), method_10356, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6758, type_3592, type_10313), Reflex::Literal("insert"), method_10357, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6758, type_6758), Reflex::Literal("erase"), method_10358, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6758, type_6758, type_6758), Reflex::Literal("erase"), method_10359, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26689), Reflex::Literal("swap"), method_10360, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10361, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<KeyedObject<long unsigned int> >,std::allocator<SmartRef<KeyedObject<long unsigned int> > > > -------------------------------
static void constructor_10387( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >();
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >();
}

static void constructor_10388( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(const ::std::allocator<SmartRef<KeyedObject<unsigned long> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(const ::std::allocator<SmartRef<KeyedObject<unsigned long> > >*)arg[0]);
}

static void constructor_10389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<unsigned long> > >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<unsigned long> > >*)arg[2]);
  }
}

static void constructor_10390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned long> > >(*(const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)arg[0]);
}

static void destructor_10391(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->::std::vector<SmartRef<KeyedObject<unsigned long> > >::~vector)();
}
static  void operator_10392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)arg[0]);
}

static  void method_10393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[1]);
}

static  void method_10394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->begin)());
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->begin)();
}

static  void method_10395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >)((((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->begin)();
}

static  void method_10396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->end)());
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->end)();
}

static  void method_10397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >)((((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->end)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->end)();
}

static  void method_10402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->size)();
}

static  void method_10403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->max_size)();
}

static  void method_10404( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<KeyedObject<unsigned long> >*)arg[1]);
  }
}

static  void method_10405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->capacity)();
}

static  void method_10406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->empty)();
}

static  void method_10407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->front)();
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->front)();
}

static  void method_10414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->front)();
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->front)();
}

static  void method_10415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->back)();
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->back)();
}

static  void method_10416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->back)();
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->back)();
}

static  void method_10417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->data)());
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->data)();
}

static  void method_10418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->data)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->data)();
}

static  void method_10419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->push_back)(*(const ::SmartRef<KeyedObject<unsigned long> >*)arg[0]);
}

static  void method_10420( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->pop_back)();
}

static  void method_10421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[1]);
}

static  void method_10422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<KeyedObject<unsigned long> >*)arg[2]);
}

static  void method_10423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[0]));
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[0]);
}

static  void method_10424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned long> >*,std::vector<SmartRef<KeyedObject<unsigned long> > > >*)arg[1]);
}

static  void method_10425( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->swap)(*(::std::vector<SmartRef<KeyedObject<unsigned long> > >*)arg[0]);
}

static  void method_10426( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned long> > >*)o)->clear)();
}

static void method_newdel_3158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<unsigned long> >,std::allocator<SmartRef<KeyedObject<unsigned long> > > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<unsigned long> > >,::std::_Vector_base<SmartRef<KeyedObject<unsigned long> >,std::allocator<SmartRef<KeyedObject<unsigned long> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<unsigned long> > > >::Generate();
}

//------Dictionary for class vector<SmartRef<KeyedObject<long unsigned int> >,std::allocator<SmartRef<KeyedObject<long unsigned int> > > > -------------------------------
void __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__datamem_bld(&__std__vector_SmartRef_KeyedObject_unsignedslong_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__funcmem_bld(&__std__vector_SmartRef_KeyedObject_unsignedslong_s_s__db_funcmem);
void __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >"), typeid(::std::vector<SmartRef<KeyedObject<unsigned long> > >), sizeof(::std::vector<SmartRef<KeyedObject<unsigned long> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3078, ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<unsigned long> > >, ::std::_Vector_base<SmartRef<KeyedObject<unsigned long> >,std::allocator<SmartRef<KeyedObject<unsigned long> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2743, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::_Alloc_value_type"))
  .AddTypedef(type_3078, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::_Base"))
  .AddTypedef(type_3627, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::_Tp_alloc_type"))
  .AddTypedef(type_6793, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::_Alloc_traits"))
  .AddTypedef(type_2743, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::value_type"))
  .AddTypedef(type_9313, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::pointer"))
  .AddTypedef(type_10376, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::const_pointer"))
  .AddTypedef(type_5656, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::reference"))
  .AddTypedef(type_7826, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::const_reference"))
  .AddTypedef(type_6683, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::iterator"))
  .AddTypedef(type_6684, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::const_iterator"))
  .AddTypedef(type_3830, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::const_reverse_iterator"))
  .AddTypedef(type_3831, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::difference_type"))
  .AddTypedef(type_3627, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned long> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10387, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26134), Reflex::Literal("vector"), constructor_10388, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_7826, type_26134), Reflex::Literal("vector"), constructor_10389, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26690), Reflex::Literal("vector"), constructor_10390, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10391, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_KeyedObject_unsignedslong_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<KeyedObject<long unsigned int> >,std::allocator<SmartRef<KeyedObject<long unsigned int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<KeyedObject<long unsigned int> >,std::allocator<SmartRef<KeyedObject<long unsigned int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26691, type_26690), Reflex::Literal("operator="), operator_10392, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_7826), Reflex::Literal("assign"), method_10393, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683), Reflex::Literal("begin"), method_10394, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6684), Reflex::Literal("begin"), method_10395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683), Reflex::Literal("end"), method_10396, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6684), Reflex::Literal("end"), method_10397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_2743), Reflex::Literal("resize"), method_10404, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10407, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656, type_3592), Reflex::Literal("operator[]"), operator_10408, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7826, type_3592), Reflex::Literal("operator[]"), operator_10409, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656, type_3592), Reflex::Literal("at"), method_10411, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7826, type_3592), Reflex::Literal("at"), method_10412, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656), Reflex::Literal("front"), method_10413, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7826), Reflex::Literal("front"), method_10414, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5656), Reflex::Literal("back"), method_10415, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7826), Reflex::Literal("back"), method_10416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9313), Reflex::Literal("data"), method_10417, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10376), Reflex::Literal("data"), method_10418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7826), Reflex::Literal("push_back"), method_10419, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10420, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683, type_6683, type_7826), Reflex::Literal("insert"), method_10421, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6683, type_3592, type_7826), Reflex::Literal("insert"), method_10422, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683, type_6683), Reflex::Literal("erase"), method_10423, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683, type_6683, type_6683), Reflex::Literal("erase"), method_10424, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26691), Reflex::Literal("swap"), method_10425, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10426, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<KeyedObject<long int> >,std::allocator<SmartRef<KeyedObject<long int> > > > -------------------------------
static void constructor_10452( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >();
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >();
}

static void constructor_10453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(const ::std::allocator<SmartRef<KeyedObject<long> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(const ::std::allocator<SmartRef<KeyedObject<long> > >*)arg[0]);
}

static void constructor_10454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<long> >*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<long> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<long> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<long> > >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<long> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<long> > >*)arg[2]);
  }
}

static void constructor_10455( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(const ::std::vector<SmartRef<KeyedObject<long> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<long> > >(*(const ::std::vector<SmartRef<KeyedObject<long> > >*)arg[0]);
}

static void destructor_10456(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<KeyedObject<long> > >*)o)->::std::vector<SmartRef<KeyedObject<long> > >::~vector)();
}
static  void operator_10457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<long> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<long> > >*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<long> > >*)arg[0]);
}

static  void method_10458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<KeyedObject<long> >*)arg[1]);
}

static  void method_10459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >)((((::std::vector<SmartRef<KeyedObject<long> > >*)o)->begin)());
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->begin)();
}

static  void method_10460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >)((((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->begin)();
}

static  void method_10461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >)((((::std::vector<SmartRef<KeyedObject<long> > >*)o)->end)());
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->end)();
}

static  void method_10462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >)((((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->end)());
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->end)();
}

static  void method_10467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->size)();
}

static  void method_10468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->max_size)();
}

static  void method_10469( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<KeyedObject<long> >*)arg[1]);
  }
}

static  void method_10470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->capacity)();
}

static  void method_10471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->empty)();
}

static  void method_10472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10476( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<long> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<long> > >*)o)->front)();
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->front)();
}

static  void method_10479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->front)();
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->front)();
}

static  void method_10480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<long> > >*)o)->back)();
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->back)();
}

static  void method_10481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->back)();
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->back)();
}

static  void method_10482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<KeyedObject<long> > >*)o)->data)());
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->data)();
}

static  void method_10483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->data)());
  else   (((const ::std::vector<SmartRef<KeyedObject<long> > >*)o)->data)();
}

static  void method_10484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->push_back)(*(const ::SmartRef<KeyedObject<long> >*)arg[0]);
}

static  void method_10485( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->pop_back)();
}

static  void method_10486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >)((((::std::vector<SmartRef<KeyedObject<long> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<long> >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<long> >*)arg[1]);
}

static  void method_10487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<KeyedObject<long> >*)arg[2]);
}

static  void method_10488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >)((((::std::vector<SmartRef<KeyedObject<long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[0]));
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[0]);
}

static  void method_10489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >)((((::std::vector<SmartRef<KeyedObject<long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<long> >*,std::vector<SmartRef<KeyedObject<long> > > >*)arg[1]);
}

static  void method_10490( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->swap)(*(::std::vector<SmartRef<KeyedObject<long> > >*)arg[0]);
}

static  void method_10491( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<long> > >*)o)->clear)();
}

static void method_newdel_3159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<long> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<long> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<long> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<long> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<long> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<long> >,std::allocator<SmartRef<KeyedObject<long> > > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<long> > >,::std::_Vector_base<SmartRef<KeyedObject<long> >,std::allocator<SmartRef<KeyedObject<long> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<long> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<long> > > >::Generate();
}

//------Dictionary for class vector<SmartRef<KeyedObject<long int> >,std::allocator<SmartRef<KeyedObject<long int> > > > -------------------------------
void __std__vector_SmartRef_KeyedObject_long_s_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_KeyedObject_long_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_long_s_s__datamem_bld(&__std__vector_SmartRef_KeyedObject_long_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_long_s_s__funcmem_bld(&__std__vector_SmartRef_KeyedObject_long_s_s__db_funcmem);
void __std__vector_SmartRef_KeyedObject_long_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >"), typeid(::std::vector<SmartRef<KeyedObject<long> > >), sizeof(::std::vector<SmartRef<KeyedObject<long> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3079, ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<long> > >, ::std::_Vector_base<SmartRef<KeyedObject<long> >,std::allocator<SmartRef<KeyedObject<long> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2744, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::_Alloc_value_type"))
  .AddTypedef(type_3079, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::_Base"))
  .AddTypedef(type_3628, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::_Tp_alloc_type"))
  .AddTypedef(type_6794, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::_Alloc_traits"))
  .AddTypedef(type_2744, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::value_type"))
  .AddTypedef(type_9332, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::pointer"))
  .AddTypedef(type_10441, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::const_pointer"))
  .AddTypedef(type_5657, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::reference"))
  .AddTypedef(type_7827, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::const_reference"))
  .AddTypedef(type_6685, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::iterator"))
  .AddTypedef(type_6686, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::const_iterator"))
  .AddTypedef(type_3832, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::const_reverse_iterator"))
  .AddTypedef(type_3833, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::difference_type"))
  .AddTypedef(type_3628, Reflex::Literal("std::vector<SmartRef<KeyedObject<long> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10452, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26147), Reflex::Literal("vector"), constructor_10453, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_7827, type_26147), Reflex::Literal("vector"), constructor_10454, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26692), Reflex::Literal("vector"), constructor_10455, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10456, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_KeyedObject_long_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<KeyedObject<long int> >,std::allocator<SmartRef<KeyedObject<long int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_long_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<KeyedObject<long int> >,std::allocator<SmartRef<KeyedObject<long int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_long_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26693, type_26692), Reflex::Literal("operator="), operator_10457, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_7827), Reflex::Literal("assign"), method_10458, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6685), Reflex::Literal("begin"), method_10459, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6686), Reflex::Literal("begin"), method_10460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6685), Reflex::Literal("end"), method_10461, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6686), Reflex::Literal("end"), method_10462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_2744), Reflex::Literal("resize"), method_10469, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10472, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657, type_3592), Reflex::Literal("operator[]"), operator_10473, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7827, type_3592), Reflex::Literal("operator[]"), operator_10474, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657, type_3592), Reflex::Literal("at"), method_10476, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7827, type_3592), Reflex::Literal("at"), method_10477, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657), Reflex::Literal("front"), method_10478, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7827), Reflex::Literal("front"), method_10479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5657), Reflex::Literal("back"), method_10480, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7827), Reflex::Literal("back"), method_10481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9332), Reflex::Literal("data"), method_10482, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10441), Reflex::Literal("data"), method_10483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7827), Reflex::Literal("push_back"), method_10484, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6685, type_6685, type_7827), Reflex::Literal("insert"), method_10486, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6685, type_3592, type_7827), Reflex::Literal("insert"), method_10487, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6685, type_6685), Reflex::Literal("erase"), method_10488, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6685, type_6685, type_6685), Reflex::Literal("erase"), method_10489, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26693), Reflex::Literal("swap"), method_10490, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10491, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > -------------------------------
static void constructor_10517( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >();
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >();
}

static void constructor_10518( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(const ::std::allocator<SmartRef<KeyedObject<unsigned int> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(const ::std::allocator<SmartRef<KeyedObject<unsigned int> > >*)arg[0]);
}

static void constructor_10519( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<unsigned int> > >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<unsigned int> > >*)arg[2]);
  }
}

static void constructor_10520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<unsigned int> > >(*(const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)arg[0]);
}

static void destructor_10521(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->::std::vector<SmartRef<KeyedObject<unsigned int> > >::~vector)();
}
static  void operator_10522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)arg[0]);
}

static  void method_10523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[1]);
}

static  void method_10524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->begin)());
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->begin)();
}

static  void method_10525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >)((((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->begin)();
}

static  void method_10526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->end)());
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->end)();
}

static  void method_10527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >)((((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->end)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->end)();
}

static  void method_10532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->size)();
}

static  void method_10533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->max_size)();
}

static  void method_10534( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<KeyedObject<unsigned int> >*)arg[1]);
  }
}

static  void method_10535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->capacity)();
}

static  void method_10536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->empty)();
}

static  void method_10537( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->front)();
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->front)();
}

static  void method_10544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->front)();
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->front)();
}

static  void method_10545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->back)();
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->back)();
}

static  void method_10546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->back)();
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->back)();
}

static  void method_10547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->data)());
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->data)();
}

static  void method_10548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->data)());
  else   (((const ::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->data)();
}

static  void method_10549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->push_back)(*(const ::SmartRef<KeyedObject<unsigned int> >*)arg[0]);
}

static  void method_10550( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->pop_back)();
}

static  void method_10551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[1]);
}

static  void method_10552( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<KeyedObject<unsigned int> >*)arg[2]);
}

static  void method_10553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[0]));
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[0]);
}

static  void method_10554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >)((((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<unsigned int> >*,std::vector<SmartRef<KeyedObject<unsigned int> > > >*)arg[1]);
}

static  void method_10555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->swap)(*(::std::vector<SmartRef<KeyedObject<unsigned int> > >*)arg[0]);
}

static  void method_10556( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<unsigned int> > >*)o)->clear)();
}

static void method_newdel_3160( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<unsigned int> > >,::std::_Vector_base<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<unsigned int> > > >::Generate();
}

//------Dictionary for class vector<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > -------------------------------
void __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__datamem_bld(&__std__vector_SmartRef_KeyedObject_unsignedsint_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__funcmem_bld(&__std__vector_SmartRef_KeyedObject_unsignedsint_s_s__db_funcmem);
void __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >"), typeid(::std::vector<SmartRef<KeyedObject<unsigned int> > >), sizeof(::std::vector<SmartRef<KeyedObject<unsigned int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3080, ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<unsigned int> > >, ::std::_Vector_base<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2745, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::_Alloc_value_type"))
  .AddTypedef(type_3080, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::_Base"))
  .AddTypedef(type_3629, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::_Tp_alloc_type"))
  .AddTypedef(type_6795, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::_Alloc_traits"))
  .AddTypedef(type_2745, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::value_type"))
  .AddTypedef(type_9351, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::pointer"))
  .AddTypedef(type_10506, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::const_pointer"))
  .AddTypedef(type_5658, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::reference"))
  .AddTypedef(type_7828, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::const_reference"))
  .AddTypedef(type_6687, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::iterator"))
  .AddTypedef(type_6688, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::const_iterator"))
  .AddTypedef(type_3834, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::const_reverse_iterator"))
  .AddTypedef(type_3835, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::difference_type"))
  .AddTypedef(type_3629, Reflex::Literal("std::vector<SmartRef<KeyedObject<unsigned int> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10517, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26160), Reflex::Literal("vector"), constructor_10518, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_7828, type_26160), Reflex::Literal("vector"), constructor_10519, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26694), Reflex::Literal("vector"), constructor_10520, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10521, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3160, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_KeyedObject_unsignedsint_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<KeyedObject<unsigned int> >,std::allocator<SmartRef<KeyedObject<unsigned int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26695, type_26694), Reflex::Literal("operator="), operator_10522, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_7828), Reflex::Literal("assign"), method_10523, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6687), Reflex::Literal("begin"), method_10524, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6688), Reflex::Literal("begin"), method_10525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6687), Reflex::Literal("end"), method_10526, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6688), Reflex::Literal("end"), method_10527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_2745), Reflex::Literal("resize"), method_10534, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10537, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658, type_3592), Reflex::Literal("operator[]"), operator_10538, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7828, type_3592), Reflex::Literal("operator[]"), operator_10539, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658, type_3592), Reflex::Literal("at"), method_10541, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7828, type_3592), Reflex::Literal("at"), method_10542, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658), Reflex::Literal("front"), method_10543, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7828), Reflex::Literal("front"), method_10544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5658), Reflex::Literal("back"), method_10545, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7828), Reflex::Literal("back"), method_10546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9351), Reflex::Literal("data"), method_10547, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10506), Reflex::Literal("data"), method_10548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7828), Reflex::Literal("push_back"), method_10549, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10550, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6687, type_6687, type_7828), Reflex::Literal("insert"), method_10551, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6687, type_3592, type_7828), Reflex::Literal("insert"), method_10552, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6687, type_6687), Reflex::Literal("erase"), method_10553, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6687, type_6687, type_6687), Reflex::Literal("erase"), method_10554, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26695), Reflex::Literal("swap"), method_10555, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10556, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > -------------------------------
static void constructor_10582( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >();
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >();
}

static void constructor_10583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(const ::std::allocator<SmartRef<KeyedObject<int> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(const ::std::allocator<SmartRef<KeyedObject<int> > >*)arg[0]);
}

static void constructor_10584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<int> >*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<int> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<int> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<int> > >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<KeyedObject<int> >*)arg[1],
      *(const ::std::allocator<SmartRef<KeyedObject<int> > >*)arg[2]);
  }
}

static void constructor_10585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(const ::std::vector<SmartRef<KeyedObject<int> > >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<KeyedObject<int> > >(*(const ::std::vector<SmartRef<KeyedObject<int> > >*)arg[0]);
}

static void destructor_10586(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<KeyedObject<int> > >*)o)->::std::vector<SmartRef<KeyedObject<int> > >::~vector)();
}
static  void operator_10587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<int> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<int> > >*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->operator=)(*(const ::std::vector<SmartRef<KeyedObject<int> > >*)arg[0]);
}

static  void method_10588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<KeyedObject<int> >*)arg[1]);
}

static  void method_10589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >)((((::std::vector<SmartRef<KeyedObject<int> > >*)o)->begin)());
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->begin)();
}

static  void method_10590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >)((((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->begin)();
}

static  void method_10591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >)((((::std::vector<SmartRef<KeyedObject<int> > >*)o)->end)());
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->end)();
}

static  void method_10592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >)((((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->end)());
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->end)();
}

static  void method_10597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->size)();
}

static  void method_10598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->max_size)();
}

static  void method_10599( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<KeyedObject<int> >*)arg[1]);
  }
}

static  void method_10600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->capacity)();
}

static  void method_10601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->empty)();
}

static  void method_10602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<int> > >*)o)->front)();
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->front)();
}

static  void method_10609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->front)();
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->front)();
}

static  void method_10610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<KeyedObject<int> > >*)o)->back)();
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->back)();
}

static  void method_10611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->back)();
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->back)();
}

static  void method_10612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<KeyedObject<int> > >*)o)->data)());
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->data)();
}

static  void method_10613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->data)());
  else   (((const ::std::vector<SmartRef<KeyedObject<int> > >*)o)->data)();
}

static  void method_10614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->push_back)(*(const ::SmartRef<KeyedObject<int> >*)arg[0]);
}

static  void method_10615( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->pop_back)();
}

static  void method_10616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >)((((::std::vector<SmartRef<KeyedObject<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<int> >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[0],
    *(const ::SmartRef<KeyedObject<int> >*)arg[1]);
}

static  void method_10617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<KeyedObject<int> >*)arg[2]);
}

static  void method_10618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >)((((::std::vector<SmartRef<KeyedObject<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[0]));
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[0]);
}

static  void method_10619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >)((((::std::vector<SmartRef<KeyedObject<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[1]));
  else   (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<KeyedObject<int> >*,std::vector<SmartRef<KeyedObject<int> > > >*)arg[1]);
}

static  void method_10620( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->swap)(*(::std::vector<SmartRef<KeyedObject<int> > >*)arg[0]);
}

static  void method_10621( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<KeyedObject<int> > >*)o)->clear)();
}

static void method_newdel_3161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<KeyedObject<int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<int> > >,::std::_Vector_base<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<int> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<KeyedObject<int> > > >::Generate();
}

//------Dictionary for class vector<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > -------------------------------
void __std__vector_SmartRef_KeyedObject_int_s_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_KeyedObject_int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_int_s_s__datamem_bld(&__std__vector_SmartRef_KeyedObject_int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_KeyedObject_int_s_s__funcmem_bld(&__std__vector_SmartRef_KeyedObject_int_s_s__db_funcmem);
void __std__vector_SmartRef_KeyedObject_int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >"), typeid(::std::vector<SmartRef<KeyedObject<int> > >), sizeof(::std::vector<SmartRef<KeyedObject<int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3081, ::Reflex::BaseOffset< ::std::vector<SmartRef<KeyedObject<int> > >, ::std::_Vector_base<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2746, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::_Alloc_value_type"))
  .AddTypedef(type_3081, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::_Base"))
  .AddTypedef(type_3630, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::_Tp_alloc_type"))
  .AddTypedef(type_6796, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::_Alloc_traits"))
  .AddTypedef(type_2746, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::value_type"))
  .AddTypedef(type_9370, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::pointer"))
  .AddTypedef(type_10571, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::const_pointer"))
  .AddTypedef(type_5659, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::reference"))
  .AddTypedef(type_7829, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::const_reference"))
  .AddTypedef(type_6689, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::iterator"))
  .AddTypedef(type_6690, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::const_iterator"))
  .AddTypedef(type_3836, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::const_reverse_iterator"))
  .AddTypedef(type_3837, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::difference_type"))
  .AddTypedef(type_3630, Reflex::Literal("std::vector<SmartRef<KeyedObject<int> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10582, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26173), Reflex::Literal("vector"), constructor_10583, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_7829, type_26173), Reflex::Literal("vector"), constructor_10584, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26696), Reflex::Literal("vector"), constructor_10585, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10586, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_KeyedObject_int_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_int_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<KeyedObject<int> >,std::allocator<SmartRef<KeyedObject<int> > > > -------------------
void __std__vector_SmartRef_KeyedObject_int_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26697, type_26696), Reflex::Literal("operator="), operator_10587, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_7829), Reflex::Literal("assign"), method_10588, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6689), Reflex::Literal("begin"), method_10589, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6690), Reflex::Literal("begin"), method_10590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6689), Reflex::Literal("end"), method_10591, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6690), Reflex::Literal("end"), method_10592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_2746), Reflex::Literal("resize"), method_10599, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10602, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659, type_3592), Reflex::Literal("operator[]"), operator_10603, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7829, type_3592), Reflex::Literal("operator[]"), operator_10604, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659, type_3592), Reflex::Literal("at"), method_10606, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7829, type_3592), Reflex::Literal("at"), method_10607, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659), Reflex::Literal("front"), method_10608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7829), Reflex::Literal("front"), method_10609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5659), Reflex::Literal("back"), method_10610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7829), Reflex::Literal("back"), method_10611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9370), Reflex::Literal("data"), method_10612, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10571), Reflex::Literal("data"), method_10613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7829), Reflex::Literal("push_back"), method_10614, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6689, type_6689, type_7829), Reflex::Literal("insert"), method_10616, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6689, type_3592, type_7829), Reflex::Literal("insert"), method_10617, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6689, type_6689), Reflex::Literal("erase"), method_10618, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6689, type_6689, type_6689), Reflex::Literal("erase"), method_10619, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26697), Reflex::Literal("swap"), method_10620, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10621, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > -------------------------------
static void constructor_10647( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >();
  else ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >();
}

static void constructor_10648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(const ::std::allocator<SmartRef<ObjectContainerBase> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(const ::std::allocator<SmartRef<ObjectContainerBase> >*)arg[0]);
}

static void constructor_10649( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ObjectContainerBase>*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ObjectContainerBase>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ObjectContainerBase>*)arg[1],
      *(const ::std::allocator<SmartRef<ObjectContainerBase> >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ObjectContainerBase>*)arg[1],
      *(const ::std::allocator<SmartRef<ObjectContainerBase> >*)arg[2]);
  }
}

static void constructor_10650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(const ::std::vector<SmartRef<ObjectContainerBase> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<ObjectContainerBase> >(*(const ::std::vector<SmartRef<ObjectContainerBase> >*)arg[0]);
}

static void destructor_10651(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<ObjectContainerBase> >*)o)->::std::vector<SmartRef<ObjectContainerBase> >::~vector)();
}
static  void operator_10652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ObjectContainerBase> >*)o)->operator=)(*(const ::std::vector<SmartRef<ObjectContainerBase> >*)arg[0]);
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->operator=)(*(const ::std::vector<SmartRef<ObjectContainerBase> >*)arg[0]);
}

static  void method_10653( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<ObjectContainerBase>*)arg[1]);
}

static  void method_10654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >)((((::std::vector<SmartRef<ObjectContainerBase> >*)o)->begin)());
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->begin)();
}

static  void method_10655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >)((((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->begin)();
}

static  void method_10656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >)((((::std::vector<SmartRef<ObjectContainerBase> >*)o)->end)());
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->end)();
}

static  void method_10657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >)((((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->end)());
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->end)();
}

static  void method_10662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->size)());
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->size)();
}

static  void method_10663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->max_size)();
}

static  void method_10664( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<ObjectContainerBase>*)arg[1]);
  }
}

static  void method_10665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->capacity)();
}

static  void method_10666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->empty)();
}

static  void method_10667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ObjectContainerBase> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ObjectContainerBase> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ObjectContainerBase> >*)o)->front)();
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->front)();
}

static  void method_10674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->front)();
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->front)();
}

static  void method_10675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ObjectContainerBase> >*)o)->back)();
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->back)();
}

static  void method_10676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->back)();
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->back)();
}

static  void method_10677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<ObjectContainerBase> >*)o)->data)());
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->data)();
}

static  void method_10678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->data)());
  else   (((const ::std::vector<SmartRef<ObjectContainerBase> >*)o)->data)();
}

static  void method_10679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->push_back)(*(const ::SmartRef<ObjectContainerBase>*)arg[0]);
}

static  void method_10680( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->pop_back)();
}

static  void method_10681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >)((((::std::vector<SmartRef<ObjectContainerBase> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[0],
    *(const ::SmartRef<ObjectContainerBase>*)arg[1]));
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[0],
    *(const ::SmartRef<ObjectContainerBase>*)arg[1]);
}

static  void method_10682( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<ObjectContainerBase>*)arg[2]);
}

static  void method_10683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >)((((::std::vector<SmartRef<ObjectContainerBase> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[0]));
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[0]);
}

static  void method_10684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >)((((::std::vector<SmartRef<ObjectContainerBase> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[1]));
  else   (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<ObjectContainerBase>*,std::vector<SmartRef<ObjectContainerBase> > >*)arg[1]);
}

static  void method_10685( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->swap)(*(::std::vector<SmartRef<ObjectContainerBase> >*)arg[0]);
}

static  void method_10686( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<ObjectContainerBase> >*)o)->clear)();
}

static void method_newdel_3162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ObjectContainerBase> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ObjectContainerBase> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ObjectContainerBase> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ObjectContainerBase> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ObjectContainerBase> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<ObjectContainerBase> >,::std::_Vector_base<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<ObjectContainerBase> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<ObjectContainerBase> > >::Generate();
}

//------Dictionary for class vector<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > -------------------------------
void __std__vector_SmartRef_ObjectContainerBase_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_ObjectContainerBase_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_ObjectContainerBase_s__datamem_bld(&__std__vector_SmartRef_ObjectContainerBase_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_ObjectContainerBase_s__funcmem_bld(&__std__vector_SmartRef_ObjectContainerBase_s__db_funcmem);
void __std__vector_SmartRef_ObjectContainerBase_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >"), typeid(::std::vector<SmartRef<ObjectContainerBase> >), sizeof(::std::vector<SmartRef<ObjectContainerBase> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3082, ::Reflex::BaseOffset< ::std::vector<SmartRef<ObjectContainerBase> >, ::std::_Vector_base<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2747, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::_Alloc_value_type"))
  .AddTypedef(type_3082, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::_Base"))
  .AddTypedef(type_3631, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::_Tp_alloc_type"))
  .AddTypedef(type_6797, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::_Alloc_traits"))
  .AddTypedef(type_2747, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::value_type"))
  .AddTypedef(type_9389, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::pointer"))
  .AddTypedef(type_10636, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::const_pointer"))
  .AddTypedef(type_5660, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::reference"))
  .AddTypedef(type_7830, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::const_reference"))
  .AddTypedef(type_6691, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::iterator"))
  .AddTypedef(type_6692, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::const_iterator"))
  .AddTypedef(type_3838, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::const_reverse_iterator"))
  .AddTypedef(type_3839, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::difference_type"))
  .AddTypedef(type_3631, Reflex::Literal("std::vector<SmartRef<ObjectContainerBase> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10647, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26186), Reflex::Literal("vector"), constructor_10648, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_7830, type_26186), Reflex::Literal("vector"), constructor_10649, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26698), Reflex::Literal("vector"), constructor_10650, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10651, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_ObjectContainerBase_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > -------------------
void __std__vector_SmartRef_ObjectContainerBase_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<ObjectContainerBase>,std::allocator<SmartRef<ObjectContainerBase> > > -------------------
void __std__vector_SmartRef_ObjectContainerBase_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26699, type_26698), Reflex::Literal("operator="), operator_10652, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_7830), Reflex::Literal("assign"), method_10653, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6691), Reflex::Literal("begin"), method_10654, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6692), Reflex::Literal("begin"), method_10655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6691), Reflex::Literal("end"), method_10656, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6692), Reflex::Literal("end"), method_10657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_2747), Reflex::Literal("resize"), method_10664, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10666, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10667, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660, type_3592), Reflex::Literal("operator[]"), operator_10668, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7830, type_3592), Reflex::Literal("operator[]"), operator_10669, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660, type_3592), Reflex::Literal("at"), method_10671, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7830, type_3592), Reflex::Literal("at"), method_10672, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660), Reflex::Literal("front"), method_10673, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7830), Reflex::Literal("front"), method_10674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5660), Reflex::Literal("back"), method_10675, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7830), Reflex::Literal("back"), method_10676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9389), Reflex::Literal("data"), method_10677, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10636), Reflex::Literal("data"), method_10678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7830), Reflex::Literal("push_back"), method_10679, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10680, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6691, type_6691, type_7830), Reflex::Literal("insert"), method_10681, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6691, type_3592, type_7830), Reflex::Literal("insert"), method_10682, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6691, type_6691), Reflex::Literal("erase"), method_10683, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6691, type_6691, type_6691), Reflex::Literal("erase"), method_10684, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26699), Reflex::Literal("swap"), method_10685, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10686, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > -------------------------------
static void constructor_10712( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ContainedObject> >();
  else ::new(mem) ::std::vector<SmartRef<ContainedObject> >();
}

static void constructor_10713( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(const ::std::allocator<SmartRef<ContainedObject> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(const ::std::allocator<SmartRef<ContainedObject> >*)arg[0]);
}

static void constructor_10714( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ContainedObject>*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ContainedObject>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ContainedObject>*)arg[1],
      *(const ::std::allocator<SmartRef<ContainedObject> >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<ContainedObject>*)arg[1],
      *(const ::std::allocator<SmartRef<ContainedObject> >*)arg[2]);
  }
}

static void constructor_10715( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(const ::std::vector<SmartRef<ContainedObject> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<ContainedObject> >(*(const ::std::vector<SmartRef<ContainedObject> >*)arg[0]);
}

static void destructor_10716(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<ContainedObject> >*)o)->::std::vector<SmartRef<ContainedObject> >::~vector)();
}
static  void operator_10717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ContainedObject> >*)o)->operator=)(*(const ::std::vector<SmartRef<ContainedObject> >*)arg[0]);
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->operator=)(*(const ::std::vector<SmartRef<ContainedObject> >*)arg[0]);
}

static  void method_10718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ContainedObject> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<ContainedObject>*)arg[1]);
}

static  void method_10719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >)((((::std::vector<SmartRef<ContainedObject> >*)o)->begin)());
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->begin)();
}

static  void method_10720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >)((((const ::std::vector<SmartRef<ContainedObject> >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->begin)();
}

static  void method_10721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >)((((::std::vector<SmartRef<ContainedObject> >*)o)->end)());
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->end)();
}

static  void method_10722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >)((((const ::std::vector<SmartRef<ContainedObject> >*)o)->end)());
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->end)();
}

static  void method_10727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<ContainedObject> >*)o)->size)());
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->size)();
}

static  void method_10728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<ContainedObject> >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->max_size)();
}

static  void method_10729( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<ContainedObject> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<ContainedObject> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<ContainedObject>*)arg[1]);
  }
}

static  void method_10730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<ContainedObject> >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->capacity)();
}

static  void method_10731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<ContainedObject> >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->empty)();
}

static  void method_10732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ContainedObject> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ContainedObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ContainedObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ContainedObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ContainedObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ContainedObject> >*)o)->front)();
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->front)();
}

static  void method_10739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ContainedObject> >*)o)->front)();
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->front)();
}

static  void method_10740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<ContainedObject> >*)o)->back)();
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->back)();
}

static  void method_10741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<ContainedObject> >*)o)->back)();
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->back)();
}

static  void method_10742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<ContainedObject> >*)o)->data)());
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->data)();
}

static  void method_10743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<ContainedObject> >*)o)->data)());
  else   (((const ::std::vector<SmartRef<ContainedObject> >*)o)->data)();
}

static  void method_10744( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ContainedObject> >*)o)->push_back)(*(const ::SmartRef<ContainedObject>*)arg[0]);
}

static  void method_10745( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<ContainedObject> >*)o)->pop_back)();
}

static  void method_10746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >)((((::std::vector<SmartRef<ContainedObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[0],
    *(const ::SmartRef<ContainedObject>*)arg[1]));
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[0],
    *(const ::SmartRef<ContainedObject>*)arg[1]);
}

static  void method_10747( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ContainedObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<ContainedObject>*)arg[2]);
}

static  void method_10748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >)((((::std::vector<SmartRef<ContainedObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[0]));
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[0]);
}

static  void method_10749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >)((((::std::vector<SmartRef<ContainedObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[1]));
  else   (((::std::vector<SmartRef<ContainedObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<ContainedObject>*,std::vector<SmartRef<ContainedObject> > >*)arg[1]);
}

static  void method_10750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<ContainedObject> >*)o)->swap)(*(::std::vector<SmartRef<ContainedObject> >*)arg[0]);
}

static  void method_10751( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<ContainedObject> >*)o)->clear)();
}

static void method_newdel_3163( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ContainedObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ContainedObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ContainedObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ContainedObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<ContainedObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<ContainedObject> >,::std::_Vector_base<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<ContainedObject> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<ContainedObject> > >::Generate();
}

//------Dictionary for class vector<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > -------------------------------
void __std__vector_SmartRef_ContainedObject_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_ContainedObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_ContainedObject_s__datamem_bld(&__std__vector_SmartRef_ContainedObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_ContainedObject_s__funcmem_bld(&__std__vector_SmartRef_ContainedObject_s__db_funcmem);
void __std__vector_SmartRef_ContainedObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<ContainedObject> >"), typeid(::std::vector<SmartRef<ContainedObject> >), sizeof(::std::vector<SmartRef<ContainedObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3083, ::Reflex::BaseOffset< ::std::vector<SmartRef<ContainedObject> >, ::std::_Vector_base<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2748, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::_Alloc_value_type"))
  .AddTypedef(type_3083, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::_Base"))
  .AddTypedef(type_3632, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::_Tp_alloc_type"))
  .AddTypedef(type_6798, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::_Alloc_traits"))
  .AddTypedef(type_2748, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::value_type"))
  .AddTypedef(type_9408, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::pointer"))
  .AddTypedef(type_10701, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::const_pointer"))
  .AddTypedef(type_5661, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::reference"))
  .AddTypedef(type_7835, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::const_reference"))
  .AddTypedef(type_6693, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::iterator"))
  .AddTypedef(type_6694, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::const_iterator"))
  .AddTypedef(type_3840, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::const_reverse_iterator"))
  .AddTypedef(type_3841, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::difference_type"))
  .AddTypedef(type_3632, Reflex::Literal("std::vector<SmartRef<ContainedObject> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10712, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26199), Reflex::Literal("vector"), constructor_10713, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_7835, type_26199), Reflex::Literal("vector"), constructor_10714, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26700), Reflex::Literal("vector"), constructor_10715, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10716, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3163, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_ContainedObject_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > -------------------
void __std__vector_SmartRef_ContainedObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<ContainedObject>,std::allocator<SmartRef<ContainedObject> > > -------------------
void __std__vector_SmartRef_ContainedObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26701, type_26700), Reflex::Literal("operator="), operator_10717, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_7835), Reflex::Literal("assign"), method_10718, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6693), Reflex::Literal("begin"), method_10719, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6694), Reflex::Literal("begin"), method_10720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6693), Reflex::Literal("end"), method_10721, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6694), Reflex::Literal("end"), method_10722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_2748), Reflex::Literal("resize"), method_10729, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10732, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661, type_3592), Reflex::Literal("operator[]"), operator_10733, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7835, type_3592), Reflex::Literal("operator[]"), operator_10734, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661, type_3592), Reflex::Literal("at"), method_10736, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7835, type_3592), Reflex::Literal("at"), method_10737, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661), Reflex::Literal("front"), method_10738, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7835), Reflex::Literal("front"), method_10739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5661), Reflex::Literal("back"), method_10740, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7835), Reflex::Literal("back"), method_10741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9408), Reflex::Literal("data"), method_10742, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10701), Reflex::Literal("data"), method_10743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7835), Reflex::Literal("push_back"), method_10744, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10745, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6693, type_6693, type_7835), Reflex::Literal("insert"), method_10746, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6693, type_3592, type_7835), Reflex::Literal("insert"), method_10747, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6693, type_6693), Reflex::Literal("erase"), method_10748, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6693, type_6693, type_6693), Reflex::Literal("erase"), method_10749, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26701), Reflex::Literal("swap"), method_10750, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10751, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > -------------------------------
static void constructor_10777( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<DataObject> >();
  else ::new(mem) ::std::vector<SmartRef<DataObject> >();
}

static void constructor_10778( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<DataObject> >(*(const ::std::allocator<SmartRef<DataObject> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<DataObject> >(*(const ::std::allocator<SmartRef<DataObject> >*)arg[0]);
}

static void constructor_10779( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<DataObject> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<DataObject> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<DataObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<DataObject>*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<DataObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<DataObject>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<DataObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<DataObject>*)arg[1],
      *(const ::std::allocator<SmartRef<DataObject> >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<DataObject> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<DataObject>*)arg[1],
      *(const ::std::allocator<SmartRef<DataObject> >*)arg[2]);
  }
}

static void constructor_10780( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<DataObject> >(*(const ::std::vector<SmartRef<DataObject> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<DataObject> >(*(const ::std::vector<SmartRef<DataObject> >*)arg[0]);
}

static void destructor_10781(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<DataObject> >*)o)->::std::vector<SmartRef<DataObject> >::~vector)();
}
static  void operator_10782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<DataObject> >*)o)->operator=)(*(const ::std::vector<SmartRef<DataObject> >*)arg[0]);
  else   (((::std::vector<SmartRef<DataObject> >*)o)->operator=)(*(const ::std::vector<SmartRef<DataObject> >*)arg[0]);
}

static  void method_10783( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<DataObject> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<DataObject>*)arg[1]);
}

static  void method_10784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >)((((::std::vector<SmartRef<DataObject> >*)o)->begin)());
  else   (((::std::vector<SmartRef<DataObject> >*)o)->begin)();
}

static  void method_10785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >)((((const ::std::vector<SmartRef<DataObject> >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->begin)();
}

static  void method_10786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >)((((::std::vector<SmartRef<DataObject> >*)o)->end)());
  else   (((::std::vector<SmartRef<DataObject> >*)o)->end)();
}

static  void method_10787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >)((((const ::std::vector<SmartRef<DataObject> >*)o)->end)());
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->end)();
}

static  void method_10792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<DataObject> >*)o)->size)());
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->size)();
}

static  void method_10793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<DataObject> >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->max_size)();
}

static  void method_10794( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<DataObject> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<DataObject> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<DataObject>*)arg[1]);
  }
}

static  void method_10795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<DataObject> >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->capacity)();
}

static  void method_10796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<DataObject> >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->empty)();
}

static  void method_10797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<DataObject> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<DataObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<DataObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<DataObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<DataObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<DataObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<DataObject> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<DataObject> >*)o)->front)();
  else   (((::std::vector<SmartRef<DataObject> >*)o)->front)();
}

static  void method_10804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<DataObject> >*)o)->front)();
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->front)();
}

static  void method_10805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<DataObject> >*)o)->back)();
  else   (((::std::vector<SmartRef<DataObject> >*)o)->back)();
}

static  void method_10806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<DataObject> >*)o)->back)();
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->back)();
}

static  void method_10807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<DataObject> >*)o)->data)());
  else   (((::std::vector<SmartRef<DataObject> >*)o)->data)();
}

static  void method_10808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<DataObject> >*)o)->data)());
  else   (((const ::std::vector<SmartRef<DataObject> >*)o)->data)();
}

static  void method_10809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<DataObject> >*)o)->push_back)(*(const ::SmartRef<DataObject>*)arg[0]);
}

static  void method_10810( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<DataObject> >*)o)->pop_back)();
}

static  void method_10811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >)((((::std::vector<SmartRef<DataObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[0],
    *(const ::SmartRef<DataObject>*)arg[1]));
  else   (((::std::vector<SmartRef<DataObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[0],
    *(const ::SmartRef<DataObject>*)arg[1]);
}

static  void method_10812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<DataObject> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<DataObject>*)arg[2]);
}

static  void method_10813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >)((((::std::vector<SmartRef<DataObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[0]));
  else   (((::std::vector<SmartRef<DataObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[0]);
}

static  void method_10814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >)((((::std::vector<SmartRef<DataObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[1]));
  else   (((::std::vector<SmartRef<DataObject> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<DataObject>*,std::vector<SmartRef<DataObject> > >*)arg[1]);
}

static  void method_10815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<DataObject> >*)o)->swap)(*(::std::vector<SmartRef<DataObject> >*)arg[0]);
}

static  void method_10816( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<DataObject> >*)o)->clear)();
}

static void method_newdel_3164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<DataObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<DataObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<DataObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<DataObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<DataObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<DataObject> >,::std::_Vector_base<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<DataObject> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<DataObject> > >::Generate();
}

//------Dictionary for class vector<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > -------------------------------
void __std__vector_SmartRef_DataObject_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_DataObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_DataObject_s__datamem_bld(&__std__vector_SmartRef_DataObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_DataObject_s__funcmem_bld(&__std__vector_SmartRef_DataObject_s__db_funcmem);
void __std__vector_SmartRef_DataObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<DataObject> >"), typeid(::std::vector<SmartRef<DataObject> >), sizeof(::std::vector<SmartRef<DataObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3084, ::Reflex::BaseOffset< ::std::vector<SmartRef<DataObject> >, ::std::_Vector_base<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2749, Reflex::Literal("std::vector<SmartRef<DataObject> >::_Alloc_value_type"))
  .AddTypedef(type_3084, Reflex::Literal("std::vector<SmartRef<DataObject> >::_Base"))
  .AddTypedef(type_3633, Reflex::Literal("std::vector<SmartRef<DataObject> >::_Tp_alloc_type"))
  .AddTypedef(type_6799, Reflex::Literal("std::vector<SmartRef<DataObject> >::_Alloc_traits"))
  .AddTypedef(type_2749, Reflex::Literal("std::vector<SmartRef<DataObject> >::value_type"))
  .AddTypedef(type_9427, Reflex::Literal("std::vector<SmartRef<DataObject> >::pointer"))
  .AddTypedef(type_10766, Reflex::Literal("std::vector<SmartRef<DataObject> >::const_pointer"))
  .AddTypedef(type_5662, Reflex::Literal("std::vector<SmartRef<DataObject> >::reference"))
  .AddTypedef(type_7836, Reflex::Literal("std::vector<SmartRef<DataObject> >::const_reference"))
  .AddTypedef(type_6695, Reflex::Literal("std::vector<SmartRef<DataObject> >::iterator"))
  .AddTypedef(type_6696, Reflex::Literal("std::vector<SmartRef<DataObject> >::const_iterator"))
  .AddTypedef(type_3842, Reflex::Literal("std::vector<SmartRef<DataObject> >::const_reverse_iterator"))
  .AddTypedef(type_3843, Reflex::Literal("std::vector<SmartRef<DataObject> >::reverse_iterator"))
  .AddTypedef(type_3592, Reflex::Literal("std::vector<SmartRef<DataObject> >::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::vector<SmartRef<DataObject> >::difference_type"))
  .AddTypedef(type_3633, Reflex::Literal("std::vector<SmartRef<DataObject> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10777, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26212), Reflex::Literal("vector"), constructor_10778, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_7836, type_26212), Reflex::Literal("vector"), constructor_10779, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26702), Reflex::Literal("vector"), constructor_10780, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10781, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_DataObject_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > -------------------
void __std__vector_SmartRef_DataObject_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<DataObject>,std::allocator<SmartRef<DataObject> > > -------------------
void __std__vector_SmartRef_DataObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26703, type_26702), Reflex::Literal("operator="), operator_10782, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_7836), Reflex::Literal("assign"), method_10783, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6695), Reflex::Literal("begin"), method_10784, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6696), Reflex::Literal("begin"), method_10785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6695), Reflex::Literal("end"), method_10786, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6696), Reflex::Literal("end"), method_10787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_10792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_10793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_2749), Reflex::Literal("resize"), method_10794, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_10795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_10796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_10797, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662, type_3592), Reflex::Literal("operator[]"), operator_10798, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7836, type_3592), Reflex::Literal("operator[]"), operator_10799, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662, type_3592), Reflex::Literal("at"), method_10801, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7836, type_3592), Reflex::Literal("at"), method_10802, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662), Reflex::Literal("front"), method_10803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7836), Reflex::Literal("front"), method_10804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5662), Reflex::Literal("back"), method_10805, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7836), Reflex::Literal("back"), method_10806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9427), Reflex::Literal("data"), method_10807, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10766), Reflex::Literal("data"), method_10808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_7836), Reflex::Literal("push_back"), method_10809, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("pop_back"), method_10810, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6695, type_6695, type_7836), Reflex::Literal("insert"), method_10811, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6695, type_3592, type_7836), Reflex::Literal("insert"), method_10812, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6695, type_6695), Reflex::Literal("erase"), method_10813, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6695, type_6695, type_6695), Reflex::Literal("erase"), method_10814, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26703), Reflex::Literal("swap"), method_10815, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_10816, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
static void constructor_13060( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>();
  else ::new(mem) ::std::basic_string<char>();
}

static void constructor_13061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_13062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
}

static void constructor_13063( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static void constructor_13064( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
}

static void constructor_13065( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_13066( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  }
}

static void constructor_13067( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void destructor_13068(void*, void * o, const std::vector<void*>&, void *) {
(((::std::basic_string<char>*)o)->::std::basic_string<char>::~basic_string)();
}
static  void operator_13069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_13070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
}

static  void operator_13071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
}

static  void method_13072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->begin)());
  else   (((::std::basic_string<char>*)o)->begin)();
}

static  void method_13073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->begin)());
  else   (((const ::std::basic_string<char>*)o)->begin)();
}

static  void method_13074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->end)());
  else   (((::std::basic_string<char>*)o)->end)();
}

static  void method_13075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->end)());
  else   (((const ::std::basic_string<char>*)o)->end)();
}

static  void method_13080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->size)());
  else   (((const ::std::basic_string<char>*)o)->size)();
}

static  void method_13081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->length)());
  else   (((const ::std::basic_string<char>*)o)->length)();
}

static  void method_13082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->max_size)());
  else   (((const ::std::basic_string<char>*)o)->max_size)();
}

static  void method_13083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_13084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0]);
}

static  void method_13085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->capacity)());
  else   (((const ::std::basic_string<char>*)o)->capacity)();
}

static  void method_13086( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::basic_string<char>*)o)->reserve)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::basic_string<char>*)o)->reserve)(*(::std::size_t*)arg[0]);
  }
}

static  void method_13087( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::basic_string<char>*)o)->clear)();
}

static  void method_13088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::basic_string<char>*)o)->empty)());
  else   (((const ::std::basic_string<char>*)o)->empty)();
}

static  void operator_13089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void operator_13093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_13094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_13095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
}

static  void method_13096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_13099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
}

static  void method_13100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_13101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->push_back)(*(char*)arg[0]);
}

static  void method_13102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_13105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
}

static  void method_13106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_13107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_13108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_13110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_13112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_13113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]));
  else   (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]);
}

static  void method_13114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)();
    else     (((::std::basic_string<char>*)o)->erase)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]);
}

static  void method_13116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]);
}

static  void method_13117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_13118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_13119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_13120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_13121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_13122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_13123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_13124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
}

static  void method_13125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_13126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
}

static  void method_13127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
}

static  void method_13128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
}

static  void method_13129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
}

static  void method_13134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static  void method_13135( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->swap)(*(::std::basic_string<char>*)arg[0]);
}

static  void method_13136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->c_str)());
  else   (((const ::std::basic_string<char>*)o)->c_str)();
}

static  void method_13137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->data)());
  else   (((const ::std::basic_string<char>*)o)->data)();
}

static  void method_13138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<char>)((((const ::std::basic_string<char>*)o)->get_allocator)());
  else   (((const ::std::basic_string<char>*)o)->get_allocator)();
}

static  void method_13139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_13161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)());
    else     (((const ::std::basic_string<char>*)o)->substr)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_13164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_13166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_13167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]);
}

static  void method_13168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_13169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static void method_newdel_3224( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
void __std__basic_string_char__db_datamem(Reflex::Class*);
void __std__basic_string_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__basic_string_char__datamem_bld(&__std__basic_string_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__basic_string_char__funcmem_bld(&__std__basic_string_char__db_funcmem);
void __std__basic_string_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::basic_string<char>"), typeid(::std::basic_string<char>), sizeof(::std::basic_string<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_3625, Reflex::Literal("std::basic_string<char>::_CharT_alloc_type"))
  .AddTypedef(type_3319, Reflex::Literal("std::basic_string<char>::traits_type"))
  .AddTypedef(type_4274, Reflex::Literal("std::basic_string<char>::value_type"))
  .AddTypedef(type_3625, Reflex::Literal("std::basic_string<char>::allocator_type"))
  .AddTypedef(type_3592, Reflex::Literal("std::basic_string<char>::size_type"))
  .AddTypedef(type_3309, Reflex::Literal("std::basic_string<char>::difference_type"))
  .AddTypedef(type_10108, Reflex::Literal("std::basic_string<char>::reference"))
  .AddTypedef(type_12372, Reflex::Literal("std::basic_string<char>::const_reference"))
  .AddTypedef(type_158, Reflex::Literal("std::basic_string<char>::pointer"))
  .AddTypedef(type_4095, Reflex::Literal("std::basic_string<char>::const_pointer"))
  .AddTypedef(type_6711, Reflex::Literal("std::basic_string<char>::iterator"))
  .AddTypedef(type_6766, Reflex::Literal("std::basic_string<char>::const_iterator"))
  .AddTypedef(type_3944, Reflex::Literal("std::basic_string<char>::const_reverse_iterator"))
  .AddTypedef(type_3945, Reflex::Literal("std::basic_string<char>::reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("basic_string"), constructor_13060, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26316), Reflex::Literal("basic_string"), constructor_13061, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7844), Reflex::Literal("basic_string"), constructor_13062, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7844, type_3592, type_3592), Reflex::Literal("basic_string"), constructor_13063, 0, "__str;__pos;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7844, type_3592, type_3592, type_26316), Reflex::Literal("basic_string"), constructor_13064, 0, "__str;__pos;__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4095, type_3592, type_26316), Reflex::Literal("basic_string"), constructor_13065, 0, "__s;__n;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4095, type_26316), Reflex::Literal("basic_string"), constructor_13066, 0, "__s;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3592, type_4274, type_26316), Reflex::Literal("basic_string"), constructor_13067, 0, "__n;__c;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~basic_string"), destructor_13068, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__basic_string_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__basic_string_char__funcmem_bld);
}

//------Delayed data member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_13038, Reflex::Literal("_M_dataplus"), OffsetOf(__shadow__::__std__basic_string_char_, _M_dataplus), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_7844), Reflex::Literal("operator="), operator_13069, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4095), Reflex::Literal("operator="), operator_13070, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4274), Reflex::Literal("operator="), operator_13071, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6711), Reflex::Literal("begin"), method_13072, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6766), Reflex::Literal("begin"), method_13073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6711), Reflex::Literal("end"), method_13074, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6766), Reflex::Literal("end"), method_13075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("size"), method_13080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("length"), method_13081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("max_size"), method_13082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592, type_4274), Reflex::Literal("resize"), method_13083, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("resize"), method_13084, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592), Reflex::Literal("capacity"), method_13085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_3592), Reflex::Literal("reserve"), method_13086, 0, "__res=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("clear"), method_13087, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("empty"), method_13088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12372, type_3592), Reflex::Literal("operator[]"), operator_13089, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10108, type_3592), Reflex::Literal("operator[]"), operator_13090, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12372, type_3592), Reflex::Literal("at"), method_13091, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10108, type_3592), Reflex::Literal("at"), method_13092, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_7844), Reflex::Literal("operator+="), operator_13093, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4095), Reflex::Literal("operator+="), operator_13094, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4274), Reflex::Literal("operator+="), operator_13095, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_7844), Reflex::Literal("append"), method_13096, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_7844, type_3592, type_3592), Reflex::Literal("append"), method_13097, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4095, type_3592), Reflex::Literal("append"), method_13098, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4095), Reflex::Literal("append"), method_13099, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_4274), Reflex::Literal("append"), method_13100, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4274), Reflex::Literal("push_back"), method_13101, 0, "__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_7844), Reflex::Literal("assign"), method_13102, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_7844, type_3592, type_3592), Reflex::Literal("assign"), method_13103, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4095, type_3592), Reflex::Literal("assign"), method_13104, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_4095), Reflex::Literal("assign"), method_13105, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_4274), Reflex::Literal("assign"), method_13106, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6711, type_3592, type_4274), Reflex::Literal("insert"), method_13107, 0, "__p;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_7844), Reflex::Literal("insert"), method_13108, 0, "__pos1;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_7844, type_3592, type_3592), Reflex::Literal("insert"), method_13109, 0, "__pos1;__str;__pos2;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_4095, type_3592), Reflex::Literal("insert"), method_13110, 0, "__pos;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_4095), Reflex::Literal("insert"), method_13111, 0, "__pos;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_3592, type_4274), Reflex::Literal("insert"), method_13112, 0, "__pos;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6711, type_6711, type_4274), Reflex::Literal("insert"), method_13113, 0, "__p;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_3592), Reflex::Literal("erase"), method_13114, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6711, type_6711), Reflex::Literal("erase"), method_13115, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6711, type_6711, type_6711), Reflex::Literal("erase"), method_13116, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_3592, type_7844), Reflex::Literal("replace"), method_13117, 0, "__pos;__n;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_3592, type_7844, type_3592, type_3592), Reflex::Literal("replace"), method_13118, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_3592, type_4095, type_3592), Reflex::Literal("replace"), method_13119, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_3592, type_4095), Reflex::Literal("replace"), method_13120, 0, "__pos;__n1;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_3592, type_3592, type_3592, type_4274), Reflex::Literal("replace"), method_13121, 0, "__pos;__n1;__n2;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_7844), Reflex::Literal("replace"), method_13122, 0, "__i1;__i2;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_4095, type_3592), Reflex::Literal("replace"), method_13123, 0, "__i1;__i2;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_4095), Reflex::Literal("replace"), method_13124, 0, "__i1;__i2;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_3592, type_4274), Reflex::Literal("replace"), method_13125, 0, "__i1;__i2;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_158, type_158), Reflex::Literal("replace"), method_13126, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_4095, type_4095), Reflex::Literal("replace"), method_13127, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_6711, type_6711), Reflex::Literal("replace"), method_13128, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10833, type_6711, type_6711, type_6766, type_6766), Reflex::Literal("replace"), method_13129, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_158, type_3592, type_3592), Reflex::Literal("copy"), method_13134, 0, "__s;__n;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_10833), Reflex::Literal("swap"), method_13135, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4095), Reflex::Literal("c_str"), method_13136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4095), Reflex::Literal("data"), method_13137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3625), Reflex::Literal("get_allocator"), method_13138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592, type_3592), Reflex::Literal("find"), method_13139, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_7844, type_3592), Reflex::Literal("find"), method_13140, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592), Reflex::Literal("find"), method_13141, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4274, type_3592), Reflex::Literal("find"), method_13142, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_7844, type_3592), Reflex::Literal("rfind"), method_13143, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592, type_3592), Reflex::Literal("rfind"), method_13144, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592), Reflex::Literal("rfind"), method_13145, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4274, type_3592), Reflex::Literal("rfind"), method_13146, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_7844, type_3592), Reflex::Literal("find_first_of"), method_13147, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592, type_3592), Reflex::Literal("find_first_of"), method_13148, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592), Reflex::Literal("find_first_of"), method_13149, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4274, type_3592), Reflex::Literal("find_first_of"), method_13150, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_7844, type_3592), Reflex::Literal("find_last_of"), method_13151, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592, type_3592), Reflex::Literal("find_last_of"), method_13152, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592), Reflex::Literal("find_last_of"), method_13153, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4274, type_3592), Reflex::Literal("find_last_of"), method_13154, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_7844, type_3592), Reflex::Literal("find_first_not_of"), method_13155, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592, type_3592), Reflex::Literal("find_first_not_of"), method_13156, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592), Reflex::Literal("find_first_not_of"), method_13157, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4274, type_3592), Reflex::Literal("find_first_not_of"), method_13158, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_7844, type_3592), Reflex::Literal("find_last_not_of"), method_13159, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592, type_3592), Reflex::Literal("find_last_not_of"), method_13160, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4095, type_3592), Reflex::Literal("find_last_not_of"), method_13161, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_4274, type_3592), Reflex::Literal("find_last_not_of"), method_13162, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3224, type_3592, type_3592), Reflex::Literal("substr"), method_13163, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_7844), Reflex::Literal("compare"), method_13164, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_3592, type_3592, type_7844), Reflex::Literal("compare"), method_13165, 0, "__pos;__n;__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_3592, type_3592, type_7844, type_3592, type_3592), Reflex::Literal("compare"), method_13166, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4095), Reflex::Literal("compare"), method_13167, 0, "__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_3592, type_3592, type_4095), Reflex::Literal("compare"), method_13168, 0, "__pos;__n1;__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_3592, type_3592, type_4095, type_3592), Reflex::Literal("compare"), method_13169, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Binomial -------------------------------
static void constructor_19289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Binomial(*(const ::Rndm::Binomial*)arg[0]);
  else ::new(mem) ::Rndm::Binomial(*(const ::Rndm::Binomial*)arg[0]);
}

static void constructor_19290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Binomial(*(long*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::Rndm::Binomial(*(long*)arg[0],
      *(double*)arg[1]);
}

static void destructor_19291(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Binomial*)o)->::Rndm::Binomial::~Binomial)();
}
static  void method_19292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::Rndm::Binomial*)o)->nEvent)());
  else   (((const ::Rndm::Binomial*)o)->nEvent)();
}

static  void method_19293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Binomial*)o)->probability)());
  else   (((const ::Rndm::Binomial*)o)->probability)();
}

static  void method_19294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Binomial*)o)->typeID)();
  else   (((::Rndm::Binomial*)o)->typeID)();
}

static  void method_19295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Binomial*)o)->clone)());
  else   (((const ::Rndm::Binomial*)o)->clone)();
}

static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Binomial,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Binomial -------------------------------
void __Rndm__Binomial_db_datamem(Reflex::Class*);
void __Rndm__Binomial_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Binomial_datamem_bld(&__Rndm__Binomial_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Binomial_funcmem_bld(&__Rndm__Binomial_db_funcmem);
void __Rndm__Binomial_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Binomial"), typeid(::Rndm::Binomial), sizeof(::Rndm::Binomial), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Binomial, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27628), Reflex::Literal("Binomial"), constructor_19289, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_2603), Reflex::Literal("Binomial"), constructor_19290, 0, "n;p", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Binomial"), destructor_19291, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Binomial_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Binomial_funcmem_bld);
}

//------Delayed data member builder for class Binomial -------------------
void __Rndm__Binomial_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_26, Reflex::Literal("m_nEvent"), OffsetOf(__shadow__::__Rndm__Binomial, m_nEvent), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_probability"), OffsetOf(__shadow__::__Rndm__Binomial, m_probability), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Binomial -------------------
void __Rndm__Binomial_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("nEvent"), method_19292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("probability"), method_19293, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19294, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19295, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Bit -------------------------------
static void constructor_19296( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Bit(*(const ::Rndm::Bit*)arg[0]);
  else ::new(mem) ::Rndm::Bit(*(const ::Rndm::Bit*)arg[0]);
}

static void constructor_19297( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Bit();
  else ::new(mem) ::Rndm::Bit();
}

static void destructor_19298(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Bit*)o)->::Rndm::Bit::~Bit)();
}
static  void method_19299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Bit*)o)->typeID)();
  else   (((::Rndm::Bit*)o)->typeID)();
}

static  void method_19300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Bit*)o)->clone)());
  else   (((const ::Rndm::Bit*)o)->clone)();
}

static void method_newdel_4208( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Rndm::Bit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Rndm::Bit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Rndm::Bit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Rndm::Bit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Rndm::Bit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Bit,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Bit -------------------------------
void __Rndm__Bit_db_datamem(Reflex::Class*);
void __Rndm__Bit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Bit_datamem_bld(&__Rndm__Bit_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Bit_funcmem_bld(&__Rndm__Bit_db_funcmem);
void __Rndm__Bit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Bit"), typeid(::Rndm::Bit), sizeof(::Rndm::Bit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Bit, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27630), Reflex::Literal("Bit"), constructor_19296, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Bit"), constructor_19297, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Bit"), destructor_19298, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4208, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Bit_funcmem_bld);
}

//------Delayed data member builder for class Bit -------------------
void __Rndm__Bit_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Bit -------------------
void __Rndm__Bit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19299, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19300, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class StudentT -------------------------------
static void constructor_19302( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::StudentT(*(const ::Rndm::StudentT*)arg[0]);
  else ::new(mem) ::Rndm::StudentT(*(const ::Rndm::StudentT*)arg[0]);
}

static void constructor_19303( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::StudentT(*(double*)arg[0]);
  else ::new(mem) ::Rndm::StudentT(*(double*)arg[0]);
}

static void destructor_19304(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::StudentT*)o)->::Rndm::StudentT::~StudentT)();
}
static  void method_19305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::StudentT*)o)->aValue)());
  else   (((const ::Rndm::StudentT*)o)->aValue)();
}

static  void method_19306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::StudentT*)o)->typeID)();
  else   (((::Rndm::StudentT*)o)->typeID)();
}

static  void method_19307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::StudentT*)o)->clone)());
  else   (((const ::Rndm::StudentT*)o)->clone)();
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::StudentT,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StudentT -------------------------------
void __Rndm__StudentT_db_datamem(Reflex::Class*);
void __Rndm__StudentT_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__StudentT_datamem_bld(&__Rndm__StudentT_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__StudentT_funcmem_bld(&__Rndm__StudentT_db_funcmem);
void __Rndm__StudentT_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::StudentT"), typeid(::Rndm::StudentT), sizeof(::Rndm::StudentT), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::StudentT, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27631), Reflex::Literal("StudentT"), constructor_19302, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603), Reflex::Literal("StudentT"), constructor_19303, 0, "a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StudentT"), destructor_19304, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__StudentT_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__StudentT_funcmem_bld);
}

//------Delayed data member builder for class StudentT -------------------
void __Rndm__StudentT_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_aValue"), OffsetOf(__shadow__::__Rndm__StudentT, m_aValue), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class StudentT -------------------
void __Rndm__StudentT_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("aValue"), method_19305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19306, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19307, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class DefinedPdf -------------------------------
static void constructor_19310( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::DefinedPdf(*(const ::Rndm::DefinedPdf*)arg[0]);
  else ::new(mem) ::Rndm::DefinedPdf(*(const ::Rndm::DefinedPdf*)arg[0]);
}

static void constructor_19311( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::DefinedPdf(*(const ::std::vector<double>*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::Rndm::DefinedPdf(*(const ::std::vector<double>*)arg[0],
      *(long*)arg[1]);
}

static void destructor_19312(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::DefinedPdf*)o)->::Rndm::DefinedPdf::~DefinedPdf)();
}
static  void method_19313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::DefinedPdf*)o)->pdf)();
  else   (((::Rndm::DefinedPdf*)o)->pdf)();
}

static  void method_19314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::Rndm::DefinedPdf*)o)->interpolation)());
  else   (((const ::Rndm::DefinedPdf*)o)->interpolation)();
}

static  void method_19315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::DefinedPdf*)o)->typeID)();
  else   (((::Rndm::DefinedPdf*)o)->typeID)();
}

static  void method_19316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::DefinedPdf*)o)->clone)());
  else   (((const ::Rndm::DefinedPdf*)o)->clone)();
}

static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::DefinedPdf,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DefinedPdf -------------------------------
void __Rndm__DefinedPdf_db_datamem(Reflex::Class*);
void __Rndm__DefinedPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__DefinedPdf_datamem_bld(&__Rndm__DefinedPdf_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__DefinedPdf_funcmem_bld(&__Rndm__DefinedPdf_db_funcmem);
void __Rndm__DefinedPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::DefinedPdf"), typeid(::Rndm::DefinedPdf), sizeof(::Rndm::DefinedPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::DefinedPdf, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27632), Reflex::Literal("DefinedPdf"), constructor_19310, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12640, type_26), Reflex::Literal("DefinedPdf"), constructor_19311, 0, "pdf;intpol", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DefinedPdf"), destructor_19312, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__DefinedPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__DefinedPdf_funcmem_bld);
}

//------Delayed data member builder for class DefinedPdf -------------------
void __Rndm__DefinedPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3167, Reflex::Literal("m_pdf"), OffsetOf(__shadow__::__Rndm__DefinedPdf, m_pdf), ::Reflex::PROTECTED)
  .AddDataMember(type_26, Reflex::Literal("m_interpolation"), OffsetOf(__shadow__::__Rndm__DefinedPdf, m_interpolation), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class DefinedPdf -------------------
void __Rndm__DefinedPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12638), Reflex::Literal("pdf"), method_19313, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("interpolation"), method_19314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19315, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19316, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Gamma -------------------------------
static void constructor_19319( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Gamma(*(const ::Rndm::Gamma*)arg[0]);
  else ::new(mem) ::Rndm::Gamma(*(const ::Rndm::Gamma*)arg[0]);
}

static void constructor_19320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Gamma(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::Rndm::Gamma(*(double*)arg[0],
      *(double*)arg[1]);
}

static void destructor_19321(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Gamma*)o)->::Rndm::Gamma::~Gamma)();
}
static  void method_19322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Gamma*)o)->kValue)());
  else   (((const ::Rndm::Gamma*)o)->kValue)();
}

static  void method_19323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Gamma*)o)->lambda)());
  else   (((const ::Rndm::Gamma*)o)->lambda)();
}

static  void method_19324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Gamma*)o)->typeID)();
  else   (((::Rndm::Gamma*)o)->typeID)();
}

static  void method_19325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Gamma*)o)->clone)());
  else   (((const ::Rndm::Gamma*)o)->clone)();
}

static void method_x175( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Gamma,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Gamma -------------------------------
void __Rndm__Gamma_db_datamem(Reflex::Class*);
void __Rndm__Gamma_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Gamma_datamem_bld(&__Rndm__Gamma_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Gamma_funcmem_bld(&__Rndm__Gamma_db_funcmem);
void __Rndm__Gamma_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Gamma"), typeid(::Rndm::Gamma), sizeof(::Rndm::Gamma), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Gamma, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27633), Reflex::Literal("Gamma"), constructor_19319, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603, type_2603), Reflex::Literal("Gamma"), constructor_19320, 0, "k;l", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Gamma"), destructor_19321, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x175, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Gamma_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Gamma_funcmem_bld);
}

//------Delayed data member builder for class Gamma -------------------
void __Rndm__Gamma_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_kValue"), OffsetOf(__shadow__::__Rndm__Gamma, m_kValue), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_lambda"), OffsetOf(__shadow__::__Rndm__Gamma, m_lambda), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Gamma -------------------
void __Rndm__Gamma_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("kValue"), method_19322, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("lambda"), method_19323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19324, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19325, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Exponential -------------------------------
static void constructor_19327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Exponential(*(const ::Rndm::Exponential*)arg[0]);
  else ::new(mem) ::Rndm::Exponential(*(const ::Rndm::Exponential*)arg[0]);
}

static void constructor_19328( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Exponential(*(double*)arg[0]);
  else ::new(mem) ::Rndm::Exponential(*(double*)arg[0]);
}

static void destructor_19329(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Exponential*)o)->::Rndm::Exponential::~Exponential)();
}
static  void method_19330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Exponential*)o)->mean)());
  else   (((const ::Rndm::Exponential*)o)->mean)();
}

static  void method_19331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Exponential*)o)->typeID)();
  else   (((::Rndm::Exponential*)o)->typeID)();
}

static  void method_19332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Exponential*)o)->clone)());
  else   (((const ::Rndm::Exponential*)o)->clone)();
}

static void method_x176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Exponential,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Exponential -------------------------------
void __Rndm__Exponential_db_datamem(Reflex::Class*);
void __Rndm__Exponential_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Exponential_datamem_bld(&__Rndm__Exponential_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Exponential_funcmem_bld(&__Rndm__Exponential_db_funcmem);
void __Rndm__Exponential_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Exponential"), typeid(::Rndm::Exponential), sizeof(::Rndm::Exponential), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Exponential, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27634), Reflex::Literal("Exponential"), constructor_19327, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603), Reflex::Literal("Exponential"), constructor_19328, 0, "m", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Exponential"), destructor_19329, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Exponential_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Exponential_funcmem_bld);
}

//------Delayed data member builder for class Exponential -------------------
void __Rndm__Exponential_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_mean"), OffsetOf(__shadow__::__Rndm__Exponential, m_mean), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Exponential -------------------
void __Rndm__Exponential_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("mean"), method_19330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19331, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19332, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Gauss -------------------------------
static void constructor_19335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Gauss(*(const ::Rndm::Gauss*)arg[0]);
  else ::new(mem) ::Rndm::Gauss(*(const ::Rndm::Gauss*)arg[0]);
}

static void constructor_19336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Gauss(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::Rndm::Gauss(*(double*)arg[0],
      *(double*)arg[1]);
}

static void destructor_19337(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Gauss*)o)->::Rndm::Gauss::~Gauss)();
}
static  void method_19338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Gauss*)o)->mean)());
  else   (((const ::Rndm::Gauss*)o)->mean)();
}

static  void method_19339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Gauss*)o)->sigma)());
  else   (((const ::Rndm::Gauss*)o)->sigma)();
}

static  void method_19340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Gauss*)o)->typeID)();
  else   (((::Rndm::Gauss*)o)->typeID)();
}

static  void method_19341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Gauss*)o)->clone)());
  else   (((const ::Rndm::Gauss*)o)->clone)();
}

static void method_x177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Gauss,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Gauss -------------------------------
void __Rndm__Gauss_db_datamem(Reflex::Class*);
void __Rndm__Gauss_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Gauss_datamem_bld(&__Rndm__Gauss_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Gauss_funcmem_bld(&__Rndm__Gauss_db_funcmem);
void __Rndm__Gauss_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Gauss"), typeid(::Rndm::Gauss), sizeof(::Rndm::Gauss), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Gauss, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27635), Reflex::Literal("Gauss"), constructor_19335, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603, type_2603), Reflex::Literal("Gauss"), constructor_19336, 0, "m;s", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Gauss"), destructor_19337, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Gauss_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Gauss_funcmem_bld);
}

//------Delayed data member builder for class Gauss -------------------
void __Rndm__Gauss_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_mean"), OffsetOf(__shadow__::__Rndm__Gauss, m_mean), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_sigma"), OffsetOf(__shadow__::__Rndm__Gauss, m_sigma), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Gauss -------------------
void __Rndm__Gauss_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("mean"), method_19338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("sigma"), method_19339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19340, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19341, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class BreitWignerCutOff -------------------------------
static void constructor_19345( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::BreitWignerCutOff(*(const ::Rndm::BreitWignerCutOff*)arg[0]);
  else ::new(mem) ::Rndm::BreitWignerCutOff(*(const ::Rndm::BreitWignerCutOff*)arg[0]);
}

static void constructor_19346( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::BreitWignerCutOff(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::Rndm::BreitWignerCutOff(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void destructor_19347(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::BreitWignerCutOff*)o)->::Rndm::BreitWignerCutOff::~BreitWignerCutOff)();
}
static  void method_19348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::BreitWignerCutOff*)o)->mean)());
  else   (((const ::Rndm::BreitWignerCutOff*)o)->mean)();
}

static  void method_19349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::BreitWignerCutOff*)o)->gamma)());
  else   (((const ::Rndm::BreitWignerCutOff*)o)->gamma)();
}

static  void method_19350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::BreitWignerCutOff*)o)->cutOff)());
  else   (((const ::Rndm::BreitWignerCutOff*)o)->cutOff)();
}

static  void method_19351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::BreitWignerCutOff*)o)->typeID)();
  else   (((::Rndm::BreitWignerCutOff*)o)->typeID)();
}

static  void method_19352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::BreitWignerCutOff*)o)->clone)());
  else   (((const ::Rndm::BreitWignerCutOff*)o)->clone)();
}

static void method_x178( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::BreitWignerCutOff,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class BreitWignerCutOff -------------------------------
void __Rndm__BreitWignerCutOff_db_datamem(Reflex::Class*);
void __Rndm__BreitWignerCutOff_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__BreitWignerCutOff_datamem_bld(&__Rndm__BreitWignerCutOff_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__BreitWignerCutOff_funcmem_bld(&__Rndm__BreitWignerCutOff_db_funcmem);
void __Rndm__BreitWignerCutOff_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::BreitWignerCutOff"), typeid(::Rndm::BreitWignerCutOff), sizeof(::Rndm::BreitWignerCutOff), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::BreitWignerCutOff, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27636), Reflex::Literal("BreitWignerCutOff"), constructor_19345, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603, type_2603, type_2603), Reflex::Literal("BreitWignerCutOff"), constructor_19346, 0, "m;g;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BreitWignerCutOff"), destructor_19347, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x178, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__BreitWignerCutOff_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__BreitWignerCutOff_funcmem_bld);
}

//------Delayed data member builder for class BreitWignerCutOff -------------------
void __Rndm__BreitWignerCutOff_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_mean"), OffsetOf(__shadow__::__Rndm__BreitWignerCutOff, m_mean), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_gamma"), OffsetOf(__shadow__::__Rndm__BreitWignerCutOff, m_gamma), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_cut"), OffsetOf(__shadow__::__Rndm__BreitWignerCutOff, m_cut), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class BreitWignerCutOff -------------------
void __Rndm__BreitWignerCutOff_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("mean"), method_19348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("gamma"), method_19349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("cutOff"), method_19350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19351, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19352, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Poisson -------------------------------
static void constructor_19354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Poisson(*(const ::Rndm::Poisson*)arg[0]);
  else ::new(mem) ::Rndm::Poisson(*(const ::Rndm::Poisson*)arg[0]);
}

static void constructor_19355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Poisson(*(double*)arg[0]);
  else ::new(mem) ::Rndm::Poisson(*(double*)arg[0]);
}

static void destructor_19356(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Poisson*)o)->::Rndm::Poisson::~Poisson)();
}
static  void method_19357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Poisson*)o)->mean)());
  else   (((const ::Rndm::Poisson*)o)->mean)();
}

static  void method_19358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Poisson*)o)->typeID)();
  else   (((::Rndm::Poisson*)o)->typeID)();
}

static  void method_19359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Poisson*)o)->clone)());
  else   (((const ::Rndm::Poisson*)o)->clone)();
}

static void method_x179( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Poisson,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Poisson -------------------------------
void __Rndm__Poisson_db_datamem(Reflex::Class*);
void __Rndm__Poisson_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Poisson_datamem_bld(&__Rndm__Poisson_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Poisson_funcmem_bld(&__Rndm__Poisson_db_funcmem);
void __Rndm__Poisson_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Poisson"), typeid(::Rndm::Poisson), sizeof(::Rndm::Poisson), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Poisson, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27637), Reflex::Literal("Poisson"), constructor_19354, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603), Reflex::Literal("Poisson"), constructor_19355, 0, "m", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Poisson"), destructor_19356, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Poisson_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Poisson_funcmem_bld);
}

//------Delayed data member builder for class Poisson -------------------
void __Rndm__Poisson_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_mean"), OffsetOf(__shadow__::__Rndm__Poisson, m_mean), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Poisson -------------------
void __Rndm__Poisson_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("mean"), method_19357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19358, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19359, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class BreitWigner -------------------------------
static void constructor_19362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::BreitWigner(*(const ::Rndm::BreitWigner*)arg[0]);
  else ::new(mem) ::Rndm::BreitWigner(*(const ::Rndm::BreitWigner*)arg[0]);
}

static void constructor_19363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::BreitWigner(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::Rndm::BreitWigner(*(double*)arg[0],
      *(double*)arg[1]);
}

static void destructor_19364(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::BreitWigner*)o)->::Rndm::BreitWigner::~BreitWigner)();
}
static  void method_19365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::BreitWigner*)o)->mean)());
  else   (((const ::Rndm::BreitWigner*)o)->mean)();
}

static  void method_19366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::BreitWigner*)o)->gamma)());
  else   (((const ::Rndm::BreitWigner*)o)->gamma)();
}

static  void method_19367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::BreitWigner*)o)->typeID)();
  else   (((::Rndm::BreitWigner*)o)->typeID)();
}

static  void method_19368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::BreitWigner*)o)->clone)());
  else   (((const ::Rndm::BreitWigner*)o)->clone)();
}

static void method_x180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::BreitWigner,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class BreitWigner -------------------------------
void __Rndm__BreitWigner_db_datamem(Reflex::Class*);
void __Rndm__BreitWigner_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__BreitWigner_datamem_bld(&__Rndm__BreitWigner_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__BreitWigner_funcmem_bld(&__Rndm__BreitWigner_db_funcmem);
void __Rndm__BreitWigner_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::BreitWigner"), typeid(::Rndm::BreitWigner), sizeof(::Rndm::BreitWigner), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::BreitWigner, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27638), Reflex::Literal("BreitWigner"), constructor_19362, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603, type_2603), Reflex::Literal("BreitWigner"), constructor_19363, 0, "m;g", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BreitWigner"), destructor_19364, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__BreitWigner_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__BreitWigner_funcmem_bld);
}

//------Delayed data member builder for class BreitWigner -------------------
void __Rndm__BreitWigner_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_mean"), OffsetOf(__shadow__::__Rndm__BreitWigner, m_mean), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_gamma"), OffsetOf(__shadow__::__Rndm__BreitWigner, m_gamma), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class BreitWigner -------------------
void __Rndm__BreitWigner_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("mean"), method_19365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("gamma"), method_19366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19367, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19368, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Chi2 -------------------------------
static void constructor_19370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Chi2(*(const ::Rndm::Chi2*)arg[0]);
  else ::new(mem) ::Rndm::Chi2(*(const ::Rndm::Chi2*)arg[0]);
}

static void constructor_19371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Chi2(*(long*)arg[0]);
  else ::new(mem) ::Rndm::Chi2(*(long*)arg[0]);
}

static void destructor_19372(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Chi2*)o)->::Rndm::Chi2::~Chi2)();
}
static  void method_19373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::Rndm::Chi2*)o)->nDOF)());
  else   (((const ::Rndm::Chi2*)o)->nDOF)();
}

static  void method_19374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Chi2*)o)->typeID)();
  else   (((::Rndm::Chi2*)o)->typeID)();
}

static  void method_19375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Chi2*)o)->clone)());
  else   (((const ::Rndm::Chi2*)o)->clone)();
}

static void method_x181( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Chi2,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Chi2 -------------------------------
void __Rndm__Chi2_db_datamem(Reflex::Class*);
void __Rndm__Chi2_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Chi2_datamem_bld(&__Rndm__Chi2_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Chi2_funcmem_bld(&__Rndm__Chi2_db_funcmem);
void __Rndm__Chi2_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Chi2"), typeid(::Rndm::Chi2), sizeof(::Rndm::Chi2), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Chi2, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27639), Reflex::Literal("Chi2"), constructor_19370, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26), Reflex::Literal("Chi2"), constructor_19371, 0, "n_dof", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Chi2"), destructor_19372, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Chi2_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Chi2_funcmem_bld);
}

//------Delayed data member builder for class Chi2 -------------------
void __Rndm__Chi2_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_26, Reflex::Literal("m_nDOF"), OffsetOf(__shadow__::__Rndm__Chi2, m_nDOF), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Chi2 -------------------
void __Rndm__Chi2_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("nDOF"), method_19373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19374, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19375, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class GaussianTail -------------------------------
static void constructor_19378( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::GaussianTail(*(const ::Rndm::GaussianTail*)arg[0]);
  else ::new(mem) ::Rndm::GaussianTail(*(const ::Rndm::GaussianTail*)arg[0]);
}

static void constructor_19379( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::GaussianTail(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::Rndm::GaussianTail(*(double*)arg[0],
      *(double*)arg[1]);
}

static void destructor_19380(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::GaussianTail*)o)->::Rndm::GaussianTail::~GaussianTail)();
}
static  void method_19381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::GaussianTail*)o)->cut)());
  else   (((const ::Rndm::GaussianTail*)o)->cut)();
}

static  void method_19382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::GaussianTail*)o)->sigma)());
  else   (((const ::Rndm::GaussianTail*)o)->sigma)();
}

static  void method_19383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::GaussianTail*)o)->typeID)();
  else   (((::Rndm::GaussianTail*)o)->typeID)();
}

static  void method_19384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::GaussianTail*)o)->clone)());
  else   (((const ::Rndm::GaussianTail*)o)->clone)();
}

static void method_x182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::GaussianTail,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GaussianTail -------------------------------
void __Rndm__GaussianTail_db_datamem(Reflex::Class*);
void __Rndm__GaussianTail_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__GaussianTail_datamem_bld(&__Rndm__GaussianTail_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__GaussianTail_funcmem_bld(&__Rndm__GaussianTail_db_funcmem);
void __Rndm__GaussianTail_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::GaussianTail"), typeid(::Rndm::GaussianTail), sizeof(::Rndm::GaussianTail), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::GaussianTail, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27640), Reflex::Literal("GaussianTail"), constructor_19378, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603, type_2603), Reflex::Literal("GaussianTail"), constructor_19379, 0, "a;s", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GaussianTail"), destructor_19380, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__GaussianTail_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__GaussianTail_funcmem_bld);
}

//------Delayed data member builder for class GaussianTail -------------------
void __Rndm__GaussianTail_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_cut"), OffsetOf(__shadow__::__Rndm__GaussianTail, m_cut), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_sigma"), OffsetOf(__shadow__::__Rndm__GaussianTail, m_sigma), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class GaussianTail -------------------
void __Rndm__GaussianTail_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("cut"), method_19381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("sigma"), method_19382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19383, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Flat -------------------------------
static void constructor_19387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Flat(*(const ::Rndm::Flat*)arg[0]);
  else ::new(mem) ::Rndm::Flat(*(const ::Rndm::Flat*)arg[0]);
}

static void constructor_19388( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Flat(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::Rndm::Flat(*(double*)arg[0],
      *(double*)arg[1]);
}

static void destructor_19389(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Flat*)o)->::Rndm::Flat::~Flat)();
}
static  void method_19390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Flat*)o)->minimum)());
  else   (((const ::Rndm::Flat*)o)->minimum)();
}

static  void method_19391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Flat*)o)->maximum)());
  else   (((const ::Rndm::Flat*)o)->maximum)();
}

static  void method_19392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Flat*)o)->typeID)();
  else   (((::Rndm::Flat*)o)->typeID)();
}

static  void method_19393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Flat*)o)->clone)());
  else   (((const ::Rndm::Flat*)o)->clone)();
}

static void method_x183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Flat,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Flat -------------------------------
void __Rndm__Flat_db_datamem(Reflex::Class*);
void __Rndm__Flat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Flat_datamem_bld(&__Rndm__Flat_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Flat_funcmem_bld(&__Rndm__Flat_db_funcmem);
void __Rndm__Flat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Flat"), typeid(::Rndm::Flat), sizeof(::Rndm::Flat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Flat, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27641), Reflex::Literal("Flat"), constructor_19387, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603, type_2603), Reflex::Literal("Flat"), constructor_19388, 0, "mi;ma", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Flat"), destructor_19389, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Flat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Flat_funcmem_bld);
}

//------Delayed data member builder for class Flat -------------------
void __Rndm__Flat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_minimum"), OffsetOf(__shadow__::__Rndm__Flat, m_minimum), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_maximum"), OffsetOf(__shadow__::__Rndm__Flat, m_maximum), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Flat -------------------
void __Rndm__Flat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("minimum"), method_19390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("maximum"), method_19391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19392, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19393, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Landau -------------------------------
static void constructor_19396( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Landau(*(const ::Rndm::Landau*)arg[0]);
  else ::new(mem) ::Rndm::Landau(*(const ::Rndm::Landau*)arg[0]);
}

static void constructor_19397( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Landau(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::Rndm::Landau(*(double*)arg[0],
      *(double*)arg[1]);
}

static void destructor_19398(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Landau*)o)->::Rndm::Landau::~Landau)();
}
static  void method_19399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Landau*)o)->mean)());
  else   (((const ::Rndm::Landau*)o)->mean)();
}

static  void method_19400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::Rndm::Landau*)o)->sigma)());
  else   (((const ::Rndm::Landau*)o)->sigma)();
}

static  void method_19401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Rndm::Landau*)o)->typeID)();
  else   (((::Rndm::Landau*)o)->typeID)();
}

static  void method_19402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Rndm::Landau*)o)->clone)());
  else   (((const ::Rndm::Landau*)o)->clone)();
}

static void method_x184( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("IRndmGen::Param")), ::Reflex::BaseOffset< ::Rndm::Landau,::IRndmGen::Param >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Landau -------------------------------
void __Rndm__Landau_db_datamem(Reflex::Class*);
void __Rndm__Landau_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Landau_datamem_bld(&__Rndm__Landau_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Landau_funcmem_bld(&__Rndm__Landau_db_funcmem);
void __Rndm__Landau_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Landau"), typeid(::Rndm::Landau), sizeof(::Rndm::Landau), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddBase(type_8014, ::Reflex::BaseOffset< ::Rndm::Landau, ::IRndmGen::Param >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27642), Reflex::Literal("Landau"), constructor_19396, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2603, type_2603), Reflex::Literal("Landau"), constructor_19397, 0, "m;s", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Landau"), destructor_19398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x184, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Landau_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Landau_funcmem_bld);
}

//------Delayed data member builder for class Landau -------------------
void __Rndm__Landau_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2603, Reflex::Literal("m_mean"), OffsetOf(__shadow__::__Rndm__Landau, m_mean), ::Reflex::PROTECTED)
  .AddDataMember(type_2603, Reflex::Literal("m_sigma"), OffsetOf(__shadow__::__Rndm__Landau, m_sigma), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Landau -------------------
void __Rndm__Landau_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("mean"), method_19399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("sigma"), method_19400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("typeID"), method_19401, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_19402, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Numbers -------------------------------
static void constructor_19405( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Numbers();
  else ::new(mem) ::Rndm::Numbers();
}

static void constructor_19406( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Numbers(*(const ::Rndm::Numbers*)arg[0]);
  else ::new(mem) ::Rndm::Numbers(*(const ::Rndm::Numbers*)arg[0]);
}

static void constructor_19407( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Numbers(*(const ::SmartIF<IRndmGenSvc>*)arg[0],
      *(const ::IRndmGen::Param*)arg[1]);
  else ::new(mem) ::Rndm::Numbers(*(const ::SmartIF<IRndmGenSvc>*)arg[0],
      *(const ::IRndmGen::Param*)arg[1]);
}

static void destructor_19408(void*, void * o, const std::vector<void*>&, void *) {
(((::Rndm::Numbers*)o)->::Rndm::Numbers::~Numbers)();
}
static  void method_19409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Rndm::Numbers*)o)->initialize)(*(const ::SmartIF<IRndmGenSvc>*)arg[0],
    *(const ::IRndmGen::Param*)arg[1]));
  else   (((::Rndm::Numbers*)o)->initialize)(*(const ::SmartIF<IRndmGenSvc>*)arg[0],
    *(const ::IRndmGen::Param*)arg[1]);
}

static void constructor_19410( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Rndm::Numbers((::IRndmGenSvc*)arg[0],
      *(const ::IRndmGen::Param*)arg[1]);
  else ::new(mem) ::Rndm::Numbers((::IRndmGenSvc*)arg[0],
      *(const ::IRndmGen::Param*)arg[1]);
}

static  void method_19411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Rndm::Numbers*)o)->initialize)((::IRndmGenSvc*)arg[0],
    *(const ::IRndmGen::Param*)arg[1]));
  else   (((::Rndm::Numbers*)o)->initialize)((::IRndmGenSvc*)arg[0],
    *(const ::IRndmGen::Param*)arg[1]);
}

static  void method_19412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::Rndm::Numbers*)o)->finalize)());
  else   (((::Rndm::Numbers*)o)->finalize)();
}

static  void converter_19413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Rndm::Numbers*)o)->operator bool)());
  else   (((const ::Rndm::Numbers*)o)->operator bool)();
}

static  void operator_19414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::Rndm::Numbers*)o)->operator())());
  else   (((::Rndm::Numbers*)o)->operator())();
}

static  void method_19415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::Rndm::Numbers*)o)->pop)());
  else   (((::Rndm::Numbers*)o)->pop)();
}

static  void method_19416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::Rndm::Numbers*)o)->shoot)());
  else   (((::Rndm::Numbers*)o)->shoot)();
}

static  void method_19417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)((((::Rndm::Numbers*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1]));
    else     (((::Rndm::Numbers*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)((((::Rndm::Numbers*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]));
    else     (((::Rndm::Numbers*)o)->shootArray)(*(::std::vector<double>*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
}

static void method_newdel_4229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Rndm::Numbers >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Rndm::Numbers >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Rndm::Numbers >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Rndm::Numbers >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Rndm::Numbers >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Numbers -------------------------------
void __Rndm__Numbers_db_datamem(Reflex::Class*);
void __Rndm__Numbers_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Rndm__Numbers_datamem_bld(&__Rndm__Numbers_db_datamem);
Reflex::GenreflexMemberBuilder __Rndm__Numbers_funcmem_bld(&__Rndm__Numbers_db_funcmem);
void __Rndm__Numbers_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Rndm::Numbers"), typeid(::Rndm::Numbers), sizeof(::Rndm::Numbers), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "Rndm::*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Numbers"), constructor_19405, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27645), Reflex::Literal("Numbers"), constructor_19406, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20987, type_21099), Reflex::Literal("Numbers"), constructor_19407, 0, "svc;par", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Numbers"), destructor_19408, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20986, type_21099), Reflex::Literal("Numbers"), constructor_19410, 0, "svc;par", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Rndm__Numbers_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Rndm__Numbers_funcmem_bld);
}

//------Delayed data member builder for class Numbers -------------------
void __Rndm__Numbers_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_27643, Reflex::Literal("m_generator"), OffsetOf(__shadow__::__Rndm__Numbers, m_generator), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Numbers -------------------
void __Rndm__Numbers_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20987, type_21099), Reflex::Literal("initialize"), method_19409, 0, "svc;par", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_20986, type_21099), Reflex::Literal("initialize"), method_19411, 0, "svc;par", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("finalize"), method_19412, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("operator bool"), converter_19413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("operator()"), operator_19414, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("pop"), method_19415, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("shoot"), method_19416, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_12638, type_26, type_26), Reflex::Literal("shootArray"), method_19417, 0, "array;num;start=0", ::Reflex::PUBLIC);
}
//------Stub functions for class Time -------------------------------
static void destructor_19723(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::Time*)o)->::Gaudi::Time::~Time)();
}
static  void operator_19724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Time*)o)->operator=)(*(const ::Gaudi::Time*)arg[0]);
  else   (((::Gaudi::Time*)o)->operator=)(*(const ::Gaudi::Time*)arg[0]);
}

static void constructor_19725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Time(*(const ::Gaudi::Time*)arg[0]);
  else ::new(mem) ::Gaudi::Time(*(const ::Gaudi::Time*)arg[0]);
}

static void constructor_19726( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Time();
  else ::new(mem) ::Gaudi::Time();
}

static void constructor_19727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Time(*(::Gaudi::TimeSpan*)arg[0]);
  else ::new(mem) ::Gaudi::Time(*(::Gaudi::TimeSpan*)arg[0]);
}

static void constructor_19728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Time(*(::longlong*)arg[0]);
  else ::new(mem) ::Gaudi::Time(*(::longlong*)arg[0]);
}

static void constructor_19729( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Time(*(::longlong*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::Gaudi::Time(*(::longlong*)arg[0],
      *(int*)arg[1]);
}

static void constructor_19730( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(::longlong*)arg[6]);
  else ::new(mem) ::Gaudi::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(::longlong*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(::longlong*)arg[6],
      *(bool*)arg[7]);
  else ::new(mem) ::Gaudi::Time(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(::longlong*)arg[6],
      *(bool*)arg[7]);
  }
}

static  void method_19731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Gaudi::Time)((((::Gaudi::Time*)o)->epoch)());
  else   (((::Gaudi::Time*)o)->epoch)();
}

static  void method_19732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Gaudi::Time)((((::Gaudi::Time*)o)->max)());
  else   (((::Gaudi::Time*)o)->max)();
}

static  void method_19733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Gaudi::Time)((((::Gaudi::Time*)o)->current)());
  else   (((::Gaudi::Time*)o)->current)();
}

static  void method_19734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Gaudi::Time)((((::Gaudi::Time*)o)->build)(*(bool*)arg[0],
      *(const ::tm*)arg[1]));
    else     (((::Gaudi::Time*)o)->build)(*(bool*)arg[0],
      *(const ::tm*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Gaudi::Time)((((::Gaudi::Time*)o)->build)(*(bool*)arg[0],
      *(const ::tm*)arg[1],
      *(::Gaudi::TimeSpan*)arg[2]));
    else     (((::Gaudi::Time*)o)->build)(*(bool*)arg[0],
      *(const ::tm*)arg[1],
      *(::Gaudi::TimeSpan*)arg[2]);
  }
}

static  void method_19735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (tm)((((const ::Gaudi::Time*)o)->split)(*(bool*)arg[0]));
    else     (((const ::Gaudi::Time*)o)->split)(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (tm)((((const ::Gaudi::Time*)o)->split)(*(bool*)arg[0],
      (int*)arg[1]));
    else     (((const ::Gaudi::Time*)o)->split)(*(bool*)arg[0],
      (int*)arg[1]);
  }
}

static  void method_19736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (tm)((((const ::Gaudi::Time*)o)->utc)());
    else     (((const ::Gaudi::Time*)o)->utc)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (tm)((((const ::Gaudi::Time*)o)->utc)((int*)arg[0]));
    else     (((const ::Gaudi::Time*)o)->utc)((int*)arg[0]);
  }
}

static  void method_19737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (tm)((((const ::Gaudi::Time*)o)->local)());
    else     (((const ::Gaudi::Time*)o)->local)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (tm)((((const ::Gaudi::Time*)o)->local)((int*)arg[0]));
    else     (((const ::Gaudi::Time*)o)->local)((int*)arg[0]);
  }
}

static  void method_19738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->year)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->year)(*(bool*)arg[0]);
}

static  void method_19739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->month)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->month)(*(bool*)arg[0]);
}

static  void method_19740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->day)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->day)(*(bool*)arg[0]);
}

static  void method_19741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->hour)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->hour)(*(bool*)arg[0]);
}

static  void method_19742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->minute)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->minute)(*(bool*)arg[0]);
}

static  void method_19743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->second)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->second)(*(bool*)arg[0]);
}

static  void method_19744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->nsecond)());
  else   (((const ::Gaudi::Time*)o)->nsecond)();
}

static  void method_19745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Time*)o)->weekday)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->weekday)(*(bool*)arg[0]);
}

static  void method_19746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Gaudi::Time*)o)->isdst)(*(bool*)arg[0]));
  else   (((const ::Gaudi::Time*)o)->isdst)(*(bool*)arg[0]);
}

static  void method_19747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)((((const ::Gaudi::Time*)o)->utcoffset)());
    else     (((const ::Gaudi::Time*)o)->utcoffset)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)((((const ::Gaudi::Time*)o)->utcoffset)((int*)arg[0]));
    else     (((const ::Gaudi::Time*)o)->utcoffset)((int*)arg[0]);
  }
}

static  void method_19748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Gaudi::Time*)o)->timezone)());
    else     (((const ::Gaudi::Time*)o)->timezone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Gaudi::Time*)o)->timezone)((int*)arg[0]));
    else     (((const ::Gaudi::Time*)o)->timezone)((int*)arg[0]);
  }
}

static  void operator_19749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Time*)o)->operator+=)(*(const ::Gaudi::TimeSpan*)arg[0]);
  else   (((::Gaudi::Time*)o)->operator+=)(*(const ::Gaudi::TimeSpan*)arg[0]);
}

static  void operator_19750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Time*)o)->operator-=)(*(const ::Gaudi::TimeSpan*)arg[0]);
  else   (((::Gaudi::Time*)o)->operator-=)(*(const ::Gaudi::TimeSpan*)arg[0]);
}

static  void method_19751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (longlong)((((const ::Gaudi::Time*)o)->ns)());
  else   (((const ::Gaudi::Time*)o)->ns)();
}

static  void method_19752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::string)((((const ::Gaudi::Time*)o)->format)(*(bool*)arg[0]));
    else     (((const ::Gaudi::Time*)o)->format)(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::string)((((const ::Gaudi::Time*)o)->format)(*(bool*)arg[0],
      *(::std::string*)arg[1]));
    else     (((const ::Gaudi::Time*)o)->format)(*(bool*)arg[0],
      *(::std::string*)arg[1]);
  }
}

static  void method_19753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::string)((((const ::Gaudi::Time*)o)->nanoformat)());
    else     (((const ::Gaudi::Time*)o)->nanoformat)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::string)((((const ::Gaudi::Time*)o)->nanoformat)(*(::size_t*)arg[0]));
    else     (((const ::Gaudi::Time*)o)->nanoformat)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::string)((((const ::Gaudi::Time*)o)->nanoformat)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::Gaudi::Time*)o)->nanoformat)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
}

static  void method_19754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::Gaudi::Time*)o)->isLeap)(*(int*)arg[0]));
  else   (((::Gaudi::Time*)o)->isLeap)(*(int*)arg[0]);
}

static  void method_19755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::Gaudi::Time*)o)->toDosDate)(*(::Gaudi::Time*)arg[0]));
  else   (((::Gaudi::Time*)o)->toDosDate)(*(::Gaudi::Time*)arg[0]);
}

static  void method_19756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Gaudi::Time)((((::Gaudi::Time*)o)->fromDosDate)(*(unsigned int*)arg[0]));
  else   (((::Gaudi::Time*)o)->fromDosDate)(*(unsigned int*)arg[0]);
}

static void method_newdel_4682( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::Time >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::Time >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::Time >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::Time >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::Time >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Time -------------------------------
void __Gaudi__Time_db_datamem(Reflex::Class*);
void __Gaudi__Time_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__Time_datamem_bld(&__Gaudi__Time_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__Time_funcmem_bld(&__Gaudi__Time_db_funcmem);
void __Gaudi__Time_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::Time"), typeid(::Gaudi::Time), sizeof(::Gaudi::Time), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1498, Reflex::Literal("Gaudi::Time::ValueType"))
  .AddEnum(Reflex::Literal("Gaudi::Time::Months"), Reflex::Literal("January=0;February=1;March=2;April=3;May=4;June=5;July=6;August=7;September=8;October=9;November=10;December=11"), &typeid(Gaudi::Time::Months), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Time"), destructor_19723, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5663, type_4403), Reflex::Literal("operator="), operator_19724, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4403), Reflex::Literal("Time"), constructor_19725, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Time"), constructor_19726, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4668), Reflex::Literal("Time"), constructor_19727, 0, "ts", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1498), Reflex::Literal("Time"), constructor_19728, 0, "nsecs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1498, type_142), Reflex::Literal("Time"), constructor_19729, 0, "secs;nsecs", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_142, type_142, type_142, type_142, type_142, type_142, type_1498, type_4206), Reflex::Literal("Time"), constructor_19730, 0, "year;month;day;hour;min;sec;nsecs;local=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4682, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__Time_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__Time_funcmem_bld);
}

//------Delayed data member builder for class Time -------------------
void __Gaudi__Time_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1498, Reflex::Literal("m_nsecs"), OffsetOf(__shadow__::__Gaudi__Time, m_nsecs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Time -------------------
void __Gaudi__Time_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4682), Reflex::Literal("epoch"), method_19731, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4682), Reflex::Literal("max"), method_19732, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4682), Reflex::Literal("current"), method_19733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4682, type_4206, type_19264, type_4668), Reflex::Literal("build"), method_19734, 0, "local;base;diff=0", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_4206, type_4096), Reflex::Literal("split"), method_19735, 0, "local;nsecpart=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_4096), Reflex::Literal("utc"), method_19736, 0, "nsecpart=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_4096), Reflex::Literal("local"), method_19737, 0, "nsecpart=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4206), Reflex::Literal("year"), method_19738, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4206), Reflex::Literal("month"), method_19739, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4206), Reflex::Literal("day"), method_19740, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4206), Reflex::Literal("hour"), method_19741, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4206), Reflex::Literal("minute"), method_19742, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4206), Reflex::Literal("second"), method_19743, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142), Reflex::Literal("nsecond"), method_19744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142, type_4206), Reflex::Literal("weekday"), method_19745, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_4206), Reflex::Literal("isdst"), method_19746, 0, "local", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1498, type_4096), Reflex::Literal("utcoffset"), method_19747, 0, "daylight=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4095, type_4096), Reflex::Literal("timezone"), method_19748, 0, "daylight=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5663, type_4402), Reflex::Literal("operator+="), operator_19749, 0, "x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5663, type_4402), Reflex::Literal("operator-="), operator_19750, 0, "x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1498), Reflex::Literal("ns"), method_19751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236, type_4206, type_3236), Reflex::Literal("format"), method_19752, 0, "local;spec=\"%c\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3236, type_2023, type_2023), Reflex::Literal("nanoformat"), method_19753, 0, "minwidth=1;maxwidth=9", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_142), Reflex::Literal("isLeap"), method_19754, 0, "year", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_203, type_4682), Reflex::Literal("toDosDate"), method_19755, 0, "time", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4682, type_203), Reflex::Literal("fromDosDate"), method_19756, 0, "dosDate", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class ObjectLoader -------------------------------
static void destructor_19782(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartDataObjectPtr::ObjectLoader*)o)->::SmartDataObjectPtr::ObjectLoader::~ObjectLoader)();
}
static  void operator_19783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataObjectPtr::ObjectLoader*)o)->operator=)(*(const ::SmartDataObjectPtr::ObjectLoader*)arg[0]);
  else   (((::SmartDataObjectPtr::ObjectLoader*)o)->operator=)(*(const ::SmartDataObjectPtr::ObjectLoader*)arg[0]);
}

static void constructor_19784( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataObjectPtr::ObjectLoader(*(const ::SmartDataObjectPtr::ObjectLoader*)arg[0]);
  else ::new(mem) ::SmartDataObjectPtr::ObjectLoader(*(const ::SmartDataObjectPtr::ObjectLoader*)arg[0]);
}

static void constructor_19785( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataObjectPtr::ObjectLoader();
  else ::new(mem) ::SmartDataObjectPtr::ObjectLoader();
}

static  void method_19786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr::ObjectLoader*)o)->access)());
  else   (((::SmartDataObjectPtr::ObjectLoader*)o)->access)();
}

static void method_newdel_4740( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectLoader >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectLoader >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectLoader >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectLoader >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectLoader >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ObjectLoader -------------------------------
void __SmartDataObjectPtr__ObjectLoader_db_datamem(Reflex::Class*);
void __SmartDataObjectPtr__ObjectLoader_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartDataObjectPtr__ObjectLoader_datamem_bld(&__SmartDataObjectPtr__ObjectLoader_db_datamem);
Reflex::GenreflexMemberBuilder __SmartDataObjectPtr__ObjectLoader_funcmem_bld(&__SmartDataObjectPtr__ObjectLoader_db_funcmem);
void __SmartDataObjectPtr__ObjectLoader_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartDataObjectPtr::ObjectLoader"), typeid(::SmartDataObjectPtr::ObjectLoader), sizeof(::SmartDataObjectPtr::ObjectLoader), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartData*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ObjectLoader"), destructor_19782, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27738, type_27739), Reflex::Literal("operator="), operator_19783, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27739), Reflex::Literal("ObjectLoader"), constructor_19784, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ObjectLoader"), constructor_19785, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4740, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__SmartDataObjectPtr__ObjectLoader_funcmem_bld);
}

//------Delayed data member builder for class ObjectLoader -------------------
void __SmartDataObjectPtr__ObjectLoader_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ObjectLoader -------------------
void __SmartDataObjectPtr__ObjectLoader_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4738), Reflex::Literal("access"), method_19786, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class ObjectFinder -------------------------------
static void destructor_19787(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartDataObjectPtr::ObjectFinder*)o)->::SmartDataObjectPtr::ObjectFinder::~ObjectFinder)();
}
static  void operator_19788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartDataObjectPtr::ObjectFinder*)o)->operator=)(*(const ::SmartDataObjectPtr::ObjectFinder*)arg[0]);
  else   (((::SmartDataObjectPtr::ObjectFinder*)o)->operator=)(*(const ::SmartDataObjectPtr::ObjectFinder*)arg[0]);
}

static void constructor_19789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataObjectPtr::ObjectFinder(*(const ::SmartDataObjectPtr::ObjectFinder*)arg[0]);
  else ::new(mem) ::SmartDataObjectPtr::ObjectFinder(*(const ::SmartDataObjectPtr::ObjectFinder*)arg[0]);
}

static void constructor_19790( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartDataObjectPtr::ObjectFinder();
  else ::new(mem) ::SmartDataObjectPtr::ObjectFinder();
}

static  void method_19791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartDataObjectPtr::ObjectFinder*)o)->access)());
  else   (((::SmartDataObjectPtr::ObjectFinder*)o)->access)();
}

static void method_newdel_4741( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectFinder >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectFinder >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectFinder >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectFinder >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartDataObjectPtr::ObjectFinder >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ObjectFinder -------------------------------
void __SmartDataObjectPtr__ObjectFinder_db_datamem(Reflex::Class*);
void __SmartDataObjectPtr__ObjectFinder_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartDataObjectPtr__ObjectFinder_datamem_bld(&__SmartDataObjectPtr__ObjectFinder_db_datamem);
Reflex::GenreflexMemberBuilder __SmartDataObjectPtr__ObjectFinder_funcmem_bld(&__SmartDataObjectPtr__ObjectFinder_db_funcmem);
void __SmartDataObjectPtr__ObjectFinder_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartDataObjectPtr::ObjectFinder"), typeid(::SmartDataObjectPtr::ObjectFinder), sizeof(::SmartDataObjectPtr::ObjectFinder), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "SmartData*")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ObjectFinder"), destructor_19787, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27740, type_27741), Reflex::Literal("operator="), operator_19788, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27741), Reflex::Literal("ObjectFinder"), constructor_19789, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ObjectFinder"), constructor_19790, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4741, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__SmartDataObjectPtr__ObjectFinder_funcmem_bld);
}

//------Delayed data member builder for class ObjectFinder -------------------
void __SmartDataObjectPtr__ObjectFinder_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ObjectFinder -------------------
void __SmartDataObjectPtr__ObjectFinder_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4738), Reflex::Literal("access"), method_19791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PythonHelper -------------------------------
static void destructor_20015(void*, void * o, const std::vector<void*>&, void *) {
(((::IUpdateManagerSvc::PythonHelper*)o)->::IUpdateManagerSvc::PythonHelper::~PythonHelper)();
}
static  void operator_20016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IUpdateManagerSvc::PythonHelper*)o)->operator=)(*(const ::IUpdateManagerSvc::PythonHelper*)arg[0]);
  else   (((::IUpdateManagerSvc::PythonHelper*)o)->operator=)(*(const ::IUpdateManagerSvc::PythonHelper*)arg[0]);
}

static void constructor_20017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IUpdateManagerSvc::PythonHelper(*(const ::IUpdateManagerSvc::PythonHelper*)arg[0]);
  else ::new(mem) ::IUpdateManagerSvc::PythonHelper(*(const ::IUpdateManagerSvc::PythonHelper*)arg[0]);
}

static void constructor_20018( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IUpdateManagerSvc::PythonHelper();
  else ::new(mem) ::IUpdateManagerSvc::PythonHelper();
}

static  void method_20019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::IUpdateManagerSvc::PythonHelper*)o)->update)((::IUpdateManagerSvc*)arg[0],
    (void*)arg[1]));
  else   (((::IUpdateManagerSvc::PythonHelper*)o)->update)((::IUpdateManagerSvc*)arg[0],
    (void*)arg[1]);
}

static  void method_20020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IUpdateManagerSvc::PythonHelper*)o)->invalidate)((::IUpdateManagerSvc*)arg[0],
    (void*)arg[1]);
}

static void method_newdel_5405( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IUpdateManagerSvc::PythonHelper >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IUpdateManagerSvc::PythonHelper >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IUpdateManagerSvc::PythonHelper >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IUpdateManagerSvc::PythonHelper >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IUpdateManagerSvc::PythonHelper >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PythonHelper -------------------------------
void __IUpdateManagerSvc__PythonHelper_db_datamem(Reflex::Class*);
void __IUpdateManagerSvc__PythonHelper_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IUpdateManagerSvc__PythonHelper_datamem_bld(&__IUpdateManagerSvc__PythonHelper_db_datamem);
Reflex::GenreflexMemberBuilder __IUpdateManagerSvc__PythonHelper_funcmem_bld(&__IUpdateManagerSvc__PythonHelper_db_funcmem);
void __IUpdateManagerSvc__PythonHelper_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IUpdateManagerSvc::PythonHelper"), typeid(::IUpdateManagerSvc::PythonHelper), sizeof(::IUpdateManagerSvc::PythonHelper), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PythonHelper"), destructor_20015, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27801, type_27802), Reflex::Literal("operator="), operator_20016, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27802), Reflex::Literal("PythonHelper"), constructor_20017, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PythonHelper"), constructor_20018, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5405, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__IUpdateManagerSvc__PythonHelper_funcmem_bld);
}

//------Delayed data member builder for class PythonHelper -------------------
void __IUpdateManagerSvc__PythonHelper_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PythonHelper -------------------
void __IUpdateManagerSvc__PythonHelper_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872, type_27803, type_1454), Reflex::Literal("update"), method_20019, 0, "ums;obj", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_27803, type_1454), Reflex::Literal("invalidate"), method_20020, 0, "ums;obj", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Array<double> -------------------------------
static void constructor_20151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<double>(*(const ::NTuple::Array<double>*)arg[0]);
  else ::new(mem) ::NTuple::Array<double>(*(const ::NTuple::Array<double>*)arg[0]);
}

static void constructor_20152( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<double>();
  else ::new(mem) ::NTuple::Array<double>();
}

static void destructor_20153(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<double>*)o)->::NTuple::Array<double>::~Array)();
}
static void method_newdel_5905( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<double> >")), ::Reflex::BaseOffset< ::NTuple::Array<double>,::NTuple::_Accessor<NTuple::_Array<double> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<double> -------------------------------
void __NTuple__Array_double__db_datamem(Reflex::Class*);
void __NTuple__Array_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_double__datamem_bld(&__NTuple__Array_double__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_double__funcmem_bld(&__NTuple__Array_double__db_funcmem);
void __NTuple__Array_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<double>"), typeid(::NTuple::Array<double>), sizeof(::NTuple::Array<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6039, ::Reflex::BaseOffset< ::NTuple::Array<double>, ::NTuple::_Accessor<NTuple::_Array<double> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27840), Reflex::Literal("Array"), constructor_20151, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20152, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20153, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5905, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<double> -------------------
void __NTuple__Array_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<double> -------------------
void __NTuple__Array_double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<short unsigned int> -------------------------------
static void constructor_20154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned short>(*(const ::NTuple::Matrix<unsigned short>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<unsigned short>(*(const ::NTuple::Matrix<unsigned short>*)arg[0]);
}

static void constructor_20155( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned short>();
  else ::new(mem) ::NTuple::Matrix<unsigned short>();
}

static void destructor_20156(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<unsigned short>*)o)->::NTuple::Matrix<unsigned short>::~Matrix)();
}
static void method_newdel_5907( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x193( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned short> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned short>,::NTuple::_Accessor<NTuple::_Matrix<unsigned short> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<short unsigned int> -------------------------------
void __NTuple__Matrix_unsignedsshort__db_datamem(Reflex::Class*);
void __NTuple__Matrix_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedsshort__datamem_bld(&__NTuple__Matrix_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedsshort__funcmem_bld(&__NTuple__Matrix_unsignedsshort__db_funcmem);
void __NTuple__Matrix_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<unsigned short>"), typeid(::NTuple::Matrix<unsigned short>), sizeof(::NTuple::Matrix<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6034, ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned short>, ::NTuple::_Accessor<NTuple::_Matrix<unsigned short> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27841), Reflex::Literal("Matrix"), constructor_20154, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20155, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20156, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5907, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x193, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<short unsigned int> -------------------
void __NTuple__Matrix_unsignedsshort__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<short unsigned int> -------------------
void __NTuple__Matrix_unsignedsshort__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<unsigned char> -------------------------------
static void constructor_20157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned char>(*(const ::NTuple::Array<unsigned char>*)arg[0]);
  else ::new(mem) ::NTuple::Array<unsigned char>(*(const ::NTuple::Array<unsigned char>*)arg[0]);
}

static void constructor_20158( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned char>();
  else ::new(mem) ::NTuple::Array<unsigned char>();
}

static void destructor_20159(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<unsigned char>*)o)->::NTuple::Array<unsigned char>::~Array)();
}
static void method_newdel_5909( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x195( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned char> >")), ::Reflex::BaseOffset< ::NTuple::Array<unsigned char>,::NTuple::_Accessor<NTuple::_Array<unsigned char> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<unsigned char> -------------------------------
void __NTuple__Array_unsignedschar__db_datamem(Reflex::Class*);
void __NTuple__Array_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedschar__datamem_bld(&__NTuple__Array_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedschar__funcmem_bld(&__NTuple__Array_unsignedschar__db_funcmem);
void __NTuple__Array_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<unsigned char>"), typeid(::NTuple::Array<unsigned char>), sizeof(::NTuple::Array<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6047, ::Reflex::BaseOffset< ::NTuple::Array<unsigned char>, ::NTuple::_Accessor<NTuple::_Array<unsigned char> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27842), Reflex::Literal("Array"), constructor_20157, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20158, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20159, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5909, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x195, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<unsigned char> -------------------
void __NTuple__Array_unsignedschar__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<unsigned char> -------------------
void __NTuple__Array_unsignedschar__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<char> -------------------------------
static void constructor_20160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<char>(*(const ::NTuple::Matrix<char>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<char>(*(const ::NTuple::Matrix<char>*)arg[0]);
}

static void constructor_20161( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<char>();
  else ::new(mem) ::NTuple::Matrix<char>();
}

static void destructor_20162(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<char>*)o)->::NTuple::Matrix<char>::~Matrix)();
}
static void method_newdel_5911( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<char> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<char>,::NTuple::_Accessor<NTuple::_Matrix<char> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<char> -------------------------------
void __NTuple__Matrix_char__db_datamem(Reflex::Class*);
void __NTuple__Matrix_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_char__datamem_bld(&__NTuple__Matrix_char__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_char__funcmem_bld(&__NTuple__Matrix_char__db_funcmem);
void __NTuple__Matrix_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<char>"), typeid(::NTuple::Matrix<char>), sizeof(::NTuple::Matrix<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6037, ::Reflex::BaseOffset< ::NTuple::Matrix<char>, ::NTuple::_Accessor<NTuple::_Matrix<char> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27843), Reflex::Literal("Matrix"), constructor_20160, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20161, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20162, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5911, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<char> -------------------
void __NTuple__Matrix_char__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<char> -------------------
void __NTuple__Matrix_char__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<unsigned int> -------------------------------
static void constructor_20163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned int>(*(const ::NTuple::Matrix<unsigned int>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<unsigned int>(*(const ::NTuple::Matrix<unsigned int>*)arg[0]);
}

static void constructor_20164( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned int>();
  else ::new(mem) ::NTuple::Matrix<unsigned int>();
}

static void destructor_20165(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<unsigned int>*)o)->::NTuple::Matrix<unsigned int>::~Matrix)();
}
static void method_newdel_5913( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x199( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned int> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned int>,::NTuple::_Accessor<NTuple::_Matrix<unsigned int> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<unsigned int> -------------------------------
void __NTuple__Matrix_unsignedsint__db_datamem(Reflex::Class*);
void __NTuple__Matrix_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedsint__datamem_bld(&__NTuple__Matrix_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedsint__funcmem_bld(&__NTuple__Matrix_unsignedsint__db_funcmem);
void __NTuple__Matrix_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<unsigned int>"), typeid(::NTuple::Matrix<unsigned int>), sizeof(::NTuple::Matrix<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6030, ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned int>, ::NTuple::_Accessor<NTuple::_Matrix<unsigned int> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27844), Reflex::Literal("Matrix"), constructor_20163, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20164, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20165, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5913, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x199, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<unsigned int> -------------------
void __NTuple__Matrix_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<unsigned int> -------------------
void __NTuple__Matrix_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<float> -------------------------------
static void constructor_20166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<float>(*(const ::NTuple::Array<float>*)arg[0]);
  else ::new(mem) ::NTuple::Array<float>(*(const ::NTuple::Array<float>*)arg[0]);
}

static void constructor_20167( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<float>();
  else ::new(mem) ::NTuple::Array<float>();
}

static void destructor_20168(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<float>*)o)->::NTuple::Array<float>::~Array)();
}
static void method_newdel_5915( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<float> >")), ::Reflex::BaseOffset< ::NTuple::Array<float>,::NTuple::_Accessor<NTuple::_Array<float> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<float> -------------------------------
void __NTuple__Array_float__db_datamem(Reflex::Class*);
void __NTuple__Array_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_float__datamem_bld(&__NTuple__Array_float__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_float__funcmem_bld(&__NTuple__Array_float__db_funcmem);
void __NTuple__Array_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<float>"), typeid(::NTuple::Array<float>), sizeof(::NTuple::Array<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6040, ::Reflex::BaseOffset< ::NTuple::Array<float>, ::NTuple::_Accessor<NTuple::_Array<float> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27845), Reflex::Literal("Array"), constructor_20166, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20167, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20168, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5915, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<float> -------------------
void __NTuple__Array_float__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<float> -------------------
void __NTuple__Array_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<bool> -------------------------------
static void constructor_20169( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<bool>(*(const ::NTuple::Array<bool>*)arg[0]);
  else ::new(mem) ::NTuple::Array<bool>(*(const ::NTuple::Array<bool>*)arg[0]);
}

static void constructor_20170( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<bool>();
  else ::new(mem) ::NTuple::Array<bool>();
}

static void destructor_20171(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<bool>*)o)->::NTuple::Array<bool>::~Array)();
}
static void method_newdel_5917( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<bool> >")), ::Reflex::BaseOffset< ::NTuple::Array<bool>,::NTuple::_Accessor<NTuple::_Array<bool> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<bool> -------------------------------
void __NTuple__Array_bool__db_datamem(Reflex::Class*);
void __NTuple__Array_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_bool__datamem_bld(&__NTuple__Array_bool__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_bool__funcmem_bld(&__NTuple__Array_bool__db_funcmem);
void __NTuple__Array_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<bool>"), typeid(::NTuple::Array<bool>), sizeof(::NTuple::Array<bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6049, ::Reflex::BaseOffset< ::NTuple::Array<bool>, ::NTuple::_Accessor<NTuple::_Array<bool> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27846), Reflex::Literal("Array"), constructor_20169, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20170, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20171, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5917, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<bool> -------------------
void __NTuple__Array_bool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<bool> -------------------
void __NTuple__Array_bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<int> -------------------------------
static void constructor_20172( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<int>(*(const ::NTuple::Array<int>*)arg[0]);
  else ::new(mem) ::NTuple::Array<int>(*(const ::NTuple::Array<int>*)arg[0]);
}

static void constructor_20173( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<int>();
  else ::new(mem) ::NTuple::Array<int>();
}

static void destructor_20174(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<int>*)o)->::NTuple::Array<int>::~Array)();
}
static void method_newdel_5919( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x205( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<int> >")), ::Reflex::BaseOffset< ::NTuple::Array<int>,::NTuple::_Accessor<NTuple::_Array<int> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<int> -------------------------------
void __NTuple__Array_int__db_datamem(Reflex::Class*);
void __NTuple__Array_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_int__datamem_bld(&__NTuple__Array_int__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_int__funcmem_bld(&__NTuple__Array_int__db_funcmem);
void __NTuple__Array_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<int>"), typeid(::NTuple::Array<int>), sizeof(::NTuple::Array<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6042, ::Reflex::BaseOffset< ::NTuple::Array<int>, ::NTuple::_Accessor<NTuple::_Array<int> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27847), Reflex::Literal("Array"), constructor_20172, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20173, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20174, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5919, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x205, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<int> -------------------
void __NTuple__Array_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<int> -------------------
void __NTuple__Array_int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<int> -------------------------------
static void constructor_20175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<int>(*(const ::NTuple::Matrix<int>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<int>(*(const ::NTuple::Matrix<int>*)arg[0]);
}

static void constructor_20176( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<int>();
  else ::new(mem) ::NTuple::Matrix<int>();
}

static void destructor_20177(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<int>*)o)->::NTuple::Matrix<int>::~Matrix)();
}
static void method_newdel_5921( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x207( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<int> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<int>,::NTuple::_Accessor<NTuple::_Matrix<int> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<int> -------------------------------
void __NTuple__Matrix_int__db_datamem(Reflex::Class*);
void __NTuple__Matrix_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_int__datamem_bld(&__NTuple__Matrix_int__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_int__funcmem_bld(&__NTuple__Matrix_int__db_funcmem);
void __NTuple__Matrix_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<int>"), typeid(::NTuple::Matrix<int>), sizeof(::NTuple::Matrix<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6031, ::Reflex::BaseOffset< ::NTuple::Matrix<int>, ::NTuple::_Accessor<NTuple::_Matrix<int> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27848), Reflex::Literal("Matrix"), constructor_20175, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20176, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20177, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5921, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x207, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<int> -------------------
void __NTuple__Matrix_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<int> -------------------
void __NTuple__Matrix_int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<double> -------------------------------
static void constructor_20178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<double>(*(const ::NTuple::Matrix<double>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<double>(*(const ::NTuple::Matrix<double>*)arg[0]);
}

static void constructor_20179( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<double>();
  else ::new(mem) ::NTuple::Matrix<double>();
}

static void destructor_20180(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<double>*)o)->::NTuple::Matrix<double>::~Matrix)();
}
static void method_newdel_5923( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<double> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<double>,::NTuple::_Accessor<NTuple::_Matrix<double> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<double> -------------------------------
void __NTuple__Matrix_double__db_datamem(Reflex::Class*);
void __NTuple__Matrix_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_double__datamem_bld(&__NTuple__Matrix_double__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_double__funcmem_bld(&__NTuple__Matrix_double__db_funcmem);
void __NTuple__Matrix_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<double>"), typeid(::NTuple::Matrix<double>), sizeof(::NTuple::Matrix<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6028, ::Reflex::BaseOffset< ::NTuple::Matrix<double>, ::NTuple::_Accessor<NTuple::_Matrix<double> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27849), Reflex::Literal("Matrix"), constructor_20178, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20179, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20180, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5923, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<double> -------------------
void __NTuple__Matrix_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<double> -------------------
void __NTuple__Matrix_double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<long unsigned int> -------------------------------
static void constructor_20181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned long>(*(const ::NTuple::Array<unsigned long>*)arg[0]);
  else ::new(mem) ::NTuple::Array<unsigned long>(*(const ::NTuple::Array<unsigned long>*)arg[0]);
}

static void constructor_20182( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned long>();
  else ::new(mem) ::NTuple::Array<unsigned long>();
}

static void destructor_20183(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<unsigned long>*)o)->::NTuple::Array<unsigned long>::~Array)();
}
static void method_newdel_5947( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x211( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned long> >")), ::Reflex::BaseOffset< ::NTuple::Array<unsigned long>,::NTuple::_Accessor<NTuple::_Array<unsigned long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<long unsigned int> -------------------------------
void __NTuple__Array_unsignedslong__db_datamem(Reflex::Class*);
void __NTuple__Array_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedslong__datamem_bld(&__NTuple__Array_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedslong__funcmem_bld(&__NTuple__Array_unsignedslong__db_funcmem);
void __NTuple__Array_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<unsigned long>"), typeid(::NTuple::Array<unsigned long>), sizeof(::NTuple::Array<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6043, ::Reflex::BaseOffset< ::NTuple::Array<unsigned long>, ::NTuple::_Accessor<NTuple::_Array<unsigned long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27850), Reflex::Literal("Array"), constructor_20181, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20182, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20183, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5947, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x211, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<long unsigned int> -------------------
void __NTuple__Array_unsignedslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<long unsigned int> -------------------
void __NTuple__Array_unsignedslong__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<unsigned char> -------------------------------
static void constructor_20184( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned char>(*(const ::NTuple::Matrix<unsigned char>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<unsigned char>(*(const ::NTuple::Matrix<unsigned char>*)arg[0]);
}

static void constructor_20185( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned char>();
  else ::new(mem) ::NTuple::Matrix<unsigned char>();
}

static void destructor_20186(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<unsigned char>*)o)->::NTuple::Matrix<unsigned char>::~Matrix)();
}
static void method_newdel_5949( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x213( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned char> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned char>,::NTuple::_Accessor<NTuple::_Matrix<unsigned char> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<unsigned char> -------------------------------
void __NTuple__Matrix_unsignedschar__db_datamem(Reflex::Class*);
void __NTuple__Matrix_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedschar__datamem_bld(&__NTuple__Matrix_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedschar__funcmem_bld(&__NTuple__Matrix_unsignedschar__db_funcmem);
void __NTuple__Matrix_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<unsigned char>"), typeid(::NTuple::Matrix<unsigned char>), sizeof(::NTuple::Matrix<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6036, ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned char>, ::NTuple::_Accessor<NTuple::_Matrix<unsigned char> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27851), Reflex::Literal("Matrix"), constructor_20184, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20185, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20186, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5949, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x213, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<unsigned char> -------------------
void __NTuple__Matrix_unsignedschar__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<unsigned char> -------------------
void __NTuple__Matrix_unsignedschar__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<short int> -------------------------------
static void constructor_20187( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<short>(*(const ::NTuple::Matrix<short>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<short>(*(const ::NTuple::Matrix<short>*)arg[0]);
}

static void constructor_20188( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<short>();
  else ::new(mem) ::NTuple::Matrix<short>();
}

static void destructor_20189(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<short>*)o)->::NTuple::Matrix<short>::~Matrix)();
}
static void method_newdel_5951( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x215( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<short> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<short>,::NTuple::_Accessor<NTuple::_Matrix<short> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<short int> -------------------------------
void __NTuple__Matrix_short__db_datamem(Reflex::Class*);
void __NTuple__Matrix_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_short__datamem_bld(&__NTuple__Matrix_short__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_short__funcmem_bld(&__NTuple__Matrix_short__db_funcmem);
void __NTuple__Matrix_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<short>"), typeid(::NTuple::Matrix<short>), sizeof(::NTuple::Matrix<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6035, ::Reflex::BaseOffset< ::NTuple::Matrix<short>, ::NTuple::_Accessor<NTuple::_Matrix<short> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27852), Reflex::Literal("Matrix"), constructor_20187, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20188, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20189, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5951, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<short int> -------------------
void __NTuple__Matrix_short__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<short int> -------------------
void __NTuple__Matrix_short__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class File -------------------------------
static  void operator_20194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::File*)o)->operator=)(*(const ::NTuple::File*)arg[0]);
  else   (((::NTuple::File*)o)->operator=)(*(const ::NTuple::File*)arg[0]);
}

static void constructor_20195( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::File(*(const ::NTuple::File*)arg[0]);
  else ::new(mem) ::NTuple::File(*(const ::NTuple::File*)arg[0]);
}

static void constructor_20196( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::File();
  else ::new(mem) ::NTuple::File();
}

static void constructor_20197( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::File(*(long*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::NTuple::File(*(long*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
}

static void destructor_20198(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::File*)o)->::NTuple::File::~File)();
}
static  void method_20199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::File*)o)->classID)();
  else   (((::NTuple::File*)o)->classID)();
}

static  void method_20200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::NTuple::File*)o)->clID)();
  else   (((const ::NTuple::File*)o)->clID)();
}

static  void method_20201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NTuple::File*)o)->setType)(*(const long*)arg[0]);
}

static  void method_20202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::NTuple::File*)o)->type)());
  else   (((const ::NTuple::File*)o)->type)();
}

static  void method_20203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::NTuple::File*)o)->name)();
  else   (((const ::NTuple::File*)o)->name)();
}

static  void method_20204( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NTuple::File*)o)->setName)(*(const ::std::string*)arg[0]);
}

static  void method_20205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::NTuple::File*)o)->logicalName)();
  else   (((const ::NTuple::File*)o)->logicalName)();
}

static  void method_20206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NTuple::File*)o)->setLogicalName)(*(const ::std::string*)arg[0]);
}

static  void method_20207( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NTuple::File*)o)->setOpen)(*(bool*)arg[0]);
}

static  void method_20208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::NTuple::File*)o)->isOpen)());
  else   (((const ::NTuple::File*)o)->isOpen)();
}

static void method_newdel_5953( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::File >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::File >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::File >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::File >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::File >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x217( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Directory")), ::Reflex::BaseOffset< ::NTuple::File,::NTuple::Directory >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::NTuple::File,::DataObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class File -------------------------------
void __NTuple__File_db_datamem(Reflex::Class*);
void __NTuple__File_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__File_datamem_bld(&__NTuple__File_db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__File_funcmem_bld(&__NTuple__File_db_funcmem);
void __NTuple__File_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::File"), typeid(::NTuple::File), sizeof(::NTuple::File), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00000028-0000-0000-0000-000000000000")
  .AddBase(type_6012, ::Reflex::BaseOffset< ::NTuple::File, ::NTuple::Directory >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27853, type_27854), Reflex::Literal("operator="), operator_20194, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27854), Reflex::Literal("File"), constructor_20195, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("File"), constructor_20196, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_3236c, type_6134), Reflex::Literal("File"), constructor_20197, 0, "type;name;logName", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~File"), destructor_20198, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5953, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x217, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__NTuple__File_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__File_funcmem_bld);
}

//------Delayed data member builder for class File -------------------
void __NTuple__File_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3236, Reflex::Literal("m_name"), OffsetOf(__shadow__::__NTuple__File, m_name), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_3236, Reflex::Literal("m_logName"), OffsetOf(__shadow__::__NTuple__File, m_logName), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_26, Reflex::Literal("m_type"), OffsetOf(__shadow__::__NTuple__File, m_type), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_4206, Reflex::Literal("m_isOpen"), OffsetOf(__shadow__::__NTuple__File, m_isOpen), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class File -------------------
void __NTuple__File_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("classID"), method_20199, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_20200, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26c), Reflex::Literal("setType"), method_20201, 0, "typ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("type"), method_20202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("name"), method_20203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setName"), method_20204, 0, "nam", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("logicalName"), method_20205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_6134), Reflex::Literal("setLogicalName"), method_20206, 0, "l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_4206), Reflex::Literal("setOpen"), method_20207, 0, "flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("isOpen"), method_20208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Item<double> -------------------------------
static void constructor_20209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<double>(*(const ::NTuple::Item<double>*)arg[0]);
  else ::new(mem) ::NTuple::Item<double>(*(const ::NTuple::Item<double>*)arg[0]);
}

static void constructor_20210( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<double>();
  else ::new(mem) ::NTuple::Item<double>();
}

static  void converter_20211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::NTuple::Item<double>*)o)->operator const double)());
  else   (((const ::NTuple::Item<double>*)o)->operator const double)();
}

static  void operator_20212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::NTuple::Item<double>*)o)->operator*)());
  else   (((::NTuple::Item<double>*)o)->operator*)();
}

static  void operator_20213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::NTuple::Item<double>*)o)->operator*)());
  else   (((const ::NTuple::Item<double>*)o)->operator*)();
}

static  void operator_20214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator++)();
  else   (((::NTuple::Item<double>*)o)->operator++)();
}

static  void operator_20215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<double>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator--)();
  else   (((::NTuple::Item<double>*)o)->operator--)();
}

static  void operator_20217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<double>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator+=)(*(const double*)arg[0]);
  else   (((::NTuple::Item<double>*)o)->operator+=)(*(const double*)arg[0]);
}

static  void operator_20220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator-=)(*(const double*)arg[0]);
  else   (((::NTuple::Item<double>*)o)->operator-=)(*(const double*)arg[0]);
}

static  void operator_20221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator*=)(*(const double*)arg[0]);
  else   (((::NTuple::Item<double>*)o)->operator*=)(*(const double*)arg[0]);
}

static  void operator_20222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<double>*)o)->operator/=)(*(const double*)arg[0]);
  else   (((::NTuple::Item<double>*)o)->operator/=)(*(const double*)arg[0]);
}

static void destructor_20223(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<double>*)o)->::NTuple::Item<double>::~Item)();
}
static void method_newdel_5954( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<double> >")), ::Reflex::BaseOffset< ::NTuple::Item<double>,::NTuple::_Accessor<NTuple::_Item<double> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<double> -------------------------------
void __NTuple__Item_double__db_datamem(Reflex::Class*);
void __NTuple__Item_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_double__datamem_bld(&__NTuple__Item_double__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_double__funcmem_bld(&__NTuple__Item_double__db_funcmem);
void __NTuple__Item_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<double>"), typeid(::NTuple::Item<double>), sizeof(::NTuple::Item<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6016, ::Reflex::BaseOffset< ::NTuple::Item<double>, ::NTuple::_Accessor<NTuple::_Item<double> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27855), Reflex::Literal("Item"), constructor_20209, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20210, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20223, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5954, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_double__funcmem_bld);
}

//------Delayed data member builder for class Item<double> -------------------
void __NTuple__Item_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<double> -------------------
void __NTuple__Item_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603c), Reflex::Literal("operator const double"), converter_20211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603), Reflex::Literal("operator*"), operator_20212, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2603c), Reflex::Literal("operator*"), operator_20213, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856), Reflex::Literal("operator++"), operator_20214, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856, type_142), Reflex::Literal("operator++"), operator_20215, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856), Reflex::Literal("operator--"), operator_20216, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856, type_142), Reflex::Literal("operator--"), operator_20217, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856, type_2603c), Reflex::Literal("operator+="), operator_20219, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856, type_2603c), Reflex::Literal("operator-="), operator_20220, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856, type_2603c), Reflex::Literal("operator*="), operator_20221, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27856, type_2603c), Reflex::Literal("operator/="), operator_20222, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Array<long int> -------------------------------
static void constructor_20224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<long>(*(const ::NTuple::Array<long>*)arg[0]);
  else ::new(mem) ::NTuple::Array<long>(*(const ::NTuple::Array<long>*)arg[0]);
}

static void constructor_20225( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<long>();
  else ::new(mem) ::NTuple::Array<long>();
}

static void destructor_20226(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<long>*)o)->::NTuple::Array<long>::~Array)();
}
static void method_newdel_5956( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<long> >")), ::Reflex::BaseOffset< ::NTuple::Array<long>,::NTuple::_Accessor<NTuple::_Array<long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<long int> -------------------------------
void __NTuple__Array_long__db_datamem(Reflex::Class*);
void __NTuple__Array_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_long__datamem_bld(&__NTuple__Array_long__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_long__funcmem_bld(&__NTuple__Array_long__db_funcmem);
void __NTuple__Array_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<long>"), typeid(::NTuple::Array<long>), sizeof(::NTuple::Array<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6044, ::Reflex::BaseOffset< ::NTuple::Array<long>, ::NTuple::_Accessor<NTuple::_Array<long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27857), Reflex::Literal("Array"), constructor_20224, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20225, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20226, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5956, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<long int> -------------------
void __NTuple__Array_long__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<long int> -------------------
void __NTuple__Array_long__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Item<bool> -------------------------------
static void constructor_20227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<bool>(*(const ::NTuple::Item<bool>*)arg[0]);
  else ::new(mem) ::NTuple::Item<bool>(*(const ::NTuple::Item<bool>*)arg[0]);
}

static void constructor_20228( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<bool>();
  else ::new(mem) ::NTuple::Item<bool>();
}

static  void converter_20229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::NTuple::Item<bool>*)o)->operator bool)());
  else   (((const ::NTuple::Item<bool>*)o)->operator bool)();
}

static void destructor_20232(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<bool>*)o)->::NTuple::Item<bool>::~Item)();
}
static void method_newdel_5958( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x223( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<bool> >")), ::Reflex::BaseOffset< ::NTuple::Item<bool>,::NTuple::_Accessor<NTuple::_Item<bool> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<bool> -------------------------------
void __NTuple__Item_bool__db_datamem(Reflex::Class*);
void __NTuple__Item_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_bool__datamem_bld(&__NTuple__Item_bool__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_bool__funcmem_bld(&__NTuple__Item_bool__db_funcmem);
void __NTuple__Item_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<bool>"), typeid(::NTuple::Item<bool>), sizeof(::NTuple::Item<bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6051, ::Reflex::BaseOffset< ::NTuple::Item<bool>, ::NTuple::_Accessor<NTuple::_Item<bool> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27858), Reflex::Literal("Item"), constructor_20227, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20228, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20232, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5958, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_bool__funcmem_bld);
}

//------Delayed data member builder for class Item<bool> -------------------
void __NTuple__Item_bool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<bool> -------------------
void __NTuple__Item_bool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("operator bool"), converter_20229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class Item<float> -------------------------------
static void constructor_20233( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<float>(*(const ::NTuple::Item<float>*)arg[0]);
  else ::new(mem) ::NTuple::Item<float>(*(const ::NTuple::Item<float>*)arg[0]);
}

static void constructor_20234( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<float>();
  else ::new(mem) ::NTuple::Item<float>();
}

static  void converter_20235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::NTuple::Item<float>*)o)->operator const float)());
  else   (((const ::NTuple::Item<float>*)o)->operator const float)();
}

static  void operator_20236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((::NTuple::Item<float>*)o)->operator*)());
  else   (((::NTuple::Item<float>*)o)->operator*)();
}

static  void operator_20237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::NTuple::Item<float>*)o)->operator*)());
  else   (((const ::NTuple::Item<float>*)o)->operator*)();
}

static  void operator_20238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator++)();
  else   (((::NTuple::Item<float>*)o)->operator++)();
}

static  void operator_20239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<float>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator--)();
  else   (((::NTuple::Item<float>*)o)->operator--)();
}

static  void operator_20241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<float>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator+=)(*(const float*)arg[0]);
  else   (((::NTuple::Item<float>*)o)->operator+=)(*(const float*)arg[0]);
}

static  void operator_20244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator-=)(*(const float*)arg[0]);
  else   (((::NTuple::Item<float>*)o)->operator-=)(*(const float*)arg[0]);
}

static  void operator_20245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator*=)(*(const float*)arg[0]);
  else   (((::NTuple::Item<float>*)o)->operator*=)(*(const float*)arg[0]);
}

static  void operator_20246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<float>*)o)->operator/=)(*(const float*)arg[0]);
  else   (((::NTuple::Item<float>*)o)->operator/=)(*(const float*)arg[0]);
}

static void destructor_20247(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<float>*)o)->::NTuple::Item<float>::~Item)();
}
static void method_newdel_5960( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x225( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<float> >")), ::Reflex::BaseOffset< ::NTuple::Item<float>,::NTuple::_Accessor<NTuple::_Item<float> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<float> -------------------------------
void __NTuple__Item_float__db_datamem(Reflex::Class*);
void __NTuple__Item_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_float__datamem_bld(&__NTuple__Item_float__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_float__funcmem_bld(&__NTuple__Item_float__db_funcmem);
void __NTuple__Item_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<float>"), typeid(::NTuple::Item<float>), sizeof(::NTuple::Item<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6017, ::Reflex::BaseOffset< ::NTuple::Item<float>, ::NTuple::_Accessor<NTuple::_Item<float> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27860), Reflex::Literal("Item"), constructor_20233, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20234, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20247, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5960, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x225, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_float__funcmem_bld);
}

//------Delayed data member builder for class Item<float> -------------------
void __NTuple__Item_float__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<float> -------------------
void __NTuple__Item_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921c), Reflex::Literal("operator const float"), converter_20235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921), Reflex::Literal("operator*"), operator_20236, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921c), Reflex::Literal("operator*"), operator_20237, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861), Reflex::Literal("operator++"), operator_20238, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861, type_142), Reflex::Literal("operator++"), operator_20239, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861), Reflex::Literal("operator--"), operator_20240, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861, type_142), Reflex::Literal("operator--"), operator_20241, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861, type_1921c), Reflex::Literal("operator+="), operator_20243, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861, type_1921c), Reflex::Literal("operator-="), operator_20244, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861, type_1921c), Reflex::Literal("operator*="), operator_20245, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27861, type_1921c), Reflex::Literal("operator/="), operator_20246, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<unsigned int> -------------------------------
static void constructor_20248( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned int>(*(const ::NTuple::Item<unsigned int>*)arg[0]);
  else ::new(mem) ::NTuple::Item<unsigned int>(*(const ::NTuple::Item<unsigned int>*)arg[0]);
}

static void constructor_20249( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned int>();
  else ::new(mem) ::NTuple::Item<unsigned int>();
}

static  void converter_20250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::NTuple::Item<unsigned int>*)o)->operator const unsigned int)());
  else   (((const ::NTuple::Item<unsigned int>*)o)->operator const unsigned int)();
}

static  void operator_20251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::NTuple::Item<unsigned int>*)o)->operator*)());
  else   (((::NTuple::Item<unsigned int>*)o)->operator*)();
}

static  void operator_20252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::NTuple::Item<unsigned int>*)o)->operator*)());
  else   (((const ::NTuple::Item<unsigned int>*)o)->operator*)();
}

static  void operator_20253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator++)();
  else   (((::NTuple::Item<unsigned int>*)o)->operator++)();
}

static  void operator_20254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned int>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator--)();
  else   (((::NTuple::Item<unsigned int>*)o)->operator--)();
}

static  void operator_20256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned int>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator+=)(*(const unsigned int*)arg[0]);
  else   (((::NTuple::Item<unsigned int>*)o)->operator+=)(*(const unsigned int*)arg[0]);
}

static  void operator_20259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator-=)(*(const unsigned int*)arg[0]);
  else   (((::NTuple::Item<unsigned int>*)o)->operator-=)(*(const unsigned int*)arg[0]);
}

static  void operator_20260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator*=)(*(const unsigned int*)arg[0]);
  else   (((::NTuple::Item<unsigned int>*)o)->operator*=)(*(const unsigned int*)arg[0]);
}

static  void operator_20261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned int>*)o)->operator/=)(*(const unsigned int*)arg[0]);
  else   (((::NTuple::Item<unsigned int>*)o)->operator/=)(*(const unsigned int*)arg[0]);
}

static void destructor_20262(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<unsigned int>*)o)->::NTuple::Item<unsigned int>::~Item)();
}
static void method_newdel_5961( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x227( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned int> >")), ::Reflex::BaseOffset< ::NTuple::Item<unsigned int>,::NTuple::_Accessor<NTuple::_Item<unsigned int> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<unsigned int> -------------------------------
void __NTuple__Item_unsignedsint__db_datamem(Reflex::Class*);
void __NTuple__Item_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedsint__datamem_bld(&__NTuple__Item_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedsint__funcmem_bld(&__NTuple__Item_unsignedsint__db_funcmem);
void __NTuple__Item_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<unsigned int>"), typeid(::NTuple::Item<unsigned int>), sizeof(::NTuple::Item<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6018, ::Reflex::BaseOffset< ::NTuple::Item<unsigned int>, ::NTuple::_Accessor<NTuple::_Item<unsigned int> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27862), Reflex::Literal("Item"), constructor_20248, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20249, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20262, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5961, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class Item<unsigned int> -------------------
void __NTuple__Item_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<unsigned int> -------------------
void __NTuple__Item_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_203c), Reflex::Literal("operator const unsigned int"), converter_20250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_203), Reflex::Literal("operator*"), operator_20251, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_203c), Reflex::Literal("operator*"), operator_20252, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863), Reflex::Literal("operator++"), operator_20253, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863, type_142), Reflex::Literal("operator++"), operator_20254, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863), Reflex::Literal("operator--"), operator_20255, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863, type_142), Reflex::Literal("operator--"), operator_20256, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863, type_203c), Reflex::Literal("operator+="), operator_20258, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863, type_203c), Reflex::Literal("operator-="), operator_20259, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863, type_203c), Reflex::Literal("operator*="), operator_20260, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27863, type_203c), Reflex::Literal("operator/="), operator_20261, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<int> -------------------------------
static void constructor_20263( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<int>(*(const ::NTuple::Item<int>*)arg[0]);
  else ::new(mem) ::NTuple::Item<int>(*(const ::NTuple::Item<int>*)arg[0]);
}

static void constructor_20264( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<int>();
  else ::new(mem) ::NTuple::Item<int>();
}

static  void converter_20265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::NTuple::Item<int>*)o)->operator const int)());
  else   (((const ::NTuple::Item<int>*)o)->operator const int)();
}

static  void operator_20266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::NTuple::Item<int>*)o)->operator*)());
  else   (((::NTuple::Item<int>*)o)->operator*)();
}

static  void operator_20267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::NTuple::Item<int>*)o)->operator*)());
  else   (((const ::NTuple::Item<int>*)o)->operator*)();
}

static  void operator_20268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator++)();
  else   (((::NTuple::Item<int>*)o)->operator++)();
}

static  void operator_20269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<int>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator--)();
  else   (((::NTuple::Item<int>*)o)->operator--)();
}

static  void operator_20271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<int>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator+=)(*(const int*)arg[0]);
  else   (((::NTuple::Item<int>*)o)->operator+=)(*(const int*)arg[0]);
}

static  void operator_20274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator-=)(*(const int*)arg[0]);
  else   (((::NTuple::Item<int>*)o)->operator-=)(*(const int*)arg[0]);
}

static  void operator_20275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator*=)(*(const int*)arg[0]);
  else   (((::NTuple::Item<int>*)o)->operator*=)(*(const int*)arg[0]);
}

static  void operator_20276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<int>*)o)->operator/=)(*(const int*)arg[0]);
  else   (((::NTuple::Item<int>*)o)->operator/=)(*(const int*)arg[0]);
}

static void destructor_20277(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<int>*)o)->::NTuple::Item<int>::~Item)();
}
static void method_newdel_5962( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<int> >")), ::Reflex::BaseOffset< ::NTuple::Item<int>,::NTuple::_Accessor<NTuple::_Item<int> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<int> -------------------------------
void __NTuple__Item_int__db_datamem(Reflex::Class*);
void __NTuple__Item_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_int__datamem_bld(&__NTuple__Item_int__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_int__funcmem_bld(&__NTuple__Item_int__db_funcmem);
void __NTuple__Item_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<int>"), typeid(::NTuple::Item<int>), sizeof(::NTuple::Item<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6019, ::Reflex::BaseOffset< ::NTuple::Item<int>, ::NTuple::_Accessor<NTuple::_Item<int> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27864), Reflex::Literal("Item"), constructor_20263, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20264, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20277, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5962, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_int__funcmem_bld);
}

//------Delayed data member builder for class Item<int> -------------------
void __NTuple__Item_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<int> -------------------
void __NTuple__Item_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142c), Reflex::Literal("operator const int"), converter_20265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142), Reflex::Literal("operator*"), operator_20266, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_142c), Reflex::Literal("operator*"), operator_20267, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865), Reflex::Literal("operator++"), operator_20268, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865, type_142), Reflex::Literal("operator++"), operator_20269, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865), Reflex::Literal("operator--"), operator_20270, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865, type_142), Reflex::Literal("operator--"), operator_20271, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865, type_142c), Reflex::Literal("operator+="), operator_20273, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865, type_142c), Reflex::Literal("operator-="), operator_20274, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865, type_142c), Reflex::Literal("operator*="), operator_20275, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27865, type_142c), Reflex::Literal("operator/="), operator_20276, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<long long unsigned int> -------------------------------
static void constructor_20278( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned long long>(*(const ::NTuple::Item<unsigned long long>*)arg[0]);
  else ::new(mem) ::NTuple::Item<unsigned long long>(*(const ::NTuple::Item<unsigned long long>*)arg[0]);
}

static void constructor_20279( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned long long>();
  else ::new(mem) ::NTuple::Item<unsigned long long>();
}

static  void converter_20280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::NTuple::Item<unsigned long long>*)o)->operator const unsigned long long)());
  else   (((const ::NTuple::Item<unsigned long long>*)o)->operator const unsigned long long)();
}

static  void operator_20281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((::NTuple::Item<unsigned long long>*)o)->operator*)());
  else   (((::NTuple::Item<unsigned long long>*)o)->operator*)();
}

static  void operator_20282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long long)((((const ::NTuple::Item<unsigned long long>*)o)->operator*)());
  else   (((const ::NTuple::Item<unsigned long long>*)o)->operator*)();
}

static  void operator_20283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator++)();
  else   (((::NTuple::Item<unsigned long long>*)o)->operator++)();
}

static  void operator_20284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned long long>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator--)();
  else   (((::NTuple::Item<unsigned long long>*)o)->operator--)();
}

static  void operator_20286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned long long>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator+=)(*(const unsigned long long*)arg[0]);
  else   (((::NTuple::Item<unsigned long long>*)o)->operator+=)(*(const unsigned long long*)arg[0]);
}

static  void operator_20289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator-=)(*(const unsigned long long*)arg[0]);
  else   (((::NTuple::Item<unsigned long long>*)o)->operator-=)(*(const unsigned long long*)arg[0]);
}

static  void operator_20290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator*=)(*(const unsigned long long*)arg[0]);
  else   (((::NTuple::Item<unsigned long long>*)o)->operator*=)(*(const unsigned long long*)arg[0]);
}

static  void operator_20291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long long>*)o)->operator/=)(*(const unsigned long long*)arg[0]);
  else   (((::NTuple::Item<unsigned long long>*)o)->operator/=)(*(const unsigned long long*)arg[0]);
}

static void destructor_20292(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<unsigned long long>*)o)->::NTuple::Item<unsigned long long>::~Item)();
}
static void method_newdel_5963( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned long long> >")), ::Reflex::BaseOffset< ::NTuple::Item<unsigned long long>,::NTuple::_Accessor<NTuple::_Item<unsigned long long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<long long unsigned int> -------------------------------
void __NTuple__Item_unsignedslongslong__db_datamem(Reflex::Class*);
void __NTuple__Item_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedslongslong__datamem_bld(&__NTuple__Item_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedslongslong__funcmem_bld(&__NTuple__Item_unsignedslongslong__db_funcmem);
void __NTuple__Item_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<unsigned long long>"), typeid(::NTuple::Item<unsigned long long>), sizeof(::NTuple::Item<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6020, ::Reflex::BaseOffset< ::NTuple::Item<unsigned long long>, ::NTuple::_Accessor<NTuple::_Item<unsigned long long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27866), Reflex::Literal("Item"), constructor_20278, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20279, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20292, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5963, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class Item<long long unsigned int> -------------------
void __NTuple__Item_unsignedslongslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<long long unsigned int> -------------------
void __NTuple__Item_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14c), Reflex::Literal("operator const unsigned long long"), converter_20280, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14), Reflex::Literal("operator*"), operator_20281, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14c), Reflex::Literal("operator*"), operator_20282, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867), Reflex::Literal("operator++"), operator_20283, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867, type_142), Reflex::Literal("operator++"), operator_20284, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867), Reflex::Literal("operator--"), operator_20285, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867, type_142), Reflex::Literal("operator--"), operator_20286, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867, type_14c), Reflex::Literal("operator+="), operator_20288, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867, type_14c), Reflex::Literal("operator-="), operator_20289, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867, type_14c), Reflex::Literal("operator*="), operator_20290, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867, type_14c), Reflex::Literal("operator/="), operator_20291, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<long unsigned int> -------------------------------
static void constructor_20293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned long>(*(const ::NTuple::Item<unsigned long>*)arg[0]);
  else ::new(mem) ::NTuple::Item<unsigned long>(*(const ::NTuple::Item<unsigned long>*)arg[0]);
}

static void constructor_20294( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned long>();
  else ::new(mem) ::NTuple::Item<unsigned long>();
}

static  void converter_20295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::NTuple::Item<unsigned long>*)o)->operator const unsigned long)());
  else   (((const ::NTuple::Item<unsigned long>*)o)->operator const unsigned long)();
}

static  void operator_20296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((::NTuple::Item<unsigned long>*)o)->operator*)());
  else   (((::NTuple::Item<unsigned long>*)o)->operator*)();
}

static  void operator_20297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::NTuple::Item<unsigned long>*)o)->operator*)());
  else   (((const ::NTuple::Item<unsigned long>*)o)->operator*)();
}

static  void operator_20298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator++)();
  else   (((::NTuple::Item<unsigned long>*)o)->operator++)();
}

static  void operator_20299( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned long>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator--)();
  else   (((::NTuple::Item<unsigned long>*)o)->operator--)();
}

static  void operator_20301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned long>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator+=)(*(const unsigned long*)arg[0]);
  else   (((::NTuple::Item<unsigned long>*)o)->operator+=)(*(const unsigned long*)arg[0]);
}

static  void operator_20304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator-=)(*(const unsigned long*)arg[0]);
  else   (((::NTuple::Item<unsigned long>*)o)->operator-=)(*(const unsigned long*)arg[0]);
}

static  void operator_20305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator*=)(*(const unsigned long*)arg[0]);
  else   (((::NTuple::Item<unsigned long>*)o)->operator*=)(*(const unsigned long*)arg[0]);
}

static  void operator_20306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned long>*)o)->operator/=)(*(const unsigned long*)arg[0]);
  else   (((::NTuple::Item<unsigned long>*)o)->operator/=)(*(const unsigned long*)arg[0]);
}

static void destructor_20307(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<unsigned long>*)o)->::NTuple::Item<unsigned long>::~Item)();
}
static void method_newdel_5964( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x233( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned long> >")), ::Reflex::BaseOffset< ::NTuple::Item<unsigned long>,::NTuple::_Accessor<NTuple::_Item<unsigned long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<long unsigned int> -------------------------------
void __NTuple__Item_unsignedslong__db_datamem(Reflex::Class*);
void __NTuple__Item_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedslong__datamem_bld(&__NTuple__Item_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedslong__funcmem_bld(&__NTuple__Item_unsignedslong__db_funcmem);
void __NTuple__Item_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<unsigned long>"), typeid(::NTuple::Item<unsigned long>), sizeof(::NTuple::Item<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6021, ::Reflex::BaseOffset< ::NTuple::Item<unsigned long>, ::NTuple::_Accessor<NTuple::_Item<unsigned long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27868), Reflex::Literal("Item"), constructor_20293, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20294, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20307, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5964, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x233, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class Item<long unsigned int> -------------------
void __NTuple__Item_unsignedslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<long unsigned int> -------------------
void __NTuple__Item_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502c), Reflex::Literal("operator const unsigned long"), converter_20295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502), Reflex::Literal("operator*"), operator_20296, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_502c), Reflex::Literal("operator*"), operator_20297, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869), Reflex::Literal("operator++"), operator_20298, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869, type_142), Reflex::Literal("operator++"), operator_20299, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869), Reflex::Literal("operator--"), operator_20300, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869, type_142), Reflex::Literal("operator--"), operator_20301, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869, type_502c), Reflex::Literal("operator+="), operator_20303, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869, type_502c), Reflex::Literal("operator-="), operator_20304, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869, type_502c), Reflex::Literal("operator*="), operator_20305, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27869, type_502c), Reflex::Literal("operator/="), operator_20306, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<long long int> -------------------------------
static void constructor_20308( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<long long>(*(const ::NTuple::Item<long long>*)arg[0]);
  else ::new(mem) ::NTuple::Item<long long>(*(const ::NTuple::Item<long long>*)arg[0]);
}

static void constructor_20309( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<long long>();
  else ::new(mem) ::NTuple::Item<long long>();
}

static  void converter_20310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::NTuple::Item<long long>*)o)->operator const long long)());
  else   (((const ::NTuple::Item<long long>*)o)->operator const long long)();
}

static  void operator_20311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((::NTuple::Item<long long>*)o)->operator*)());
  else   (((::NTuple::Item<long long>*)o)->operator*)();
}

static  void operator_20312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::NTuple::Item<long long>*)o)->operator*)());
  else   (((const ::NTuple::Item<long long>*)o)->operator*)();
}

static  void operator_20313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator++)();
  else   (((::NTuple::Item<long long>*)o)->operator++)();
}

static  void operator_20314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<long long>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator--)();
  else   (((::NTuple::Item<long long>*)o)->operator--)();
}

static  void operator_20316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<long long>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20318( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator+=)(*(const long long*)arg[0]);
  else   (((::NTuple::Item<long long>*)o)->operator+=)(*(const long long*)arg[0]);
}

static  void operator_20319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator-=)(*(const long long*)arg[0]);
  else   (((::NTuple::Item<long long>*)o)->operator-=)(*(const long long*)arg[0]);
}

static  void operator_20320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator*=)(*(const long long*)arg[0]);
  else   (((::NTuple::Item<long long>*)o)->operator*=)(*(const long long*)arg[0]);
}

static  void operator_20321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long long>*)o)->operator/=)(*(const long long*)arg[0]);
  else   (((::NTuple::Item<long long>*)o)->operator/=)(*(const long long*)arg[0]);
}

static void destructor_20322(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<long long>*)o)->::NTuple::Item<long long>::~Item)();
}
static void method_newdel_5965( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x235( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<long long> >")), ::Reflex::BaseOffset< ::NTuple::Item<long long>,::NTuple::_Accessor<NTuple::_Item<long long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<long long int> -------------------------------
void __NTuple__Item_longslong__db_datamem(Reflex::Class*);
void __NTuple__Item_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_longslong__datamem_bld(&__NTuple__Item_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_longslong__funcmem_bld(&__NTuple__Item_longslong__db_funcmem);
void __NTuple__Item_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<long long>"), typeid(::NTuple::Item<long long>), sizeof(::NTuple::Item<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6022, ::Reflex::BaseOffset< ::NTuple::Item<long long>, ::NTuple::_Accessor<NTuple::_Item<long long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27870), Reflex::Literal("Item"), constructor_20308, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20309, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20322, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5965, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_longslong__funcmem_bld);
}

//------Delayed data member builder for class Item<long long int> -------------------
void __NTuple__Item_longslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<long long int> -------------------
void __NTuple__Item_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_189c), Reflex::Literal("operator const long long"), converter_20310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_189), Reflex::Literal("operator*"), operator_20311, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_189c), Reflex::Literal("operator*"), operator_20312, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871), Reflex::Literal("operator++"), operator_20313, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871, type_142), Reflex::Literal("operator++"), operator_20314, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871), Reflex::Literal("operator--"), operator_20315, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871, type_142), Reflex::Literal("operator--"), operator_20316, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871, type_189c), Reflex::Literal("operator+="), operator_20318, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871, type_189c), Reflex::Literal("operator-="), operator_20319, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871, type_189c), Reflex::Literal("operator*="), operator_20320, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27871, type_189c), Reflex::Literal("operator/="), operator_20321, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<long int> -------------------------------
static void constructor_20323( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<long>(*(const ::NTuple::Item<long>*)arg[0]);
  else ::new(mem) ::NTuple::Item<long>(*(const ::NTuple::Item<long>*)arg[0]);
}

static void constructor_20324( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<long>();
  else ::new(mem) ::NTuple::Item<long>();
}

static  void converter_20325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::NTuple::Item<long>*)o)->operator const long)());
  else   (((const ::NTuple::Item<long>*)o)->operator const long)();
}

static  void operator_20326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((::NTuple::Item<long>*)o)->operator*)());
  else   (((::NTuple::Item<long>*)o)->operator*)();
}

static  void operator_20327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::NTuple::Item<long>*)o)->operator*)());
  else   (((const ::NTuple::Item<long>*)o)->operator*)();
}

static  void operator_20328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator++)();
  else   (((::NTuple::Item<long>*)o)->operator++)();
}

static  void operator_20329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<long>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator--)();
  else   (((::NTuple::Item<long>*)o)->operator--)();
}

static  void operator_20331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<long>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator+=)(*(const long*)arg[0]);
  else   (((::NTuple::Item<long>*)o)->operator+=)(*(const long*)arg[0]);
}

static  void operator_20334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator-=)(*(const long*)arg[0]);
  else   (((::NTuple::Item<long>*)o)->operator-=)(*(const long*)arg[0]);
}

static  void operator_20335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator*=)(*(const long*)arg[0]);
  else   (((::NTuple::Item<long>*)o)->operator*=)(*(const long*)arg[0]);
}

static  void operator_20336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<long>*)o)->operator/=)(*(const long*)arg[0]);
  else   (((::NTuple::Item<long>*)o)->operator/=)(*(const long*)arg[0]);
}

static void destructor_20337(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<long>*)o)->::NTuple::Item<long>::~Item)();
}
static void method_newdel_5966( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x237( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<long> >")), ::Reflex::BaseOffset< ::NTuple::Item<long>,::NTuple::_Accessor<NTuple::_Item<long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<long int> -------------------------------
void __NTuple__Item_long__db_datamem(Reflex::Class*);
void __NTuple__Item_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_long__datamem_bld(&__NTuple__Item_long__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_long__funcmem_bld(&__NTuple__Item_long__db_funcmem);
void __NTuple__Item_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<long>"), typeid(::NTuple::Item<long>), sizeof(::NTuple::Item<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6023, ::Reflex::BaseOffset< ::NTuple::Item<long>, ::NTuple::_Accessor<NTuple::_Item<long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27872), Reflex::Literal("Item"), constructor_20323, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20324, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20337, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5966, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x237, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_long__funcmem_bld);
}

//------Delayed data member builder for class Item<long int> -------------------
void __NTuple__Item_long__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<long int> -------------------
void __NTuple__Item_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26c), Reflex::Literal("operator const long"), converter_20325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("operator*"), operator_20326, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26c), Reflex::Literal("operator*"), operator_20327, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873), Reflex::Literal("operator++"), operator_20328, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873, type_142), Reflex::Literal("operator++"), operator_20329, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873), Reflex::Literal("operator--"), operator_20330, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873, type_142), Reflex::Literal("operator--"), operator_20331, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873, type_26c), Reflex::Literal("operator+="), operator_20333, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873, type_26c), Reflex::Literal("operator-="), operator_20334, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873, type_26c), Reflex::Literal("operator*="), operator_20335, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27873, type_26c), Reflex::Literal("operator/="), operator_20336, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<short unsigned int> -------------------------------
static void constructor_20338( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned short>(*(const ::NTuple::Item<unsigned short>*)arg[0]);
  else ::new(mem) ::NTuple::Item<unsigned short>(*(const ::NTuple::Item<unsigned short>*)arg[0]);
}

static void constructor_20339( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned short>();
  else ::new(mem) ::NTuple::Item<unsigned short>();
}

static  void converter_20340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::NTuple::Item<unsigned short>*)o)->operator const unsigned short)());
  else   (((const ::NTuple::Item<unsigned short>*)o)->operator const unsigned short)();
}

static  void operator_20341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::NTuple::Item<unsigned short>*)o)->operator*)());
  else   (((::NTuple::Item<unsigned short>*)o)->operator*)();
}

static  void operator_20342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::NTuple::Item<unsigned short>*)o)->operator*)());
  else   (((const ::NTuple::Item<unsigned short>*)o)->operator*)();
}

static  void operator_20343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator++)();
  else   (((::NTuple::Item<unsigned short>*)o)->operator++)();
}

static  void operator_20344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned short>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator--)();
  else   (((::NTuple::Item<unsigned short>*)o)->operator--)();
}

static  void operator_20346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned short>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator+=)(*(const unsigned short*)arg[0]);
  else   (((::NTuple::Item<unsigned short>*)o)->operator+=)(*(const unsigned short*)arg[0]);
}

static  void operator_20349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator-=)(*(const unsigned short*)arg[0]);
  else   (((::NTuple::Item<unsigned short>*)o)->operator-=)(*(const unsigned short*)arg[0]);
}

static  void operator_20350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator*=)(*(const unsigned short*)arg[0]);
  else   (((::NTuple::Item<unsigned short>*)o)->operator*=)(*(const unsigned short*)arg[0]);
}

static  void operator_20351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned short>*)o)->operator/=)(*(const unsigned short*)arg[0]);
  else   (((::NTuple::Item<unsigned short>*)o)->operator/=)(*(const unsigned short*)arg[0]);
}

static void destructor_20352(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<unsigned short>*)o)->::NTuple::Item<unsigned short>::~Item)();
}
static void method_newdel_5967( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x239( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned short> >")), ::Reflex::BaseOffset< ::NTuple::Item<unsigned short>,::NTuple::_Accessor<NTuple::_Item<unsigned short> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<short unsigned int> -------------------------------
void __NTuple__Item_unsignedsshort__db_datamem(Reflex::Class*);
void __NTuple__Item_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedsshort__datamem_bld(&__NTuple__Item_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedsshort__funcmem_bld(&__NTuple__Item_unsignedsshort__db_funcmem);
void __NTuple__Item_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<unsigned short>"), typeid(::NTuple::Item<unsigned short>), sizeof(::NTuple::Item<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6024, ::Reflex::BaseOffset< ::NTuple::Item<unsigned short>, ::NTuple::_Accessor<NTuple::_Item<unsigned short> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27874), Reflex::Literal("Item"), constructor_20338, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20339, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20352, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5967, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x239, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class Item<short unsigned int> -------------------
void __NTuple__Item_unsignedsshort__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<short unsigned int> -------------------
void __NTuple__Item_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_333c), Reflex::Literal("operator const unsigned short"), converter_20340, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_333), Reflex::Literal("operator*"), operator_20341, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_333c), Reflex::Literal("operator*"), operator_20342, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875), Reflex::Literal("operator++"), operator_20343, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875, type_142), Reflex::Literal("operator++"), operator_20344, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875), Reflex::Literal("operator--"), operator_20345, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875, type_142), Reflex::Literal("operator--"), operator_20346, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875, type_333c), Reflex::Literal("operator+="), operator_20348, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875, type_333c), Reflex::Literal("operator-="), operator_20349, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875, type_333c), Reflex::Literal("operator*="), operator_20350, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27875, type_333c), Reflex::Literal("operator/="), operator_20351, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<short int> -------------------------------
static void constructor_20353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<short>(*(const ::NTuple::Item<short>*)arg[0]);
  else ::new(mem) ::NTuple::Item<short>(*(const ::NTuple::Item<short>*)arg[0]);
}

static void constructor_20354( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<short>();
  else ::new(mem) ::NTuple::Item<short>();
}

static  void converter_20355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::NTuple::Item<short>*)o)->operator const short)());
  else   (((const ::NTuple::Item<short>*)o)->operator const short)();
}

static  void operator_20356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::NTuple::Item<short>*)o)->operator*)());
  else   (((::NTuple::Item<short>*)o)->operator*)();
}

static  void operator_20357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::NTuple::Item<short>*)o)->operator*)());
  else   (((const ::NTuple::Item<short>*)o)->operator*)();
}

static  void operator_20358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator++)();
  else   (((::NTuple::Item<short>*)o)->operator++)();
}

static  void operator_20359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<short>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator--)();
  else   (((::NTuple::Item<short>*)o)->operator--)();
}

static  void operator_20361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<short>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator+=)(*(const short*)arg[0]);
  else   (((::NTuple::Item<short>*)o)->operator+=)(*(const short*)arg[0]);
}

static  void operator_20364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator-=)(*(const short*)arg[0]);
  else   (((::NTuple::Item<short>*)o)->operator-=)(*(const short*)arg[0]);
}

static  void operator_20365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator*=)(*(const short*)arg[0]);
  else   (((::NTuple::Item<short>*)o)->operator*=)(*(const short*)arg[0]);
}

static  void operator_20366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<short>*)o)->operator/=)(*(const short*)arg[0]);
  else   (((::NTuple::Item<short>*)o)->operator/=)(*(const short*)arg[0]);
}

static void destructor_20367(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<short>*)o)->::NTuple::Item<short>::~Item)();
}
static void method_newdel_5968( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x241( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<short> >")), ::Reflex::BaseOffset< ::NTuple::Item<short>,::NTuple::_Accessor<NTuple::_Item<short> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<short int> -------------------------------
void __NTuple__Item_short__db_datamem(Reflex::Class*);
void __NTuple__Item_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_short__datamem_bld(&__NTuple__Item_short__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_short__funcmem_bld(&__NTuple__Item_short__db_funcmem);
void __NTuple__Item_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<short>"), typeid(::NTuple::Item<short>), sizeof(::NTuple::Item<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6025, ::Reflex::BaseOffset< ::NTuple::Item<short>, ::NTuple::_Accessor<NTuple::_Item<short> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27876), Reflex::Literal("Item"), constructor_20353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20354, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20367, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5968, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x241, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_short__funcmem_bld);
}

//------Delayed data member builder for class Item<short int> -------------------
void __NTuple__Item_short__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<short int> -------------------
void __NTuple__Item_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_869c), Reflex::Literal("operator const short"), converter_20355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_869), Reflex::Literal("operator*"), operator_20356, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_869c), Reflex::Literal("operator*"), operator_20357, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877), Reflex::Literal("operator++"), operator_20358, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877, type_142), Reflex::Literal("operator++"), operator_20359, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877), Reflex::Literal("operator--"), operator_20360, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877, type_142), Reflex::Literal("operator--"), operator_20361, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877, type_869c), Reflex::Literal("operator+="), operator_20363, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877, type_869c), Reflex::Literal("operator-="), operator_20364, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877, type_869c), Reflex::Literal("operator*="), operator_20365, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27877, type_869c), Reflex::Literal("operator/="), operator_20366, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<unsigned char> -------------------------------
static void constructor_20368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned char>(*(const ::NTuple::Item<unsigned char>*)arg[0]);
  else ::new(mem) ::NTuple::Item<unsigned char>(*(const ::NTuple::Item<unsigned char>*)arg[0]);
}

static void constructor_20369( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<unsigned char>();
  else ::new(mem) ::NTuple::Item<unsigned char>();
}

static  void converter_20370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned char)((((const ::NTuple::Item<unsigned char>*)o)->operator const unsigned char)());
  else   (((const ::NTuple::Item<unsigned char>*)o)->operator const unsigned char)();
}

static  void operator_20371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned char)((((::NTuple::Item<unsigned char>*)o)->operator*)());
  else   (((::NTuple::Item<unsigned char>*)o)->operator*)();
}

static  void operator_20372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned char)((((const ::NTuple::Item<unsigned char>*)o)->operator*)());
  else   (((const ::NTuple::Item<unsigned char>*)o)->operator*)();
}

static  void operator_20373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator++)();
  else   (((::NTuple::Item<unsigned char>*)o)->operator++)();
}

static  void operator_20374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned char>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator--)();
  else   (((::NTuple::Item<unsigned char>*)o)->operator--)();
}

static  void operator_20376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<unsigned char>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator+=)(*(const unsigned char*)arg[0]);
  else   (((::NTuple::Item<unsigned char>*)o)->operator+=)(*(const unsigned char*)arg[0]);
}

static  void operator_20379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator-=)(*(const unsigned char*)arg[0]);
  else   (((::NTuple::Item<unsigned char>*)o)->operator-=)(*(const unsigned char*)arg[0]);
}

static  void operator_20380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator*=)(*(const unsigned char*)arg[0]);
  else   (((::NTuple::Item<unsigned char>*)o)->operator*=)(*(const unsigned char*)arg[0]);
}

static  void operator_20381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<unsigned char>*)o)->operator/=)(*(const unsigned char*)arg[0]);
  else   (((::NTuple::Item<unsigned char>*)o)->operator/=)(*(const unsigned char*)arg[0]);
}

static void destructor_20382(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<unsigned char>*)o)->::NTuple::Item<unsigned char>::~Item)();
}
static void method_newdel_5969( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x243( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<unsigned char> >")), ::Reflex::BaseOffset< ::NTuple::Item<unsigned char>,::NTuple::_Accessor<NTuple::_Item<unsigned char> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<unsigned char> -------------------------------
void __NTuple__Item_unsignedschar__db_datamem(Reflex::Class*);
void __NTuple__Item_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedschar__datamem_bld(&__NTuple__Item_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_unsignedschar__funcmem_bld(&__NTuple__Item_unsignedschar__db_funcmem);
void __NTuple__Item_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<unsigned char>"), typeid(::NTuple::Item<unsigned char>), sizeof(::NTuple::Item<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6026, ::Reflex::BaseOffset< ::NTuple::Item<unsigned char>, ::NTuple::_Accessor<NTuple::_Item<unsigned char> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27878), Reflex::Literal("Item"), constructor_20368, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20369, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20382, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5969, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x243, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class Item<unsigned char> -------------------
void __NTuple__Item_unsignedschar__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<unsigned char> -------------------
void __NTuple__Item_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278c), Reflex::Literal("operator const unsigned char"), converter_20370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("operator*"), operator_20371, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278c), Reflex::Literal("operator*"), operator_20372, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879), Reflex::Literal("operator++"), operator_20373, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879, type_142), Reflex::Literal("operator++"), operator_20374, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879), Reflex::Literal("operator--"), operator_20375, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879, type_142), Reflex::Literal("operator--"), operator_20376, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879, type_278c), Reflex::Literal("operator+="), operator_20378, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879, type_278c), Reflex::Literal("operator-="), operator_20379, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879, type_278c), Reflex::Literal("operator*="), operator_20380, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27879, type_278c), Reflex::Literal("operator/="), operator_20381, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Item<char> -------------------------------
static void constructor_20383( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<char>(*(const ::NTuple::Item<char>*)arg[0]);
  else ::new(mem) ::NTuple::Item<char>(*(const ::NTuple::Item<char>*)arg[0]);
}

static void constructor_20384( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Item<char>();
  else ::new(mem) ::NTuple::Item<char>();
}

static  void converter_20385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (char)((((const ::NTuple::Item<char>*)o)->operator const char)());
  else   (((const ::NTuple::Item<char>*)o)->operator const char)();
}

static  void operator_20386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (char)((((::NTuple::Item<char>*)o)->operator*)());
  else   (((::NTuple::Item<char>*)o)->operator*)();
}

static  void operator_20387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (char)((((const ::NTuple::Item<char>*)o)->operator*)());
  else   (((const ::NTuple::Item<char>*)o)->operator*)();
}

static  void operator_20388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator++)();
  else   (((::NTuple::Item<char>*)o)->operator++)();
}

static  void operator_20389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator++)(*(int*)arg[0]);
  else   (((::NTuple::Item<char>*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_20390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator--)();
  else   (((::NTuple::Item<char>*)o)->operator--)();
}

static  void operator_20391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator--)(*(int*)arg[0]);
  else   (((::NTuple::Item<char>*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_20393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator+=)(*(const char*)arg[0]);
  else   (((::NTuple::Item<char>*)o)->operator+=)(*(const char*)arg[0]);
}

static  void operator_20394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator-=)(*(const char*)arg[0]);
  else   (((::NTuple::Item<char>*)o)->operator-=)(*(const char*)arg[0]);
}

static  void operator_20395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator*=)(*(const char*)arg[0]);
  else   (((::NTuple::Item<char>*)o)->operator*=)(*(const char*)arg[0]);
}

static  void operator_20396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Item<char>*)o)->operator/=)(*(const char*)arg[0]);
  else   (((::NTuple::Item<char>*)o)->operator/=)(*(const char*)arg[0]);
}

static void destructor_20397(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Item<char>*)o)->::NTuple::Item<char>::~Item)();
}
static void method_newdel_5970( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Item<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Item<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Item<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Item<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Item<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x245( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Item<char> >")), ::Reflex::BaseOffset< ::NTuple::Item<char>,::NTuple::_Accessor<NTuple::_Item<char> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Item<char> -------------------------------
void __NTuple__Item_char__db_datamem(Reflex::Class*);
void __NTuple__Item_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Item_char__datamem_bld(&__NTuple__Item_char__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Item_char__funcmem_bld(&__NTuple__Item_char__db_funcmem);
void __NTuple__Item_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Item<char>"), typeid(::NTuple::Item<char>), sizeof(::NTuple::Item<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Item<*>")
  .AddBase(type_6027, ::Reflex::BaseOffset< ::NTuple::Item<char>, ::NTuple::_Accessor<NTuple::_Item<char> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27880), Reflex::Literal("Item"), constructor_20383, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_20384, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_20397, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5970, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x245, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Item_char__funcmem_bld);
}

//------Delayed data member builder for class Item<char> -------------------
void __NTuple__Item_char__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Item<char> -------------------
void __NTuple__Item_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274c), Reflex::Literal("operator const char"), converter_20385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274), Reflex::Literal("operator*"), operator_20386, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274c), Reflex::Literal("operator*"), operator_20387, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881), Reflex::Literal("operator++"), operator_20388, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881, type_142), Reflex::Literal("operator++"), operator_20389, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881), Reflex::Literal("operator--"), operator_20390, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881, type_142), Reflex::Literal("operator--"), operator_20391, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881, type_4274c), Reflex::Literal("operator+="), operator_20393, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881, type_4274c), Reflex::Literal("operator-="), operator_20394, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881, type_4274c), Reflex::Literal("operator*="), operator_20395, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881, type_4274c), Reflex::Literal("operator/="), operator_20396, 0, "data", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class ColumnWiseTuple -------------------------------
static  void operator_20434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::ColumnWiseTuple*)o)->operator=)(*(const ::NTuple::ColumnWiseTuple*)arg[0]);
  else   (((::NTuple::ColumnWiseTuple*)o)->operator=)(*(const ::NTuple::ColumnWiseTuple*)arg[0]);
}

static void constructor_20435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::ColumnWiseTuple(*(const ::std::string*)arg[0]);
  else ::new(mem) ::NTuple::ColumnWiseTuple(*(const ::std::string*)arg[0]);
}

static void destructor_20436(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::ColumnWiseTuple*)o)->::NTuple::ColumnWiseTuple::~ColumnWiseTuple)();
}
static  void method_20437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::NTuple::ColumnWiseTuple*)o)->clID)();
  else   (((const ::NTuple::ColumnWiseTuple*)o)->clID)();
}

static  void method_20438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::ColumnWiseTuple*)o)->classID)();
  else   (((::NTuple::ColumnWiseTuple*)o)->classID)();
}

static void method_x246( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::TupleImp")), ::Reflex::BaseOffset< ::NTuple::ColumnWiseTuple,::NTuple::TupleImp >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Tuple")), ::Reflex::BaseOffset< ::NTuple::ColumnWiseTuple,::NTuple::Tuple >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::NTuple::ColumnWiseTuple,::DataObject >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INTuple")), ::Reflex::BaseOffset< ::NTuple::ColumnWiseTuple,::INTuple >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ColumnWiseTuple -------------------------------
void __NTuple__ColumnWiseTuple_db_datamem(Reflex::Class*);
void __NTuple__ColumnWiseTuple_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__ColumnWiseTuple_datamem_bld(&__NTuple__ColumnWiseTuple_db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__ColumnWiseTuple_funcmem_bld(&__NTuple__ColumnWiseTuple_db_funcmem);
void __NTuple__ColumnWiseTuple_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::ColumnWiseTuple"), typeid(::NTuple::ColumnWiseTuple), sizeof(::NTuple::ColumnWiseTuple), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "0000002B-0000-0000-0000-000000000000")
  .AddBase(type_6008, ::Reflex::BaseOffset< ::NTuple::ColumnWiseTuple, ::NTuple::TupleImp >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27895, type_27896), Reflex::Literal("operator="), operator_20434, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134), Reflex::Literal("ColumnWiseTuple"), constructor_20435, 0, "title", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ColumnWiseTuple"), destructor_20436, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x246, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__ColumnWiseTuple_funcmem_bld);
}

//------Delayed data member builder for class ColumnWiseTuple -------------------
void __NTuple__ColumnWiseTuple_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class ColumnWiseTuple -------------------
void __NTuple__ColumnWiseTuple_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_20437, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("classID"), method_20438, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Matrix<float> -------------------------------
static void constructor_20439( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<float>(*(const ::NTuple::Matrix<float>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<float>(*(const ::NTuple::Matrix<float>*)arg[0]);
}

static void constructor_20440( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<float>();
  else ::new(mem) ::NTuple::Matrix<float>();
}

static void destructor_20441(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<float>*)o)->::NTuple::Matrix<float>::~Matrix)();
}
static void method_newdel_5988( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x248( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<float> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<float>,::NTuple::_Accessor<NTuple::_Matrix<float> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<float> -------------------------------
void __NTuple__Matrix_float__db_datamem(Reflex::Class*);
void __NTuple__Matrix_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_float__datamem_bld(&__NTuple__Matrix_float__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_float__funcmem_bld(&__NTuple__Matrix_float__db_funcmem);
void __NTuple__Matrix_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<float>"), typeid(::NTuple::Matrix<float>), sizeof(::NTuple::Matrix<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6029, ::Reflex::BaseOffset< ::NTuple::Matrix<float>, ::NTuple::_Accessor<NTuple::_Matrix<float> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27897), Reflex::Literal("Matrix"), constructor_20439, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20440, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20441, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5988, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x248, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<float> -------------------
void __NTuple__Matrix_float__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<float> -------------------
void __NTuple__Matrix_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<char> -------------------------------
static void constructor_20449( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<char>(*(const ::NTuple::Array<char>*)arg[0]);
  else ::new(mem) ::NTuple::Array<char>(*(const ::NTuple::Array<char>*)arg[0]);
}

static void constructor_20450( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<char>();
  else ::new(mem) ::NTuple::Array<char>();
}

static void destructor_20451(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<char>*)o)->::NTuple::Array<char>::~Array)();
}
static void method_newdel_5992( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x250( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<char> >")), ::Reflex::BaseOffset< ::NTuple::Array<char>,::NTuple::_Accessor<NTuple::_Array<char> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<char> -------------------------------
void __NTuple__Array_char__db_datamem(Reflex::Class*);
void __NTuple__Array_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_char__datamem_bld(&__NTuple__Array_char__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_char__funcmem_bld(&__NTuple__Array_char__db_funcmem);
void __NTuple__Array_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<char>"), typeid(::NTuple::Array<char>), sizeof(::NTuple::Array<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6048, ::Reflex::BaseOffset< ::NTuple::Array<char>, ::NTuple::_Accessor<NTuple::_Array<char> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27901), Reflex::Literal("Array"), constructor_20449, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20450, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20451, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5992, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x250, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<char> -------------------
void __NTuple__Array_char__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<char> -------------------
void __NTuple__Array_char__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<long int> -------------------------------
static void constructor_20452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<long>(*(const ::NTuple::Matrix<long>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<long>(*(const ::NTuple::Matrix<long>*)arg[0]);
}

static void constructor_20453( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<long>();
  else ::new(mem) ::NTuple::Matrix<long>();
}

static void destructor_20454(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<long>*)o)->::NTuple::Matrix<long>::~Matrix)();
}
static void method_newdel_5994( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x252( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<long> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<long>,::NTuple::_Accessor<NTuple::_Matrix<long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<long int> -------------------------------
void __NTuple__Matrix_long__db_datamem(Reflex::Class*);
void __NTuple__Matrix_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_long__datamem_bld(&__NTuple__Matrix_long__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_long__funcmem_bld(&__NTuple__Matrix_long__db_funcmem);
void __NTuple__Matrix_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<long>"), typeid(::NTuple::Matrix<long>), sizeof(::NTuple::Matrix<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6033, ::Reflex::BaseOffset< ::NTuple::Matrix<long>, ::NTuple::_Accessor<NTuple::_Matrix<long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27902), Reflex::Literal("Matrix"), constructor_20452, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20453, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20454, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5994, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x252, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<long int> -------------------
void __NTuple__Matrix_long__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<long int> -------------------
void __NTuple__Matrix_long__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<long unsigned int> -------------------------------
static void constructor_20479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned long>(*(const ::NTuple::Matrix<unsigned long>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<unsigned long>(*(const ::NTuple::Matrix<unsigned long>*)arg[0]);
}

static void constructor_20480( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<unsigned long>();
  else ::new(mem) ::NTuple::Matrix<unsigned long>();
}

static void destructor_20481(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<unsigned long>*)o)->::NTuple::Matrix<unsigned long>::~Matrix)();
}
static void method_newdel_6001( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x254( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<unsigned long> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned long>,::NTuple::_Accessor<NTuple::_Matrix<unsigned long> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<long unsigned int> -------------------------------
void __NTuple__Matrix_unsignedslong__db_datamem(Reflex::Class*);
void __NTuple__Matrix_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedslong__datamem_bld(&__NTuple__Matrix_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_unsignedslong__funcmem_bld(&__NTuple__Matrix_unsignedslong__db_funcmem);
void __NTuple__Matrix_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<unsigned long>"), typeid(::NTuple::Matrix<unsigned long>), sizeof(::NTuple::Matrix<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6032, ::Reflex::BaseOffset< ::NTuple::Matrix<unsigned long>, ::NTuple::_Accessor<NTuple::_Matrix<unsigned long> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27913), Reflex::Literal("Matrix"), constructor_20479, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20480, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20481, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6001, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x254, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<long unsigned int> -------------------
void __NTuple__Matrix_unsignedslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<long unsigned int> -------------------
void __NTuple__Matrix_unsignedslong__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<bool> -------------------------------
static void constructor_20482( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<bool>(*(const ::NTuple::Matrix<bool>*)arg[0]);
  else ::new(mem) ::NTuple::Matrix<bool>(*(const ::NTuple::Matrix<bool>*)arg[0]);
}

static void constructor_20483( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Matrix<bool>();
  else ::new(mem) ::NTuple::Matrix<bool>();
}

static void destructor_20484(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<bool>*)o)->::NTuple::Matrix<bool>::~Matrix)();
}
static void method_newdel_6002( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Matrix<bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x256( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Matrix<bool> >")), ::Reflex::BaseOffset< ::NTuple::Matrix<bool>,::NTuple::_Accessor<NTuple::_Matrix<bool> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Matrix<bool> -------------------------------
void __NTuple__Matrix_bool__db_datamem(Reflex::Class*);
void __NTuple__Matrix_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_bool__datamem_bld(&__NTuple__Matrix_bool__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_bool__funcmem_bld(&__NTuple__Matrix_bool__db_funcmem);
void __NTuple__Matrix_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<bool>"), typeid(::NTuple::Matrix<bool>), sizeof(::NTuple::Matrix<bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddBase(type_6038, ::Reflex::BaseOffset< ::NTuple::Matrix<bool>, ::NTuple::_Accessor<NTuple::_Matrix<bool> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27914), Reflex::Literal("Matrix"), constructor_20482, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Matrix"), constructor_20483, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20484, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6002, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x256, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Matrix<bool> -------------------
void __NTuple__Matrix_bool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<bool> -------------------
void __NTuple__Matrix_bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Matrix<IOpaqueAddress*> -------------------------------
static void destructor_20488(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Matrix<IOpaqueAddress*>*)o)->::NTuple::Matrix<IOpaqueAddress*>::~Matrix)();
}
static  void method_20489( void*, void* o, const std::vector<void*>&, void*)
{
  (((::NTuple::Matrix<IOpaqueAddress*>*)o)->dummy)();
}

//------Dictionary for class Matrix<IOpaqueAddress*> -------------------------------
void __NTuple__Matrix_IOpaqueAddressp__db_datamem(Reflex::Class*);
void __NTuple__Matrix_IOpaqueAddressp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_IOpaqueAddressp__datamem_bld(&__NTuple__Matrix_IOpaqueAddressp__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Matrix_IOpaqueAddressp__funcmem_bld(&__NTuple__Matrix_IOpaqueAddressp__db_funcmem);
void __NTuple__Matrix_IOpaqueAddressp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Matrix<IOpaqueAddress*>"), typeid(::NTuple::Matrix<IOpaqueAddress*>), sizeof(::NTuple::Matrix<IOpaqueAddress*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Matrix<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Matrix"), destructor_20488, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Matrix_IOpaqueAddressp__funcmem_bld);
}

//------Delayed data member builder for class Matrix<IOpaqueAddress*> -------------------
void __NTuple__Matrix_IOpaqueAddressp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Matrix<IOpaqueAddress*> -------------------
void __NTuple__Matrix_IOpaqueAddressp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("dummy"), method_20489, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class Array<unsigned int> -------------------------------
static void constructor_20525( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned int>(*(const ::NTuple::Array<unsigned int>*)arg[0]);
  else ::new(mem) ::NTuple::Array<unsigned int>(*(const ::NTuple::Array<unsigned int>*)arg[0]);
}

static void constructor_20526( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned int>();
  else ::new(mem) ::NTuple::Array<unsigned int>();
}

static void destructor_20527(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<unsigned int>*)o)->::NTuple::Array<unsigned int>::~Array)();
}
static void method_newdel_6009( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x258( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned int> >")), ::Reflex::BaseOffset< ::NTuple::Array<unsigned int>,::NTuple::_Accessor<NTuple::_Array<unsigned int> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<unsigned int> -------------------------------
void __NTuple__Array_unsignedsint__db_datamem(Reflex::Class*);
void __NTuple__Array_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedsint__datamem_bld(&__NTuple__Array_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedsint__funcmem_bld(&__NTuple__Array_unsignedsint__db_funcmem);
void __NTuple__Array_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<unsigned int>"), typeid(::NTuple::Array<unsigned int>), sizeof(::NTuple::Array<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6041, ::Reflex::BaseOffset< ::NTuple::Array<unsigned int>, ::NTuple::_Accessor<NTuple::_Array<unsigned int> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27919), Reflex::Literal("Array"), constructor_20525, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20526, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20527, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6009, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x258, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<unsigned int> -------------------
void __NTuple__Array_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<unsigned int> -------------------
void __NTuple__Array_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Directory -------------------------------
static  void operator_20528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Directory*)o)->operator=)(*(const ::NTuple::Directory*)arg[0]);
  else   (((::NTuple::Directory*)o)->operator=)(*(const ::NTuple::Directory*)arg[0]);
}

static void constructor_20529( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Directory(*(const ::NTuple::Directory*)arg[0]);
  else ::new(mem) ::NTuple::Directory(*(const ::NTuple::Directory*)arg[0]);
}

static void constructor_20530( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Directory();
  else ::new(mem) ::NTuple::Directory();
}

static void destructor_20531(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Directory*)o)->::NTuple::Directory::~Directory)();
}
static  void method_20532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::Directory*)o)->classID)();
  else   (((::NTuple::Directory*)o)->classID)();
}

static  void method_20533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::NTuple::Directory*)o)->clID)();
  else   (((const ::NTuple::Directory*)o)->clID)();
}

static void method_newdel_6012( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Directory >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Directory >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Directory >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Directory >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Directory >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x260( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::NTuple::Directory,::DataObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Directory -------------------------------
void __NTuple__Directory_db_datamem(Reflex::Class*);
void __NTuple__Directory_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Directory_datamem_bld(&__NTuple__Directory_db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Directory_funcmem_bld(&__NTuple__Directory_db_funcmem);
void __NTuple__Directory_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Directory"), typeid(::NTuple::Directory), sizeof(::NTuple::Directory), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00000029-0000-0000-0000-000000000000")
  .AddBase(type_303, ::Reflex::BaseOffset< ::NTuple::Directory, ::DataObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27920, type_27921), Reflex::Literal("operator="), operator_20528, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27921), Reflex::Literal("Directory"), constructor_20529, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Directory"), constructor_20530, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Directory"), destructor_20531, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6012, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x260, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Directory_funcmem_bld);
}

//------Delayed data member builder for class Directory -------------------
void __NTuple__Directory_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Directory -------------------
void __NTuple__Directory_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("classID"), method_20532, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_20533, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class Array<short unsigned int> -------------------------------
static void constructor_20534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned short>(*(const ::NTuple::Array<unsigned short>*)arg[0]);
  else ::new(mem) ::NTuple::Array<unsigned short>(*(const ::NTuple::Array<unsigned short>*)arg[0]);
}

static void constructor_20535( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<unsigned short>();
  else ::new(mem) ::NTuple::Array<unsigned short>();
}

static void destructor_20536(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<unsigned short>*)o)->::NTuple::Array<unsigned short>::~Array)();
}
static void method_newdel_6013( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x262( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<unsigned short> >")), ::Reflex::BaseOffset< ::NTuple::Array<unsigned short>,::NTuple::_Accessor<NTuple::_Array<unsigned short> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<short unsigned int> -------------------------------
void __NTuple__Array_unsignedsshort__db_datamem(Reflex::Class*);
void __NTuple__Array_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedsshort__datamem_bld(&__NTuple__Array_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_unsignedsshort__funcmem_bld(&__NTuple__Array_unsignedsshort__db_funcmem);
void __NTuple__Array_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<unsigned short>"), typeid(::NTuple::Array<unsigned short>), sizeof(::NTuple::Array<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6045, ::Reflex::BaseOffset< ::NTuple::Array<unsigned short>, ::NTuple::_Accessor<NTuple::_Array<unsigned short> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27922), Reflex::Literal("Array"), constructor_20534, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20535, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20536, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6013, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x262, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<short unsigned int> -------------------
void __NTuple__Array_unsignedsshort__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<short unsigned int> -------------------
void __NTuple__Array_unsignedsshort__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<short int> -------------------------------
static void constructor_20537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<short>(*(const ::NTuple::Array<short>*)arg[0]);
  else ::new(mem) ::NTuple::Array<short>(*(const ::NTuple::Array<short>*)arg[0]);
}

static void constructor_20538( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::Array<short>();
  else ::new(mem) ::NTuple::Array<short>();
}

static void destructor_20539(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<short>*)o)->::NTuple::Array<short>::~Array)();
}
static void method_newdel_6014( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NTuple::Array<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NTuple::Array<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NTuple::Array<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NTuple::Array<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NTuple::Array<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x264( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::_Accessor<NTuple::_Array<short> >")), ::Reflex::BaseOffset< ::NTuple::Array<short>,::NTuple::_Accessor<NTuple::_Array<short> > >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Array<short int> -------------------------------
void __NTuple__Array_short__db_datamem(Reflex::Class*);
void __NTuple__Array_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_short__datamem_bld(&__NTuple__Array_short__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_short__funcmem_bld(&__NTuple__Array_short__db_funcmem);
void __NTuple__Array_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<short>"), typeid(::NTuple::Array<short>), sizeof(::NTuple::Array<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddBase(type_6046, ::Reflex::BaseOffset< ::NTuple::Array<short>, ::NTuple::_Accessor<NTuple::_Array<short> > >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27923), Reflex::Literal("Array"), constructor_20537, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Array"), constructor_20538, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20539, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6014, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x264, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Array<short int> -------------------
void __NTuple__Array_short__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<short int> -------------------
void __NTuple__Array_short__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Array<IOpaqueAddress*> -------------------------------
static void destructor_20543(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::Array<IOpaqueAddress*>*)o)->::NTuple::Array<IOpaqueAddress*>::~Array)();
}
static  void method_20544( void*, void* o, const std::vector<void*>&, void*)
{
  (((::NTuple::Array<IOpaqueAddress*>*)o)->dummy)();
}

//------Dictionary for class Array<IOpaqueAddress*> -------------------------------
void __NTuple__Array_IOpaqueAddressp__db_datamem(Reflex::Class*);
void __NTuple__Array_IOpaqueAddressp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__Array_IOpaqueAddressp__datamem_bld(&__NTuple__Array_IOpaqueAddressp__db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__Array_IOpaqueAddressp__funcmem_bld(&__NTuple__Array_IOpaqueAddressp__db_funcmem);
void __NTuple__Array_IOpaqueAddressp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::Array<IOpaqueAddress*>"), typeid(::NTuple::Array<IOpaqueAddress*>), sizeof(::NTuple::Array<IOpaqueAddress*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "NTuple::Array<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Array"), destructor_20543, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__NTuple__Array_IOpaqueAddressp__funcmem_bld);
}

//------Delayed data member builder for class Array<IOpaqueAddress*> -------------------
void __NTuple__Array_IOpaqueAddressp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Array<IOpaqueAddress*> -------------------
void __NTuple__Array_IOpaqueAddressp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843), Reflex::Literal("dummy"), method_20544, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT);
}
//------Stub functions for class RowWiseTuple -------------------------------
static  void operator_20925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::RowWiseTuple*)o)->operator=)(*(const ::NTuple::RowWiseTuple*)arg[0]);
  else   (((::NTuple::RowWiseTuple*)o)->operator=)(*(const ::NTuple::RowWiseTuple*)arg[0]);
}

static void constructor_20926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NTuple::RowWiseTuple(*(const ::std::string*)arg[0]);
  else ::new(mem) ::NTuple::RowWiseTuple(*(const ::std::string*)arg[0]);
}

static void destructor_20927(void*, void * o, const std::vector<void*>&, void *) {
(((::NTuple::RowWiseTuple*)o)->::NTuple::RowWiseTuple::~RowWiseTuple)();
}
static  void method_20928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::NTuple::RowWiseTuple*)o)->clID)();
  else   (((const ::NTuple::RowWiseTuple*)o)->clID)();
}

static  void method_20929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NTuple::RowWiseTuple*)o)->classID)();
  else   (((::NTuple::RowWiseTuple*)o)->classID)();
}

static void method_x265( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::TupleImp")), ::Reflex::BaseOffset< ::NTuple::RowWiseTuple,::NTuple::TupleImp >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("NTuple::Tuple")), ::Reflex::BaseOffset< ::NTuple::RowWiseTuple,::NTuple::Tuple >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::NTuple::RowWiseTuple,::DataObject >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("INTuple")), ::Reflex::BaseOffset< ::NTuple::RowWiseTuple,::INTuple >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RowWiseTuple -------------------------------
void __NTuple__RowWiseTuple_db_datamem(Reflex::Class*);
void __NTuple__RowWiseTuple_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NTuple__RowWiseTuple_datamem_bld(&__NTuple__RowWiseTuple_db_datamem);
Reflex::GenreflexMemberBuilder __NTuple__RowWiseTuple_funcmem_bld(&__NTuple__RowWiseTuple_db_funcmem);
void __NTuple__RowWiseTuple_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NTuple::RowWiseTuple"), typeid(::NTuple::RowWiseTuple), sizeof(::NTuple::RowWiseTuple), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "0000002A-0000-0000-0000-000000000000")
  .AddBase(type_6008, ::Reflex::BaseOffset< ::NTuple::RowWiseTuple, ::NTuple::TupleImp >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28106, type_28107), Reflex::Literal("operator="), operator_20925, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134), Reflex::Literal("RowWiseTuple"), constructor_20926, 0, "title", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RowWiseTuple"), destructor_20927, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x265, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__NTuple__RowWiseTuple_funcmem_bld);
}

//------Delayed data member builder for class RowWiseTuple -------------------
void __NTuple__RowWiseTuple_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RowWiseTuple -------------------
void __NTuple__RowWiseTuple_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("clID"), method_20928, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("classID"), method_20929, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Param -------------------------------
static void destructor_24396(void*, void * o, const std::vector<void*>&, void *) {
(((::IRndmGen::Param*)o)->::IRndmGen::Param::~Param)();
}
static  void method_24397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::IRndmGen::Param*)o)->type)();
  else   (((const ::IRndmGen::Param*)o)->type)();
}

static  void method_24398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IRndmGen::Param*)o)->clone)());
  else   (((const ::IRndmGen::Param*)o)->clone)();
}

//------Dictionary for class Param -------------------------------
void __IRndmGen__Param_db_datamem(Reflex::Class*);
void __IRndmGen__Param_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IRndmGen__Param_datamem_bld(&__IRndmGen__Param_db_datamem);
Reflex::GenreflexMemberBuilder __IRndmGen__Param_funcmem_bld(&__IRndmGen__Param_db_funcmem);
void __IRndmGen__Param_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IRndmGen::Param"), typeid(::IRndmGen::Param), sizeof(::IRndmGen::Param), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Param"), destructor_24396, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__IRndmGen__Param_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IRndmGen__Param_funcmem_bld);
}

//------Delayed data member builder for class Param -------------------
void __IRndmGen__Param_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_210c, Reflex::Literal("m_type"), OffsetOf(__shadow__::__IRndmGen__Param, m_type), ::Reflex::PROTECTED | ::Reflex::CONST);
}
//------Delayed function member builder for class Param -------------------
void __IRndmGen__Param_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7851), Reflex::Literal("type"), method_24397, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27629), Reflex::Literal("clone"), method_24398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class Link -------------------------------
static void constructor_24413( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LinkManager::Link(*(const ::LinkManager::Link*)arg[0]);
  else ::new(mem) ::LinkManager::Link(*(const ::LinkManager::Link*)arg[0]);
}

static void constructor_24414( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::LinkManager::Link(*(long*)arg[0],
      *(const ::std::string*)arg[1]);
  else ::new(mem) ::LinkManager::Link(*(long*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LinkManager::Link(*(long*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::DataObject*)arg[2]);
  else ::new(mem) ::LinkManager::Link(*(long*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::DataObject*)arg[2]);
  }
}

static void constructor_24415( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LinkManager::Link();
  else ::new(mem) ::LinkManager::Link();
}

static  void operator_24416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LinkManager::Link*)o)->operator=)(*(const ::LinkManager::Link*)arg[0]);
  else   (((::LinkManager::Link*)o)->operator=)(*(const ::LinkManager::Link*)arg[0]);
}

static void destructor_24417(void*, void * o, const std::vector<void*>&, void *) {
(((::LinkManager::Link*)o)->::LinkManager::Link::~Link)();
}
static  void method_24418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LinkManager::Link*)o)->set)(*(long*)arg[0],
    *(const ::std::string*)arg[1],
    (const ::DataObject*)arg[2]);
}

static  void operator_24419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::LinkManager::Link*)o)->operator==)(*(const ::LinkManager::Link*)arg[0]));
  else   (((const ::LinkManager::Link*)o)->operator==)(*(const ::LinkManager::Link*)arg[0]);
}

static  void method_24420( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LinkManager::Link*)o)->setObject)((const ::DataObject*)arg[0]);
}

static  void method_24421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::LinkManager::Link*)o)->object)());
  else   (((const ::LinkManager::Link*)o)->object)();
}

static  void method_24422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LinkManager::Link*)o)->path)();
  else   (((const ::LinkManager::Link*)o)->path)();
}

static  void method_24423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::LinkManager::Link*)o)->ID)());
  else   (((const ::LinkManager::Link*)o)->ID)();
}

static  void method_24424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LinkManager::Link*)o)->address)());
  else   (((::LinkManager::Link*)o)->address)();
}

static void method_newdel_8321( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LinkManager::Link >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LinkManager::Link >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LinkManager::Link >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LinkManager::Link >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LinkManager::Link >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Link -------------------------------
void __LinkManager__Link_db_datamem(Reflex::Class*);
void __LinkManager__Link_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LinkManager__Link_datamem_bld(&__LinkManager__Link_db_datamem);
Reflex::GenreflexMemberBuilder __LinkManager__Link_funcmem_bld(&__LinkManager__Link_db_funcmem);
void __LinkManager__Link_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LinkManager::Link"), typeid(::LinkManager::Link), sizeof(::LinkManager::Link), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28737), Reflex::Literal("Link"), constructor_24413, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26, type_6134, type_19998), Reflex::Literal("Link"), constructor_24414, 0, "id;path;pObject=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Link"), constructor_24415, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Link"), destructor_24417, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8321, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LinkManager__Link_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LinkManager__Link_funcmem_bld);
}

//------Delayed data member builder for class Link -------------------
void __LinkManager__Link_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3236, Reflex::Literal("m_path"), OffsetOf(__shadow__::__LinkManager__Link, m_path), ::Reflex::PROTECTED)
  .AddDataMember(type_19429, Reflex::Literal("m_pObject"), OffsetOf(__shadow__::__LinkManager__Link, m_pObject), ::Reflex::PROTECTED | ::Reflex::TRANSIENT)
  .AddDataMember(type_26, Reflex::Literal("m_id"), OffsetOf(__shadow__::__LinkManager__Link, m_id), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Link -------------------
void __LinkManager__Link_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28738, type_28737), Reflex::Literal("operator="), operator_24416, 0, "link", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_26, type_6134, type_19998), Reflex::Literal("set"), method_24418, 0, "id;path;pObject", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206, type_28737), Reflex::Literal("operator=="), operator_24419, 0, "link", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_843, type_19998), Reflex::Literal("setObject"), method_24420, 0, "pObject", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19429), Reflex::Literal("object"), method_24421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("path"), method_24422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26), Reflex::Literal("ID"), method_24423, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19941), Reflex::Literal("address"), method_24424, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
static void function_4658( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(Gaudi::operator!=(*(const ::std::string*)arg[0],
    *(const ::Gaudi::StringKey*)arg[1]));
  else Gaudi::operator!=(*(const ::std::string*)arg[0],
    *(const ::Gaudi::StringKey*)arg[1]);
}
static void function_4659( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::createInstance(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
  else Gaudi::createInstance(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
}
static void function_4662( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::setInstance((::IAppMgrUI*)arg[0]);
  else Gaudi::setInstance((::IAppMgrUI*)arg[0]);
}
static void function_4663( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::setInstance((::ISvcLocator*)arg[0]);
  else Gaudi::setInstance((::ISvcLocator*)arg[0]);
}
static void function_4664( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::svcLocator();
  else Gaudi::svcLocator();
}
static void function_4672( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)(Gaudi::hash_value(*(const ::Gaudi::StringKey*)arg[0]));
  else Gaudi::hash_value(*(const ::Gaudi::StringKey*)arg[0]);
}
static void function_4673( void*, void*, const std::vector<void*>&, void*)
{
  Gaudi::popCurrentDataObject();
}
static void function_4674( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::getCurrentDataObject();
  else Gaudi::getCurrentDataObject();
}
static void function_4675( void*, void*, const std::vector<void*>& arg, void*)
{
  Gaudi::pushCurrentDataObject((::DataObject**)arg[0]);
}
static void function_4676( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::StringKey*)arg[1]);
  else Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::StringKey*)arg[1]);
}
static void function_4677( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::Histo1DDef*)arg[1]);
  else Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::Histo1DDef*)arg[1]);
}
static void function_4678( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::TimeSpan*)arg[1]);
  else Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::TimeSpan*)arg[1]);
}
static void function_4679( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::Time*)arg[1]);
  else Gaudi::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::Time*)arg[1]);
}
static void function_4680( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(Gaudi::operator==(*(const ::std::string*)arg[0],
    *(const ::Gaudi::StringKey*)arg[1]));
  else Gaudi::operator==(*(const ::std::string*)arg[0],
    *(const ::Gaudi::StringKey*)arg[1]);
}
static void function_4681( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::createApplicationMgrEx(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
  else Gaudi::createApplicationMgrEx(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_4683( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::createApplicationMgr();
  else Gaudi::createApplicationMgr();
}
static void function_4684( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::createApplicationMgr(*(const ::std::string*)arg[0]);
  else Gaudi::createApplicationMgr(*(const ::std::string*)arg[0]);
}
static void function_4685( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::createApplicationMgr(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
  else Gaudi::createApplicationMgr(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_8897( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::affinityMask());
    else System::affinityMask();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::affinityMask(*(::System::InfoType*)arg[0]));
    else System::affinityMask(*(::System::InfoType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::affinityMask(*(::System::InfoType*)arg[0],
      *(long*)arg[1]));
    else System::affinityMask(*(::System::InfoType*)arg[0],
      *(long*)arg[1]);
  }
}
static void function_8898( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)(System::procID());
  else System::procID();
}
static void function_8899( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::machineType();
  else System::machineType();
}
static void function_8902( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::upTime());
    else System::upTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::upTime(*(::System::TimeType*)arg[0]));
    else System::upTime(*(::System::TimeType*)arg[0]);
  }
}
static void function_8903( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)(System::typeinfoName((const char*)arg[0]));
  else System::typeinfoName((const char*)arg[0]);
}
static void function_8904( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)(System::typeinfoName(*(const ::std::type_info*)arg[0]));
  else System::typeinfoName(*(const ::std::type_info*)arg[0]);
}
static void function_8905( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::pagefileUsageLimit());
    else System::pagefileUsageLimit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsageLimit(*(::System::MemoryUnit*)arg[0]));
    else System::pagefileUsageLimit(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsageLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::pagefileUsageLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsageLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::pagefileUsageLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8906( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)9>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)9>(*(long long*)arg[0]);
}
static void function_8907( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)1>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)1>(*(long long*)arg[0]);
}
static void function_8908( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)8>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)8>(*(long long*)arg[0]);
}
static void function_8909( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)7>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)7>(*(long long*)arg[0]);
}
static void function_8910( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)6>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)6>(*(long long*)arg[0]);
}
static void function_8911( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)5>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)5>(*(long long*)arg[0]);
}
static void function_8912( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)4>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)4>(*(long long*)arg[0]);
}
static void function_8913( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)3>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)3>(*(long long*)arg[0]);
}
static void function_8914( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)2>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)2>(*(long long*)arg[0]);
}
static void function_8915( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)(System::adjustTime<(System::TimeType)0>(*(long long*)arg[0]));
  else System::adjustTime<(System::TimeType)0>(*(long long*)arg[0]);
}
static void function_8916( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (longlong)(System::adjustTime(*(::System::TimeType*)arg[0],
    *(::longlong*)arg[1]));
  else System::adjustTime(*(::System::TimeType*)arg[0],
    *(::longlong*)arg[1]);
}
static void function_8917( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (System::ThreadHandle)(System::threadSelf());
  else System::threadSelf();
}
static void function_8918( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::virtualMemoryLimit());
    else System::virtualMemoryLimit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemoryLimit(*(::System::MemoryUnit*)arg[0]));
    else System::virtualMemoryLimit(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::virtualMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::virtualMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8919( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (System::ProcessHandle)(System::processHandle());
  else System::processHandle();
}
static void function_8920( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::pagedMemoryPeak());
    else System::pagedMemoryPeak();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemoryPeak(*(::System::MemoryUnit*)arg[0]));
    else System::pagedMemoryPeak(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::pagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::pagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8921( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (StatusCode)(System::resolveEnv(*(const ::std::string*)arg[0],
      *(::std::string*)arg[1]));
    else System::resolveEnv(*(const ::std::string*)arg[0],
      *(::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (StatusCode)(System::resolveEnv(*(const ::std::string*)arg[0],
      *(::std::string*)arg[1],
      *(int*)arg[2]));
    else System::resolveEnv(*(const ::std::string*)arg[0],
      *(::std::string*)arg[1],
      *(int*)arg[2]);
  }
}
static void function_8922( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::nonPagedMemory());
    else System::nonPagedMemory();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemory(*(::System::MemoryUnit*)arg[0]));
    else System::nonPagedMemory(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::nonPagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::nonPagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8923( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::userTime());
    else System::userTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::userTime(*(::System::TimeType*)arg[0]));
    else System::userTime(*(::System::TimeType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (longlong)(System::userTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::userTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (longlong)(System::userTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::userTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8924( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::basePriority());
    else System::basePriority();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::basePriority(*(::System::InfoType*)arg[0]));
    else System::basePriority(*(::System::InfoType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::basePriority(*(::System::InfoType*)arg[0],
      *(long*)arg[1]));
    else System::basePriority(*(::System::InfoType*)arg[0],
      *(long*)arg[1]);
  }
}
static void function_8925( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)(System::argc());
  else System::argc();
}
static void function_8926( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)System::argv();
  else System::argv();
}
static void function_8929( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned long)(System::unloadDynamicLib(*(::System::ImageHandle*)arg[0]));
  else System::unloadDynamicLib(*(::System::ImageHandle*)arg[0]);
}
static void function_8930( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)(System::numCmdLineArgs());
  else System::numCmdLineArgs();
}
static void function_8931( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)(System::moduleType());
  else System::moduleType();
}
static void function_8932( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)(System::linkedModules());
  else System::linkedModules();
}
static void function_8933( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)(System::getErrorString(*(unsigned long*)arg[0]));
  else System::getErrorString(*(unsigned long*)arg[0]);
}
static void function_8934( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)(System::homeDirectory());
  else System::homeDirectory();
}
static void function_8935( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (int)(System::setEnv(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else System::setEnv(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (int)(System::setEnv(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2]));
    else System::setEnv(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(int*)arg[2]);
  }
}
static void function_8936( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::pagefileUsagePeak());
    else System::pagefileUsagePeak();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsagePeak(*(::System::MemoryUnit*)arg[0]));
    else System::pagefileUsagePeak(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsagePeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::pagefileUsagePeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsagePeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::pagefileUsagePeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8937( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned long)(System::loadDynamicLib(*(const ::std::string*)arg[0],
    (::System::ImageHandle*)arg[1]));
  else System::loadDynamicLib(*(const ::std::string*)arg[0],
    (::System::ImageHandle*)arg[1]);
}
static void function_8940( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::osName();
  else System::osName();
}
static void function_8941( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::numPageFault());
    else System::numPageFault();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::numPageFault(*(::System::InfoType*)arg[0]));
    else System::numPageFault(*(::System::InfoType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::numPageFault(*(::System::InfoType*)arg[0],
      *(long*)arg[1]));
    else System::numPageFault(*(::System::InfoType*)arg[0],
      *(long*)arg[1]);
  }
}
static void function_8942( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::virtualMemoryPeak());
    else System::virtualMemoryPeak();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemoryPeak(*(::System::MemoryUnit*)arg[0]));
    else System::virtualMemoryPeak(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::virtualMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::virtualMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8943( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::mappedMemory());
    else System::mappedMemory();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::mappedMemory(*(::System::MemoryUnit*)arg[0]));
    else System::mappedMemory(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::mappedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::mappedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::mappedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::mappedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8944( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::creationTime());
    else System::creationTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::creationTime(*(::System::TimeType*)arg[0]));
    else System::creationTime(*(::System::TimeType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (longlong)(System::creationTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::creationTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (longlong)(System::creationTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::creationTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8945( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(System::getStackLevel((void*)arg[0],
    *(void**)arg[1],
    *(::std::string*)arg[2],
    *(::std::string*)arg[3]));
  else System::getStackLevel((void*)arg[0],
    *(void**)arg[1],
    *(::std::string*)arg[2],
    *(::std::string*)arg[3]);
}
static void function_8946( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)(System::adjustMemory(*(::System::MemoryUnit*)arg[0],
    *(long*)arg[1]));
  else System::adjustMemory(*(::System::MemoryUnit*)arg[0],
    *(long*)arg[1]);
}
static void function_8947( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)(System::getEnv());
  else System::getEnv();
}
static void function_8948( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(System::getEnv(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]));
  else System::getEnv(*(const ::std::string*)arg[0],
    *(::std::string*)arg[1]);
}
static void function_8949( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(System::getEnv((const char*)arg[0],
    *(::std::string*)arg[1]));
  else System::getEnv((const char*)arg[0],
    *(::std::string*)arg[1]);
}
static void function_8950( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)(System::getEnv((const char*)arg[0]));
  else System::getEnv((const char*)arg[0]);
}
static void function_8951( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::currentTime());
    else System::currentTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::currentTime(*(::System::TimeType*)arg[0]));
    else System::currentTime(*(::System::TimeType*)arg[0]);
  }
}
static void function_8952( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (longlong)(System::tickCount());
  else System::tickCount();
}
static void function_8954( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned long)(System::getProcedureByName(*(::System::ImageHandle*)arg[0],
    *(const ::std::string*)arg[1],
    (::System::Creator*)arg[2]));
  else System::getProcedureByName(*(::System::ImageHandle*)arg[0],
    *(const ::std::string*)arg[1],
    (::System::Creator*)arg[2]);
}
static void function_8955( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned long)(System::getProcedureByName(*(::System::ImageHandle*)arg[0],
    *(const ::std::string*)arg[1],
    (::System::EntryPoint*)arg[2]));
  else System::getProcedureByName(*(::System::ImageHandle*)arg[0],
    *(const ::std::string*)arg[1],
    (::System::EntryPoint*)arg[2]);
}
static void function_8957( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::mappedMemoryPeak());
    else System::mappedMemoryPeak();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::mappedMemoryPeak(*(::System::MemoryUnit*)arg[0]));
    else System::mappedMemoryPeak(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::mappedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::mappedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::mappedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::mappedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8958( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::cpuTime());
    else System::cpuTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::cpuTime(*(::System::TimeType*)arg[0]));
    else System::cpuTime(*(::System::TimeType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (longlong)(System::cpuTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::cpuTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (longlong)(System::cpuTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::cpuTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8959( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)(System::getLastError());
  else System::getLastError();
}
static void function_8960( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::osVersion();
  else System::osVersion();
}
static void function_8961( void*, void*, const std::vector<void*>& arg, void*)
{
  System::setModuleHandle(*(::System::ImageHandle*)arg[0]);
}
static void function_8962( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::minMemoryLimit());
    else System::minMemoryLimit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::minMemoryLimit(*(::System::MemoryUnit*)arg[0]));
    else System::minMemoryLimit(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::minMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::minMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::minMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::minMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8963( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::pagefileUsage());
    else System::pagefileUsage();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsage(*(::System::MemoryUnit*)arg[0]));
    else System::pagefileUsage(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsage(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::pagefileUsage(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::pagefileUsage(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::pagefileUsage(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8965( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::pagedMemory());
    else System::pagedMemory();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemory(*(::System::MemoryUnit*)arg[0]));
    else System::pagedMemory(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::pagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::pagedMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8966( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)(System::cmdLineArgs());
  else System::cmdLineArgs();
}
static void function_8967( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)(System::tempDirectory());
  else System::tempDirectory();
}
static void function_8968( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::hostName();
  else System::hostName();
}
static void function_8969( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (bool)(System::backTrace(*(::std::string*)arg[0],
      *(const int*)arg[1]));
    else System::backTrace(*(::std::string*)arg[0],
      *(const int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (bool)(System::backTrace(*(::std::string*)arg[0],
      *(const int*)arg[1],
      *(const int*)arg[2]));
    else System::backTrace(*(::std::string*)arg[0],
      *(const int*)arg[1],
      *(const int*)arg[2]);
  }
}
static void function_8970( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)(System::backTrace((void**)arg[0],
    *(const int*)arg[1]));
  else System::backTrace((void**)arg[0],
    *(const int*)arg[1]);
}
static void function_8971( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (System::ImageHandle)(System::exeHandle());
  else System::exeHandle();
}
static void function_8973( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)(System::getLastErrorString());
  else System::getLastErrorString();
}
static void function_8974( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::moduleNameFull();
  else System::moduleNameFull();
}
static void function_8975( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (System::ImageHandle)(System::moduleHandle());
  else System::moduleHandle();
}
static void function_8976( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryLimit());
    else System::nonPagedMemoryLimit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryLimit(*(::System::MemoryUnit*)arg[0]));
    else System::nonPagedMemoryLimit(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::nonPagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::nonPagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8977( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::ellapsedTime());
    else System::ellapsedTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::ellapsedTime(*(::System::TimeType*)arg[0]));
    else System::ellapsedTime(*(::System::TimeType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (longlong)(System::ellapsedTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::ellapsedTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (longlong)(System::ellapsedTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::ellapsedTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8978( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::remainingTime());
    else System::remainingTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::remainingTime(*(::System::TimeType*)arg[0]));
    else System::remainingTime(*(::System::TimeType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (longlong)(System::remainingTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::remainingTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (longlong)(System::remainingTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::remainingTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8979( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)(System::breakExecution(*(long*)arg[0]));
  else System::breakExecution(*(long*)arg[0]);
}
static void function_8980( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)(System::breakExecution());
  else System::breakExecution();
}
static void function_8982( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryPeak());
    else System::nonPagedMemoryPeak();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryPeak(*(::System::MemoryUnit*)arg[0]));
    else System::nonPagedMemoryPeak(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::nonPagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::nonPagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::nonPagedMemoryPeak(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8983( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::priorityBoost());
    else System::priorityBoost();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::priorityBoost(*(::System::InfoType*)arg[0]));
    else System::priorityBoost(*(::System::InfoType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::priorityBoost(*(::System::InfoType*)arg[0],
      *(long*)arg[1]));
    else System::priorityBoost(*(::System::InfoType*)arg[0],
      *(long*)arg[1]);
  }
}
static void function_8984( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::exeName();
  else System::exeName();
}
static void function_8985( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::exitStatus());
    else System::exitStatus();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::exitStatus(*(::System::InfoType*)arg[0]));
    else System::exitStatus(*(::System::InfoType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::exitStatus(*(::System::InfoType*)arg[0],
      *(long*)arg[1]));
    else System::exitStatus(*(::System::InfoType*)arg[0],
      *(long*)arg[1]);
  }
}
static void function_8986( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::virtualMemory());
    else System::virtualMemory();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemory(*(::System::MemoryUnit*)arg[0]));
    else System::virtualMemory(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::virtualMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::virtualMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::virtualMemory(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8987( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (System::ProcessTime)(System::getProcessTime());
    else System::getProcessTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (System::ProcessTime)(System::getProcessTime(*(long*)arg[0]));
    else System::getProcessTime(*(long*)arg[0]);
  }
}
static void function_8988( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::pagedMemoryLimit());
    else System::pagedMemoryLimit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemoryLimit(*(::System::MemoryUnit*)arg[0]));
    else System::pagedMemoryLimit(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::pagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::pagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::pagedMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8990( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::kernelTime());
    else System::kernelTime();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::kernelTime(*(::System::TimeType*)arg[0]));
    else System::kernelTime(*(::System::TimeType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (longlong)(System::kernelTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::kernelTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (longlong)(System::kernelTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::kernelTime(*(::System::TimeType*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8991( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::accountName();
  else System::accountName();
}
static void function_8992( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (longlong)(System::systemStart());
    else System::systemStart();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (longlong)(System::systemStart(*(::System::TimeType*)arg[0]));
    else System::systemStart(*(::System::TimeType*)arg[0]);
  }
}
static void function_8993( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&System::moduleName();
  else System::moduleName();
}
static void function_8994( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::parentID());
    else System::parentID();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::parentID(*(::System::InfoType*)arg[0]));
    else System::parentID(*(::System::InfoType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::parentID(*(::System::InfoType*)arg[0],
      *(long*)arg[1]));
    else System::parentID(*(::System::InfoType*)arg[0],
      *(long*)arg[1]);
  }
}
static void function_8995( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (long)(System::maxMemoryLimit());
    else System::maxMemoryLimit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (long)(System::maxMemoryLimit(*(::System::MemoryUnit*)arg[0]));
    else System::maxMemoryLimit(*(::System::MemoryUnit*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (long)(System::maxMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]));
    else System::maxMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (long)(System::maxMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]));
    else System::maxMemoryLimit(*(::System::MemoryUnit*)arg[0],
      *(::System::InfoType*)arg[1],
      *(long*)arg[2]);
  }
}
static void function_8996( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(System::isEnvSet((const char*)arg[0]));
  else System::isEnvSet((const char*)arg[0]);
}
static void function_19540( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::GaudiUtils::VectorMap<Gaudi::StringKey,double,std::less<const Gaudi::StringKey>,std::allocator<std::pair<Gaudi::StringKey,double> > >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::GaudiUtils::VectorMap<Gaudi::StringKey,double,std::less<const Gaudi::StringKey>,std::allocator<std::pair<Gaudi::StringKey,double> > >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19541( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::GaudiUtils::VectorMap<std::basic_string<char>,double,std::less<const std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,double> > >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::GaudiUtils::VectorMap<std::basic_string<char>,double,std::less<const std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,double> > >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19542( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<Gaudi::StringKey>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<Gaudi::StringKey>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19543( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::Gaudi::StringKey*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::Gaudi::StringKey*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19544( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::pair<double,double> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::pair<double,double> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19545( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,Gaudi::Histo1DDef>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,Gaudi::Histo1DDef>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19546( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::Gaudi::Histo1DDef*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::Gaudi::Histo1DDef*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19547( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::string*)arg[0],
    *(::std::string*)arg[1],
    *(const ::std::string*)arg[2]));
  else Gaudi::Parsers::parse(*(::std::string*)arg[0],
    *(::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
}
static void function_19548( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,unsigned int>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,unsigned int>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19549( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<unsigned int,std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<unsigned int,std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19550( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<int,std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<int,std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19551( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::vector<double> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::vector<double> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19552( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::vector<int> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::vector<int> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19553( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19554( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,double>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,double>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19555( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,int>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,int>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19556( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19557( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<int,double>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<int,double>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19558( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::map<int,int>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::map<int,int>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19559( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<std::vector<double> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<std::vector<double> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19560( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19561( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<std::pair<int,int> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<std::pair<int,int> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19562( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<std::pair<double,double> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<std::pair<double,double> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19563( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::pair<int,int>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::pair<int,int>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19564( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::pair<double,double>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::pair<double,double>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19565( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<std::basic_string<char> >*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19566( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<long double>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<long double>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19567( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<float>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<float>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19568( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<double>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<double>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19569( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<unsigned long long>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<unsigned long long>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19570( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<long long>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<long long>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19571( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<unsigned long>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<unsigned long>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19572( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<long>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<long>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19573( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<unsigned int>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<unsigned int>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19574( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<unsigned short>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<unsigned short>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19575( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<short>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<short>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19576( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<int>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<int>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19577( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<signed char>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<signed char>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19578( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<unsigned char>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<unsigned char>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19579( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<char>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<char>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19580( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::vector<bool>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::vector<bool>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19581( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19582( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(long double*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(long double*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19583( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(float*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(float*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19584( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(double*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(double*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19585( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(unsigned long long*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(unsigned long long*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19586( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(long long*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(long long*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19587( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(unsigned long*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(unsigned long*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19588( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(long*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(long*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19589( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(unsigned int*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(unsigned int*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19590( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(unsigned short*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(unsigned short*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19591( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(short*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(short*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19592( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(int*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(int*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19593( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(signed char*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(signed char*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19594( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(unsigned char*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(unsigned char*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19595( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(char*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(char*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19596( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Parsers::parse(*(bool*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Parsers::parse(*(bool*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19624( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)(Gaudi::PluginService::Debug());
  else Gaudi::PluginService::Debug();
}
static void function_19626( void*, void*, const std::vector<void*>& arg, void*)
{
  Gaudi::PluginService::SetDebug(*(int*)arg[0]);
}
static void function_19628( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)(Gaudi::StateMachine::ChangeState(*(const ::Gaudi::StateMachine::Transition*)arg[0],
    *(const ::Gaudi::StateMachine::State*)arg[1]));
  else Gaudi::StateMachine::ChangeState(*(const ::Gaudi::StateMachine::Transition*)arg[0],
    *(const ::Gaudi::StateMachine::State*)arg[1]);
}
static void function_19630( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::StateMachine::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::StateMachine::Transition*)arg[1]);
  else Gaudi::StateMachine::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::StateMachine::Transition*)arg[1]);
}
static void function_19631( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::StateMachine::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::StateMachine::State*)arg[1]);
  else Gaudi::StateMachine::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::StateMachine::State*)arg[1]);
}
static void function_19679( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream((const char*)arg[0],
    *(::std::ostream*)arg[1]);
  else Gaudi::Utils::toStream((const char*)arg[0],
    *(::std::ostream*)arg[1]);
}
static void function_19680( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const long double*)arg[0],
      *(::std::ostream*)arg[1]);
    else Gaudi::Utils::toStream(*(const long double*)arg[0],
      *(::std::ostream*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const long double*)arg[0],
      *(::std::ostream*)arg[1],
      *(const int*)arg[2]);
    else Gaudi::Utils::toStream(*(const long double*)arg[0],
      *(::std::ostream*)arg[1],
      *(const int*)arg[2]);
  }
}
static void function_19681( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const double*)arg[0],
      *(::std::ostream*)arg[1]);
    else Gaudi::Utils::toStream(*(const double*)arg[0],
      *(::std::ostream*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const double*)arg[0],
      *(::std::ostream*)arg[1],
      *(const int*)arg[2]);
    else Gaudi::Utils::toStream(*(const double*)arg[0],
      *(::std::ostream*)arg[1],
      *(const int*)arg[2]);
  }
}
static void function_19682( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const float*)arg[0],
      *(::std::ostream*)arg[1]);
    else Gaudi::Utils::toStream(*(const float*)arg[0],
      *(::std::ostream*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const float*)arg[0],
      *(::std::ostream*)arg[1],
      *(const int*)arg[2]);
    else Gaudi::Utils::toStream(*(const float*)arg[0],
      *(::std::ostream*)arg[1],
      *(const int*)arg[2]);
  }
}
static void function_19683( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const bool*)arg[0],
    *(::std::ostream*)arg[1]);
  else Gaudi::Utils::toStream(*(const bool*)arg[0],
    *(::std::ostream*)arg[1]);
}
static void function_19684( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const ::std::string*)arg[0],
    *(::std::ostream*)arg[1]);
  else Gaudi::Utils::toStream(*(const ::std::string*)arg[0],
    *(::std::ostream*)arg[1]);
}
static void function_19685( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream<std::string>(*(const ::std::string*)arg[0],
    *(::std::basic_ostream<char,std::char_traits<char> >*)arg[1]);
  else Gaudi::Utils::toStream<std::string>(*(const ::std::string*)arg[0],
    *(::std::basic_ostream<char,std::char_traits<char> >*)arg[1]);
}
static void function_19686( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::toStream(*(const ::Gaudi::StringKey*)arg[0],
    *(::std::ostream*)arg[1]);
  else Gaudi::Utils::toStream(*(const ::Gaudi::StringKey*)arg[0],
    *(::std::ostream*)arg[1]);
}
static void function_19689( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::Utils::getProperty((const ::std::vector<const Property*>*)arg[0],
    *(const ::std::string*)arg[1]);
  else Gaudi::Utils::getProperty((const ::std::vector<const Property*>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19690( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::Utils::getProperty((const ::IInterface*)arg[0],
    *(const ::std::string*)arg[1]);
  else Gaudi::Utils::getProperty((const ::IInterface*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19691( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::Utils::getProperty((const ::IProperty*)arg[0],
    *(const ::std::string*)arg[1]);
  else Gaudi::Utils::getProperty((const ::IProperty*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19692( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2],
      *(const bool*)arg[3]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2],
      *(const bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2],
      *(const bool*)arg[3],
      *(const ::std::string*)arg[4]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2],
      *(const bool*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2],
      *(const bool*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::StatEntity*)arg[2],
      *(const bool*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}
static void function_19693( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1],
      *(const bool*)arg[2]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1],
      *(const bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1],
      *(const bool*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1],
      *(const bool*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1],
      *(const bool*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]));
    else Gaudi::Utils::formatAsTableRow(*(const ::std::string*)arg[0],
      *(const ::StatEntity*)arg[1],
      *(const bool*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]);
  }
}
static void function_19694( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::StatEntity*)arg[0],
      *(const bool*)arg[1]));
    else Gaudi::Utils::formatAsTableRow(*(const ::StatEntity*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::StatEntity*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::string*)arg[2]));
    else Gaudi::Utils::formatAsTableRow(*(const ::StatEntity*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (std::string)(Gaudi::Utils::formatAsTableRow(*(const ::StatEntity*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::formatAsTableRow(*(const ::StatEntity*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19695( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(Gaudi::Utils::hasProperty((const ::std::vector<const Property*>*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Utils::hasProperty((const ::std::vector<const Property*>*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19696( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(Gaudi::Utils::hasProperty((const ::IInterface*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Utils::hasProperty((const ::IInterface*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19697( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)(Gaudi::Utils::hasProperty((const ::IProperty*)arg[0],
    *(const ::std::string*)arg[1]));
  else Gaudi::Utils::hasProperty((const ::IProperty*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_19699( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19700( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19701( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19702( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19703( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::Property* const*)arg[2]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::Property* const*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::Property* const*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]));
    else Gaudi::Utils::setProperty((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::Property* const*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  }
}
static void function_19704( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty<std::string>((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::string*)arg[2]));
    else Gaudi::Utils::setProperty<std::string>((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty<std::string>((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]));
    else Gaudi::Utils::setProperty<std::string>((::IInterface*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  }
}
static void function_19705( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::Property*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19706( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const ::Property*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19707( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      (const char*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19708( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]));
    else Gaudi::Utils::setProperty((::IProperty*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  }
}
static void function_19709( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty((::IProperty*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(const ::Property* const*)arg[2],
    *(const ::std::basic_string<char>*)arg[3]));
  else Gaudi::Utils::setProperty((::IProperty*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(const ::Property* const*)arg[2],
    *(const ::std::basic_string<char>*)arg[3]);
}
static void function_19710( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (StatusCode)(Gaudi::Utils::setProperty<std::string>((::IProperty*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(const ::std::string*)arg[2],
    *(const ::std::basic_string<char>*)arg[3]));
  else Gaudi::Utils::setProperty<std::string>((::IProperty*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(const ::std::string*)arg[2],
    *(const ::std::basic_string<char>*)arg[3]);
}
static void function_19711( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::Utils::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::Utils::TypeNameString*)arg[1]);
  else Gaudi::Utils::operator<<(*(::std::ostream*)arg[0],
    *(const ::Gaudi::Utils::TypeNameString*)arg[1]);
}
static void function_19712( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::Histos::book((::IHistogramSvc*)arg[0],
    *(const ::std::string*)arg[1],
    *(const int*)arg[2],
    *(const ::Gaudi::Histo1DDef*)arg[3]);
  else Gaudi::Histos::book((::IHistogramSvc*)arg[0],
    *(const ::std::string*)arg[1],
    *(const int*)arg[2],
    *(const ::Gaudi::Histo1DDef*)arg[3]);
}
static void function_19713( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::Histos::book((::IHistogramSvc*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(const ::Gaudi::Histo1DDef*)arg[3]);
  else Gaudi::Histos::book((::IHistogramSvc*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(const ::Gaudi::Histo1DDef*)arg[3]);
}
static void function_19714( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::Histos::book((::IHistogramSvc*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::Gaudi::Histo1DDef*)arg[2]);
  else Gaudi::Histos::book((::IHistogramSvc*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::Gaudi::Histo1DDef*)arg[2]);
}
static void function_27691( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Gaudi::PluginService::Details::getCreator(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
  else Gaudi::PluginService::Details::getCreator(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}
static void function_27692( void*, void*, const std::vector<void*>& arg, void*)
{
  Gaudi::PluginService::Details::setLogger((::Gaudi::PluginService::Details::Logger*)arg[0]);
}
static void function_27693( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&Gaudi::PluginService::Details::logger();
  else Gaudi::PluginService::Details::logger();
}
static void function_27694( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)(Gaudi::PluginService::Details::demangle(*(const ::std::type_info*)arg[0]));
  else Gaudi::PluginService::Details::demangle(*(const ::std::type_info*)arg[0]);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __IInterface_dict(); 
      __extend_interfaces1_IInterface__dict(); 
      __IDataStreamTool_dict(); 
      __extend_interfaces1_IDataStreamTool__dict(); 
      __IProperty_dict(); 
      __extend_interfaces1_IProperty__dict(); 
      __extend_interfaces2_IService_IAuditor__dict(); 
      __GaudiHandleBase_dict(); 
      __GaudiHandleInfo_dict(); 
      __Incident_dict(); 
      __InterfaceID_dict(); 
      __IUpdateable_dict(); 
      __extends1_AlgTool_IDataStreamTool__dict(); 
      __DataObject_dict(); 
      __IDetDataSvc_dict(); 
      __IClassManager_dict(); 
      __implements1_IInterface__dict(); 
      __implements1_IProperty__dict(); 
      __IClassInfo_dict(); 
      __IAlgorithm_dict(); 
      __IIncidentListener_dict(); 
      __IStatusCodeSvc_dict(); 
      __ISerialize_dict(); 
      __IExceptionSvc_dict(); 
      __ObjectContainerBase_dict(); 
      __SmartDataObjectPtr_dict(); 
      __extend_interfaces3_IAlgTool_IProperty_IStateful__dict(); 
      __extend_interfaces3_IService_IProperty_IStateful__dict(); 
      __extend_interfaces3_IAlgorithm_IProperty_IStateful__dict(); 
      __extend_interfaces3_IService_IChronoSvc_IStatSvc__dict(); 
      __IDataStoreAgent_dict(); 
      __GaudiHandleArrayBase_dict(); 
      __IConversionSvc_dict(); 
      __IPersistencySvc_dict(); 
      __IMessageSvc_dict(); 
      __IMonitorSvc_dict(); 
      __IDataStoreLeaves_dict(); 
      __INTupleSvc_dict(); 
      __IAlgTool_dict(); 
      __IRndmEngine_dict(); 
      __IService_dict(); 
      __GenericAddress_dict(); 
      __IssueSeverity_dict(); 
      __IConverter_dict(); 
      __IEvtSelector_dict(); 
      __SmartDataStorePtr_ObjectContainerBase_SmartDataObjectPtr__ObjectLoader__dict(); 
      __SmartDataStorePtr_DataObject_SmartDataObjectPtr__ObjectLoader__dict(); 
      __GaudiHandleProperty_dict(); 
      __IUpdateManagerSvc_dict(); 
      __IPartitionControl_dict(); 
      __ISvcLocator_dict(); 
      __IAuditorSvc_dict(); 
      __GaudiHandleArrayProperty_dict(); 
      __AlgTool_dict(); 
      __ContainedObject_dict(); 
      __IInspector_dict(); 
      __Service_dict(); 
      __IDataSourceMgr_dict(); 
      __IDataProviderSvc_dict(); 
      __KeyedObject_unsignedslong__dict(); 
      __KeyedObject_long__dict(); 
      __KeyedObject_unsignedsint__dict(); 
      __KeyedObject_int__dict(); 
      __ITHistSvc_dict(); 
      __IAuditor_dict(); 
      __SmartIF_IAlgorithm__dict(); 
      __IIncidentSvc_dict(); 
      __SmartIF_IIncidentSvc__dict(); 
      __SmartIF_IService__dict(); 
      __SmartIF_IAuditorSvc__dict(); 
      __ISvcManager_dict(); 
      __SmartIF_ISvcManager__dict(); 
      __SmartIF_ISvcLocator__dict(); 
      __SmartIF_IMessageSvc__dict(); 
      __SmartIF_IMonitorSvc__dict(); 
      __IAlgContextSvc_dict(); 
      __SmartIF_IAlgContextSvc__dict(); 
      __IToolSvc_dict(); 
      __SmartIF_IToolSvc__dict(); 
      __SmartIF_IExceptionSvc__dict(); 
      __IRndmGenSvc_dict(); 
      __SmartIF_IRndmGenSvc__dict(); 
      __IChronoStatSvc_dict(); 
      __SmartIF_IChronoStatSvc__dict(); 
      __SmartIF_INTupleSvc__dict(); 
      __IHistogramSvc_dict(); 
      __SmartIF_IHistogramSvc__dict(); 
      __SmartIF_IConversionSvc__dict(); 
      __SmartIF_IDataProviderSvc__dict(); 
      __SmartIF_IProperty__dict(); 
      __SmartRefBase_dict(); 
      __ICounterSvc_dict(); 
      __IDataManagerSvc_dict(); 
      __IPartPropSvc_dict(); 
      __IRegistry_dict(); 
      __IStatSvc_dict(); 
      __IEventProcessor_dict(); 
      __SmartDataPtr_ObjectContainerBase__dict(); 
      __SmartDataPtr_DataObject__dict(); 
      __IJobOptionsSvc_dict(); 
      __INTuple_dict(); 
      __IParticlePropertySvc_dict(); 
      __implements3_IAlgTool_IProperty_IStateful__dict(); 
      __implements3_IService_IProperty_IStateful__dict(); 
      __implements3_IAlgorithm_IProperty_IStateful__dict(); 
      __IEventTimeDecoder_dict(); 
      __IStagerSvc_dict(); 
      __ICounterSummarySvc_dict(); 
      __Property_dict(); 
      __IHistorySvc_dict(); 
      __IAlgManager_dict(); 
      __IChronoSvc_dict(); 
      __ISelectStatement_dict(); 
      __IMagneticFieldSvc_dict(); 
      __IValidity_dict(); 
      __IAppMgrUI_dict(); 
      __IAddressCreator_dict(); 
      __SmartRefVector_KeyedObject_unsignedslong_s__dict(); 
      __SmartRefVector_KeyedObject_long_s__dict(); 
      __SmartRefVector_KeyedObject_unsignedsint_s__dict(); 
      __SmartRefVector_KeyedObject_int_s__dict(); 
      __SmartRefVector_ObjectContainerBase__dict(); 
      __SmartRefVector_ContainedObject__dict(); 
      __SmartRefVector_DataObject__dict(); 
      __IStateful_dict(); 
      __IRndmGen_dict(); 
      __SmartRef_KeyedObject_unsignedslong_s__dict(); 
      __SmartRef_KeyedObject_long_s__dict(); 
      __SmartRef_KeyedObject_unsignedsint_s__dict(); 
      __SmartRef_KeyedObject_int_s__dict(); 
      __SmartRef_ObjectContainerBase__dict(); 
      __SmartRef_ContainedObject__dict(); 
      __SmartRef_DataObject__dict(); 
      __LinkManager_dict(); 
      __INamedInterface_dict(); 
      __IOpaqueAddress_dict(); 
      __IRunable_dict(); 
      __StatusCode_dict(); 
      __Algorithm_dict(); 
      __IIssueLogger_dict(); 
      __IInspectable_dict(); 
      __std__vector_ContainedObjectp__dict(); 
      __std__vector_constsContainedObjectp__dict(); 
      __std__vector_LinkManager__Linkp__dict(); 
      __std__vector_SmartRef_KeyedObject_unsignedslong_s_s__dict(); 
      __std__vector_SmartRef_KeyedObject_long_s_s__dict(); 
      __std__vector_SmartRef_KeyedObject_unsignedsint_s_s__dict(); 
      __std__vector_SmartRef_KeyedObject_int_s_s__dict(); 
      __std__vector_SmartRef_ObjectContainerBase_s__dict(); 
      __std__vector_SmartRef_ContainedObject_s__dict(); 
      __std__vector_SmartRef_DataObject_s__dict(); 
      __std__basic_string_char__dict(); 
      __Rndm__Binomial_dict(); 
      __Rndm__Bit_dict(); 
      __Rndm__StudentT_dict(); 
      __Rndm__DefinedPdf_dict(); 
      __Rndm__Gamma_dict(); 
      __Rndm__Exponential_dict(); 
      __Rndm__Gauss_dict(); 
      __Rndm__BreitWignerCutOff_dict(); 
      __Rndm__Poisson_dict(); 
      __Rndm__BreitWigner_dict(); 
      __Rndm__Chi2_dict(); 
      __Rndm__GaussianTail_dict(); 
      __Rndm__Flat_dict(); 
      __Rndm__Landau_dict(); 
      __Rndm__Numbers_dict(); 
      __Gaudi__Time_dict(); 
      __SmartDataObjectPtr__ObjectLoader_dict(); 
      __SmartDataObjectPtr__ObjectFinder_dict(); 
      __IUpdateManagerSvc__PythonHelper_dict(); 
      __NTuple__Array_double__dict(); 
      __NTuple__Matrix_unsignedsshort__dict(); 
      __NTuple__Array_unsignedschar__dict(); 
      __NTuple__Matrix_char__dict(); 
      __NTuple__Matrix_unsignedsint__dict(); 
      __NTuple__Array_float__dict(); 
      __NTuple__Array_bool__dict(); 
      __NTuple__Array_int__dict(); 
      __NTuple__Matrix_int__dict(); 
      __NTuple__Matrix_double__dict(); 
      __NTuple__Array_unsignedslong__dict(); 
      __NTuple__Matrix_unsignedschar__dict(); 
      __NTuple__Matrix_short__dict(); 
      __NTuple__File_dict(); 
      __NTuple__Item_double__dict(); 
      __NTuple__Array_long__dict(); 
      __NTuple__Item_bool__dict(); 
      __NTuple__Item_float__dict(); 
      __NTuple__Item_unsignedsint__dict(); 
      __NTuple__Item_int__dict(); 
      __NTuple__Item_unsignedslongslong__dict(); 
      __NTuple__Item_unsignedslong__dict(); 
      __NTuple__Item_longslong__dict(); 
      __NTuple__Item_long__dict(); 
      __NTuple__Item_unsignedsshort__dict(); 
      __NTuple__Item_short__dict(); 
      __NTuple__Item_unsignedschar__dict(); 
      __NTuple__Item_char__dict(); 
      __NTuple__ColumnWiseTuple_dict(); 
      __NTuple__Matrix_float__dict(); 
      __NTuple__Array_char__dict(); 
      __NTuple__Matrix_long__dict(); 
      __NTuple__Matrix_unsignedslong__dict(); 
      __NTuple__Matrix_bool__dict(); 
      __NTuple__Matrix_IOpaqueAddressp__dict(); 
      __NTuple__Array_unsignedsint__dict(); 
      __NTuple__Directory_dict(); 
      __NTuple__Array_unsignedsshort__dict(); 
      __NTuple__Array_short__dict(); 
      __NTuple__Array_IOpaqueAddressp__dict(); 
      __NTuple__RowWiseTuple_dict(); 
      __IRndmGen__Param_dict(); 
      __LinkManager__Link_dict(); 
      ::Reflex::Type t0 = ::Reflex::FunctionTypeBuilder(type_4206, type_6134, type_19538);      ::Reflex::FunctionBuilder(t0, Reflex::Literal("Gaudi::operator!="), function_4658, 0, Reflex::Literal("key1;key2"), ::Reflex::PUBLIC);
      ::Reflex::Type t1 = ::Reflex::FunctionTypeBuilder(type_19539, type_6134, type_6134, type_6134);      ::Reflex::FunctionBuilder(t1, Reflex::Literal("Gaudi::createInstance"), function_4659, 0, Reflex::Literal("name;factname;ddlname"), ::Reflex::PUBLIC);
      ::Reflex::Type t2 = ::Reflex::FunctionTypeBuilder(type_19623, type_19623);      ::Reflex::FunctionBuilder(t2, Reflex::Literal("Gaudi::setInstance"), function_4662, 0, Reflex::Literal("newInstance"), ::Reflex::PUBLIC);
      ::Reflex::Type t3 = ::Reflex::FunctionTypeBuilder(type_19445, type_19445);      ::Reflex::FunctionBuilder(t3, Reflex::Literal("Gaudi::setInstance"), function_4663, 0, Reflex::Literal("newInstance"), ::Reflex::PUBLIC);
      ::Reflex::Type t4 = ::Reflex::FunctionTypeBuilder(type_19445);      ::Reflex::FunctionBuilder(t4, Reflex::Literal("Gaudi::svcLocator"), function_4664, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t5 = ::Reflex::FunctionTypeBuilder(type_3592, type_19538);      ::Reflex::FunctionBuilder(t5, Reflex::Literal("Gaudi::hash_value"), function_4672, 0, Reflex::Literal("key"), ::Reflex::PUBLIC);
      ::Reflex::Type t6 = ::Reflex::FunctionTypeBuilder(type_843);      ::Reflex::FunctionBuilder(t6, Reflex::Literal("Gaudi::popCurrentDataObject"), function_4673, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t7 = ::Reflex::FunctionTypeBuilder(type_19429);      ::Reflex::FunctionBuilder(t7, Reflex::Literal("Gaudi::getCurrentDataObject"), function_4674, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t8 = ::Reflex::FunctionTypeBuilder(type_843, type_19715);      ::Reflex::FunctionBuilder(t8, Reflex::Literal("Gaudi::pushCurrentDataObject"), function_4675, 0, Reflex::Literal("pobjAddr"), ::Reflex::PUBLIC);
      ::Reflex::Type t9 = ::Reflex::FunctionTypeBuilder(type_7831, type_7831, type_19538);      ::Reflex::FunctionBuilder(t9, Reflex::Literal("Gaudi::operator<<"), function_4676, 0, Reflex::Literal("o;key"), ::Reflex::PUBLIC);
      ::Reflex::Type t10 = ::Reflex::FunctionTypeBuilder(type_7831, type_7831, type_19716);      ::Reflex::FunctionBuilder(t10, Reflex::Literal("Gaudi::operator<<"), function_4677, 0, Reflex::Literal("o;histo"), ::Reflex::PUBLIC);
      ::Reflex::Type t11 = ::Reflex::FunctionTypeBuilder(type_7831, type_7831, type_4402);      ::Reflex::FunctionBuilder(t11, Reflex::Literal("Gaudi::operator<<"), function_4678, 0, Reflex::Literal("out;time"), ::Reflex::PUBLIC);
      ::Reflex::Type t12 = ::Reflex::FunctionTypeBuilder(type_7831, type_7831, type_4403);      ::Reflex::FunctionBuilder(t12, Reflex::Literal("Gaudi::operator<<"), function_4679, 0, Reflex::Literal("out;time"), ::Reflex::PUBLIC);
      ::Reflex::Type t13 = ::Reflex::FunctionTypeBuilder(type_4206, type_6134, type_19538);      ::Reflex::FunctionBuilder(t13, Reflex::Literal("Gaudi::operator=="), function_4680, 0, Reflex::Literal("key1;key2"), ::Reflex::PUBLIC);
      ::Reflex::Type t14 = ::Reflex::FunctionTypeBuilder(type_19623, type_6134, type_6134);      ::Reflex::FunctionBuilder(t14, Reflex::Literal("Gaudi::createApplicationMgrEx"), function_4681, 0, Reflex::Literal("dllname;factname"), ::Reflex::PUBLIC);
      ::Reflex::Type t15 = ::Reflex::FunctionTypeBuilder(type_19623);      ::Reflex::FunctionBuilder(t15, Reflex::Literal("Gaudi::createApplicationMgr"), function_4683, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t16 = ::Reflex::FunctionTypeBuilder(type_19623, type_6134);      ::Reflex::FunctionBuilder(t16, Reflex::Literal("Gaudi::createApplicationMgr"), function_4684, 0, Reflex::Literal("dllname"), ::Reflex::PUBLIC);
      ::Reflex::Type t17 = ::Reflex::FunctionTypeBuilder(type_19623, type_6134, type_6134);      ::Reflex::FunctionBuilder(t17, Reflex::Literal("Gaudi::createApplicationMgr"), function_4685, 0, Reflex::Literal("dllname;factname"), ::Reflex::PUBLIC);
      ::Reflex::Type t18 = ::Reflex::FunctionTypeBuilder(type_26, type_8939, type_26);      ::Reflex::FunctionBuilder(t18, Reflex::Literal("System::affinityMask"), function_8897, 0, Reflex::Literal("fetch=ProcessBasics;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t19 = ::Reflex::FunctionTypeBuilder(type_26);      ::Reflex::FunctionBuilder(t19, Reflex::Literal("System::procID"), function_8898, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t20 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t20, Reflex::Literal("System::machineType"), function_8899, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t21 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981);      ::Reflex::FunctionBuilder(t21, Reflex::Literal("System::upTime"), function_8902, 0, Reflex::Literal("typ=Hour"), ::Reflex::PUBLIC);
      ::Reflex::Type t22 = ::Reflex::FunctionTypeBuilder(type_3236c, type_4095);      ::Reflex::FunctionBuilder(t22, Reflex::Literal("System::typeinfoName"), function_8903, 0, Reflex::Literal(""), ::Reflex::PUBLIC);
      ::Reflex::Type t23 = ::Reflex::FunctionTypeBuilder(type_3236c, type_19928);      ::Reflex::FunctionBuilder(t23, Reflex::Literal("System::typeinfoName"), function_8904, 0, Reflex::Literal(""), ::Reflex::PUBLIC);
      ::Reflex::Type t24 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t24, Reflex::Literal("System::pagefileUsageLimit"), function_8905, 0, Reflex::Literal("unit=kByte;fetch=Quota;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t25 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t25, Reflex::Literal("System::adjustTime<(System::TimeType)9>"), function_8906, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t26 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t26, Reflex::Literal("System::adjustTime<(System::TimeType)1>"), function_8907, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t27 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t27, Reflex::Literal("System::adjustTime<(System::TimeType)8>"), function_8908, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t28 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t28, Reflex::Literal("System::adjustTime<(System::TimeType)7>"), function_8909, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t29 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t29, Reflex::Literal("System::adjustTime<(System::TimeType)6>"), function_8910, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t30 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t30, Reflex::Literal("System::adjustTime<(System::TimeType)5>"), function_8911, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t31 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t31, Reflex::Literal("System::adjustTime<(System::TimeType)4>"), function_8912, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t32 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t32, Reflex::Literal("System::adjustTime<(System::TimeType)3>"), function_8913, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t33 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t33, Reflex::Literal("System::adjustTime<(System::TimeType)2>"), function_8914, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t34 = ::Reflex::FunctionTypeBuilder(type_189, type_189);      ::Reflex::FunctionBuilder(t34, Reflex::Literal("System::adjustTime<(System::TimeType)0>"), function_8915, 0, Reflex::Literal("t"), ::Reflex::PUBLIC);
      ::Reflex::Type t35 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981, type_1498);      ::Reflex::FunctionBuilder(t35, Reflex::Literal("System::adjustTime"), function_8916, 0, Reflex::Literal("typ;timevalue"), ::Reflex::PUBLIC);
      ::Reflex::Type t36 = ::Reflex::FunctionTypeBuilder(type_8956);      ::Reflex::FunctionBuilder(t36, Reflex::Literal("System::threadSelf"), function_8917, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t37 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t37, Reflex::Literal("System::virtualMemoryLimit"), function_8918, 0, Reflex::Literal("unit=kByte;fetch=Quota;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t38 = ::Reflex::FunctionTypeBuilder(type_8989);      ::Reflex::FunctionBuilder(t38, Reflex::Literal("System::processHandle"), function_8919, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t39 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t39, Reflex::Literal("System::pagedMemoryPeak"), function_8920, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t40 = ::Reflex::FunctionTypeBuilder(type_2872, type_6134, type_19991, type_142);      ::Reflex::FunctionBuilder(t40, Reflex::Literal("System::resolveEnv"), function_8921, 0, Reflex::Literal("var;res;recusions=124"), ::Reflex::PUBLIC);
      ::Reflex::Type t41 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t41, Reflex::Literal("System::nonPagedMemory"), function_8922, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t42 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981, type_8939, type_26);      ::Reflex::FunctionBuilder(t42, Reflex::Literal("System::userTime"), function_8923, 0, Reflex::Literal("typ=milliSec;fetch=Times;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t43 = ::Reflex::FunctionTypeBuilder(type_26, type_8939, type_26);      ::Reflex::FunctionBuilder(t43, Reflex::Literal("System::basePriority"), function_8924, 0, Reflex::Literal("fetch=ProcessBasics;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t44 = ::Reflex::FunctionTypeBuilder(type_26);      ::Reflex::FunctionBuilder(t44, Reflex::Literal("System::argc"), function_8925, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t45 = ::Reflex::FunctionTypeBuilder(type_4141);      ::Reflex::FunctionBuilder(t45, Reflex::Literal("System::argv"), function_8926, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t46 = ::Reflex::FunctionTypeBuilder(type_502, type_8964);      ::Reflex::FunctionBuilder(t46, Reflex::Literal("System::unloadDynamicLib"), function_8929, 0, Reflex::Literal("handle"), ::Reflex::PUBLIC);
      ::Reflex::Type t47 = ::Reflex::FunctionTypeBuilder(type_26);      ::Reflex::FunctionBuilder(t47, Reflex::Literal("System::numCmdLineArgs"), function_8930, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t48 = ::Reflex::FunctionTypeBuilder(type_8953);      ::Reflex::FunctionBuilder(t48, Reflex::Literal("System::moduleType"), function_8931, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t49 = ::Reflex::FunctionTypeBuilder(type_3165c);      ::Reflex::FunctionBuilder(t49, Reflex::Literal("System::linkedModules"), function_8932, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t50 = ::Reflex::FunctionTypeBuilder(type_3236c, type_502);      ::Reflex::FunctionBuilder(t50, Reflex::Literal("System::getErrorString"), function_8933, 0, Reflex::Literal("error"), ::Reflex::PUBLIC);
      ::Reflex::Type t51 = ::Reflex::FunctionTypeBuilder(type_3236);      ::Reflex::FunctionBuilder(t51, Reflex::Literal("System::homeDirectory"), function_8934, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t52 = ::Reflex::FunctionTypeBuilder(type_142, type_6134, type_6134, type_142);      ::Reflex::FunctionBuilder(t52, Reflex::Literal("System::setEnv"), function_8935, 0, Reflex::Literal("name;value;overwrite=1"), ::Reflex::PUBLIC);
      ::Reflex::Type t53 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t53, Reflex::Literal("System::pagefileUsagePeak"), function_8936, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t54 = ::Reflex::FunctionTypeBuilder(type_502, type_6134, type_26073);      ::Reflex::FunctionBuilder(t54, Reflex::Literal("System::loadDynamicLib"), function_8937, 0, Reflex::Literal("name;handle"), ::Reflex::PUBLIC);
      ::Reflex::Type t55 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t55, Reflex::Literal("System::osName"), function_8940, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t56 = ::Reflex::FunctionTypeBuilder(type_26, type_8939, type_26);      ::Reflex::FunctionBuilder(t56, Reflex::Literal("System::numPageFault"), function_8941, 0, Reflex::Literal("fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t57 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t57, Reflex::Literal("System::virtualMemoryPeak"), function_8942, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t58 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t58, Reflex::Literal("System::mappedMemory"), function_8943, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t59 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981, type_8939, type_26);      ::Reflex::FunctionBuilder(t59, Reflex::Literal("System::creationTime"), function_8944, 0, Reflex::Literal("typ=milliSec;fetch=Times;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t60 = ::Reflex::FunctionTypeBuilder(type_4206, type_1454, type_12772, type_19991, type_19991);      ::Reflex::FunctionBuilder(t60, Reflex::Literal("System::getStackLevel"), function_8945, 0, Reflex::Literal("addresses;addr;fnc;lib"), ::Reflex::PUBLIC);
      ::Reflex::Type t61 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_26);      ::Reflex::FunctionBuilder(t61, Reflex::Literal("System::adjustMemory"), function_8946, 0, Reflex::Literal("typ;value"), ::Reflex::PUBLIC);
      ::Reflex::Type t62 = ::Reflex::FunctionTypeBuilder(type_3165);      ::Reflex::FunctionBuilder(t62, Reflex::Literal("System::getEnv"), function_8947, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t63 = ::Reflex::FunctionTypeBuilder(type_4206, type_6134, type_19991);      ::Reflex::FunctionBuilder(t63, Reflex::Literal("System::getEnv"), function_8948, 0, Reflex::Literal("var;value"), ::Reflex::PUBLIC);
      ::Reflex::Type t64 = ::Reflex::FunctionTypeBuilder(type_4206, type_4095, type_19991);      ::Reflex::FunctionBuilder(t64, Reflex::Literal("System::getEnv"), function_8949, 0, Reflex::Literal("var;value"), ::Reflex::PUBLIC);
      ::Reflex::Type t65 = ::Reflex::FunctionTypeBuilder(type_3236, type_4095);      ::Reflex::FunctionBuilder(t65, Reflex::Literal("System::getEnv"), function_8950, 0, Reflex::Literal("var"), ::Reflex::PUBLIC);
      ::Reflex::Type t66 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981);      ::Reflex::FunctionBuilder(t66, Reflex::Literal("System::currentTime"), function_8951, 0, Reflex::Literal("typ=milliSec"), ::Reflex::PUBLIC);
      ::Reflex::Type t67 = ::Reflex::FunctionTypeBuilder(type_1498);      ::Reflex::FunctionBuilder(t67, Reflex::Literal("System::tickCount"), function_8952, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t68 = ::Reflex::FunctionTypeBuilder(type_502, type_8964, type_6134, type_26084);      ::Reflex::FunctionBuilder(t68, Reflex::Literal("System::getProcedureByName"), function_8954, 0, Reflex::Literal("handle;name;pFunction"), ::Reflex::PUBLIC);
      ::Reflex::Type t69 = ::Reflex::FunctionTypeBuilder(type_502, type_8964, type_6134, type_26085);      ::Reflex::FunctionBuilder(t69, Reflex::Literal("System::getProcedureByName"), function_8955, 0, Reflex::Literal("handle;name;pFunction"), ::Reflex::PUBLIC);
      ::Reflex::Type t70 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t70, Reflex::Literal("System::mappedMemoryPeak"), function_8957, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t71 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981, type_8939, type_26);      ::Reflex::FunctionBuilder(t71, Reflex::Literal("System::cpuTime"), function_8958, 0, Reflex::Literal("typ=milliSec;fetch=Times;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t72 = ::Reflex::FunctionTypeBuilder(type_502);      ::Reflex::FunctionBuilder(t72, Reflex::Literal("System::getLastError"), function_8959, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t73 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t73, Reflex::Literal("System::osVersion"), function_8960, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t74 = ::Reflex::FunctionTypeBuilder(type_843, type_8964);      ::Reflex::FunctionBuilder(t74, Reflex::Literal("System::setModuleHandle"), function_8961, 0, Reflex::Literal("handle"), ::Reflex::PUBLIC);
      ::Reflex::Type t75 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t75, Reflex::Literal("System::minMemoryLimit"), function_8962, 0, Reflex::Literal("unit=kByte;fetch=Quota;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t76 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t76, Reflex::Literal("System::pagefileUsage"), function_8963, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t77 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t77, Reflex::Literal("System::pagedMemory"), function_8965, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t78 = ::Reflex::FunctionTypeBuilder(type_3165c);      ::Reflex::FunctionBuilder(t78, Reflex::Literal("System::cmdLineArgs"), function_8966, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t79 = ::Reflex::FunctionTypeBuilder(type_3236);      ::Reflex::FunctionBuilder(t79, Reflex::Literal("System::tempDirectory"), function_8967, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t80 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t80, Reflex::Literal("System::hostName"), function_8968, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t81 = ::Reflex::FunctionTypeBuilder(type_4206, type_19991, type_142c, type_142c);      ::Reflex::FunctionBuilder(t81, Reflex::Literal("System::backTrace"), function_8969, 0, Reflex::Literal("btrace;depth;offset=0"), ::Reflex::PUBLIC);
      ::Reflex::Type t82 = ::Reflex::FunctionTypeBuilder(type_142, type_4283, type_142c);      ::Reflex::FunctionBuilder(t82, Reflex::Literal("System::backTrace"), function_8970, 0, Reflex::Literal("addresses;depth"), ::Reflex::PUBLIC);
      ::Reflex::Type t83 = ::Reflex::FunctionTypeBuilder(type_8964);      ::Reflex::FunctionBuilder(t83, Reflex::Literal("System::exeHandle"), function_8971, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t84 = ::Reflex::FunctionTypeBuilder(type_3236c);      ::Reflex::FunctionBuilder(t84, Reflex::Literal("System::getLastErrorString"), function_8973, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t85 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t85, Reflex::Literal("System::moduleNameFull"), function_8974, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t86 = ::Reflex::FunctionTypeBuilder(type_8964);      ::Reflex::FunctionBuilder(t86, Reflex::Literal("System::moduleHandle"), function_8975, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t87 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t87, Reflex::Literal("System::nonPagedMemoryLimit"), function_8976, 0, Reflex::Literal("unit=kByte;fetch=Quota;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t88 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981, type_8939, type_26);      ::Reflex::FunctionBuilder(t88, Reflex::Literal("System::ellapsedTime"), function_8977, 0, Reflex::Literal("typ=milliSec;fetch=Times;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t89 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981, type_8939, type_26);      ::Reflex::FunctionBuilder(t89, Reflex::Literal("System::remainingTime"), function_8978, 0, Reflex::Literal("typ=milliSec;fetch=Quota;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t90 = ::Reflex::FunctionTypeBuilder(type_26, type_26);      ::Reflex::FunctionBuilder(t90, Reflex::Literal("System::breakExecution"), function_8979, 0, Reflex::Literal("pid"), ::Reflex::PUBLIC);
      ::Reflex::Type t91 = ::Reflex::FunctionTypeBuilder(type_26);      ::Reflex::FunctionBuilder(t91, Reflex::Literal("System::breakExecution"), function_8980, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t92 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t92, Reflex::Literal("System::nonPagedMemoryPeak"), function_8982, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t93 = ::Reflex::FunctionTypeBuilder(type_26, type_8939, type_26);      ::Reflex::FunctionBuilder(t93, Reflex::Literal("System::priorityBoost"), function_8983, 0, Reflex::Literal("fetch=PriorityBoost;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t94 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t94, Reflex::Literal("System::exeName"), function_8984, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t95 = ::Reflex::FunctionTypeBuilder(type_26, type_8939, type_26);      ::Reflex::FunctionBuilder(t95, Reflex::Literal("System::exitStatus"), function_8985, 0, Reflex::Literal("fetch=ProcessBasics;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t96 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t96, Reflex::Literal("System::virtualMemory"), function_8986, 0, Reflex::Literal("unit=kByte;fetch=Memory;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t97 = ::Reflex::FunctionTypeBuilder(type_8938, type_26);      ::Reflex::FunctionBuilder(t97, Reflex::Literal("System::getProcessTime"), function_8987, 0, Reflex::Literal("pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t98 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t98, Reflex::Literal("System::pagedMemoryLimit"), function_8988, 0, Reflex::Literal("unit=kByte;fetch=Quota;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t99 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981, type_8939, type_26);      ::Reflex::FunctionBuilder(t99, Reflex::Literal("System::kernelTime"), function_8990, 0, Reflex::Literal("typ=milliSec;fetch=Times;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t100 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t100, Reflex::Literal("System::accountName"), function_8991, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t101 = ::Reflex::FunctionTypeBuilder(type_1498, type_8981);      ::Reflex::FunctionBuilder(t101, Reflex::Literal("System::systemStart"), function_8992, 0, Reflex::Literal("typ=Sec"), ::Reflex::PUBLIC);
      ::Reflex::Type t102 = ::Reflex::FunctionTypeBuilder(type_6134);      ::Reflex::FunctionBuilder(t102, Reflex::Literal("System::moduleName"), function_8993, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t103 = ::Reflex::FunctionTypeBuilder(type_26, type_8939, type_26);      ::Reflex::FunctionBuilder(t103, Reflex::Literal("System::parentID"), function_8994, 0, Reflex::Literal("fetch=ProcessBasics;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t104 = ::Reflex::FunctionTypeBuilder(type_26, type_8972, type_8939, type_26);      ::Reflex::FunctionBuilder(t104, Reflex::Literal("System::maxMemoryLimit"), function_8995, 0, Reflex::Literal("unit=kByte;fetch=Quota;pid=-0x000000001"), ::Reflex::PUBLIC);
      ::Reflex::Type t105 = ::Reflex::FunctionTypeBuilder(type_4206, type_4095);      ::Reflex::FunctionBuilder(t105, Reflex::Literal("System::isEnvSet"), function_8996, 0, Reflex::Literal("var"), ::Reflex::PUBLIC);
      ::Reflex::Type t106 = ::Reflex::FunctionTypeBuilder(type_2872, type_27681, type_6134);      ::Reflex::FunctionBuilder(t106, Reflex::Literal("Gaudi::Parsers::parse"), function_19540, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t107 = ::Reflex::FunctionTypeBuilder(type_2872, type_27682, type_6134);      ::Reflex::FunctionBuilder(t107, Reflex::Literal("Gaudi::Parsers::parse"), function_19541, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t108 = ::Reflex::FunctionTypeBuilder(type_2872, type_27683, type_6134);      ::Reflex::FunctionBuilder(t108, Reflex::Literal("Gaudi::Parsers::parse"), function_19542, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t109 = ::Reflex::FunctionTypeBuilder(type_2872, type_27684, type_6134);      ::Reflex::FunctionBuilder(t109, Reflex::Literal("Gaudi::Parsers::parse"), function_19543, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t110 = ::Reflex::FunctionTypeBuilder(type_2872, type_27131, type_6134);      ::Reflex::FunctionBuilder(t110, Reflex::Literal("Gaudi::Parsers::parse"), function_19544, 0, Reflex::Literal("params;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t111 = ::Reflex::FunctionTypeBuilder(type_2872, type_27126, type_6134);      ::Reflex::FunctionBuilder(t111, Reflex::Literal("Gaudi::Parsers::parse"), function_19545, 0, Reflex::Literal("histos;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t112 = ::Reflex::FunctionTypeBuilder(type_2872, type_27127, type_6134);      ::Reflex::FunctionBuilder(t112, Reflex::Literal("Gaudi::Parsers::parse"), function_19546, 0, Reflex::Literal("histo;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t113 = ::Reflex::FunctionTypeBuilder(type_2872, type_19991, type_19991, type_6134);      ::Reflex::FunctionBuilder(t113, Reflex::Literal("Gaudi::Parsers::parse"), function_19547, 0, Reflex::Literal("name;value;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t114 = ::Reflex::FunctionTypeBuilder(type_2872, type_27122, type_6134);      ::Reflex::FunctionBuilder(t114, Reflex::Literal("Gaudi::Parsers::parse"), function_19548, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t115 = ::Reflex::FunctionTypeBuilder(type_2872, type_27118, type_6134);      ::Reflex::FunctionBuilder(t115, Reflex::Literal("Gaudi::Parsers::parse"), function_19549, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t116 = ::Reflex::FunctionTypeBuilder(type_2872, type_27113, type_6134);      ::Reflex::FunctionBuilder(t116, Reflex::Literal("Gaudi::Parsers::parse"), function_19550, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t117 = ::Reflex::FunctionTypeBuilder(type_2872, type_27109, type_6134);      ::Reflex::FunctionBuilder(t117, Reflex::Literal("Gaudi::Parsers::parse"), function_19551, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t118 = ::Reflex::FunctionTypeBuilder(type_2872, type_27105, type_6134);      ::Reflex::FunctionBuilder(t118, Reflex::Literal("Gaudi::Parsers::parse"), function_19552, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t119 = ::Reflex::FunctionTypeBuilder(type_2872, type_27101, type_6134);      ::Reflex::FunctionBuilder(t119, Reflex::Literal("Gaudi::Parsers::parse"), function_19553, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t120 = ::Reflex::FunctionTypeBuilder(type_2872, type_27097, type_6134);      ::Reflex::FunctionBuilder(t120, Reflex::Literal("Gaudi::Parsers::parse"), function_19554, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t121 = ::Reflex::FunctionTypeBuilder(type_2872, type_27093, type_6134);      ::Reflex::FunctionBuilder(t121, Reflex::Literal("Gaudi::Parsers::parse"), function_19555, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t122 = ::Reflex::FunctionTypeBuilder(type_2872, type_27080, type_6134);      ::Reflex::FunctionBuilder(t122, Reflex::Literal("Gaudi::Parsers::parse"), function_19556, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t123 = ::Reflex::FunctionTypeBuilder(type_2872, type_27089, type_6134);      ::Reflex::FunctionBuilder(t123, Reflex::Literal("Gaudi::Parsers::parse"), function_19557, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t124 = ::Reflex::FunctionTypeBuilder(type_2872, type_27085, type_6134);      ::Reflex::FunctionBuilder(t124, Reflex::Literal("Gaudi::Parsers::parse"), function_19558, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t125 = ::Reflex::FunctionTypeBuilder(type_2872, type_26763, type_6134);      ::Reflex::FunctionBuilder(t125, Reflex::Literal("Gaudi::Parsers::parse"), function_19559, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t126 = ::Reflex::FunctionTypeBuilder(type_2872, type_26760, type_6134);      ::Reflex::FunctionBuilder(t126, Reflex::Literal("Gaudi::Parsers::parse"), function_19560, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t127 = ::Reflex::FunctionTypeBuilder(type_2872, type_26758, type_6134);      ::Reflex::FunctionBuilder(t127, Reflex::Literal("Gaudi::Parsers::parse"), function_19561, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t128 = ::Reflex::FunctionTypeBuilder(type_2872, type_26755, type_6134);      ::Reflex::FunctionBuilder(t128, Reflex::Literal("Gaudi::Parsers::parse"), function_19562, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t129 = ::Reflex::FunctionTypeBuilder(type_2872, type_12504, type_6134);      ::Reflex::FunctionBuilder(t129, Reflex::Literal("Gaudi::Parsers::parse"), function_19563, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t130 = ::Reflex::FunctionTypeBuilder(type_2872, type_12437, type_6134);      ::Reflex::FunctionBuilder(t130, Reflex::Literal("Gaudi::Parsers::parse"), function_19564, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t131 = ::Reflex::FunctionTypeBuilder(type_2872, type_12571, type_6134);      ::Reflex::FunctionBuilder(t131, Reflex::Literal("Gaudi::Parsers::parse"), function_19565, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t132 = ::Reflex::FunctionTypeBuilder(type_2872, type_26729, type_6134);      ::Reflex::FunctionBuilder(t132, Reflex::Literal("Gaudi::Parsers::parse"), function_19566, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t133 = ::Reflex::FunctionTypeBuilder(type_2872, type_26731, type_6134);      ::Reflex::FunctionBuilder(t133, Reflex::Literal("Gaudi::Parsers::parse"), function_19567, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t134 = ::Reflex::FunctionTypeBuilder(type_2872, type_12638, type_6134);      ::Reflex::FunctionBuilder(t134, Reflex::Literal("Gaudi::Parsers::parse"), function_19568, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t135 = ::Reflex::FunctionTypeBuilder(type_2872, type_26733, type_6134);      ::Reflex::FunctionBuilder(t135, Reflex::Literal("Gaudi::Parsers::parse"), function_19569, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t136 = ::Reflex::FunctionTypeBuilder(type_2872, type_26735, type_6134);      ::Reflex::FunctionBuilder(t136, Reflex::Literal("Gaudi::Parsers::parse"), function_19570, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t137 = ::Reflex::FunctionTypeBuilder(type_2872, type_26737, type_6134);      ::Reflex::FunctionBuilder(t137, Reflex::Literal("Gaudi::Parsers::parse"), function_19571, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t138 = ::Reflex::FunctionTypeBuilder(type_2872, type_19910, type_6134);      ::Reflex::FunctionBuilder(t138, Reflex::Literal("Gaudi::Parsers::parse"), function_19572, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t139 = ::Reflex::FunctionTypeBuilder(type_2872, type_26739, type_6134);      ::Reflex::FunctionBuilder(t139, Reflex::Literal("Gaudi::Parsers::parse"), function_19573, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t140 = ::Reflex::FunctionTypeBuilder(type_2872, type_26743, type_6134);      ::Reflex::FunctionBuilder(t140, Reflex::Literal("Gaudi::Parsers::parse"), function_19574, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t141 = ::Reflex::FunctionTypeBuilder(type_2872, type_26745, type_6134);      ::Reflex::FunctionBuilder(t141, Reflex::Literal("Gaudi::Parsers::parse"), function_19575, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t142 = ::Reflex::FunctionTypeBuilder(type_2872, type_26741, type_6134);      ::Reflex::FunctionBuilder(t142, Reflex::Literal("Gaudi::Parsers::parse"), function_19576, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t143 = ::Reflex::FunctionTypeBuilder(type_2872, type_26750, type_6134);      ::Reflex::FunctionBuilder(t143, Reflex::Literal("Gaudi::Parsers::parse"), function_19577, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t144 = ::Reflex::FunctionTypeBuilder(type_2872, type_26747, type_6134);      ::Reflex::FunctionBuilder(t144, Reflex::Literal("Gaudi::Parsers::parse"), function_19578, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t145 = ::Reflex::FunctionTypeBuilder(type_2872, type_26752, type_6134);      ::Reflex::FunctionBuilder(t145, Reflex::Literal("Gaudi::Parsers::parse"), function_19579, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t146 = ::Reflex::FunctionTypeBuilder(type_2872, type_26723, type_6134);      ::Reflex::FunctionBuilder(t146, Reflex::Literal("Gaudi::Parsers::parse"), function_19580, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t147 = ::Reflex::FunctionTypeBuilder(type_2872, type_19991, type_6134);      ::Reflex::FunctionBuilder(t147, Reflex::Literal("Gaudi::Parsers::parse"), function_19581, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t148 = ::Reflex::FunctionTypeBuilder(type_2872, type_11636, type_6134);      ::Reflex::FunctionBuilder(t148, Reflex::Literal("Gaudi::Parsers::parse"), function_19582, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t149 = ::Reflex::FunctionTypeBuilder(type_2872, type_11703, type_6134);      ::Reflex::FunctionBuilder(t149, Reflex::Literal("Gaudi::Parsers::parse"), function_19583, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t150 = ::Reflex::FunctionTypeBuilder(type_2872, type_10966, type_6134);      ::Reflex::FunctionBuilder(t150, Reflex::Literal("Gaudi::Parsers::parse"), function_19584, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t151 = ::Reflex::FunctionTypeBuilder(type_2872, type_11770, type_6134);      ::Reflex::FunctionBuilder(t151, Reflex::Literal("Gaudi::Parsers::parse"), function_19585, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t152 = ::Reflex::FunctionTypeBuilder(type_2872, type_11837, type_6134);      ::Reflex::FunctionBuilder(t152, Reflex::Literal("Gaudi::Parsers::parse"), function_19586, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t153 = ::Reflex::FunctionTypeBuilder(type_2872, type_11904, type_6134);      ::Reflex::FunctionBuilder(t153, Reflex::Literal("Gaudi::Parsers::parse"), function_19587, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t154 = ::Reflex::FunctionTypeBuilder(type_2872, type_10899, type_6134);      ::Reflex::FunctionBuilder(t154, Reflex::Literal("Gaudi::Parsers::parse"), function_19588, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t155 = ::Reflex::FunctionTypeBuilder(type_2872, type_11970, type_6134);      ::Reflex::FunctionBuilder(t155, Reflex::Literal("Gaudi::Parsers::parse"), function_19589, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t156 = ::Reflex::FunctionTypeBuilder(type_2872, type_12104, type_6134);      ::Reflex::FunctionBuilder(t156, Reflex::Literal("Gaudi::Parsers::parse"), function_19590, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t157 = ::Reflex::FunctionTypeBuilder(type_2872, type_12171, type_6134);      ::Reflex::FunctionBuilder(t157, Reflex::Literal("Gaudi::Parsers::parse"), function_19591, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t158 = ::Reflex::FunctionTypeBuilder(type_2872, type_12037, type_6134);      ::Reflex::FunctionBuilder(t158, Reflex::Literal("Gaudi::Parsers::parse"), function_19592, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t159 = ::Reflex::FunctionTypeBuilder(type_2872, type_12305, type_6134);      ::Reflex::FunctionBuilder(t159, Reflex::Literal("Gaudi::Parsers::parse"), function_19593, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t160 = ::Reflex::FunctionTypeBuilder(type_2872, type_12238, type_6134);      ::Reflex::FunctionBuilder(t160, Reflex::Literal("Gaudi::Parsers::parse"), function_19594, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t161 = ::Reflex::FunctionTypeBuilder(type_2872, type_10108, type_6134);      ::Reflex::FunctionBuilder(t161, Reflex::Literal("Gaudi::Parsers::parse"), function_19595, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t162 = ::Reflex::FunctionTypeBuilder(type_2872, type_13607, type_6134);      ::Reflex::FunctionBuilder(t162, Reflex::Literal("Gaudi::Parsers::parse"), function_19596, 0, Reflex::Literal("result;input"), ::Reflex::PUBLIC);
      ::Reflex::Type t163 = ::Reflex::FunctionTypeBuilder(type_142);      ::Reflex::FunctionBuilder(t163, Reflex::Literal("Gaudi::PluginService::Debug"), function_19624, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t164 = ::Reflex::FunctionTypeBuilder(type_843, type_142);      ::Reflex::FunctionBuilder(t164, Reflex::Literal("Gaudi::PluginService::SetDebug"), function_19626, 0, Reflex::Literal("debugLevel"), ::Reflex::PUBLIC);
      ::Reflex::Type t165 = ::Reflex::FunctionTypeBuilder(type_19509, type_19629c, type_19509c);      ::Reflex::FunctionBuilder(t165, Reflex::Literal("Gaudi::StateMachine::ChangeState"), function_19628, 0, Reflex::Literal("transition;state"), ::Reflex::PUBLIC);
      ::Reflex::Type t166 = ::Reflex::FunctionTypeBuilder(type_7831, type_7831, type_27698);      ::Reflex::FunctionBuilder(t166, Reflex::Literal("Gaudi::StateMachine::operator<<"), function_19630, 0, Reflex::Literal("s;t"), ::Reflex::PUBLIC);
      ::Reflex::Type t167 = ::Reflex::FunctionTypeBuilder(type_7831, type_7831, type_27699);      ::Reflex::FunctionBuilder(t167, Reflex::Literal("Gaudi::StateMachine::operator<<"), function_19631, 0, Reflex::Literal("s;st"), ::Reflex::PUBLIC);
      ::Reflex::Type t168 = ::Reflex::FunctionTypeBuilder(type_7831, type_4095, type_7831);      ::Reflex::FunctionBuilder(t168, Reflex::Literal("Gaudi::Utils::toStream"), function_19679, 0, Reflex::Literal("obj;s"), ::Reflex::PUBLIC);
      ::Reflex::Type t169 = ::Reflex::FunctionTypeBuilder(type_7831, type_4100c, type_7831, type_142c);      ::Reflex::FunctionBuilder(t169, Reflex::Literal("Gaudi::Utils::toStream"), function_19680, 0, Reflex::Literal("obj;s;prec=10"), ::Reflex::PUBLIC);
      ::Reflex::Type t170 = ::Reflex::FunctionTypeBuilder(type_7831, type_2603c, type_7831, type_142c);      ::Reflex::FunctionBuilder(t170, Reflex::Literal("Gaudi::Utils::toStream"), function_19681, 0, Reflex::Literal("obj;s;prec=8"), ::Reflex::PUBLIC);
      ::Reflex::Type t171 = ::Reflex::FunctionTypeBuilder(type_7831, type_1921c, type_7831, type_142c);      ::Reflex::FunctionBuilder(t171, Reflex::Literal("Gaudi::Utils::toStream"), function_19682, 0, Reflex::Literal("obj;s;prec=6"), ::Reflex::PUBLIC);
      ::Reflex::Type t172 = ::Reflex::FunctionTypeBuilder(type_7831, type_4206c, type_7831);      ::Reflex::FunctionBuilder(t172, Reflex::Literal("Gaudi::Utils::toStream"), function_19683, 0, Reflex::Literal("obj;s"), ::Reflex::PUBLIC);
      ::Reflex::Type t173 = ::Reflex::FunctionTypeBuilder(type_7831, type_6134, type_7831);      ::Reflex::FunctionBuilder(t173, Reflex::Literal("Gaudi::Utils::toStream"), function_19684, 0, Reflex::Literal("obj;s"), ::Reflex::PUBLIC);
      ::Reflex::Type t174 = ::Reflex::FunctionTypeBuilder(type_10067, type_6134, type_10067);      ::Reflex::FunctionBuilder(t174, Reflex::Literal("Gaudi::Utils::toStream<std::string>"), function_19685, 0, Reflex::Literal("obj;s"), ::Reflex::PUBLIC);
      ::Reflex::Type t175 = ::Reflex::FunctionTypeBuilder(type_7831, type_19538, type_7831);      ::Reflex::FunctionBuilder(t175, Reflex::Literal("Gaudi::Utils::toStream"), function_19686, 0, Reflex::Literal("key;s"), ::Reflex::PUBLIC);
      ::Reflex::Type t176 = ::Reflex::FunctionTypeBuilder(type_11093, type_24141, type_6134);      ::Reflex::FunctionBuilder(t176, Reflex::Literal("Gaudi::Utils::getProperty"), function_19689, 0, Reflex::Literal("p;name"), ::Reflex::PUBLIC);
      ::Reflex::Type t177 = ::Reflex::FunctionTypeBuilder(type_11428, type_19852, type_6134);      ::Reflex::FunctionBuilder(t177, Reflex::Literal("Gaudi::Utils::getProperty"), function_19690, 0, Reflex::Literal("p;name"), ::Reflex::PUBLIC);
      ::Reflex::Type t178 = ::Reflex::FunctionTypeBuilder(type_11428, type_27722, type_6134);      ::Reflex::FunctionBuilder(t178, Reflex::Literal("Gaudi::Utils::getProperty"), function_19691, 0, Reflex::Literal("p;name"), ::Reflex::PUBLIC);
      ::Reflex::Type t179 = ::Reflex::FunctionTypeBuilder(type_3236, type_6134, type_6134, type_7460, type_4206c, type_6134, type_6134);      ::Reflex::FunctionBuilder(t179, Reflex::Literal("Gaudi::Utils::formatAsTableRow"), function_19692, 0, Reflex::Literal("name;group;entity;flag=true;format1=\" %|15.15s|%|-15.15s|%|32t||%|7d| |%|11.7g| |%|#11.5g| |%|#10.5g| |%|#10.5g| |%|#10.5g| |\";format2=\"*%|15.15s|%|-15.15s|%|32t||%|7d| |%|11.5g| |(%|#9.7g| +- %|-#8.6g|)%%|    -----    |   -----   |\""), ::Reflex::PUBLIC);
      ::Reflex::Type t180 = ::Reflex::FunctionTypeBuilder(type_3236, type_6134, type_7460, type_4206c, type_6134, type_6134);      ::Reflex::FunctionBuilder(t180, Reflex::Literal("Gaudi::Utils::formatAsTableRow"), function_19693, 0, Reflex::Literal("name;counter;flag=true;format1=\" %|-15.15s|%|17t||%|7d| |%|11.7g| |%|#11.5g| |%|#10.5g| |%|#10.5g| |%|#10.5g| |\";format2=\"*%|-15.15s|%|17t||%|7d| |%|11.5g| |(%|#9.7g| +- %|-#8.6g|)%%|   -----   |   -----   |\""), ::Reflex::PUBLIC);
      ::Reflex::Type t181 = ::Reflex::FunctionTypeBuilder(type_3236, type_7460, type_4206c, type_6134, type_6134);      ::Reflex::FunctionBuilder(t181, Reflex::Literal("Gaudi::Utils::formatAsTableRow"), function_19694, 0, Reflex::Literal("counter;flag;format1=\" |%|7d| |%|11.7g| |%|#11.5g| |%|#10.5g| |%|#10.5g| |%|#10.5g| |\";format2=\"*|%|7d| |%|11.5g| |(%|#9.7g| +- %|-#8.6g|)%%|   -----   |   -----   |\""), ::Reflex::PUBLIC);
      ::Reflex::Type t182 = ::Reflex::FunctionTypeBuilder(type_4206, type_24141, type_6134);      ::Reflex::FunctionBuilder(t182, Reflex::Literal("Gaudi::Utils::hasProperty"), function_19695, 0, Reflex::Literal("p;name"), ::Reflex::PUBLIC);
      ::Reflex::Type t183 = ::Reflex::FunctionTypeBuilder(type_4206, type_19852, type_6134);      ::Reflex::FunctionBuilder(t183, Reflex::Literal("Gaudi::Utils::hasProperty"), function_19696, 0, Reflex::Literal("p;name"), ::Reflex::PUBLIC);
      ::Reflex::Type t184 = ::Reflex::FunctionTypeBuilder(type_4206, type_27722, type_6134);      ::Reflex::FunctionBuilder(t184, Reflex::Literal("Gaudi::Utils::hasProperty"), function_19697, 0, Reflex::Literal("p;name"), ::Reflex::PUBLIC);
      ::Reflex::Type t185 = ::Reflex::FunctionTypeBuilder(type_2872, type_19539, type_6134, type_7834, type_6134);      ::Reflex::FunctionBuilder(t185, Reflex::Literal("Gaudi::Utils::setProperty"), function_19699, 0, Reflex::Literal("component;name;property;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t186 = ::Reflex::FunctionTypeBuilder(type_2872, type_19539, type_6134, type_11093, type_6134);      ::Reflex::FunctionBuilder(t186, Reflex::Literal("Gaudi::Utils::setProperty"), function_19700, 0, Reflex::Literal("component;name;property;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t187 = ::Reflex::FunctionTypeBuilder(type_2872, type_19539, type_6134, type_4095, type_6134);      ::Reflex::FunctionBuilder(t187, Reflex::Literal("Gaudi::Utils::setProperty"), function_19701, 0, Reflex::Literal("component;name;value;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t188 = ::Reflex::FunctionTypeBuilder(type_2872, type_19539, type_6134, type_6134, type_6134);      ::Reflex::FunctionBuilder(t188, Reflex::Literal("Gaudi::Utils::setProperty"), function_19702, 0, Reflex::Literal("component;name;value;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t189 = ::Reflex::FunctionTypeBuilder(type_2872, type_19539, type_7844, type_11104, type_7844);      ::Reflex::FunctionBuilder(t189, Reflex::Literal("Gaudi::Utils::setProperty"), function_19703, 0, Reflex::Literal("component;name;value;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t190 = ::Reflex::FunctionTypeBuilder(type_2872, type_19539, type_7844, type_6134, type_7844);      ::Reflex::FunctionBuilder(t190, Reflex::Literal("Gaudi::Utils::setProperty<std::string>"), function_19704, 0, Reflex::Literal("component;name;value;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t191 = ::Reflex::FunctionTypeBuilder(type_2872, type_19990, type_6134, type_7834, type_6134);      ::Reflex::FunctionBuilder(t191, Reflex::Literal("Gaudi::Utils::setProperty"), function_19705, 0, Reflex::Literal("component;name;property;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t192 = ::Reflex::FunctionTypeBuilder(type_2872, type_19990, type_6134, type_11093, type_6134);      ::Reflex::FunctionBuilder(t192, Reflex::Literal("Gaudi::Utils::setProperty"), function_19706, 0, Reflex::Literal("component;name;property;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t193 = ::Reflex::FunctionTypeBuilder(type_2872, type_19990, type_6134, type_4095, type_6134);      ::Reflex::FunctionBuilder(t193, Reflex::Literal("Gaudi::Utils::setProperty"), function_19707, 0, Reflex::Literal("component;name;value;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t194 = ::Reflex::FunctionTypeBuilder(type_2872, type_19990, type_6134, type_6134, type_6134);      ::Reflex::FunctionBuilder(t194, Reflex::Literal("Gaudi::Utils::setProperty"), function_19708, 0, Reflex::Literal("component;name;value;doc=\"\""), ::Reflex::PUBLIC);
      ::Reflex::Type t195 = ::Reflex::FunctionTypeBuilder(type_2872, type_19990, type_7844, type_11104, type_7844);      ::Reflex::FunctionBuilder(t195, Reflex::Literal("Gaudi::Utils::setProperty"), function_19709, 0, Reflex::Literal("component;name;value;doc"), ::Reflex::PUBLIC);
      ::Reflex::Type t196 = ::Reflex::FunctionTypeBuilder(type_2872, type_19990, type_7844, type_6134, type_7844);      ::Reflex::FunctionBuilder(t196, Reflex::Literal("Gaudi::Utils::setProperty<std::string>"), function_19710, 0, Reflex::Literal("component;name;value;doc"), ::Reflex::PUBLIC);
      ::Reflex::Type t197 = ::Reflex::FunctionTypeBuilder(type_7831, type_7831, type_20039);      ::Reflex::FunctionBuilder(t197, Reflex::Literal("Gaudi::Utils::operator<<"), function_19711, 0, Reflex::Literal("s;tn"), ::Reflex::PUBLIC);
      ::Reflex::Type t198 = ::Reflex::FunctionTypeBuilder(type_24382, type_21000, type_6134, type_142c, type_19716);      ::Reflex::FunctionBuilder(t198, Reflex::Literal("Gaudi::Histos::book"), function_19712, 0, Reflex::Literal("svc;dir;id;hist"), ::Reflex::PUBLIC);
      ::Reflex::Type t199 = ::Reflex::FunctionTypeBuilder(type_24382, type_21000, type_6134, type_6134, type_19716);      ::Reflex::FunctionBuilder(t199, Reflex::Literal("Gaudi::Histos::book"), function_19713, 0, Reflex::Literal("svc;dir;id;hist"), ::Reflex::PUBLIC);
      ::Reflex::Type t200 = ::Reflex::FunctionTypeBuilder(type_24382, type_21000, type_6134, type_19716);      ::Reflex::FunctionBuilder(t200, Reflex::Literal("Gaudi::Histos::book"), function_19714, 0, Reflex::Literal("svc;path;hist"), ::Reflex::PUBLIC);
      ::Reflex::Type t201 = ::Reflex::FunctionTypeBuilder(type_1454, type_6134, type_6134);      ::Reflex::FunctionBuilder(t201, Reflex::Literal("Gaudi::PluginService::Details::getCreator"), function_27691, 0, Reflex::Literal("id;type"), ::Reflex::PUBLIC);
      ::Reflex::Type t202 = ::Reflex::FunctionTypeBuilder(type_843, type_31594);      ::Reflex::FunctionBuilder(t202, Reflex::Literal("Gaudi::PluginService::Details::setLogger"), function_27692, 0, Reflex::Literal("logger"), ::Reflex::PUBLIC);
      ::Reflex::Type t203 = ::Reflex::FunctionTypeBuilder(type_31595);      ::Reflex::FunctionBuilder(t203, Reflex::Literal("Gaudi::PluginService::Details::logger"), function_27693, 0, Reflex::Literal(0), ::Reflex::PUBLIC);
      ::Reflex::Type t204 = ::Reflex::FunctionTypeBuilder(type_3236, type_19928);      ::Reflex::FunctionBuilder(t204, Reflex::Literal("Gaudi::PluginService::Details::demangle"), function_27694, 0, Reflex::Literal("id"), ::Reflex::PUBLIC);
      ::Reflex::EnumBuilder(Reflex::Literal("MSG::Color"),typeid(::MSG::Color), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("BLACK"),0)
        .AddItem(Reflex::Literal("RED"),1)
        .AddItem(Reflex::Literal("GREEN"),2)
        .AddItem(Reflex::Literal("YELLOW"),3)
        .AddItem(Reflex::Literal("BLUE"),4)
        .AddItem(Reflex::Literal("PURPLE"),5)
        .AddItem(Reflex::Literal("CYAN"),6)
        .AddItem(Reflex::Literal("WHITE"),7)
        .AddItem(Reflex::Literal("NUM_COLORS"),8);
      ::Reflex::EnumBuilder(Reflex::Literal("MSG::Level"),typeid(::MSG::Level), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("NIL"),0)
        .AddItem(Reflex::Literal("VERBOSE"),1)
        .AddItem(Reflex::Literal("DEBUG"),2)
        .AddItem(Reflex::Literal("INFO"),3)
        .AddItem(Reflex::Literal("WARNING"),4)
        .AddItem(Reflex::Literal("ERROR"),5)
        .AddItem(Reflex::Literal("FATAL"),6)
        .AddItem(Reflex::Literal("ALWAYS"),7)
        .AddItem(Reflex::Literal("NUM_LEVELS"),8);
      ::Reflex::EnumBuilder(Reflex::Literal("Gaudi::StateMachine::State"),typeid(::Gaudi::StateMachine::State), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("OFFLINE"),0)
        .AddItem(Reflex::Literal("CONFIGURED"),1)
        .AddItem(Reflex::Literal("INITIALIZED"),2)
        .AddItem(Reflex::Literal("RUNNING"),3);
      ::Reflex::EnumBuilder(Reflex::Literal("Gaudi::StateMachine::Transition"),typeid(::Gaudi::StateMachine::Transition), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("CONFIGURE"),0)
        .AddItem(Reflex::Literal("INITIALIZE"),1)
        .AddItem(Reflex::Literal("START"),2)
        .AddItem(Reflex::Literal("STOP"),3)
        .AddItem(Reflex::Literal("FINALIZE"),4)
        .AddItem(Reflex::Literal("TERMINATE"),5);
      ::Reflex::EnumBuilder(Reflex::Literal("Gaudi::CounterSummary::SaveType"),typeid(::Gaudi::CounterSummary::SaveType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("SaveSimpleCounter"),0)
        .AddItem(Reflex::Literal("SaveStatEntity"),1)
        .AddItem(Reflex::Literal("SaveAlwaysSimpleCounter"),2)
        .AddItem(Reflex::Literal("SaveAlwaysStatEntity"),3);
    }
    ~Dictionaries() {
      type_1730.Unload(); // class IInterface 
      type_44.Unload(); // class extend_interfaces1<IInterface> 
      type_686.Unload(); // class IDataStreamTool 
      type_45.Unload(); // class extend_interfaces1<IDataStreamTool> 
      type_2383.Unload(); // class IProperty 
      type_46.Unload(); // class extend_interfaces1<IProperty> 
      type_47.Unload(); // class extend_interfaces2<IService,IAuditor> 
      type_120.Unload(); // class GaudiHandleBase 
      type_133.Unload(); // class GaudiHandleInfo 
      type_208.Unload(); // class Incident 
      type_210.Unload(); // class InterfaceID 
      type_239.Unload(); // class IUpdateable 
      type_261.Unload(); // class extends1<AlgTool,IDataStreamTool> 
      type_303.Unload(); // class DataObject 
      type_394.Unload(); // class IDetDataSvc 
      type_417.Unload(); // class IClassManager 
      type_489.Unload(); // class implements1<IInterface> 
      type_490.Unload(); // class implements1<IProperty> 
      type_506.Unload(); // class IClassInfo 
      type_549.Unload(); // class IAlgorithm 
      type_553.Unload(); // class IIncidentListener 
      type_573.Unload(); // class IStatusCodeSvc 
      type_581.Unload(); // class ISerialize 
      type_610.Unload(); // class IExceptionSvc 
      type_612.Unload(); // class ObjectContainerBase 
      type_654.Unload(); // class SmartDataObjectPtr 
      type_663.Unload(); // class extend_interfaces3<IAlgTool,IProperty,IStateful> 
      type_664.Unload(); // class extend_interfaces3<IService,IProperty,IStateful> 
      type_665.Unload(); // class extend_interfaces3<IAlgorithm,IProperty,IStateful> 
      type_666.Unload(); // class extend_interfaces3<IService,IChronoSvc,IStatSvc> 
      type_674.Unload(); // class IDataStoreAgent 
      type_709.Unload(); // class GaudiHandleArrayBase 
      type_732.Unload(); // class IConversionSvc 
      type_750.Unload(); // class IPersistencySvc 
      type_777.Unload(); // class IMessageSvc 
      type_788.Unload(); // class IMonitorSvc 
      type_790.Unload(); // class IDataStoreLeaves 
      type_810.Unload(); // class INTupleSvc 
      type_813.Unload(); // class IAlgTool 
      type_897.Unload(); // class IRndmEngine 
      type_934.Unload(); // class IService 
      type_995.Unload(); // class GenericAddress 
      type_1006.Unload(); // class IssueSeverity 
      type_1044.Unload(); // class IConverter 
      type_1049.Unload(); // class IEvtSelector 
      type_1082.Unload(); // class SmartDataStorePtr<ObjectContainerBase,SmartDataObjectPtr::ObjectLoader> 
      type_1083.Unload(); // class SmartDataStorePtr<DataObject,SmartDataObjectPtr::ObjectLoader> 
      type_1141.Unload(); // class GaudiHandleProperty 
      type_1187.Unload(); // class IUpdateManagerSvc 
      type_1192.Unload(); // class IPartitionControl 
      type_1221.Unload(); // class ISvcLocator 
      type_1222.Unload(); // class IAuditorSvc 
      type_1223.Unload(); // class GaudiHandleArrayProperty 
      type_1234.Unload(); // class AlgTool 
      type_1249.Unload(); // class ContainedObject 
      type_1334.Unload(); // class IInspector 
      type_1365.Unload(); // class Service 
      type_1385.Unload(); // class IDataSourceMgr 
      type_1414.Unload(); // class IDataProviderSvc 
      type_1450.Unload(); // class KeyedObject<unsigned long> 
      type_1451.Unload(); // class KeyedObject<long> 
      type_1452.Unload(); // class KeyedObject<unsigned int> 
      type_1453.Unload(); // class KeyedObject<int> 
      type_1544.Unload(); // class ITHistSvc 
      type_1590.Unload(); // class IAuditor 
      type_1591.Unload(); // class SmartIF<IAlgorithm> 
      type_1778.Unload(); // class IIncidentSvc 
      type_1592.Unload(); // class SmartIF<IIncidentSvc> 
      type_1593.Unload(); // class SmartIF<IService> 
      type_1594.Unload(); // class SmartIF<IAuditorSvc> 
      type_1636.Unload(); // class ISvcManager 
      type_1595.Unload(); // class SmartIF<ISvcManager> 
      type_1596.Unload(); // class SmartIF<ISvcLocator> 
      type_1597.Unload(); // class SmartIF<IMessageSvc> 
      type_1598.Unload(); // class SmartIF<IMonitorSvc> 
      type_2156.Unload(); // class IAlgContextSvc 
      type_1599.Unload(); // class SmartIF<IAlgContextSvc> 
      type_2197.Unload(); // class IToolSvc 
      type_1600.Unload(); // class SmartIF<IToolSvc> 
      type_1601.Unload(); // class SmartIF<IExceptionSvc> 
      type_1710.Unload(); // class IRndmGenSvc 
      type_1602.Unload(); // class SmartIF<IRndmGenSvc> 
      type_2374.Unload(); // class IChronoStatSvc 
      type_1603.Unload(); // class SmartIF<IChronoStatSvc> 
      type_1604.Unload(); // class SmartIF<INTupleSvc> 
      type_2722.Unload(); // class IHistogramSvc 
      type_1605.Unload(); // class SmartIF<IHistogramSvc> 
      type_1606.Unload(); // class SmartIF<IConversionSvc> 
      type_1607.Unload(); // class SmartIF<IDataProviderSvc> 
      type_1609.Unload(); // class SmartIF<IProperty> 
      type_1617.Unload(); // class SmartRefBase 
      type_1695.Unload(); // class ICounterSvc 
      type_1699.Unload(); // class IDataManagerSvc 
      type_1723.Unload(); // class IPartPropSvc 
      type_1726.Unload(); // class IRegistry 
      type_1763.Unload(); // class IStatSvc 
      type_1791.Unload(); // class IEventProcessor 
      type_1829.Unload(); // class SmartDataPtr<ObjectContainerBase> 
      type_1830.Unload(); // class SmartDataPtr<DataObject> 
      type_1841.Unload(); // class IJobOptionsSvc 
      type_1857.Unload(); // class INTuple 
      type_1859.Unload(); // class IParticlePropertySvc 
      type_1915.Unload(); // class implements3<IAlgTool,IProperty,IStateful> 
      type_1916.Unload(); // class implements3<IService,IProperty,IStateful> 
      type_1917.Unload(); // class implements3<IAlgorithm,IProperty,IStateful> 
      type_1946.Unload(); // class IEventTimeDecoder 
      type_1954.Unload(); // class IStagerSvc 
      type_2054.Unload(); // class ICounterSummarySvc 
      type_2061.Unload(); // class Property 
      type_2087.Unload(); // class IHistorySvc 
      type_2099.Unload(); // class IAlgManager 
      type_2244.Unload(); // class IChronoSvc 
      type_2260.Unload(); // class ISelectStatement 
      type_2266.Unload(); // class IMagneticFieldSvc 
      type_2345.Unload(); // class IValidity 
      type_2390.Unload(); // class IAppMgrUI 
      type_2469.Unload(); // class IAddressCreator 
      type_2510.Unload(); // class SmartRefVector<KeyedObject<unsigned long> > 
      type_2511.Unload(); // class SmartRefVector<KeyedObject<long> > 
      type_2512.Unload(); // class SmartRefVector<KeyedObject<unsigned int> > 
      type_2513.Unload(); // class SmartRefVector<KeyedObject<int> > 
      type_2514.Unload(); // class SmartRefVector<ObjectContainerBase> 
      type_2515.Unload(); // class SmartRefVector<ContainedObject> 
      type_2516.Unload(); // class SmartRefVector<DataObject> 
      type_2654.Unload(); // class IStateful 
      type_2739.Unload(); // class IRndmGen 
      type_2743.Unload(); // class SmartRef<KeyedObject<unsigned long> > 
      type_2744.Unload(); // class SmartRef<KeyedObject<long> > 
      type_2745.Unload(); // class SmartRef<KeyedObject<unsigned int> > 
      type_2746.Unload(); // class SmartRef<KeyedObject<int> > 
      type_2747.Unload(); // class SmartRef<ObjectContainerBase> 
      type_2748.Unload(); // class SmartRef<ContainedObject> 
      type_2749.Unload(); // class SmartRef<DataObject> 
      type_2759.Unload(); // class LinkManager 
      type_2776.Unload(); // class INamedInterface 
      type_2811.Unload(); // class IOpaqueAddress 
      type_2823.Unload(); // class IRunable 
      type_2872.Unload(); // class StatusCode 
      type_2912.Unload(); // class Algorithm 
      type_2935.Unload(); // class IIssueLogger 
      type_2950.Unload(); // class IInspectable 
      type_3155.Unload(); // class std::vector<ContainedObject*> 
      type_3156.Unload(); // class std::vector<const ContainedObject*> 
      type_3157.Unload(); // class std::vector<LinkManager::Link*> 
      type_3158.Unload(); // class std::vector<SmartRef<KeyedObject<unsigned long> > > 
      type_3159.Unload(); // class std::vector<SmartRef<KeyedObject<long> > > 
      type_3160.Unload(); // class std::vector<SmartRef<KeyedObject<unsigned int> > > 
      type_3161.Unload(); // class std::vector<SmartRef<KeyedObject<int> > > 
      type_3162.Unload(); // class std::vector<SmartRef<ObjectContainerBase> > 
      type_3163.Unload(); // class std::vector<SmartRef<ContainedObject> > 
      type_3164.Unload(); // class std::vector<SmartRef<DataObject> > 
      type_3224.Unload(); // class std::basic_string<char> 
      type_4207.Unload(); // class Rndm::Binomial 
      type_4208.Unload(); // class Rndm::Bit 
      type_4209.Unload(); // class Rndm::StudentT 
      type_4210.Unload(); // class Rndm::DefinedPdf 
      type_4211.Unload(); // class Rndm::Gamma 
      type_4212.Unload(); // class Rndm::Exponential 
      type_4221.Unload(); // class Rndm::Gauss 
      type_4222.Unload(); // class Rndm::BreitWignerCutOff 
      type_4223.Unload(); // class Rndm::Poisson 
      type_4224.Unload(); // class Rndm::BreitWigner 
      type_4225.Unload(); // class Rndm::Chi2 
      type_4226.Unload(); // class Rndm::GaussianTail 
      type_4227.Unload(); // class Rndm::Flat 
      type_4228.Unload(); // class Rndm::Landau 
      type_4229.Unload(); // class Rndm::Numbers 
      type_4682.Unload(); // class Gaudi::Time 
      type_4740.Unload(); // class SmartDataObjectPtr::ObjectLoader 
      type_4741.Unload(); // class SmartDataObjectPtr::ObjectFinder 
      type_5405.Unload(); // class IUpdateManagerSvc::PythonHelper 
      type_5905.Unload(); // class NTuple::Array<double> 
      type_5907.Unload(); // class NTuple::Matrix<unsigned short> 
      type_5909.Unload(); // class NTuple::Array<unsigned char> 
      type_5911.Unload(); // class NTuple::Matrix<char> 
      type_5913.Unload(); // class NTuple::Matrix<unsigned int> 
      type_5915.Unload(); // class NTuple::Array<float> 
      type_5917.Unload(); // class NTuple::Array<bool> 
      type_5919.Unload(); // class NTuple::Array<int> 
      type_5921.Unload(); // class NTuple::Matrix<int> 
      type_5923.Unload(); // class NTuple::Matrix<double> 
      type_5947.Unload(); // class NTuple::Array<unsigned long> 
      type_5949.Unload(); // class NTuple::Matrix<unsigned char> 
      type_5951.Unload(); // class NTuple::Matrix<short> 
      type_5953.Unload(); // class NTuple::File 
      type_5954.Unload(); // class NTuple::Item<double> 
      type_5956.Unload(); // class NTuple::Array<long> 
      type_5958.Unload(); // class NTuple::Item<bool> 
      type_5960.Unload(); // class NTuple::Item<float> 
      type_5961.Unload(); // class NTuple::Item<unsigned int> 
      type_5962.Unload(); // class NTuple::Item<int> 
      type_5963.Unload(); // class NTuple::Item<unsigned long long> 
      type_5964.Unload(); // class NTuple::Item<unsigned long> 
      type_5965.Unload(); // class NTuple::Item<long long> 
      type_5966.Unload(); // class NTuple::Item<long> 
      type_5967.Unload(); // class NTuple::Item<unsigned short> 
      type_5968.Unload(); // class NTuple::Item<short> 
      type_5969.Unload(); // class NTuple::Item<unsigned char> 
      type_5970.Unload(); // class NTuple::Item<char> 
      type_5987.Unload(); // class NTuple::ColumnWiseTuple 
      type_5988.Unload(); // class NTuple::Matrix<float> 
      type_5992.Unload(); // class NTuple::Array<char> 
      type_5994.Unload(); // class NTuple::Matrix<long> 
      type_6001.Unload(); // class NTuple::Matrix<unsigned long> 
      type_6002.Unload(); // class NTuple::Matrix<bool> 
      type_6003.Unload(); // class NTuple::Matrix<IOpaqueAddress*> 
      type_6009.Unload(); // class NTuple::Array<unsigned int> 
      type_6012.Unload(); // class NTuple::Directory 
      type_6013.Unload(); // class NTuple::Array<unsigned short> 
      type_6014.Unload(); // class NTuple::Array<short> 
      type_6015.Unload(); // class NTuple::Array<IOpaqueAddress*> 
      type_6096.Unload(); // class NTuple::RowWiseTuple 
      type_8014.Unload(); // class IRndmGen::Param 
      type_8321.Unload(); // class LinkManager::Link 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
