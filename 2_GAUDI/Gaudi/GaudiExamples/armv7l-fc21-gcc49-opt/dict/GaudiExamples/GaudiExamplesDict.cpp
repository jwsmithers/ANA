// Generated at Mon Feb 16 20:50:16 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="lcg-g++-4.9.1"
  GCCXML_CXXFLAGS="-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard "
  GCCXML_EXECUTABLE="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__SSP_STRONG__='3' -D__DBL_MIN_EXP__='(-1021)' -D__HQ_FBIT__='15' -D__UINT_LEAST16_MAX__='65535' -D__ARM_SIZEOF_WCHAR_T='32' -D__ATOMIC_ACQUIRE='2' -D__SFRACT_IBIT__='0' -D__FLT_MIN__='1.1754943508222875e-38F' -D__GCC_IEC_559_COMPLEX='2' -D__UFRACT_MAX__='0XFFFFP-16UR' -D__UINT_LEAST8_TYPE__='unsigned char' -D__DQ_FBIT__='63' -D__INTMAX_C(c)='c ## LL' -D__ARM_FEATURE_SAT='1' -D__ULFRACT_FBIT__='32' -D__SACCUM_EPSILON__='0x1P-7HK' -D__CHAR_BIT__='8' -D__USQ_IBIT__='0' -D__UINT8_MAX__='255' -D__ACCUM_FBIT__='15' -D__WINT_MAX__='4294967295U' -D__USFRACT_FBIT__='8' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='4294967295U' -D__ARM_ARCH_ISA_ARM='1' -D__WCHAR_MAX__='4294967295U' -D__LACCUM_IBIT__='32' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.9406564584124654e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__GCC_IEC_559='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__cpp_binary_literals='201304' -D__LLACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LLK' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__FRACT_FBIT__='15' -D__UINT_FAST64_MAX__='18446744073709551615ULL' -D__SIG_ATOMIC_TYPE__='int' -D__UACCUM_FBIT__='16' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__ARMEL__='1' -D__ARM_FEATURE_UNALIGNED='1' -D__LFRACT_IBIT__='0' -D__GNUC_PATCHLEVEL__='2' -D__LFRACT_MAX__='0X7FFFFFFFP-31LR' -D__UINT_FAST8_MAX__='255' -D__has_include(STR)='__has_include__(STR)' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615ULL' -D__SA_FBIT__='15' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.7976931348623157e+308L' -D__FRACT_MAX__='0X7FFFP-15R' -D__UFRACT_FBIT__='16' -D__ARM_FP='12' -D__UFRACT_MIN__='0.0UR' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long long unsigned int' -D__LLFRACT_EPSILON__='0x1P-63LLR' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__CHAR_UNSIGNED__='1' -D__UINT32_MAX__='4294967295U' -D__ULFRACT_MAX__='0XFFFFFFFFP-32ULR' -D__TA_IBIT__='64' -D__LDBL_MAX_EXP__='1024' -D__WINT_MIN__='0U' -D__linux__='1' -D__ULLFRACT_MIN__='0.0ULLR' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='0U' -D__INT64_C(c)='c ## LL' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D_FORTIFY_SOURCE='2' -D__LLACCUM_MIN__='(-0X1P31LLK-0X1P31LLK)' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='4' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USACCUM_IBIT__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__LFRACT_MIN__='(-0.5LR-0.5LR)' -D__HA_IBIT__='8' -D__ARM_NEON_FP='4' -D__TQ_IBIT__='0' -D__FLT_EPSILON__='1.1920928955078125e-7F' -D__APCS_32__='1' -D__GXX_WEAK__='1' -D__USFRACT_IBIT__='0' -D__LDBL_MIN__='2.2250738585072014e-308L' -D__FRACT_MIN__='(-0.5R-0.5R)' -D__DEC32_MAX__='9.999999E96DF' -D__DA_IBIT__='32' -D__ARM_SIZEOF_MINIMAL_ENUM='4' -D__INT32_MAX__='2147483647' -D__UQQ_FBIT__='8' -D__SIZEOF_LONG__='4' -D__UACCUM_MAX__='0XFFFFFFFFP-16UK' -D__STDC_IEC_559__='1' -D__STDC_ISO_10646__='201103L' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='17' -D__LFRACT_EPSILON__='0x1P-31LR' -D__ULFRACT_MIN__='0.0ULR' -D__gnu_linux__='1' -D__has_include_next(STR)='__has_include_next__(STR)' -D__ARM_PCS_VFP='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__ULACCUM_IBIT__='32' -D__UACCUM_EPSILON__='0x1P-16UK' -D__GNUC__='4' -D__ULLACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULLK' -D__GXX_RTTI='1' -D__HQ_IBIT__='0' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='8' -D__BIGGEST_ALIGNMENT__='8' -D__DQ_IBIT__='0' -D__DBL_MAX__='double(1.7976931348623157e+308L)' -D__ULFRACT_IBIT__='0' -D__INT_FAST32_MAX__='2147483647' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807LL' -D__ACCUM_IBIT__='16' -D__DEC32_MIN_EXP__='(-94)' -D__THUMB_INTERWORK__='1' -D__LACCUM_MAX__='0X7FFFFFFFFFFFFFFFP-31LK' -D__INT_FAST16_TYPE__='int' -D__LDBL_HAS_DENORM__='1' -D__ARM_FEATURE_LDREX='15' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__ACCUM_MAX__='0X7FFFFFFFP-15K' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__USACCUM_EPSILON__='0x1P-8UHK' -D__DEC128_EPSILON__='1E-33DL' -D__SFRACT_MAX__='0X7FP-7HR' -D__FRACT_IBIT__='0' -D__PTRDIFF_MAX__='2147483647' -D__UACCUM_MIN__='0.0UK' -D__STDC_NO_THREADS__='1' -D__UACCUM_IBIT__='16' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='4' -D__ULACCUM_MAX__='0XFFFFFFFFFFFFFFFFP-32ULK' -D__SIZEOF_WINT_T__='4' -D__SA_IBIT__='16' -D__ULLACCUM_MIN__='0.0ULLK' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__UTA_FBIT__='64' -D__FLT_MIN_EXP__='(-125)' -D__USFRACT_MAX__='0XFFP-8UHR' -D__UFRACT_IBIT__='0' -D__ARM_FEATURE_QBIT='1' -D__INT_FAST64_TYPE__='long long int' -D__DBL_MIN__='double(2.2250738585072014e-308L)' -D__FLT_MIN_10_EXP__='(-37)' -D__LACCUM_MIN__='(-0X1P31LK-0X1P31LK)' -D__ULLACCUM_FBIT__='32' -D__GXX_TYPEINFO_EQUALITY_INLINE='0' -D__ULLFRACT_EPSILON__='0x1P-64ULLR' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__ACCUM_MIN__='(-0X1P15K-0X1P15K)' -D__SQ_IBIT__='0' -D__UINT8_TYPE__='unsigned char' -D__UHA_FBIT__='8' -D__SFRACT_MIN__='(-0.5HR-0.5HR)' -D__UTQ_FBIT__='128' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.9.2 20141101 (Red Hat 4.9.2-1)"' -D__UINT64_C(c)='c ## ULL' -D__ULLFRACT_FBIT__='64' -D__FRACT_EPSILON__='0x1P-15R' -D__ULACCUM_MIN__='0.0ULK' -D_STDC_PREDEF_H='1' -D__UDA_FBIT__='32' -D__LLACCUM_EPSILON__='0x1P-31LLK' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__USFRACT_MIN__='0.0UHR' -D__ULLACCUM_IBIT__='32' -D__UQQ_IBIT__='0' -D__STDC_IEC_559_COMPLEX__='1' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__UHQ_FBIT__='16' -D__LLACCUM_FBIT__='31' -D__INT_FAST32_TYPE__='int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='unsigned int' -D__UINT64_MAX__='18446744073709551615ULL' -D__UDQ_FBIT__='64' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__ULFRACT_EPSILON__='0x1P-32ULR' -D__LLFRACT_FBIT__='63' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__ARM_ARCH_PROFILE='65' -D__LDBL_EPSILON__='2.2204460492503131e-16L' -D__UINTMAX_C(c)='c ## ULL' -D__GNUC_RH_RELEASE__='1' -D__SACCUM_MAX__='0X7FFFP-7HK' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__VFP_FP__='1' -D__SIZEOF_PTRDIFF_T__='4' -D__LACCUM_EPSILON__='0x1P-31LK' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='2147483647' -D__UINT_FAST32_MAX__='4294967295U' -D__UINT_LEAST64_TYPE__='long long unsigned int' -D__USACCUM_MAX__='0XFFFFP-8UHK' -D__SFRACT_EPSILON__='0x1P-7HR' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='2147483647L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__unix='1' -D__USA_FBIT__='16' -D__UINT_FAST16_TYPE__='unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__ARM_32BIT_STATE='1' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__SACCUM_FBIT__='7' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long long int' -D__ARM_FEATURE_CLZ='1' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__SQ_FBIT__='31' -D__DEC32_MAX_EXP__='97' -D__ARM_ARCH_ISA_THUMB='2' -D__INT_FAST8_MAX__='127' -D__ARM_ARCH='7' -D__INTPTR_MAX__='2147483647' -D__QQ_FBIT__='7' -Dlinux='1' -D__UTA_IBIT__='64' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='53' -D__SFRACT_FBIT__='7' -D__SACCUM_MIN__='(-0X1P7HK-0X1P7HK)' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__INTPTR_TYPE__='int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='unsigned int' -D__SIZEOF_FLOAT__='4' -D__USQ_FBIT__='32' -D__UINTPTR_MAX__='4294967295U' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807LL' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long long unsigned int' -D__INT_MAX__='2147483647' -D__LACCUM_FBIT__='31' -D__USACCUM_MIN__='0.0UHK' -D__UHA_IBIT__='8' -D__INT64_TYPE__='long long int' -D__FLT_MAX_EXP__='128' -D__UTQ_IBIT__='0' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807LL' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__ULLFRACT_IBIT__='0' -D__LDBL_MIN_EXP__='(-1021)' -D__arm__='1' -D__UDA_IBIT__='32' -D__INT_LEAST8_MAX__='127' -D__LFRACT_FBIT__='31' -D__WCHAR_UNSIGNED__='1' -D__ARM_ARCH_7A__='1' -D__LDBL_MAX_10_EXP__='308' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.2204460492503131e-16L)' -D__ARM_FEATURE_SIMD32='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long long unsigned int' -D__LLFRACT_MAX__='0X7FFFFFFFFFFFFFFFP-63LLR' -D__TQ_FBIT__='127' -D__INT_FAST8_TYPE__='signed char' -D__ULLACCUM_EPSILON__='0x1P-32ULLK' -D__UHQ_IBIT__='0' -D__LLACCUM_IBIT__='32' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__TA_FBIT__='63' -D__UDQ_IBIT__='0' -D__ORDER_BIG_ENDIAN__='4321' -D__ACCUM_EPSILON__='0x1P-15K' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807LL' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.4012984643248171e-45F' -D__LLFRACT_IBIT__='0' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.4028234663852886e+38F' -D__USACCUM_FBIT__='8' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__UFRACT_EPSILON__='0x1P-16UR' -D__INTMAX_TYPE__='long long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='9' -D__UINTMAX_MAX__='18446744073709551615ULL' -D__DEC32_MANT_DIG__='7' -D__HA_FBIT__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='4.9406564584124654e-324L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='int' -D__LLFRACT_MIN__='(-0.5LLR-0.5LLR)' -D__ATOMIC_SEQ_CST='5' -D__DA_FBIT__='31' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='unsigned int' -D__USA_IBIT__='16' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__ARM_EABI__='1' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-307)' -D__SIZEOF_LONG_LONG__='8' -D__ULACCUM_EPSILON__='0x1P-32ULK' -D__SACCUM_IBIT__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='15' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='4294967295U' -D__GNUC_GNU_INLINE__='1' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__ULLFRACT_MAX__='0XFFFFFFFFFFFFFFFFP-64ULLR' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__USFRACT_EPSILON__='0x1P-8UHR' -D__ULACCUM_FBIT__='32' -D__ARM_FEATURE_DSP='1' -D__QQ_IBIT__='0' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9/GCC/4.9" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/armv7hl-redhat-linux-gnueabi" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/../../../../include/c++/4.9.2/backward" -isystem"/usr/lib/gcc/armv7hl-redhat-linux-gnueabi/4.9.2/include" -isystem"/usr/local/include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/home/jwsmith/HDD/lcgcmake-install-gcc49/gccxml/0.9.0_20131026/armv7l-fc21-gcc49-opt/share/gccxml-0.9"

Compiler info:
lcg-g++-4.9.1 (GCC) 4.9.2 20141101 (Red Hat 4.9.2-1)
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/home/jwsmith/HDD/Gaudi/GaudiExamples/src/IO/dict.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("Gaudi::Examples") );
  ::Reflex::Type type_112 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_630 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_493 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2904 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_2883 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1439 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_240 = ::Reflex::TypeBuilder(Reflex::Literal("DataObject"));
  ::Reflex::Type type_53 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_2106 = ::Reflex::TypeBuilder(Reflex::Literal("StatusCode"));
  ::Reflex::Type type_3223 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Time"));
  ::Reflex::Type type_1635 = ::Reflex::TypeBuilder(Reflex::Literal("StreamBuffer"));
  ::Reflex::Type type_1217 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefBase"));
  ::Reflex::Type type_930 = ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject"));
  ::Reflex::Type type_2424 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_2103 = ::Reflex::TypeBuilder(Reflex::Literal("KeyedObject<int>"));
  ::Reflex::Type type_463 = ::Reflex::TypeBuilder(Reflex::Literal("ObjectContainerBase"));
  ::Reflex::Type type_4314 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Examples::Event"));
  ::Reflex::Type type_2291 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3082 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Examples::MyTrack"));
  ::Reflex::Type type_9110 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Examples::Counter"));
  ::Reflex::Type type_3025 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Examples::MyVertex"));
  ::Reflex::Type type_4357 = ::Reflex::TypeBuilder(Reflex::Literal("Gaudi::Examples::Collision"));
  ::Reflex::Type type_2260 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ContainedObject*>"));
  ::Reflex::Type type_2257 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<KeyedObject<int>*>"));
  ::Reflex::Type type_2007 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::Event>"));
  ::Reflex::Type type_2595 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<KeyedObject<int>*>"));
  ::Reflex::Type type_2006 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::MyTrack>"));
  ::Reflex::Type type_2005 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::MyVertex>"));
  ::Reflex::Type type_2259 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const ContainedObject*>"));
  ::Reflex::Type type_2008 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::Collision>"));
  ::Reflex::Type type_373 = ::Reflex::TypeBuilder(Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>"));
  ::Reflex::Type type_372 = ::Reflex::TypeBuilder(Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>"));
  ::Reflex::Type type_2261 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>"));
  ::Reflex::Type type_445 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<Gaudi::Examples::MyTrack>"));
  ::Reflex::Type type_2258 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>"));
  ::Reflex::Type type_443 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<Gaudi::Examples::MyVertex>"));
  ::Reflex::Type type_444 = ::Reflex::TypeBuilder(Reflex::Literal("SmartRefVector<Gaudi::Examples::Collision>"));
  ::Reflex::Type type_2599 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Gaudi::Examples::MyTrack*>"));
  ::Reflex::Type type_2596 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Gaudi::Examples::MyVertex*>"));
  ::Reflex::Type type_2266 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const Gaudi::Examples::MyTrack*>"));
  ::Reflex::Type type_2711 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_1591 = ::Reflex::TypeBuilder(Reflex::Literal("SharedObjectsContainer<Gaudi::Examples::MyTrack>"));
  ::Reflex::Type type_2264 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >"));
  ::Reflex::Type type_2263 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >"));
  ::Reflex::Type type_2265 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >"));
  ::Reflex::Type type_3278 = ::Reflex::TypeBuilder(Reflex::Literal("Containers::KeyedObjectManager<Containers::hashmap>"));
  ::Reflex::Type type_2602 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<Gaudi::Examples::MyTrack> >"));
  ::Reflex::Type type_2601 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<Gaudi::Examples::MyVertex> >"));
  ::Reflex::Type type_2603 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SmartRef<Gaudi::Examples::Collision> >"));
  ::Reflex::Type type_3965 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<KeyedObject<int>*> >"));
  ::Reflex::Type type_3967 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<Gaudi::Examples::MyTrack*> >"));
  ::Reflex::Type type_3966 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<Gaudi::Examples::MyVertex*> >"));
  ::Reflex::Type type_2218 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<KeyedObject<int>*,std::allocator<KeyedObject<int>*> >"));
  ::Reflex::Type type_3968 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<Gaudi::Examples::MyTrack> > >"));
  ::Reflex::Type type_3918 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >"));
  ::Reflex::Type type_3969 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<Gaudi::Examples::MyVertex> > >"));
  ::Reflex::Type type_3973 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SmartRef<Gaudi::Examples::Collision> > >"));
  ::Reflex::Type type_3919 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<KeyedObject<int>* const*,std::vector<KeyedObject<int>*> >"));
  ::Reflex::Type type_2220 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> >"));
  ::Reflex::Type type_2219 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> >"));
  ::Reflex::Type type_970 = ::Reflex::TypeBuilder(Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >"));
  ::Reflex::Type type_969 = ::Reflex::TypeBuilder(Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >"));
  ::Reflex::Type type_3090 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >"));
  ::Reflex::Type type_3295 = ::Reflex::TypeBuilder(Reflex::Literal("Containers::traits<Containers::KeyedObjectManager<Containers::hashmap>,Gaudi::Examples::MyTrack>"));
  ::Reflex::Type type_3294 = ::Reflex::TypeBuilder(Reflex::Literal("Containers::traits<Containers::KeyedObjectManager<Containers::hashmap>,Gaudi::Examples::MyVertex>"));
  ::Reflex::Type type_3033 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >"));
  ::Reflex::Type type_3092 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> >"));
  ::Reflex::Type type_3035 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> >"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> > >"));
  ::Reflex::Type type_2221 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > >"));
  ::Reflex::Type type_2222 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > >"));
  ::Reflex::Type type_2665 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<KeyedObject<int>* const*,std::vector<KeyedObject<int>*> > >"));
  ::Reflex::Type type_2226 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > >"));
  ::Reflex::Type type_3923 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >"));
  ::Reflex::Type type_3921 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >"));
  ::Reflex::Type type_3922 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >"));
  ::Reflex::Type type_2670 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> > >"));
  ::Reflex::Type type_3200 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >"));
  ::Reflex::Type type_2668 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> > >"));
  ::Reflex::Type type_3162 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >"));
  ::Reflex::Type type_3181 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >"));
  ::Reflex::Type type_2669 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> > >"));
  ::Reflex::Type type_2667 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> > >"));
  ::Reflex::Type type_2672 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > > >"));
  ::Reflex::Type type_2674 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > > >"));
  ::Reflex::Type type_2682 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > > >"));
  ::Reflex::Type type_2671 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > > >"));
  ::Reflex::Type type_2673 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > > >"));
  ::Reflex::Type type_2681 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > > >"));
  ::Reflex::Type type_10498 = ::Reflex::ReferenceBuilder(type_3025);
  ::Reflex::Type type_3025c = ::Reflex::ConstBuilder(type_3025);
  ::Reflex::Type type_10499 = ::Reflex::ReferenceBuilder(type_3025c);
  ::Reflex::Type type_1391 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("CLID"), type_53);
  ::Reflex::Type type_1391c = ::Reflex::ConstBuilder(type_1391);
  ::Reflex::Type type_8974 = ::Reflex::ReferenceBuilder(type_1391c);
  ::Reflex::Type type_4314c = ::Reflex::ConstBuilder(type_4314);
  ::Reflex::Type type_10503 = ::Reflex::PointerBuilder(type_4314c);
  ::Reflex::Type type_10526 = ::Reflex::PointerBuilder(type_4314);
  ::Reflex::Type type_3082c = ::Reflex::ConstBuilder(type_3082);
  ::Reflex::Type type_10500 = ::Reflex::PointerBuilder(type_3082c);
  ::Reflex::Type type_3084 = ::Reflex::PointerBuilder(type_3082);
  ::Reflex::Type type_445c = ::Reflex::ConstBuilder(type_445);
  ::Reflex::Type type_4196 = ::Reflex::ReferenceBuilder(type_445c);
  ::Reflex::Type type_444c = ::Reflex::ConstBuilder(type_444);
  ::Reflex::Type type_4202 = ::Reflex::ReferenceBuilder(type_444c);
  ::Reflex::Type type_10542 = ::Reflex::PointerBuilder(type_4357);
  ::Reflex::Type type_3724 = ::Reflex::ReferenceBuilder(type_1635);
  ::Reflex::Type type_3027 = ::Reflex::PointerBuilder(type_3025);
  ::Reflex::Type type_3029 = ::Reflex::ReferenceBuilder(type_3027);
  ::Reflex::Type type_3027c = ::Reflex::ConstBuilder(type_3027);
  ::Reflex::Type type_3031 = ::Reflex::ReferenceBuilder(type_3027c);
  ::Reflex::Type type_3039 = ::Reflex::PointerBuilder(type_3027);
  ::Reflex::Type type_3041 = ::Reflex::PointerBuilder(type_3027c);
  ::Reflex::Type type_2904c = ::Reflex::ConstBuilder(type_2904);
  ::Reflex::Type type_2826 = ::Reflex::PointerBuilder(type_2904c);
  ::Reflex::Type type_372c = ::Reflex::ConstBuilder(type_372);
  ::Reflex::Type type_9033 = ::Reflex::ReferenceBuilder(type_372c);
  ::Reflex::Type type_1516 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_53);
  ::Reflex::Type type_5534 = ::Reflex::PointerBuilder(type_930);
  ::Reflex::Type type_930c = ::Reflex::ConstBuilder(type_930);
  ::Reflex::Type type_9034 = ::Reflex::PointerBuilder(type_930c);
  ::Reflex::Type type_5307 = ::Reflex::ReferenceBuilder(type_2711);
  ::Reflex::Type type_10501 = ::Reflex::ReferenceBuilder(type_3082);
  ::Reflex::Type type_10502 = ::Reflex::ReferenceBuilder(type_3082c);
  ::Reflex::Type type_10497 = ::Reflex::PointerBuilder(type_3025c);
  ::Reflex::Type type_443c = ::Reflex::ConstBuilder(type_443);
  ::Reflex::Type type_4198 = ::Reflex::ReferenceBuilder(type_443c);
  ::Reflex::Type type_3086 = ::Reflex::ReferenceBuilder(type_3084);
  ::Reflex::Type type_3084c = ::Reflex::ConstBuilder(type_3084);
  ::Reflex::Type type_3088 = ::Reflex::ReferenceBuilder(type_3084c);
  ::Reflex::Type type_3096 = ::Reflex::PointerBuilder(type_3084);
  ::Reflex::Type type_3098 = ::Reflex::PointerBuilder(type_3084c);
  ::Reflex::Type type_373c = ::Reflex::ConstBuilder(type_373);
  ::Reflex::Type type_9067 = ::Reflex::ReferenceBuilder(type_373c);
  ::Reflex::Type type_240c = ::Reflex::ConstBuilder(type_240);
  ::Reflex::Type type_9073 = ::Reflex::PointerBuilder(type_240c);
  ::Reflex::Type type_3727 = ::Reflex::ReferenceBuilder(type_443);
  ::Reflex::Type type_9074 = ::Reflex::PointerBuilder(type_240);
  ::Reflex::Type type_2424c = ::Reflex::ConstBuilder(type_2424);
  ::Reflex::Type type_9075 = ::Reflex::PointerBuilder(type_2424c);
  ::Reflex::Type type_10543 = ::Reflex::ReferenceBuilder(type_4357);
  ::Reflex::Type type_4357c = ::Reflex::ConstBuilder(type_4357);
  ::Reflex::Type type_10544 = ::Reflex::ReferenceBuilder(type_4357c);
  ::Reflex::Type type_3731 = ::Reflex::ReferenceBuilder(type_444);
  ::Reflex::Type type_3725 = ::Reflex::ReferenceBuilder(type_445);
  ::Reflex::Type type_9340 = ::Reflex::PointerBuilder(type_2258);
  ::Reflex::Type type_9341 = ::Reflex::ReferenceBuilder(type_969);
  ::Reflex::Type type_969c = ::Reflex::ConstBuilder(type_969);
  ::Reflex::Type type_9342 = ::Reflex::ReferenceBuilder(type_969c);
  ::Reflex::Type type_9343 = ::Reflex::ReferenceBuilder(type_2260);
  ::Reflex::Type type_2259c = ::Reflex::ConstBuilder(type_2259);
  ::Reflex::Type type_9344 = ::Reflex::PointerBuilder(type_2259c);
  ::Reflex::Type type_112c = ::Reflex::ConstBuilder(type_112);
  ::Reflex::Type type_8348 = ::Reflex::ReferenceBuilder(type_112c);
  ::Reflex::Type type_9345 = ::Reflex::PointerBuilder(type_2261);
  ::Reflex::Type type_9346 = ::Reflex::ReferenceBuilder(type_970);
  ::Reflex::Type type_970c = ::Reflex::ConstBuilder(type_970);
  ::Reflex::Type type_9347 = ::Reflex::ReferenceBuilder(type_970c);
  ::Reflex::Type type_2005c = ::Reflex::ConstBuilder(type_2005);
  ::Reflex::Type type_4199 = ::Reflex::ReferenceBuilder(type_2005c);
  ::Reflex::Type type_2291c = ::Reflex::ConstBuilder(type_2291);
  ::Reflex::Type type_4211 = ::Reflex::ReferenceBuilder(type_2291c);
  ::Reflex::Type type_3728 = ::Reflex::ReferenceBuilder(type_2005);
  ::Reflex::Type type_2006c = ::Reflex::ConstBuilder(type_2006);
  ::Reflex::Type type_4197 = ::Reflex::ReferenceBuilder(type_2006c);
  ::Reflex::Type type_3726 = ::Reflex::ReferenceBuilder(type_2006);
  ::Reflex::Type type_10527 = ::Reflex::ReferenceBuilder(type_4314);
  ::Reflex::Type type_10528 = ::Reflex::ReferenceBuilder(type_4314c);
  ::Reflex::Type type_3223c = ::Reflex::ConstBuilder(type_3223);
  ::Reflex::Type type_2989 = ::Reflex::ReferenceBuilder(type_3223c);
  ::Reflex::Type type_2812 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_2711);
  ::Reflex::Type type_4205 = ::Reflex::ReferenceBuilder(type_2812);
  ::Reflex::Type type_2007c = ::Reflex::ConstBuilder(type_2007);
  ::Reflex::Type type_4200 = ::Reflex::ReferenceBuilder(type_2007c);
  ::Reflex::Type type_3729 = ::Reflex::ReferenceBuilder(type_2007);
  ::Reflex::Type type_10529 = ::Reflex::PointerBuilder(type_4357c);
  ::Reflex::Type type_2008c = ::Reflex::ConstBuilder(type_2008);
  ::Reflex::Type type_4201 = ::Reflex::ReferenceBuilder(type_2008c);
  ::Reflex::Type type_3730 = ::Reflex::ReferenceBuilder(type_2008);
  ::Reflex::Type type_5402 = ::Reflex::PointerBuilder(type_2103);
  ::Reflex::Type type_5079 = ::Reflex::PointerBuilder(type_5402);
  ::Reflex::Type type_5402c = ::Reflex::ConstBuilder(type_5402);
  ::Reflex::Type type_5409 = ::Reflex::PointerBuilder(type_5402c);
  ::Reflex::Type type_5411 = ::Reflex::ReferenceBuilder(type_5402);
  ::Reflex::Type type_5413 = ::Reflex::ReferenceBuilder(type_5402c);
  ::Reflex::Type type_2567 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_53);
  ::Reflex::Type type_2357 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_112);
  ::Reflex::Type type_2595c = ::Reflex::ConstBuilder(type_2595);
  ::Reflex::Type type_12222 = ::Reflex::ReferenceBuilder(type_2595c);
  ::Reflex::Type type_2257c = ::Reflex::ConstBuilder(type_2257);
  ::Reflex::Type type_12396 = ::Reflex::ReferenceBuilder(type_2257c);
  ::Reflex::Type type_12397 = ::Reflex::ReferenceBuilder(type_2257);
  ::Reflex::Type type_2596c = ::Reflex::ConstBuilder(type_2596);
  ::Reflex::Type type_12235 = ::Reflex::ReferenceBuilder(type_2596c);
  ::Reflex::Type type_2258c = ::Reflex::ConstBuilder(type_2258);
  ::Reflex::Type type_12398 = ::Reflex::ReferenceBuilder(type_2258c);
  ::Reflex::Type type_12399 = ::Reflex::ReferenceBuilder(type_2258);
  ::Reflex::Type type_2599c = ::Reflex::ConstBuilder(type_2599);
  ::Reflex::Type type_12248 = ::Reflex::ReferenceBuilder(type_2599c);
  ::Reflex::Type type_2261c = ::Reflex::ConstBuilder(type_2261);
  ::Reflex::Type type_12402 = ::Reflex::ReferenceBuilder(type_2261c);
  ::Reflex::Type type_12403 = ::Reflex::ReferenceBuilder(type_2261);
  ::Reflex::Type type_5153 = ::Reflex::PointerBuilder(type_2005);
  ::Reflex::Type type_5738 = ::Reflex::PointerBuilder(type_2005c);
  ::Reflex::Type type_2601c = ::Reflex::ConstBuilder(type_2601);
  ::Reflex::Type type_12274 = ::Reflex::ReferenceBuilder(type_2601c);
  ::Reflex::Type type_2263c = ::Reflex::ConstBuilder(type_2263);
  ::Reflex::Type type_4222 = ::Reflex::ReferenceBuilder(type_2263c);
  ::Reflex::Type type_3733 = ::Reflex::ReferenceBuilder(type_2263);
  ::Reflex::Type type_5134 = ::Reflex::PointerBuilder(type_2006);
  ::Reflex::Type type_5803 = ::Reflex::PointerBuilder(type_2006c);
  ::Reflex::Type type_2602c = ::Reflex::ConstBuilder(type_2602);
  ::Reflex::Type type_12261 = ::Reflex::ReferenceBuilder(type_2602c);
  ::Reflex::Type type_2264c = ::Reflex::ConstBuilder(type_2264);
  ::Reflex::Type type_12406 = ::Reflex::ReferenceBuilder(type_2264c);
  ::Reflex::Type type_12407 = ::Reflex::ReferenceBuilder(type_2264);
  ::Reflex::Type type_5227 = ::Reflex::PointerBuilder(type_2008);
  ::Reflex::Type type_5868 = ::Reflex::PointerBuilder(type_2008c);
  ::Reflex::Type type_2603c = ::Reflex::ConstBuilder(type_2603);
  ::Reflex::Type type_12326 = ::Reflex::ReferenceBuilder(type_2603c);
  ::Reflex::Type type_2265c = ::Reflex::ConstBuilder(type_2265);
  ::Reflex::Type type_4223 = ::Reflex::ReferenceBuilder(type_2265c);
  ::Reflex::Type type_3734 = ::Reflex::ReferenceBuilder(type_2265);
  ::Reflex::Type type_15815 = ::Reflex::ReferenceBuilder(type_9110);
  ::Reflex::Type type_9110c = ::Reflex::ConstBuilder(type_9110);
  ::Reflex::Type type_15816 = ::Reflex::ReferenceBuilder(type_9110c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __Gaudi__Examples__MyVertex
#undef __Gaudi__Examples__MyVertex
#endif
class __Gaudi__Examples__MyVertex : public ::KeyedObject<int> {
  public:
  __Gaudi__Examples__MyVertex();
  virtual ~__Gaudi__Examples__MyVertex() throw();
  virtual ::StreamBuffer& serialize(StreamBuffer&) const throw();
  virtual const ::CLID& clID() const throw();
  virtual ::StreamBuffer& serialize(StreamBuffer&) throw();
  float m_x;
  float m_y;
  float m_z;
  ::SmartRef<Gaudi::Examples::Event> m_event;
  ::SmartRef<Gaudi::Examples::MyTrack> m_motherParticle;
  ::SmartRefVector<Gaudi::Examples::MyTrack> m_decayParticles;
  ::SmartRefVector<Gaudi::Examples::Collision> m_collisions;
};
#ifdef __ObjectVector_Gaudi__Examples__MyVertex_
#undef __ObjectVector_Gaudi__Examples__MyVertex_
#endif
class __ObjectVector_Gaudi__Examples__MyVertex_ : public ::ObjectContainerBase {
  public:
  __ObjectVector_Gaudi__Examples__MyVertex_();
  virtual ~__ObjectVector_Gaudi__Examples__MyVertex_() throw();
  virtual const ::CLID& clID() const throw();
  virtual long index(ContainedObject const*) const throw();
  virtual ::size_t numberOfObjects() const throw();
  virtual ::std::basic_ostream<char,std::char_traits<char> >& fillStream(std::ostream&) const throw();
  virtual long add(ContainedObject*) throw();
  virtual long remove(ContainedObject*) throw();
  virtual ::ContainedObject* containedObject(long) const throw();
  ::std::vector<Gaudi::Examples::MyVertex*> m_vector;
};
#ifdef __Gaudi__Examples__MyTrack
#undef __Gaudi__Examples__MyTrack
#endif
class __Gaudi__Examples__MyTrack : public ::KeyedObject<int> {
  public:
  __Gaudi__Examples__MyTrack();
  virtual ~__Gaudi__Examples__MyTrack() throw();
  virtual ::StreamBuffer& serialize(StreamBuffer&) const throw();
  virtual const ::CLID& clID() const throw();
  virtual ::StreamBuffer& serialize(StreamBuffer&) throw();
  float m_px;
  float m_py;
  float m_pz;
  ::SmartRef<Gaudi::Examples::Event> m_event;
  ::SmartRef<Gaudi::Examples::MyVertex> m_originVertex;
  ::SmartRefVector<Gaudi::Examples::MyVertex> m_decayVertices;
};
#ifdef __ObjectVector_Gaudi__Examples__MyTrack_
#undef __ObjectVector_Gaudi__Examples__MyTrack_
#endif
class __ObjectVector_Gaudi__Examples__MyTrack_ : public ::ObjectContainerBase {
  public:
  __ObjectVector_Gaudi__Examples__MyTrack_();
  virtual ~__ObjectVector_Gaudi__Examples__MyTrack_() throw();
  virtual const ::CLID& clID() const throw();
  virtual long index(ContainedObject const*) const throw();
  virtual ::size_t numberOfObjects() const throw();
  virtual ::std::basic_ostream<char,std::char_traits<char> >& fillStream(std::ostream&) const throw();
  virtual long add(ContainedObject*) throw();
  virtual long remove(ContainedObject*) throw();
  virtual ::ContainedObject* containedObject(long) const throw();
  ::std::vector<Gaudi::Examples::MyTrack*> m_vector;
};
#ifdef __SmartRefVector_Gaudi__Examples__MyVertex_
#undef __SmartRefVector_Gaudi__Examples__MyVertex_
#endif
class __SmartRefVector_Gaudi__Examples__MyVertex_ : public ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > {
  public:
  __SmartRefVector_Gaudi__Examples__MyVertex_();
  void* m_data;
  void* m_contd;
};
#ifdef __Gaudi__Examples__Collision
#undef __Gaudi__Examples__Collision
#endif
class __Gaudi__Examples__Collision : public ::DataObject {
  public:
  __Gaudi__Examples__Collision();
  virtual ~__Gaudi__Examples__Collision() throw();
  int m_collision;
};
#ifdef __SmartRefVector_Gaudi__Examples__Collision_
#undef __SmartRefVector_Gaudi__Examples__Collision_
#endif
class __SmartRefVector_Gaudi__Examples__Collision_ : public ::std::vector<SmartRef<Gaudi::Examples::Collision> > {
  public:
  __SmartRefVector_Gaudi__Examples__Collision_();
  void* m_data;
  void* m_contd;
};
#ifdef __SmartRefVector_Gaudi__Examples__MyTrack_
#undef __SmartRefVector_Gaudi__Examples__MyTrack_
#endif
class __SmartRefVector_Gaudi__Examples__MyTrack_ : public ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > {
  public:
  __SmartRefVector_Gaudi__Examples__MyTrack_();
  void* m_data;
  void* m_contd;
};
#ifdef __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_
#undef __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_
#endif
class __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_ : public ::ObjectContainerBase {
  public:
  __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_();
  virtual ~__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_() throw();
#ifdef __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease
#undef __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease
#endif
  struct __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease {
    public:
    __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease();
  };
#ifdef __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease
#undef __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease
#endif
  struct __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease {
    public:
    __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease();
  };
  virtual const ::CLID& clID() const throw();
  virtual long index(ContainedObject const*) const throw();
  virtual ::size_t numberOfObjects() const throw();
  virtual const ::std::vector<const ContainedObject*>* containedObjects() const throw();
  virtual long add(ContainedObject*) throw();
  virtual ::StatusCode update() throw();
  virtual ::size_t containedObjects(std::vector<ContainedObject*, std::allocator<ContainedObject*> >&) const throw();
  virtual long remove(ContainedObject*) throw();
  virtual ::ContainedObject* containedObject(long) const throw();
  ::Containers::KeyedObjectManager<Containers::hashmap> m_cont;
  ::std::vector<Gaudi::Examples::MyVertex*> m_sequential;
  void* m_random;
};
#ifdef __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_
#undef __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_
#endif
class __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_ : public ::ObjectContainerBase {
  public:
  __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_();
  virtual ~__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_() throw();
#ifdef __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease
#undef __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease
#endif
  struct __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease {
    public:
    __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____InsertRelease();
  };
#ifdef __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease
#undef __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease
#endif
  struct __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease {
    public:
    __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s____RemoveRelease();
  };
  virtual const ::CLID& clID() const throw();
  virtual long index(ContainedObject const*) const throw();
  virtual ::size_t numberOfObjects() const throw();
  virtual const ::std::vector<const ContainedObject*>* containedObjects() const throw();
  virtual long add(ContainedObject*) throw();
  virtual ::StatusCode update() throw();
  virtual ::size_t containedObjects(std::vector<ContainedObject*, std::allocator<ContainedObject*> >&) const throw();
  virtual long remove(ContainedObject*) throw();
  virtual ::ContainedObject* containedObject(long) const throw();
  ::Containers::KeyedObjectManager<Containers::hashmap> m_cont;
  ::std::vector<Gaudi::Examples::MyTrack*> m_sequential;
  void* m_random;
};
#ifdef __SmartRef_Gaudi__Examples__MyVertex_
#undef __SmartRef_Gaudi__Examples__MyVertex_
#endif
class __SmartRef_Gaudi__Examples__MyVertex_ {
  public:
  __SmartRef_Gaudi__Examples__MyVertex_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_Gaudi__Examples__MyTrack_
#undef __SmartRef_Gaudi__Examples__MyTrack_
#endif
class __SmartRef_Gaudi__Examples__MyTrack_ {
  public:
  __SmartRef_Gaudi__Examples__MyTrack_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __Gaudi__Examples__Event
#undef __Gaudi__Examples__Event
#endif
class __Gaudi__Examples__Event : public ::DataObject {
  public:
  __Gaudi__Examples__Event();
  virtual ~__Gaudi__Examples__Event() throw();
  int m_event;
  int m_run;
  ::Gaudi::Time m_time;
  ::SmartRefVector<Gaudi::Examples::Collision> m_collisions;
};
#ifdef __SmartRef_Gaudi__Examples__Event_
#undef __SmartRef_Gaudi__Examples__Event_
#endif
class __SmartRef_Gaudi__Examples__Event_ {
  public:
  __SmartRef_Gaudi__Examples__Event_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __SmartRef_Gaudi__Examples__Collision_
#undef __SmartRef_Gaudi__Examples__Collision_
#endif
class __SmartRef_Gaudi__Examples__Collision_ {
  public:
  __SmartRef_Gaudi__Examples__Collision_();
  ::SmartRefBase m_base;
  void* m_target;
};
#ifdef __std__vector_KeyedObject_int_p_
#undef __std__vector_KeyedObject_int_p_
#endif
class __std__vector_KeyedObject_int_p_ : protected ::std::_Vector_base<KeyedObject<int>*,std::allocator<KeyedObject<int>*> > {
  public:
  __std__vector_KeyedObject_int_p_();
};
#ifdef __std__vector_Gaudi__Examples__MyVertexp_
#undef __std__vector_Gaudi__Examples__MyVertexp_
#endif
class __std__vector_Gaudi__Examples__MyVertexp_ : protected ::std::_Vector_base<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> > {
  public:
  __std__vector_Gaudi__Examples__MyVertexp_();
};
#ifdef __std__vector_Gaudi__Examples__MyTrackp_
#undef __std__vector_Gaudi__Examples__MyTrackp_
#endif
class __std__vector_Gaudi__Examples__MyTrackp_ : protected ::std::_Vector_base<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> > {
  public:
  __std__vector_Gaudi__Examples__MyTrackp_();
};
#ifdef __std__vector_SmartRef_Gaudi__Examples__MyVertex_s_
#undef __std__vector_SmartRef_Gaudi__Examples__MyVertex_s_
#endif
class __std__vector_SmartRef_Gaudi__Examples__MyVertex_s_ : protected ::std::_Vector_base<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > {
  public:
  __std__vector_SmartRef_Gaudi__Examples__MyVertex_s_();
};
#ifdef __std__vector_SmartRef_Gaudi__Examples__MyTrack_s_
#undef __std__vector_SmartRef_Gaudi__Examples__MyTrack_s_
#endif
class __std__vector_SmartRef_Gaudi__Examples__MyTrack_s_ : protected ::std::_Vector_base<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > {
  public:
  __std__vector_SmartRef_Gaudi__Examples__MyTrack_s_();
};
#ifdef __std__vector_SmartRef_Gaudi__Examples__Collision_s_
#undef __std__vector_SmartRef_Gaudi__Examples__Collision_s_
#endif
class __std__vector_SmartRef_Gaudi__Examples__Collision_s_ : protected ::std::_Vector_base<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > {
  public:
  __std__vector_SmartRef_Gaudi__Examples__Collision_s_();
};
#ifdef __Gaudi__Examples__Counter
#undef __Gaudi__Examples__Counter
#endif
class __Gaudi__Examples__Counter : public ::DataObject {
  public:
  __Gaudi__Examples__Counter();
  virtual ~__Gaudi__Examples__Counter() throw();
  int m_counter;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class MyVertex -------------------------------
static  void operator_9008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::MyVertex*)o)->operator=)(*(const ::Gaudi::Examples::MyVertex*)arg[0]);
  else   (((::Gaudi::Examples::MyVertex*)o)->operator=)(*(const ::Gaudi::Examples::MyVertex*)arg[0]);
}

static void constructor_9009( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::MyVertex();
  else ::new(mem) ::Gaudi::Examples::MyVertex();
}

static void constructor_9010( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::MyVertex(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
  else ::new(mem) ::Gaudi::Examples::MyVertex(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
}

static void destructor_9011(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::Examples::MyVertex*)o)->::Gaudi::Examples::MyVertex::~MyVertex)();
}
static  void method_9012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::MyVertex*)o)->clID)();
  else   (((const ::Gaudi::Examples::MyVertex*)o)->clID)();
}

static  void method_9013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::MyVertex*)o)->classID)();
  else   (((::Gaudi::Examples::MyVertex*)o)->classID)();
}

static  void method_9014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::Gaudi::Examples::MyVertex*)o)->x)());
  else   (((const ::Gaudi::Examples::MyVertex*)o)->x)();
}

static  void method_9015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::Gaudi::Examples::MyVertex*)o)->y)());
  else   (((const ::Gaudi::Examples::MyVertex*)o)->y)();
}

static  void method_9016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::Gaudi::Examples::MyVertex*)o)->z)());
  else   (((const ::Gaudi::Examples::MyVertex*)o)->z)();
}

static  void method_9017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->setX)(*(float*)arg[0]);
}

static  void method_9018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->setY)(*(float*)arg[0]);
}

static  void method_9019( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->setZ)(*(float*)arg[0]);
}

static  void method_9020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Gaudi::Examples::MyVertex*)o)->event)());
  else   (((const ::Gaudi::Examples::MyVertex*)o)->event)();
}

static  void method_9021( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->setEvent)((::Gaudi::Examples::Event*)arg[0]);
}

static  void method_9022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Gaudi::Examples::MyVertex*)o)->motherParticle)());
  else   (((const ::Gaudi::Examples::MyVertex*)o)->motherParticle)();
}

static  void method_9023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->setMotherParticle)((::Gaudi::Examples::MyTrack*)arg[0]);
}

static  void method_9024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::MyVertex*)o)->decayParticles)();
  else   (((const ::Gaudi::Examples::MyVertex*)o)->decayParticles)();
}

static  void method_9025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->addDecayParticle)((::Gaudi::Examples::MyTrack*)arg[0]);
}

static  void method_9026( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->removeDecayParticle)((::Gaudi::Examples::MyTrack*)arg[0]);
}

static  void method_9027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::MyVertex*)o)->collisions)();
  else   (((const ::Gaudi::Examples::MyVertex*)o)->collisions)();
}

static  void method_9028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->addCollision)((::Gaudi::Examples::Collision*)arg[0]);
}

static  void method_9029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyVertex*)o)->removeCollision)((::Gaudi::Examples::Collision*)arg[0]);
}

static  void method_9030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::MyVertex*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::Gaudi::Examples::MyVertex*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_9031( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::MyVertex*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::Gaudi::Examples::MyVertex*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_3025( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyVertex >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyVertex >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyVertex >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyVertex >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyVertex >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("KeyedObject<int>")), ::Reflex::BaseOffset< ::Gaudi::Examples::MyVertex,::KeyedObject<int> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject")), ::Reflex::BaseOffset< ::Gaudi::Examples::MyVertex,::ContainedObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MyVertex -------------------------------
void __Gaudi__Examples__MyVertex_db_datamem(Reflex::Class*);
void __Gaudi__Examples__MyVertex_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__MyVertex_datamem_bld(&__Gaudi__Examples__MyVertex_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__MyVertex_funcmem_bld(&__Gaudi__Examples__MyVertex_db_funcmem);
void __Gaudi__Examples__MyVertex_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::Examples::MyVertex"), typeid(::Gaudi::Examples::MyVertex), sizeof(::Gaudi::Examples::MyVertex), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00000164-0000-0000-0000-000000000000")
  .AddBase(type_2103, ::Reflex::BaseOffset< ::Gaudi::Examples::MyVertex, ::KeyedObject<int> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10498, type_10499), Reflex::Literal("operator="), operator_9008, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MyVertex"), constructor_9009, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1439, type_1439, type_1439), Reflex::Literal("MyVertex"), constructor_9010, 0, "x;y;z", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MyVertex"), destructor_9011, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3025, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__Examples__MyVertex_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__Examples__MyVertex_funcmem_bld);
}

//------Delayed data member builder for class MyVertex -------------------
void __Gaudi__Examples__MyVertex_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1439, Reflex::Literal("m_x"), OffsetOf(__shadow__::__Gaudi__Examples__MyVertex, m_x), ::Reflex::PROTECTED)
  .AddDataMember(type_1439, Reflex::Literal("m_y"), OffsetOf(__shadow__::__Gaudi__Examples__MyVertex, m_y), ::Reflex::PROTECTED)
  .AddDataMember(type_1439, Reflex::Literal("m_z"), OffsetOf(__shadow__::__Gaudi__Examples__MyVertex, m_z), ::Reflex::PROTECTED)
  .AddDataMember(type_2007, Reflex::Literal("m_event"), OffsetOf(__shadow__::__Gaudi__Examples__MyVertex, m_event), ::Reflex::PROTECTED)
  .AddDataMember(type_2006, Reflex::Literal("m_motherParticle"), OffsetOf(__shadow__::__Gaudi__Examples__MyVertex, m_motherParticle), ::Reflex::PROTECTED)
  .AddDataMember(type_445, Reflex::Literal("m_decayParticles"), OffsetOf(__shadow__::__Gaudi__Examples__MyVertex, m_decayParticles), ::Reflex::PROTECTED)
  .AddDataMember(type_444, Reflex::Literal("m_collisions"), OffsetOf(__shadow__::__Gaudi__Examples__MyVertex, m_collisions), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class MyVertex -------------------
void __Gaudi__Examples__MyVertex_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_9012, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_9013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("x"), method_9014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("y"), method_9015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("z"), method_9016, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1439), Reflex::Literal("setX"), method_9017, 0, "x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1439), Reflex::Literal("setY"), method_9018, 0, "y", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1439), Reflex::Literal("setZ"), method_9019, 0, "z", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10503), Reflex::Literal("event"), method_9020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_10526), Reflex::Literal("setEvent"), method_9021, 0, "evt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10500), Reflex::Literal("motherParticle"), method_9022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3084), Reflex::Literal("setMotherParticle"), method_9023, 0, "mother", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4196), Reflex::Literal("decayParticles"), method_9024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3084), Reflex::Literal("addDecayParticle"), method_9025, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3084), Reflex::Literal("removeDecayParticle"), method_9026, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4202), Reflex::Literal("collisions"), method_9027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_10542), Reflex::Literal("addCollision"), method_9028, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_10542), Reflex::Literal("removeCollision"), method_9029, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_9030, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_9031, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class ObjectVector<Gaudi::Examples::MyVertex> -------------------------------
static void constructor_3043( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ObjectVector<Gaudi::Examples::MyVertex>();
  else ::new(mem) ::ObjectVector<Gaudi::Examples::MyVertex>();
}

static void constructor_3044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ObjectVector<Gaudi::Examples::MyVertex>((const char*)arg[0]);
  else ::new(mem) ::ObjectVector<Gaudi::Examples::MyVertex>((const char*)arg[0]);
}

static void constructor_3045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ObjectVector<Gaudi::Examples::MyVertex>(*(const ::ObjectVector<Gaudi::Examples::MyVertex>*)arg[0]);
  else ::new(mem) ::ObjectVector<Gaudi::Examples::MyVertex>(*(const ::ObjectVector<Gaudi::Examples::MyVertex>*)arg[0]);
}

static void destructor_3046(void*, void * o, const std::vector<void*>&, void *) {
(((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->::ObjectVector<Gaudi::Examples::MyVertex>::~ObjectVector)();
}
static  void method_3047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->clID)();
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->clID)();
}

static  void method_3048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->classID)();
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->classID)();
}

static  void operator_3049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->operator=)(*(const ::ObjectVector<Gaudi::Examples::MyVertex>*)arg[0]);
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->operator=)(*(const ::ObjectVector<Gaudi::Examples::MyVertex>*)arg[0]);
}

static  void method_3050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->begin)());
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->begin)();
}

static  void method_3051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> >)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->begin)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->begin)();
}

static  void method_3052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->end)());
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->end)();
}

static  void method_3053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> >)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->end)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->end)();
}

static  void method_3058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->size)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->size)();
}

static  void method_3059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->numberOfObjects)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->numberOfObjects)();
}

static  void method_3060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->max_size)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->max_size)();
}

static  void method_3061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->capacity)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->capacity)();
}

static  void method_3062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_3063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->empty)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->empty)();
}

static  void method_3064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->front)();
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->front)();
}

static  void method_3065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->front)();
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->front)();
}

static  void method_3066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->back)();
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->back)();
}

static  void method_3067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->back)();
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->back)();
}

static  void method_3068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->push_back)(*(::Gaudi::Examples::MyVertex* const*)arg[0]);
}

static  void method_3069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->add)((::ContainedObject*)arg[0]));
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->add)((::ContainedObject*)arg[0]);
}

static  void method_3070( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->pop_back)();
}

static  void method_3071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->remove)((::ContainedObject*)arg[0]));
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->remove)((::ContainedObject*)arg[0]);
}

static  void method_3072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::Gaudi::Examples::MyVertex* const*)arg[1]));
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::Gaudi::Examples::MyVertex* const*)arg[1]);
}

static  void method_3073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0]);
}

static  void method_3074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[1]);
}

static  void method_3075( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->clear)();
}

static  void operator_3076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::ObjectVector<Gaudi::Examples::MyVertex>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_3077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_3078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->index)((const ::ContainedObject*)arg[0]));
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->index)((const ::ContainedObject*)arg[0]);
}

static  void method_3079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->containedObject)(*(long*)arg[0]));
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->containedObject)(*(long*)arg[0]);
}

static  void method_3080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->fillStream)(*(::std::basic_ostream<char,std::char_traits<char> >*)arg[0]);
  else   (((const ::ObjectVector<Gaudi::Examples::MyVertex>*)o)->fillStream)(*(::std::basic_ostream<char,std::char_traits<char> >*)arg[0]);
}

static void method_newdel_372( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyVertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyVertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyVertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyVertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyVertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ObjectContainerBase")), ::Reflex::BaseOffset< ::ObjectVector<Gaudi::Examples::MyVertex>,::ObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::ObjectVector<Gaudi::Examples::MyVertex>,::DataObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ObjectVector<Gaudi::Examples::MyVertex> -------------------------------
void __ObjectVector_Gaudi__Examples__MyVertex__db_datamem(Reflex::Class*);
void __ObjectVector_Gaudi__Examples__MyVertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ObjectVector_Gaudi__Examples__MyVertex__datamem_bld(&__ObjectVector_Gaudi__Examples__MyVertex__db_datamem);
Reflex::GenreflexMemberBuilder __ObjectVector_Gaudi__Examples__MyVertex__funcmem_bld(&__ObjectVector_Gaudi__Examples__MyVertex__db_funcmem);
void __ObjectVector_Gaudi__Examples__MyVertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>"), typeid(::ObjectVector<Gaudi::Examples::MyVertex>), sizeof(::ObjectVector<Gaudi::Examples::MyVertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00020164-0000-0000-0000-000000000000")
  .AddBase(type_463, ::Reflex::BaseOffset< ::ObjectVector<Gaudi::Examples::MyVertex>, ::ObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3025, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::contained_type"))
  .AddTypedef(type_3027, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::value_type"))
  .AddTypedef(type_3029, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::reference"))
  .AddTypedef(type_3031, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::const_reference"))
  .AddTypedef(type_3033, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::iterator"))
  .AddTypedef(type_3035, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::const_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::reverse_iterator"))
  .AddTypedef(type_2667, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::const_reverse_iterator"))
  .AddTypedef(type_3039, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::pointer"))
  .AddTypedef(type_3041, Reflex::Literal("ObjectVector<Gaudi::Examples::MyVertex>::const_pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ObjectVector"), constructor_3043, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2826), Reflex::Literal("ObjectVector"), constructor_3044, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9033), Reflex::Literal("ObjectVector"), constructor_3045, 0, "value", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ObjectVector"), destructor_3046, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_372, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ObjectVector_Gaudi__Examples__MyVertex__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ObjectVector_Gaudi__Examples__MyVertex__funcmem_bld);
}

//------Delayed data member builder for class ObjectVector<Gaudi::Examples::MyVertex> -------------------
void __ObjectVector_Gaudi__Examples__MyVertex__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2258, Reflex::Literal("m_vector"), OffsetOf(__shadow__::__ObjectVector_Gaudi__Examples__MyVertex_, m_vector), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ObjectVector<Gaudi::Examples::MyVertex> -------------------
void __ObjectVector_Gaudi__Examples__MyVertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_3047, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_3048, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9033, type_9033), Reflex::Literal("operator="), operator_3049, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("begin"), method_3050, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3035), Reflex::Literal("begin"), method_3051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("end"), method_3052, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3035), Reflex::Literal("end"), method_3053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("size"), method_3058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("numberOfObjects"), method_3059, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("max_size"), method_3060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("capacity"), method_3061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1516), Reflex::Literal("reserve"), method_3062, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_3063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029), Reflex::Literal("front"), method_3064, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031), Reflex::Literal("front"), method_3065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029), Reflex::Literal("back"), method_3066, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031), Reflex::Literal("back"), method_3067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3031), Reflex::Literal("push_back"), method_3068, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("add"), method_3069, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_3070, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("remove"), method_3071, 0, "value", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_3033, type_3031), Reflex::Literal("insert"), method_3072, 0, "position;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3033), Reflex::Literal("erase"), method_3073, 0, "position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3033, type_3033), Reflex::Literal("erase"), method_3074, 0, "first;last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_3075, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029, type_1516), Reflex::Literal("operator[]"), operator_3076, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031, type_1516), Reflex::Literal("operator[]"), operator_3077, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_9034), Reflex::Literal("index"), method_3078, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5534, type_493), Reflex::Literal("containedObject"), method_3079, 0, "dist", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5307, type_5307), Reflex::Literal("fillStream"), method_3080, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class MyTrack -------------------------------
static  void operator_9045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::MyTrack*)o)->operator=)(*(const ::Gaudi::Examples::MyTrack*)arg[0]);
  else   (((::Gaudi::Examples::MyTrack*)o)->operator=)(*(const ::Gaudi::Examples::MyTrack*)arg[0]);
}

static void constructor_9046( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::MyTrack();
  else ::new(mem) ::Gaudi::Examples::MyTrack();
}

static void constructor_9047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::MyTrack(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
  else ::new(mem) ::Gaudi::Examples::MyTrack(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
}

static void destructor_9048(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::Examples::MyTrack*)o)->::Gaudi::Examples::MyTrack::~MyTrack)();
}
static  void method_9049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::MyTrack*)o)->clID)();
  else   (((const ::Gaudi::Examples::MyTrack*)o)->clID)();
}

static  void method_9050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::MyTrack*)o)->classID)();
  else   (((::Gaudi::Examples::MyTrack*)o)->classID)();
}

static  void method_9051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::Gaudi::Examples::MyTrack*)o)->px)());
  else   (((const ::Gaudi::Examples::MyTrack*)o)->px)();
}

static  void method_9052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::Gaudi::Examples::MyTrack*)o)->py)());
  else   (((const ::Gaudi::Examples::MyTrack*)o)->py)();
}

static  void method_9053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::Gaudi::Examples::MyTrack*)o)->pz)());
  else   (((const ::Gaudi::Examples::MyTrack*)o)->pz)();
}

static  void method_9054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyTrack*)o)->setPx)(*(float*)arg[0]);
}

static  void method_9055( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyTrack*)o)->setPy)(*(float*)arg[0]);
}

static  void method_9056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyTrack*)o)->setPz)(*(float*)arg[0]);
}

static  void method_9057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Gaudi::Examples::MyTrack*)o)->event)());
  else   (((const ::Gaudi::Examples::MyTrack*)o)->event)();
}

static  void method_9058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyTrack*)o)->setEvent)((::Gaudi::Examples::Event*)arg[0]);
}

static  void method_9059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Gaudi::Examples::MyTrack*)o)->originVertex)());
  else   (((const ::Gaudi::Examples::MyTrack*)o)->originVertex)();
}

static  void method_9060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyTrack*)o)->setOriginVertex)((::Gaudi::Examples::MyVertex*)arg[0]);
}

static  void method_9061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::MyTrack*)o)->decayVertices)();
  else   (((const ::Gaudi::Examples::MyTrack*)o)->decayVertices)();
}

static  void method_9062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyTrack*)o)->addDecayVertex)((::Gaudi::Examples::MyVertex*)arg[0]);
}

static  void method_9063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::MyTrack*)o)->removeDecayVertex)((::Gaudi::Examples::MyVertex*)arg[0]);
}

static  void method_9064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::MyTrack*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::Gaudi::Examples::MyTrack*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_9065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::MyTrack*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::Gaudi::Examples::MyTrack*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_3082( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyTrack >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyTrack >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyTrack >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyTrack >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::MyTrack >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("KeyedObject<int>")), ::Reflex::BaseOffset< ::Gaudi::Examples::MyTrack,::KeyedObject<int> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ContainedObject")), ::Reflex::BaseOffset< ::Gaudi::Examples::MyTrack,::ContainedObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MyTrack -------------------------------
void __Gaudi__Examples__MyTrack_db_datamem(Reflex::Class*);
void __Gaudi__Examples__MyTrack_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__MyTrack_datamem_bld(&__Gaudi__Examples__MyTrack_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__MyTrack_funcmem_bld(&__Gaudi__Examples__MyTrack_db_funcmem);
void __Gaudi__Examples__MyTrack_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::Examples::MyTrack"), typeid(::Gaudi::Examples::MyTrack), sizeof(::Gaudi::Examples::MyTrack), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00000163-0000-0000-0000-000000000000")
  .AddBase(type_2103, ::Reflex::BaseOffset< ::Gaudi::Examples::MyTrack, ::KeyedObject<int> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2261, Reflex::Literal("Gaudi::Examples::MyTrack::Vector"))
  .AddTypedef(type_2266, Reflex::Literal("Gaudi::Examples::MyTrack::ConstVector"))
  .AddTypedef(type_1591, Reflex::Literal("Gaudi::Examples::MyTrack::Selection"))
  .AddTypedef(type_970, Reflex::Literal("Gaudi::Examples::MyTrack::Container"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10501, type_10502), Reflex::Literal("operator="), operator_9045, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MyTrack"), constructor_9046, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1439, type_1439, type_1439), Reflex::Literal("MyTrack"), constructor_9047, 0, "x;y;z", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MyTrack"), destructor_9048, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3082, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__Examples__MyTrack_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__Examples__MyTrack_funcmem_bld);
}

//------Delayed data member builder for class MyTrack -------------------
void __Gaudi__Examples__MyTrack_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1439, Reflex::Literal("m_px"), OffsetOf(__shadow__::__Gaudi__Examples__MyTrack, m_px), ::Reflex::PROTECTED)
  .AddDataMember(type_1439, Reflex::Literal("m_py"), OffsetOf(__shadow__::__Gaudi__Examples__MyTrack, m_py), ::Reflex::PROTECTED)
  .AddDataMember(type_1439, Reflex::Literal("m_pz"), OffsetOf(__shadow__::__Gaudi__Examples__MyTrack, m_pz), ::Reflex::PROTECTED)
  .AddDataMember(type_2007, Reflex::Literal("m_event"), OffsetOf(__shadow__::__Gaudi__Examples__MyTrack, m_event), ::Reflex::PROTECTED)
  .AddDataMember(type_2005, Reflex::Literal("m_originVertex"), OffsetOf(__shadow__::__Gaudi__Examples__MyTrack, m_originVertex), ::Reflex::PROTECTED)
  .AddDataMember(type_443, Reflex::Literal("m_decayVertices"), OffsetOf(__shadow__::__Gaudi__Examples__MyTrack, m_decayVertices), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class MyTrack -------------------
void __Gaudi__Examples__MyTrack_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_9049, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_9050, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("px"), method_9051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("py"), method_9052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("pz"), method_9053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1439), Reflex::Literal("setPx"), method_9054, 0, "px", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1439), Reflex::Literal("setPy"), method_9055, 0, "py", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1439), Reflex::Literal("setPz"), method_9056, 0, "pz", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10503), Reflex::Literal("event"), method_9057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_10526), Reflex::Literal("setEvent"), method_9058, 0, "evt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10497), Reflex::Literal("originVertex"), method_9059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3027), Reflex::Literal("setOriginVertex"), method_9060, 0, "origin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4198), Reflex::Literal("decayVertices"), method_9061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3027), Reflex::Literal("addDecayVertex"), method_9062, 0, "vtx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3027), Reflex::Literal("removeDecayVertex"), method_9063, 0, "vtx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_9064, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_9065, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class ObjectVector<Gaudi::Examples::MyTrack> -------------------------------
static void constructor_3100( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ObjectVector<Gaudi::Examples::MyTrack>();
  else ::new(mem) ::ObjectVector<Gaudi::Examples::MyTrack>();
}

static void constructor_3101( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ObjectVector<Gaudi::Examples::MyTrack>((const char*)arg[0]);
  else ::new(mem) ::ObjectVector<Gaudi::Examples::MyTrack>((const char*)arg[0]);
}

static void constructor_3102( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ObjectVector<Gaudi::Examples::MyTrack>(*(const ::ObjectVector<Gaudi::Examples::MyTrack>*)arg[0]);
  else ::new(mem) ::ObjectVector<Gaudi::Examples::MyTrack>(*(const ::ObjectVector<Gaudi::Examples::MyTrack>*)arg[0]);
}

static void destructor_3103(void*, void * o, const std::vector<void*>&, void *) {
(((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->::ObjectVector<Gaudi::Examples::MyTrack>::~ObjectVector)();
}
static  void method_3104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->clID)();
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->clID)();
}

static  void method_3105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->classID)();
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->classID)();
}

static  void operator_3106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->operator=)(*(const ::ObjectVector<Gaudi::Examples::MyTrack>*)arg[0]);
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->operator=)(*(const ::ObjectVector<Gaudi::Examples::MyTrack>*)arg[0]);
}

static  void method_3107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->begin)());
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->begin)();
}

static  void method_3108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> >)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->begin)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->begin)();
}

static  void method_3109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->end)());
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->end)();
}

static  void method_3110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> >)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->end)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->end)();
}

static  void method_3115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->size)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->size)();
}

static  void method_3116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->numberOfObjects)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->numberOfObjects)();
}

static  void method_3117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->max_size)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->max_size)();
}

static  void method_3118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->capacity)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->capacity)();
}

static  void method_3119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_3120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->empty)());
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->empty)();
}

static  void method_3121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->front)();
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->front)();
}

static  void method_3122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->front)();
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->front)();
}

static  void method_3123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->back)();
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->back)();
}

static  void method_3124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->back)();
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->back)();
}

static  void method_3125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->push_back)(*(::Gaudi::Examples::MyTrack* const*)arg[0]);
}

static  void method_3126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->add)((::ContainedObject*)arg[0]));
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->add)((::ContainedObject*)arg[0]);
}

static  void method_3127( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->pop_back)();
}

static  void method_3128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->remove)((::ContainedObject*)arg[0]));
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->remove)((::ContainedObject*)arg[0]);
}

static  void method_3129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::Gaudi::Examples::MyTrack* const*)arg[1]));
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::Gaudi::Examples::MyTrack* const*)arg[1]);
}

static  void method_3130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0]);
}

static  void method_3131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[1]);
}

static  void method_3132( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->clear)();
}

static  void operator_3133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::ObjectVector<Gaudi::Examples::MyTrack>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_3134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_3135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->index)((const ::ContainedObject*)arg[0]));
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->index)((const ::ContainedObject*)arg[0]);
}

static  void method_3136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->containedObject)(*(long*)arg[0]));
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->containedObject)(*(long*)arg[0]);
}

static  void method_3137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->fillStream)(*(::std::basic_ostream<char,std::char_traits<char> >*)arg[0]);
  else   (((const ::ObjectVector<Gaudi::Examples::MyTrack>*)o)->fillStream)(*(::std::basic_ostream<char,std::char_traits<char> >*)arg[0]);
}

static void method_newdel_373( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyTrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyTrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyTrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyTrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ObjectVector<Gaudi::Examples::MyTrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ObjectContainerBase")), ::Reflex::BaseOffset< ::ObjectVector<Gaudi::Examples::MyTrack>,::ObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::ObjectVector<Gaudi::Examples::MyTrack>,::DataObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class ObjectVector<Gaudi::Examples::MyTrack> -------------------------------
void __ObjectVector_Gaudi__Examples__MyTrack__db_datamem(Reflex::Class*);
void __ObjectVector_Gaudi__Examples__MyTrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ObjectVector_Gaudi__Examples__MyTrack__datamem_bld(&__ObjectVector_Gaudi__Examples__MyTrack__db_datamem);
Reflex::GenreflexMemberBuilder __ObjectVector_Gaudi__Examples__MyTrack__funcmem_bld(&__ObjectVector_Gaudi__Examples__MyTrack__db_funcmem);
void __ObjectVector_Gaudi__Examples__MyTrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>"), typeid(::ObjectVector<Gaudi::Examples::MyTrack>), sizeof(::ObjectVector<Gaudi::Examples::MyTrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00020163-0000-0000-0000-000000000000")
  .AddBase(type_463, ::Reflex::BaseOffset< ::ObjectVector<Gaudi::Examples::MyTrack>, ::ObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3082, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::contained_type"))
  .AddTypedef(type_3084, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::value_type"))
  .AddTypedef(type_3086, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::reference"))
  .AddTypedef(type_3088, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::const_reference"))
  .AddTypedef(type_3090, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::iterator"))
  .AddTypedef(type_3092, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::const_iterator"))
  .AddTypedef(type_2670, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::reverse_iterator"))
  .AddTypedef(type_2669, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::const_reverse_iterator"))
  .AddTypedef(type_3096, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::pointer"))
  .AddTypedef(type_3098, Reflex::Literal("ObjectVector<Gaudi::Examples::MyTrack>::const_pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ObjectVector"), constructor_3100, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2826), Reflex::Literal("ObjectVector"), constructor_3101, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9067), Reflex::Literal("ObjectVector"), constructor_3102, 0, "value", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ObjectVector"), destructor_3103, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_373, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ObjectVector_Gaudi__Examples__MyTrack__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ObjectVector_Gaudi__Examples__MyTrack__funcmem_bld);
}

//------Delayed data member builder for class ObjectVector<Gaudi::Examples::MyTrack> -------------------
void __ObjectVector_Gaudi__Examples__MyTrack__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2261, Reflex::Literal("m_vector"), OffsetOf(__shadow__::__ObjectVector_Gaudi__Examples__MyTrack_, m_vector), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ObjectVector<Gaudi::Examples::MyTrack> -------------------
void __ObjectVector_Gaudi__Examples__MyTrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_3104, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_3105, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9067, type_9067), Reflex::Literal("operator="), operator_3106, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090), Reflex::Literal("begin"), method_3107, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3092), Reflex::Literal("begin"), method_3108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090), Reflex::Literal("end"), method_3109, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3092), Reflex::Literal("end"), method_3110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("size"), method_3115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("numberOfObjects"), method_3116, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("max_size"), method_3117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("capacity"), method_3118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1516), Reflex::Literal("reserve"), method_3119, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_3120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("front"), method_3121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3088), Reflex::Literal("front"), method_3122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("back"), method_3123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3088), Reflex::Literal("back"), method_3124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3088), Reflex::Literal("push_back"), method_3125, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("add"), method_3126, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_3127, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("remove"), method_3128, 0, "value", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090, type_3090, type_3088), Reflex::Literal("insert"), method_3129, 0, "position;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3090), Reflex::Literal("erase"), method_3130, 0, "position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3090, type_3090), Reflex::Literal("erase"), method_3131, 0, "first;last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_3132, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086, type_1516), Reflex::Literal("operator[]"), operator_3133, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3088, type_1516), Reflex::Literal("operator[]"), operator_3134, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_9034), Reflex::Literal("index"), method_3135, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5534, type_493), Reflex::Literal("containedObject"), method_3136, 0, "dist", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5307, type_5307), Reflex::Literal("fillStream"), method_3137, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<Gaudi::Examples::MyVertex> -------------------------------
static void destructor_3165(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->::SmartRefVector<Gaudi::Examples::MyVertex>::~SmartRefVector)();
}
static void constructor_3167( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<Gaudi::Examples::MyVertex>();
  else ::new(mem) ::SmartRefVector<Gaudi::Examples::MyVertex>();
}

static void constructor_3168( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<Gaudi::Examples::MyVertex>(*(const ::SmartRefVector<Gaudi::Examples::MyVertex>*)arg[0]);
  else ::new(mem) ::SmartRefVector<Gaudi::Examples::MyVertex>(*(const ::SmartRefVector<Gaudi::Examples::MyVertex>*)arg[0]);
}

static  void operator_3169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_3170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_3171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_3172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_3173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator=)(*(const ::SmartRefVector<Gaudi::Examples::MyVertex>*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->operator=)(*(const ::SmartRefVector<Gaudi::Examples::MyVertex>*)arg[0]);
}

static  void method_3174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->type)());
  else   (((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->type)();
}

static  void method_3175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_3176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::MyVertex>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_443( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyVertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyVertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyVertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyVertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyVertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >")), ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::MyVertex>,::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > >")), ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::MyVertex>,::std::_Vector_base<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<Gaudi::Examples::MyVertex> -------------------------------
void __SmartRefVector_Gaudi__Examples__MyVertex__db_datamem(Reflex::Class*);
void __SmartRefVector_Gaudi__Examples__MyVertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_Gaudi__Examples__MyVertex__datamem_bld(&__SmartRefVector_Gaudi__Examples__MyVertex__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_Gaudi__Examples__MyVertex__funcmem_bld(&__SmartRefVector_Gaudi__Examples__MyVertex__db_funcmem);
void __SmartRefVector_Gaudi__Examples__MyVertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<Gaudi::Examples::MyVertex>"), typeid(::SmartRefVector<Gaudi::Examples::MyVertex>), sizeof(::SmartRefVector<Gaudi::Examples::MyVertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2263, ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::MyVertex>, ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2005, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyVertex>::_Entry"))
  .AddTypedef(type_2263, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyVertex>::_Base"))
  .AddTypedef(type_3162, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyVertex>::_BaseConstIter"))
  .AddTypedef(type_2005, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyVertex>::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_3165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_3167, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4198), Reflex::Literal("SmartRefVector"), constructor_3168, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_443, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_Gaudi__Examples__MyVertex__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_Gaudi__Examples__MyVertex__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<Gaudi::Examples::MyVertex> -------------------
void __SmartRefVector_Gaudi__Examples__MyVertex__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9073, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_Gaudi__Examples__MyVertex_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_9034, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_Gaudi__Examples__MyVertex_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<Gaudi::Examples::MyVertex> -------------------
void __SmartRefVector_Gaudi__Examples__MyVertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3727, type_5534), Reflex::Literal("operator()"), operator_3169, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4198, type_9034), Reflex::Literal("operator()"), operator_3170, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3727, type_9074), Reflex::Literal("operator()"), operator_3171, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4198, type_9073), Reflex::Literal("operator()"), operator_3172, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3727, type_4198), Reflex::Literal("operator="), operator_3173, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("type"), method_3174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("readRefs"), method_3175, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("writeRefs"), method_3176, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Collision -------------------------------
static  void operator_10531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Collision*)o)->operator=)(*(const ::Gaudi::Examples::Collision*)arg[0]);
  else   (((::Gaudi::Examples::Collision*)o)->operator=)(*(const ::Gaudi::Examples::Collision*)arg[0]);
}

static void constructor_10532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::Collision(*(const ::Gaudi::Examples::Collision*)arg[0]);
  else ::new(mem) ::Gaudi::Examples::Collision(*(const ::Gaudi::Examples::Collision*)arg[0]);
}

static void constructor_10533( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::Collision();
  else ::new(mem) ::Gaudi::Examples::Collision();
}

static void constructor_10534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::Collision(*(int*)arg[0]);
  else ::new(mem) ::Gaudi::Examples::Collision(*(int*)arg[0]);
}

static void destructor_10535(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::Examples::Collision*)o)->::Gaudi::Examples::Collision::~Collision)();
}
static  void method_10536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Collision*)o)->clID)();
  else   (((const ::Gaudi::Examples::Collision*)o)->clID)();
}

static  void method_10537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Collision*)o)->classID)();
  else   (((::Gaudi::Examples::Collision*)o)->classID)();
}

static  void method_10538( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::Collision*)o)->setCollision)(*(int*)arg[0]);
}

static  void method_10539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Examples::Collision*)o)->collision)());
  else   (((const ::Gaudi::Examples::Collision*)o)->collision)();
}

static  void method_10540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Collision*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::Gaudi::Examples::Collision*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_10541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Collision*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::Gaudi::Examples::Collision*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_4357( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Collision >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Collision >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Collision >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Collision >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Collision >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::Gaudi::Examples::Collision,::DataObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Collision -------------------------------
void __Gaudi__Examples__Collision_db_datamem(Reflex::Class*);
void __Gaudi__Examples__Collision_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__Collision_datamem_bld(&__Gaudi__Examples__Collision_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__Collision_funcmem_bld(&__Gaudi__Examples__Collision_db_funcmem);
void __Gaudi__Examples__Collision_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::Examples::Collision"), typeid(::Gaudi::Examples::Collision), sizeof(::Gaudi::Examples::Collision), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "0000006F-0000-0000-0000-000000000000")
  .AddBase(type_240, ::Reflex::BaseOffset< ::Gaudi::Examples::Collision, ::DataObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10543, type_10544), Reflex::Literal("operator="), operator_10531, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10544), Reflex::Literal("Collision"), constructor_10532, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Collision"), constructor_10533, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_112), Reflex::Literal("Collision"), constructor_10534, 0, "num", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Collision"), destructor_10535, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4357, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__Examples__Collision_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__Examples__Collision_funcmem_bld);
}

//------Delayed data member builder for class Collision -------------------
void __Gaudi__Examples__Collision_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_112, Reflex::Literal("m_collision"), OffsetOf(__shadow__::__Gaudi__Examples__Collision, m_collision), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Collision -------------------
void __Gaudi__Examples__Collision_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_10536, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_10537, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_112), Reflex::Literal("setCollision"), method_10538, 0, "num", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("collision"), method_10539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_10540, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_10541, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class SmartRefVector<Gaudi::Examples::Collision> -------------------------------
static void destructor_3184(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<Gaudi::Examples::Collision>*)o)->::SmartRefVector<Gaudi::Examples::Collision>::~SmartRefVector)();
}
static void constructor_3186( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<Gaudi::Examples::Collision>();
  else ::new(mem) ::SmartRefVector<Gaudi::Examples::Collision>();
}

static void constructor_3187( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<Gaudi::Examples::Collision>(*(const ::SmartRefVector<Gaudi::Examples::Collision>*)arg[0]);
  else ::new(mem) ::SmartRefVector<Gaudi::Examples::Collision>(*(const ::SmartRefVector<Gaudi::Examples::Collision>*)arg[0]);
}

static  void operator_3188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_3189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_3190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_3191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_3192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator=)(*(const ::SmartRefVector<Gaudi::Examples::Collision>*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::Collision>*)o)->operator=)(*(const ::SmartRefVector<Gaudi::Examples::Collision>*)arg[0]);
}

static  void method_3193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->type)());
  else   (((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->type)();
}

static  void method_3194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::Collision>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::Collision>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_3195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::Collision>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_444( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::Collision> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::Collision> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::Collision> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::Collision> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::Collision> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >")), ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::Collision>,::std::vector<SmartRef<Gaudi::Examples::Collision> > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > >")), ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::Collision>,::std::_Vector_base<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<Gaudi::Examples::Collision> -------------------------------
void __SmartRefVector_Gaudi__Examples__Collision__db_datamem(Reflex::Class*);
void __SmartRefVector_Gaudi__Examples__Collision__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_Gaudi__Examples__Collision__datamem_bld(&__SmartRefVector_Gaudi__Examples__Collision__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_Gaudi__Examples__Collision__funcmem_bld(&__SmartRefVector_Gaudi__Examples__Collision__db_funcmem);
void __SmartRefVector_Gaudi__Examples__Collision__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<Gaudi::Examples::Collision>"), typeid(::SmartRefVector<Gaudi::Examples::Collision>), sizeof(::SmartRefVector<Gaudi::Examples::Collision>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2265, ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::Collision>, ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2008, Reflex::Literal("SmartRefVector<Gaudi::Examples::Collision>::_Entry"))
  .AddTypedef(type_2265, Reflex::Literal("SmartRefVector<Gaudi::Examples::Collision>::_Base"))
  .AddTypedef(type_3181, Reflex::Literal("SmartRefVector<Gaudi::Examples::Collision>::_BaseConstIter"))
  .AddTypedef(type_2008, Reflex::Literal("SmartRefVector<Gaudi::Examples::Collision>::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_3184, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_3186, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4202), Reflex::Literal("SmartRefVector"), constructor_3187, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_444, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_Gaudi__Examples__Collision__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_Gaudi__Examples__Collision__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<Gaudi::Examples::Collision> -------------------
void __SmartRefVector_Gaudi__Examples__Collision__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9073, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_Gaudi__Examples__Collision_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_9034, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_Gaudi__Examples__Collision_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<Gaudi::Examples::Collision> -------------------
void __SmartRefVector_Gaudi__Examples__Collision__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3731, type_5534), Reflex::Literal("operator()"), operator_3188, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4202, type_9034), Reflex::Literal("operator()"), operator_3189, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3731, type_9074), Reflex::Literal("operator()"), operator_3190, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4202, type_9073), Reflex::Literal("operator()"), operator_3191, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3731, type_4202), Reflex::Literal("operator="), operator_3192, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("type"), method_3193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("readRefs"), method_3194, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("writeRefs"), method_3195, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SmartRefVector<Gaudi::Examples::MyTrack> -------------------------------
static void destructor_3203(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->::SmartRefVector<Gaudi::Examples::MyTrack>::~SmartRefVector)();
}
static void constructor_3205( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<Gaudi::Examples::MyTrack>();
  else ::new(mem) ::SmartRefVector<Gaudi::Examples::MyTrack>();
}

static void constructor_3206( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRefVector<Gaudi::Examples::MyTrack>(*(const ::SmartRefVector<Gaudi::Examples::MyTrack>*)arg[0]);
  else ::new(mem) ::SmartRefVector<Gaudi::Examples::MyTrack>(*(const ::SmartRefVector<Gaudi::Examples::MyTrack>*)arg[0]);
}

static  void operator_3207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_3208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_3209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_3210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_3211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator=)(*(const ::SmartRefVector<Gaudi::Examples::MyTrack>*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->operator=)(*(const ::SmartRefVector<Gaudi::Examples::MyTrack>*)arg[0]);
}

static  void method_3212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->type)());
  else   (((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->type)();
}

static  void method_3213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->readRefs)(*(::StreamBuffer*)arg[0]);
}

static  void method_3214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRefVector<Gaudi::Examples::MyTrack>*)o)->writeRefs)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_445( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyTrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyTrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyTrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyTrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRefVector<Gaudi::Examples::MyTrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >")), ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::MyTrack>,::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > >")), ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::MyTrack>,::std::_Vector_base<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SmartRefVector<Gaudi::Examples::MyTrack> -------------------------------
void __SmartRefVector_Gaudi__Examples__MyTrack__db_datamem(Reflex::Class*);
void __SmartRefVector_Gaudi__Examples__MyTrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRefVector_Gaudi__Examples__MyTrack__datamem_bld(&__SmartRefVector_Gaudi__Examples__MyTrack__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRefVector_Gaudi__Examples__MyTrack__funcmem_bld(&__SmartRefVector_Gaudi__Examples__MyTrack__db_funcmem);
void __SmartRefVector_Gaudi__Examples__MyTrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRefVector<Gaudi::Examples::MyTrack>"), typeid(::SmartRefVector<Gaudi::Examples::MyTrack>), sizeof(::SmartRefVector<Gaudi::Examples::MyTrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2264, ::Reflex::BaseOffset< ::SmartRefVector<Gaudi::Examples::MyTrack>, ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2006, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyTrack>::_Entry"))
  .AddTypedef(type_2264, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyTrack>::_Base"))
  .AddTypedef(type_3200, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyTrack>::_BaseConstIter"))
  .AddTypedef(type_2006, Reflex::Literal("SmartRefVector<Gaudi::Examples::MyTrack>::_BaseValueType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRefVector"), destructor_3203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRefVector"), constructor_3205, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4196), Reflex::Literal("SmartRefVector"), constructor_3206, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_445, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRefVector_Gaudi__Examples__MyTrack__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRefVector_Gaudi__Examples__MyTrack__funcmem_bld);
}

//------Delayed data member builder for class SmartRefVector<Gaudi::Examples::MyTrack> -------------------
void __SmartRefVector_Gaudi__Examples__MyTrack__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9073, Reflex::Literal("m_data"), OffsetOf(__shadow__::__SmartRefVector_Gaudi__Examples__MyTrack_, m_data), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_9034, Reflex::Literal("m_contd"), OffsetOf(__shadow__::__SmartRefVector_Gaudi__Examples__MyTrack_, m_contd), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRefVector<Gaudi::Examples::MyTrack> -------------------
void __SmartRefVector_Gaudi__Examples__MyTrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3725, type_5534), Reflex::Literal("operator()"), operator_3207, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4196, type_9034), Reflex::Literal("operator()"), operator_3208, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3725, type_9074), Reflex::Literal("operator()"), operator_3209, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4196, type_9073), Reflex::Literal("operator()"), operator_3210, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3725, type_4196), Reflex::Literal("operator="), operator_3211, 0, "copy", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("type"), method_3212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("readRefs"), method_3213, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("writeRefs"), method_3214, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > -------------------------------
static  void operator_3597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator=)(*(const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator=)(*(const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
}

static void constructor_3598( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >(*(const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
  else ::new(mem) ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >(*(const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
}

static void constructor_3601( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >();
  else ::new(mem) ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >();
}

static void destructor_3602(void*, void * o, const std::vector<void*>&, void *) {
(((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::~KeyedContainer)();
}
static  void method_3603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->clID)();
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->clID)();
}

static  void method_3604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->classID)();
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->classID)();
}

static  void method_3605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->numberOfObjects)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->numberOfObjects)();
}

static  void method_3606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->add)((::ContainedObject*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->add)((::ContainedObject*)arg[0]);
}

static  void method_3607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->remove)((::ContainedObject*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->remove)((::ContainedObject*)arg[0]);
}

static  void method_3608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObject)(*(long*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObject)(*(long*)arg[0]);
}

static  void method_3609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->index)((const ::ContainedObject*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->index)((const ::ContainedObject*)arg[0]);
}

static  void method_3610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)(*(::std::vector<ContainedObject*>*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)(*(::std::vector<ContainedObject*>*)arg[0]);
}

static  void method_3611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->size)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->size)();
}

static  void method_3612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->empty)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->empty)();
}

static  void method_3613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_3614( void*, void* o, const std::vector<void*>&, void*)
{
  (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->clear)();
}

static  void method_3615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)();
}

static  void method_3616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->update)());
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->update)();
}

static  void method_3617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)());
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)();
}

static  void method_3618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> >)((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)();
}

static  void method_3619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)());
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)();
}

static  void method_3620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> >)((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)();
}

static  void method_3625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->object)(*(const int*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->object)(*(const int*)arg[0]);
}

static  void operator_3626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator())(*(const int*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator())(*(const int*)arg[0]);
}

static  void method_3627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_3628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)((::Gaudi::Examples::MyVertex* const)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)((::Gaudi::Examples::MyVertex* const)arg[0]);
}

static  void method_3629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0]);
}

static  void method_3630( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
      *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
      *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_3631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyVertex* const)arg[0],
    *(const int*)arg[1]);
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyVertex* const)arg[0],
    *(const int*)arg[1]);
}

static  void method_3632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyVertex* const)arg[0]);
  else   (((::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyVertex* const)arg[0]);
}

static void method_newdel_969( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ObjectContainerBase")), ::Reflex::BaseOffset< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >,::ObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >,::DataObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > -------------------------------
void __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__db_datamem(Reflex::Class*);
void __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__datamem_bld(&__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__db_datamem);
Reflex::GenreflexMemberBuilder __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__funcmem_bld(&__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__db_funcmem);
void __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >"), typeid(::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >), sizeof(::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00060164-0000-0000-0000-000000000000")
  .AddBase(type_463, ::Reflex::BaseOffset< ::KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >, ::ObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3025, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::contained_type"))
  .AddTypedef(type_3278, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::container_type"))
  .AddTypedef(type_2258, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::seq_type"))
  .AddTypedef(type_112, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::key_type"))
  .AddTypedef(type_3027, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::value_type"))
  .AddTypedef(type_3029, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::reference"))
  .AddTypedef(type_3031, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::const_reference"))
  .AddTypedef(type_3033, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::iterator"))
  .AddTypedef(type_3035, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::const_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::reverse_iterator"))
  .AddTypedef(type_2667, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::const_reverse_iterator"))
  .AddTypedef(type_3294, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> >::traits"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9341, type_9342), Reflex::Literal("operator="), operator_3597, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9342), Reflex::Literal("KeyedContainer"), constructor_3598, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("KeyedContainer"), constructor_3601, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~KeyedContainer"), destructor_3602, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_969, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__funcmem_bld);
}

//------Delayed data member builder for class KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > -------------------
void __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3278, Reflex::Literal("m_cont"), OffsetOf(__shadow__::__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_, m_cont), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_2258, Reflex::Literal("m_sequential"), OffsetOf(__shadow__::__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_, m_sequential), ::Reflex::PRIVATE)
  .AddDataMember(type_9340, Reflex::Literal("m_random"), OffsetOf(__shadow__::__KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s_, m_random), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > -------------------
void __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_3603, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_3604, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("numberOfObjects"), method_3605, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("add"), method_3606, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("remove"), method_3607, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5534, type_493), Reflex::Literal("containedObject"), method_3608, 0, "key_value", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_9034), Reflex::Literal("index"), method_3609, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516, type_9343), Reflex::Literal("containedObjects"), method_3610, 0, "vec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("size"), method_3611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_3612, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1516), Reflex::Literal("reserve"), method_3613, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_3614, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9344), Reflex::Literal("containedObjects"), method_3615, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2106), Reflex::Literal("update"), method_3616, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("begin"), method_3617, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3035), Reflex::Literal("begin"), method_3618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("end"), method_3619, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3035), Reflex::Literal("end"), method_3620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3027, type_8348), Reflex::Literal("object"), method_3625, 0, "kval", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3027, type_8348), Reflex::Literal("operator()"), operator_3626, 0, "kval", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_8348), Reflex::Literal("erase"), method_3627, 0, "kval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_3027c), Reflex::Literal("erase"), method_3628, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_3033), Reflex::Literal("erase"), method_3629, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3033, type_3033, type_2883), Reflex::Literal("erase"), method_3630, 0, "start_pos;stop_pos;use_tmp=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8348, type_3027c, type_8348), Reflex::Literal("insert"), method_3631, 0, "val;kval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8348, type_3027c), Reflex::Literal("insert"), method_3632, 0, "val", ::Reflex::PUBLIC);
}
//------Stub functions for class KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > -------------------------------
static  void operator_3650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator=)(*(const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator=)(*(const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
}

static void constructor_3651( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >(*(const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
  else ::new(mem) ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >(*(const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)arg[0]);
}

static void constructor_3654( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >();
  else ::new(mem) ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >();
}

static void destructor_3655(void*, void * o, const std::vector<void*>&, void *) {
(((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::~KeyedContainer)();
}
static  void method_3656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->clID)();
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->clID)();
}

static  void method_3657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->classID)();
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->classID)();
}

static  void method_3658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->numberOfObjects)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->numberOfObjects)();
}

static  void method_3659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->add)((::ContainedObject*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->add)((::ContainedObject*)arg[0]);
}

static  void method_3660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->remove)((::ContainedObject*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->remove)((::ContainedObject*)arg[0]);
}

static  void method_3661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObject)(*(long*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObject)(*(long*)arg[0]);
}

static  void method_3662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->index)((const ::ContainedObject*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->index)((const ::ContainedObject*)arg[0]);
}

static  void method_3663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)(*(::std::vector<ContainedObject*>*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)(*(::std::vector<ContainedObject*>*)arg[0]);
}

static  void method_3664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->size)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->size)();
}

static  void method_3665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->empty)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->empty)();
}

static  void method_3666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_3667( void*, void* o, const std::vector<void*>&, void*)
{
  (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->clear)();
}

static  void method_3668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->containedObjects)();
}

static  void method_3669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (StatusCode)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->update)());
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->update)();
}

static  void method_3670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)());
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)();
}

static  void method_3671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> >)((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->begin)();
}

static  void method_3672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)());
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)();
}

static  void method_3673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> >)((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)());
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->end)();
}

static  void method_3678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->object)(*(const int*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->object)(*(const int*)arg[0]);
}

static  void operator_3679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator())(*(const int*)arg[0]));
  else   (((const ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->operator())(*(const int*)arg[0]);
}

static  void method_3680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_3681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)((::Gaudi::Examples::MyTrack* const)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)((::Gaudi::Examples::MyTrack* const)arg[0]);
}

static  void method_3682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long)((((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0]));
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0]);
}

static  void method_3683( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
      *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
      *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[1],
      *(bool*)arg[2]);
  }
}

static  void method_3684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyTrack* const)arg[0],
    *(const int*)arg[1]);
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyTrack* const)arg[0],
    *(const int*)arg[1]);
}

static  void method_3685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyTrack* const)arg[0]);
  else   (((::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >*)o)->insert)((::Gaudi::Examples::MyTrack* const)arg[0]);
}

static void method_newdel_970( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("ObjectContainerBase")), ::Reflex::BaseOffset< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >,::ObjectContainerBase >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >,::DataObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > -------------------------------
void __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__db_datamem(Reflex::Class*);
void __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__datamem_bld(&__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__db_datamem);
Reflex::GenreflexMemberBuilder __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__funcmem_bld(&__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__db_funcmem);
void __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >"), typeid(::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >), sizeof(::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "00060163-0000-0000-0000-000000000000")
  .AddBase(type_463, ::Reflex::BaseOffset< ::KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >, ::ObjectContainerBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3082, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::contained_type"))
  .AddTypedef(type_3278, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::container_type"))
  .AddTypedef(type_2261, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::seq_type"))
  .AddTypedef(type_112, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::key_type"))
  .AddTypedef(type_3084, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::value_type"))
  .AddTypedef(type_3086, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::reference"))
  .AddTypedef(type_3088, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::const_reference"))
  .AddTypedef(type_3090, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::iterator"))
  .AddTypedef(type_3092, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::const_iterator"))
  .AddTypedef(type_2670, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::reverse_iterator"))
  .AddTypedef(type_2669, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::const_reverse_iterator"))
  .AddTypedef(type_3295, Reflex::Literal("KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> >::traits"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9346, type_9347), Reflex::Literal("operator="), operator_3650, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9347), Reflex::Literal("KeyedContainer"), constructor_3651, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("KeyedContainer"), constructor_3654, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~KeyedContainer"), destructor_3655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_970, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__funcmem_bld);
}

//------Delayed data member builder for class KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > -------------------
void __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3278, Reflex::Literal("m_cont"), OffsetOf(__shadow__::__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_, m_cont), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_2261, Reflex::Literal("m_sequential"), OffsetOf(__shadow__::__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_, m_sequential), ::Reflex::PRIVATE)
  .AddDataMember(type_9345, Reflex::Literal("m_random"), OffsetOf(__shadow__::__KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s_, m_random), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > -------------------
void __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_3656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_3657, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("numberOfObjects"), method_3658, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("add"), method_3659, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_5534), Reflex::Literal("remove"), method_3660, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5534, type_493), Reflex::Literal("containedObject"), method_3661, 0, "key_value", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_9034), Reflex::Literal("index"), method_3662, 0, "p", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516, type_9343), Reflex::Literal("containedObjects"), method_3663, 0, "vec", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1516), Reflex::Literal("size"), method_3664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_3665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_1516), Reflex::Literal("reserve"), method_3666, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_3667, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9344), Reflex::Literal("containedObjects"), method_3668, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2106), Reflex::Literal("update"), method_3669, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090), Reflex::Literal("begin"), method_3670, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3092), Reflex::Literal("begin"), method_3671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090), Reflex::Literal("end"), method_3672, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3092), Reflex::Literal("end"), method_3673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084, type_8348), Reflex::Literal("object"), method_3678, 0, "kval", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084, type_8348), Reflex::Literal("operator()"), operator_3679, 0, "kval", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_8348), Reflex::Literal("erase"), method_3680, 0, "kval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_3084c), Reflex::Literal("erase"), method_3681, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493, type_3090), Reflex::Literal("erase"), method_3682, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3090, type_3090, type_2883), Reflex::Literal("erase"), method_3683, 0, "start_pos;stop_pos;use_tmp=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8348, type_3084c, type_8348), Reflex::Literal("insert"), method_3684, 0, "val;kval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8348, type_3084c), Reflex::Literal("insert"), method_3685, 0, "val", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<Gaudi::Examples::MyVertex> -------------------------------
static void destructor_4231(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->::SmartRef<Gaudi::Examples::MyVertex>::~SmartRef)();
}
static void constructor_4232( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>();
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>();
}

static void constructor_4233( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((::Gaudi::Examples::MyVertex*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((::Gaudi::Examples::MyVertex*)arg[0]);
}

static void constructor_4234( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::Gaudi::Examples::MyVertex*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::Gaudi::Examples::MyVertex*)arg[0]);
}

static void constructor_4235( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]);
}

static void constructor_4236( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyVertex*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyVertex*)arg[2]);
  }
}

static void constructor_4237( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyVertex*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyVertex*)arg[3]);
  }
}

static void constructor_4238( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyVertex*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyVertex*)arg[3]);
  }
}

static void constructor_4239( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyVertex*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyVertex>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyVertex*)arg[2]);
  }
}

static  void method_4240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_4241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_4242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->hintID)());
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->hintID)();
}

static  void method_4243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->linkID)());
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->linkID)();
}

static  void method_4244( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_4245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->type)());
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->type)();
}

static  void method_4246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyVertex>*)o)->data)());
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->data)();
}

static  void method_4247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->data)());
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->data)();
}

static  void method_4248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->target)());
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->target)();
}

static  void method_4249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyVertex>*)o)->target)());
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->target)();
}

static  void method_4250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->path)();
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->path)();
}

static  void operator_4251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]);
}

static  void operator_4252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]);
}

static  void method_4253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_4254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_4255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_4256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_4257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_4258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_4259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]);
}

static  void operator_4260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator=)((::Gaudi::Examples::MyVertex*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator=)((::Gaudi::Examples::MyVertex*)arg[0]);
}

static  void operator_4261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator*)();
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator*)();
}

static  void operator_4262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator*)();
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator*)();
}

static  void operator_4263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator->)());
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator->)();
}

static  void operator_4264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator->)());
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator->)();
}

static  void converter_4265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator const Gaudi::Examples::MyVertex*)());
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator const Gaudi::Examples::MyVertex*)();
}

static  void converter_4266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator Gaudi::Examples::MyVertex*)());
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->operator Gaudi::Examples::MyVertex*)();
}

static  void method_4267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::MyVertex>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_4268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyVertex>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyVertex>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2005( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyVertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyVertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyVertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyVertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyVertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<Gaudi::Examples::MyVertex> -------------------------------
void __SmartRef_Gaudi__Examples__MyVertex__db_datamem(Reflex::Class*);
void __SmartRef_Gaudi__Examples__MyVertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__MyVertex__datamem_bld(&__SmartRef_Gaudi__Examples__MyVertex__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__MyVertex__funcmem_bld(&__SmartRef_Gaudi__Examples__MyVertex__db_funcmem);
void __SmartRef_Gaudi__Examples__MyVertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::MyVertex>"), typeid(::SmartRef<Gaudi::Examples::MyVertex>), sizeof(::SmartRef<Gaudi::Examples::MyVertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_3025, Reflex::Literal("SmartRef<Gaudi::Examples::MyVertex>::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_4231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_4232, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3027), Reflex::Literal("SmartRef"), constructor_4233, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10497), Reflex::Literal("SmartRef"), constructor_4234, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4199), Reflex::Literal("SmartRef"), constructor_4235, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_493, type_493, type_3027), Reflex::Literal("SmartRef"), constructor_4236, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9034, type_493, type_493, type_3027), Reflex::Literal("SmartRef"), constructor_4237, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_493, type_3027), Reflex::Literal("SmartRef"), constructor_4238, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_3027), Reflex::Literal("SmartRef"), constructor_4239, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2005, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_Gaudi__Examples__MyVertex__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_Gaudi__Examples__MyVertex__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<Gaudi::Examples::MyVertex> -------------------
void __SmartRef_Gaudi__Examples__MyVertex__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1217, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__MyVertex_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_10497, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__MyVertex_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<Gaudi::Examples::MyVertex> -------------------
void __SmartRef_Gaudi__Examples__MyVertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9073), Reflex::Literal("shouldFollowLink"), method_4240, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9034), Reflex::Literal("shouldFollowLink"), method_4241, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("hintID"), method_4242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("linkID"), method_4243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_9074, type_493, type_493), Reflex::Literal("set"), method_4244, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("type"), method_4245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3027), Reflex::Literal("data"), method_4246, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10497), Reflex::Literal("data"), method_4247, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10497), Reflex::Literal("target"), method_4248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3027), Reflex::Literal("target"), method_4249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211), Reflex::Literal("path"), method_4250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4199), Reflex::Literal("operator=="), operator_4251, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4199), Reflex::Literal("operator!="), operator_4252, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4199, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4253, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4254, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_5534), Reflex::Literal("operator()"), operator_4255, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4199, type_9034), Reflex::Literal("operator()"), operator_4256, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_9074), Reflex::Literal("operator()"), operator_4257, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4199, type_9073), Reflex::Literal("operator()"), operator_4258, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_4199), Reflex::Literal("operator="), operator_4259, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_3027), Reflex::Literal("operator="), operator_4260, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10498), Reflex::Literal("operator*"), operator_4261, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10499), Reflex::Literal("operator*"), operator_4262, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3027), Reflex::Literal("operator->"), operator_4263, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10497), Reflex::Literal("operator->"), operator_4264, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10497), Reflex::Literal("operator const Gaudi::Examples::MyVertex*"), converter_4265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3027), Reflex::Literal("operator Gaudi::Examples::MyVertex*"), converter_4266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("writeRef"), method_4267, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("readRef"), method_4268, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<Gaudi::Examples::MyTrack> -------------------------------
static void destructor_4273(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->::SmartRef<Gaudi::Examples::MyTrack>::~SmartRef)();
}
static void constructor_4274( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>();
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>();
}

static void constructor_4275( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((::Gaudi::Examples::MyTrack*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((::Gaudi::Examples::MyTrack*)arg[0]);
}

static void constructor_4276( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::Gaudi::Examples::MyTrack*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::Gaudi::Examples::MyTrack*)arg[0]);
}

static void constructor_4277( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]);
}

static void constructor_4278( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyTrack*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyTrack*)arg[2]);
  }
}

static void constructor_4279( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyTrack*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyTrack*)arg[3]);
  }
}

static void constructor_4280( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyTrack*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::MyTrack*)arg[3]);
  }
}

static void constructor_4281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyTrack*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::MyTrack>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::MyTrack*)arg[2]);
  }
}

static  void method_4282( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_4283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_4284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->hintID)());
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->hintID)();
}

static  void method_4285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->linkID)());
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->linkID)();
}

static  void method_4286( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_4287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->type)());
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->type)();
}

static  void method_4288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyTrack>*)o)->data)());
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->data)();
}

static  void method_4289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->data)());
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->data)();
}

static  void method_4290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->target)());
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->target)();
}

static  void method_4291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyTrack>*)o)->target)());
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->target)();
}

static  void method_4292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->path)();
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->path)();
}

static  void operator_4293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]);
}

static  void operator_4294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]);
}

static  void method_4295( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_4296( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_4297( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_4298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_4299( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_4300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_4301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]);
}

static  void operator_4302( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator=)((::Gaudi::Examples::MyTrack*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator=)((::Gaudi::Examples::MyTrack*)arg[0]);
}

static  void operator_4303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator*)();
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator*)();
}

static  void operator_4304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator*)();
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator*)();
}

static  void operator_4305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator->)());
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator->)();
}

static  void operator_4306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator->)());
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator->)();
}

static  void converter_4307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator const Gaudi::Examples::MyTrack*)());
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator const Gaudi::Examples::MyTrack*)();
}

static  void converter_4308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator Gaudi::Examples::MyTrack*)());
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->operator Gaudi::Examples::MyTrack*)();
}

static  void method_4309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::MyTrack>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_4310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::MyTrack>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::MyTrack>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2006( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyTrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyTrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyTrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyTrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::MyTrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<Gaudi::Examples::MyTrack> -------------------------------
void __SmartRef_Gaudi__Examples__MyTrack__db_datamem(Reflex::Class*);
void __SmartRef_Gaudi__Examples__MyTrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__MyTrack__datamem_bld(&__SmartRef_Gaudi__Examples__MyTrack__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__MyTrack__funcmem_bld(&__SmartRef_Gaudi__Examples__MyTrack__db_funcmem);
void __SmartRef_Gaudi__Examples__MyTrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::MyTrack>"), typeid(::SmartRef<Gaudi::Examples::MyTrack>), sizeof(::SmartRef<Gaudi::Examples::MyTrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_3082, Reflex::Literal("SmartRef<Gaudi::Examples::MyTrack>::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_4273, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_4274, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3084), Reflex::Literal("SmartRef"), constructor_4275, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10500), Reflex::Literal("SmartRef"), constructor_4276, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4197), Reflex::Literal("SmartRef"), constructor_4277, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_493, type_493, type_3084), Reflex::Literal("SmartRef"), constructor_4278, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9034, type_493, type_493, type_3084), Reflex::Literal("SmartRef"), constructor_4279, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_493, type_3084), Reflex::Literal("SmartRef"), constructor_4280, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_3084), Reflex::Literal("SmartRef"), constructor_4281, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2006, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_Gaudi__Examples__MyTrack__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_Gaudi__Examples__MyTrack__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<Gaudi::Examples::MyTrack> -------------------
void __SmartRef_Gaudi__Examples__MyTrack__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1217, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__MyTrack_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_10500, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__MyTrack_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<Gaudi::Examples::MyTrack> -------------------
void __SmartRef_Gaudi__Examples__MyTrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9073), Reflex::Literal("shouldFollowLink"), method_4282, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9034), Reflex::Literal("shouldFollowLink"), method_4283, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("hintID"), method_4284, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("linkID"), method_4285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_9074, type_493, type_493), Reflex::Literal("set"), method_4286, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("type"), method_4287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084), Reflex::Literal("data"), method_4288, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10500), Reflex::Literal("data"), method_4289, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10500), Reflex::Literal("target"), method_4290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084), Reflex::Literal("target"), method_4291, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211), Reflex::Literal("path"), method_4292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4197), Reflex::Literal("operator=="), operator_4293, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4197), Reflex::Literal("operator!="), operator_4294, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4295, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4296, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726, type_5534), Reflex::Literal("operator()"), operator_4297, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197, type_9034), Reflex::Literal("operator()"), operator_4298, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726, type_9074), Reflex::Literal("operator()"), operator_4299, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197, type_9073), Reflex::Literal("operator()"), operator_4300, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726, type_4197), Reflex::Literal("operator="), operator_4301, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726, type_3084), Reflex::Literal("operator="), operator_4302, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10501), Reflex::Literal("operator*"), operator_4303, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10502), Reflex::Literal("operator*"), operator_4304, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084), Reflex::Literal("operator->"), operator_4305, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10500), Reflex::Literal("operator->"), operator_4306, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10500), Reflex::Literal("operator const Gaudi::Examples::MyTrack*"), converter_4307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084), Reflex::Literal("operator Gaudi::Examples::MyTrack*"), converter_4308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("writeRef"), method_4309, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("readRef"), method_4310, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class Event -------------------------------
static  void operator_10508( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Event*)o)->operator=)(*(const ::Gaudi::Examples::Event*)arg[0]);
  else   (((::Gaudi::Examples::Event*)o)->operator=)(*(const ::Gaudi::Examples::Event*)arg[0]);
}

static void constructor_10509( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::Event(*(const ::Gaudi::Examples::Event*)arg[0]);
  else ::new(mem) ::Gaudi::Examples::Event(*(const ::Gaudi::Examples::Event*)arg[0]);
}

static void constructor_10510( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::Event();
  else ::new(mem) ::Gaudi::Examples::Event();
}

static void destructor_10511(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::Examples::Event*)o)->::Gaudi::Examples::Event::~Event)();
}
static  void method_10512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Event*)o)->clID)();
  else   (((const ::Gaudi::Examples::Event*)o)->clID)();
}

static  void method_10513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Event*)o)->classID)();
  else   (((::Gaudi::Examples::Event*)o)->classID)();
}

static  void method_10514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Examples::Event*)o)->event)());
  else   (((const ::Gaudi::Examples::Event*)o)->event)();
}

static  void method_10515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::Event*)o)->setEvent)(*(int*)arg[0]);
}

static  void method_10516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Examples::Event*)o)->run)());
  else   (((const ::Gaudi::Examples::Event*)o)->run)();
}

static  void method_10517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::Event*)o)->setRun)(*(int*)arg[0]);
}

static  void method_10518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Event*)o)->time)();
  else   (((const ::Gaudi::Examples::Event*)o)->time)();
}

static  void method_10519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::Event*)o)->setTime)(*(const ::Gaudi::Time*)arg[0]);
}

static  void method_10520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Event*)o)->collisions)();
  else   (((const ::Gaudi::Examples::Event*)o)->collisions)();
}

static  void method_10521( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::Event*)o)->addCollision)((::Gaudi::Examples::Collision*)arg[0]);
}

static  void method_10522( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::Event*)o)->removeCollision)((::Gaudi::Examples::Collision*)arg[0]);
}

static  void method_10523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Event*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((const ::Gaudi::Examples::Event*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_10524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Event*)o)->serialize)(*(::StreamBuffer*)arg[0]);
  else   (((::Gaudi::Examples::Event*)o)->serialize)(*(::StreamBuffer*)arg[0]);
}

static  void method_10525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Event*)o)->fillStream)(*(::std::ostream*)arg[0]);
  else   (((const ::Gaudi::Examples::Event*)o)->fillStream)(*(::std::ostream*)arg[0]);
}

static void method_newdel_4314( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Event >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Event >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Event >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Event >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Event >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::Gaudi::Examples::Event,::DataObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Event -------------------------------
void __Gaudi__Examples__Event_db_datamem(Reflex::Class*);
void __Gaudi__Examples__Event_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__Event_datamem_bld(&__Gaudi__Examples__Event_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__Event_funcmem_bld(&__Gaudi__Examples__Event_db_funcmem);
void __Gaudi__Examples__Event_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::Examples::Event"), typeid(::Gaudi::Examples::Event), sizeof(::Gaudi::Examples::Event), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "0000006E-0000-0000-0000-000000000000")
  .AddBase(type_240, ::Reflex::BaseOffset< ::Gaudi::Examples::Event, ::DataObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10527, type_10528), Reflex::Literal("operator="), operator_10508, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10528), Reflex::Literal("Event"), constructor_10509, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Event"), constructor_10510, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Event"), destructor_10511, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4314, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__Examples__Event_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__Examples__Event_funcmem_bld);
}

//------Delayed data member builder for class Event -------------------
void __Gaudi__Examples__Event_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_112, Reflex::Literal("m_event"), OffsetOf(__shadow__::__Gaudi__Examples__Event, m_event), ::Reflex::PRIVATE)
  .AddDataMember(type_112, Reflex::Literal("m_run"), OffsetOf(__shadow__::__Gaudi__Examples__Event, m_run), ::Reflex::PRIVATE)
  .AddDataMember(type_3223, Reflex::Literal("m_time"), OffsetOf(__shadow__::__Gaudi__Examples__Event, m_time), ::Reflex::PRIVATE)
  .AddDataMember(type_444, Reflex::Literal("m_collisions"), OffsetOf(__shadow__::__Gaudi__Examples__Event, m_collisions), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Event -------------------
void __Gaudi__Examples__Event_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_10512, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_10513, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("event"), method_10514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_112), Reflex::Literal("setEvent"), method_10515, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("run"), method_10516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_112), Reflex::Literal("setRun"), method_10517, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2989), Reflex::Literal("time"), method_10518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2989), Reflex::Literal("setTime"), method_10519, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4202), Reflex::Literal("collisions"), method_10520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_10542), Reflex::Literal("addCollision"), method_10521, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_10542), Reflex::Literal("removeCollision"), method_10522, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_10523, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("serialize"), method_10524, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4205, type_4205), Reflex::Literal("fillStream"), method_10525, 0, "s", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class SmartRef<Gaudi::Examples::Event> -------------------------------
static void destructor_4316(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<Gaudi::Examples::Event>*)o)->::SmartRef<Gaudi::Examples::Event>::~SmartRef)();
}
static void constructor_4317( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>();
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>();
}

static void constructor_4318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((::Gaudi::Examples::Event*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((::Gaudi::Examples::Event*)arg[0]);
}

static void constructor_4319( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::Gaudi::Examples::Event*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::Gaudi::Examples::Event*)arg[0]);
}

static void constructor_4320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]);
}

static void constructor_4321( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Event*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Event*)arg[2]);
  }
}

static void constructor_4322( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Event*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Event*)arg[3]);
  }
}

static void constructor_4323( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Event*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Event*)arg[3]);
  }
}

static void constructor_4324( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Event*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Event>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Event*)arg[2]);
  }
}

static  void method_4325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Event>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_4326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Event>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_4327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::Event>*)o)->hintID)());
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->hintID)();
}

static  void method_4328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::Event>*)o)->linkID)());
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->linkID)();
}

static  void method_4329( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<Gaudi::Examples::Event>*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_4330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Event>*)o)->type)());
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->type)();
}

static  void method_4331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Event>*)o)->data)());
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->data)();
}

static  void method_4332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Event>*)o)->data)());
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->data)();
}

static  void method_4333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Event>*)o)->target)());
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->target)();
}

static  void method_4334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Event>*)o)->target)());
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->target)();
}

static  void method_4335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Event>*)o)->path)();
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->path)();
}

static  void operator_4336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]);
}

static  void operator_4337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]);
}

static  void method_4338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Event>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_4339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Event>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_4340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Event>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_4341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_4342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Event>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_4343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_4344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Event>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::Event>*)arg[0]);
}

static  void operator_4345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Event>*)o)->operator=)((::Gaudi::Examples::Event*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->operator=)((::Gaudi::Examples::Event*)arg[0]);
}

static  void operator_4346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Event>*)o)->operator*)();
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->operator*)();
}

static  void operator_4347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator*)();
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator*)();
}

static  void operator_4348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Event>*)o)->operator->)());
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->operator->)();
}

static  void operator_4349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator->)());
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator->)();
}

static  void converter_4350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator const Gaudi::Examples::Event*)());
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->operator const Gaudi::Examples::Event*)();
}

static  void converter_4351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Event>*)o)->operator Gaudi::Examples::Event*)());
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->operator Gaudi::Examples::Event*)();
}

static  void method_4352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Event>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::Event>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_4353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Event>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Event>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2007( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Event> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Event> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Event> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Event> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Event> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<Gaudi::Examples::Event> -------------------------------
void __SmartRef_Gaudi__Examples__Event__db_datamem(Reflex::Class*);
void __SmartRef_Gaudi__Examples__Event__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__Event__datamem_bld(&__SmartRef_Gaudi__Examples__Event__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__Event__funcmem_bld(&__SmartRef_Gaudi__Examples__Event__db_funcmem);
void __SmartRef_Gaudi__Examples__Event__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::Event>"), typeid(::SmartRef<Gaudi::Examples::Event>), sizeof(::SmartRef<Gaudi::Examples::Event>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_4314, Reflex::Literal("SmartRef<Gaudi::Examples::Event>::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_4316, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_4317, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10526), Reflex::Literal("SmartRef"), constructor_4318, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10503), Reflex::Literal("SmartRef"), constructor_4319, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4200), Reflex::Literal("SmartRef"), constructor_4320, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_493, type_493, type_10526), Reflex::Literal("SmartRef"), constructor_4321, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9034, type_493, type_493, type_10526), Reflex::Literal("SmartRef"), constructor_4322, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_493, type_10526), Reflex::Literal("SmartRef"), constructor_4323, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_10526), Reflex::Literal("SmartRef"), constructor_4324, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2007, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_Gaudi__Examples__Event__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_Gaudi__Examples__Event__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<Gaudi::Examples::Event> -------------------
void __SmartRef_Gaudi__Examples__Event__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1217, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__Event_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_10503, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__Event_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<Gaudi::Examples::Event> -------------------
void __SmartRef_Gaudi__Examples__Event__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9073), Reflex::Literal("shouldFollowLink"), method_4325, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9034), Reflex::Literal("shouldFollowLink"), method_4326, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("hintID"), method_4327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("linkID"), method_4328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_9074, type_493, type_493), Reflex::Literal("set"), method_4329, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("type"), method_4330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10526), Reflex::Literal("data"), method_4331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10503), Reflex::Literal("data"), method_4332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10503), Reflex::Literal("target"), method_4333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10526), Reflex::Literal("target"), method_4334, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211), Reflex::Literal("path"), method_4335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4200), Reflex::Literal("operator=="), operator_4336, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4200), Reflex::Literal("operator!="), operator_4337, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4200, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4338, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3729, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4339, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3729, type_5534), Reflex::Literal("operator()"), operator_4340, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4200, type_9034), Reflex::Literal("operator()"), operator_4341, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3729, type_9074), Reflex::Literal("operator()"), operator_4342, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4200, type_9073), Reflex::Literal("operator()"), operator_4343, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3729, type_4200), Reflex::Literal("operator="), operator_4344, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3729, type_10526), Reflex::Literal("operator="), operator_4345, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10527), Reflex::Literal("operator*"), operator_4346, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10528), Reflex::Literal("operator*"), operator_4347, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10526), Reflex::Literal("operator->"), operator_4348, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10503), Reflex::Literal("operator->"), operator_4349, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10503), Reflex::Literal("operator const Gaudi::Examples::Event*"), converter_4350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10526), Reflex::Literal("operator Gaudi::Examples::Event*"), converter_4351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("writeRef"), method_4352, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("readRef"), method_4353, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class SmartRef<Gaudi::Examples::Collision> -------------------------------
static void destructor_4359(void*, void * o, const std::vector<void*>&, void *) {
(((::SmartRef<Gaudi::Examples::Collision>*)o)->::SmartRef<Gaudi::Examples::Collision>::~SmartRef)();
}
static void constructor_4360( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>();
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>();
}

static void constructor_4361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((::Gaudi::Examples::Collision*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((::Gaudi::Examples::Collision*)arg[0]);
}

static void constructor_4362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::Gaudi::Examples::Collision*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::Gaudi::Examples::Collision*)arg[0]);
}

static void constructor_4363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]);
}

static void constructor_4364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>(*(long*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>(*(long*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Collision*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>(*(long*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Collision*)arg[2]);
  }
}

static void constructor_4365( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Collision*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::ContainedObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Collision*)arg[3]);
  }
}

static void constructor_4366( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Collision*)arg[3]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      *(long*)arg[2],
      (::Gaudi::Examples::Collision*)arg[3]);
  }
}

static void constructor_4367( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Collision*)arg[2]);
  else ::new(mem) ::SmartRef<Gaudi::Examples::Collision>((const ::DataObject*)arg[0],
      *(long*)arg[1],
      (::Gaudi::Examples::Collision*)arg[2]);
  }
}

static  void method_4368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->shouldFollowLink)((const ::DataObject*)arg[0]);
}

static  void method_4369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->shouldFollowLink)((const ::ContainedObject*)arg[0]);
}

static  void method_4370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->hintID)());
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->hintID)();
}

static  void method_4371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long)((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->linkID)());
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->linkID)();
}

static  void method_4372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SmartRef<Gaudi::Examples::Collision>*)o)->set)((::DataObject*)arg[0],
    *(long*)arg[1],
    *(long*)arg[2]);
}

static  void method_4373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->type)());
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->type)();
}

static  void method_4374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Collision>*)o)->data)());
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->data)();
}

static  void method_4375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->data)());
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->data)();
}

static  void method_4376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->target)());
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->target)();
}

static  void method_4377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Collision>*)o)->target)());
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->target)();
}

static  void method_4378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Collision>*)o)->path)();
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->path)();
}

static  void operator_4379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator==)(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]);
}

static  void operator_4380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]));
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator!=)(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]);
}

static  void method_4381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Collision>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void method_4382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Collision>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->_setEnvironment)((const ::DataObject*)arg[0],
    (const ::ContainedObject*)arg[1]);
}

static  void operator_4383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((::ContainedObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((::ContainedObject*)arg[0]);
}

static  void operator_4384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((const ::ContainedObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((const ::ContainedObject*)arg[0]);
}

static  void operator_4385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((::DataObject*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((::DataObject*)arg[0]);
}

static  void operator_4386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((const ::DataObject*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator())((const ::DataObject*)arg[0]);
}

static  void operator_4387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Collision>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->operator=)(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]);
}

static  void operator_4388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Collision>*)o)->operator=)((::Gaudi::Examples::Collision*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->operator=)((::Gaudi::Examples::Collision*)arg[0]);
}

static  void operator_4389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Collision>*)o)->operator*)();
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->operator*)();
}

static  void operator_4390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator*)();
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator*)();
}

static  void operator_4391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Collision>*)o)->operator->)());
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->operator->)();
}

static  void operator_4392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator->)());
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator->)();
}

static  void converter_4393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator const Gaudi::Examples::Collision*)());
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->operator const Gaudi::Examples::Collision*)();
}

static  void converter_4394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SmartRef<Gaudi::Examples::Collision>*)o)->operator Gaudi::Examples::Collision*)());
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->operator Gaudi::Examples::Collision*)();
}

static  void method_4395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SmartRef<Gaudi::Examples::Collision>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
  else   (((const ::SmartRef<Gaudi::Examples::Collision>*)o)->writeRef)(*(::StreamBuffer*)arg[0]);
}

static  void method_4396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SmartRef<Gaudi::Examples::Collision>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
  else   (((::SmartRef<Gaudi::Examples::Collision>*)o)->readRef)(*(::StreamBuffer*)arg[0]);
}

static void method_newdel_2008( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Collision> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Collision> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Collision> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Collision> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SmartRef<Gaudi::Examples::Collision> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SmartRef<Gaudi::Examples::Collision> -------------------------------
void __SmartRef_Gaudi__Examples__Collision__db_datamem(Reflex::Class*);
void __SmartRef_Gaudi__Examples__Collision__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__Collision__datamem_bld(&__SmartRef_Gaudi__Examples__Collision__db_datamem);
Reflex::GenreflexMemberBuilder __SmartRef_Gaudi__Examples__Collision__funcmem_bld(&__SmartRef_Gaudi__Examples__Collision__db_funcmem);
void __SmartRef_Gaudi__Examples__Collision__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SmartRef<Gaudi::Examples::Collision>"), typeid(::SmartRef<Gaudi::Examples::Collision>), sizeof(::SmartRef<Gaudi::Examples::Collision>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_83"), Reflex::Literal("VALID=0;INVALID=-1"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_4357, Reflex::Literal("SmartRef<Gaudi::Examples::Collision>::entry_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SmartRef"), destructor_4359, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SmartRef"), constructor_4360, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10542), Reflex::Literal("SmartRef"), constructor_4361, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10529), Reflex::Literal("SmartRef"), constructor_4362, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4201), Reflex::Literal("SmartRef"), constructor_4363, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_493, type_493, type_10542), Reflex::Literal("SmartRef"), constructor_4364, 0, "hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9034, type_493, type_493, type_10542), Reflex::Literal("SmartRef"), constructor_4365, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_493, type_10542), Reflex::Literal("SmartRef"), constructor_4366, 0, "pObj;hint;link;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9073, type_493, type_10542), Reflex::Literal("SmartRef"), constructor_4367, 0, "pObj;hint;obj=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2008, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SmartRef_Gaudi__Examples__Collision__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SmartRef_Gaudi__Examples__Collision__funcmem_bld);
}

//------Delayed data member builder for class SmartRef<Gaudi::Examples::Collision> -------------------
void __SmartRef_Gaudi__Examples__Collision__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1217, Reflex::Literal("m_base"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__Collision_, m_base), ::Reflex::PROTECTED)
  .AddDataMember(type_10529, Reflex::Literal("m_target"), OffsetOf(__shadow__::__SmartRef_Gaudi__Examples__Collision_, m_target), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class SmartRef<Gaudi::Examples::Collision> -------------------
void __SmartRef_Gaudi__Examples__Collision__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9073), Reflex::Literal("shouldFollowLink"), method_4368, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_9034), Reflex::Literal("shouldFollowLink"), method_4369, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("hintID"), method_4370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_493), Reflex::Literal("linkID"), method_4371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_9074, type_493, type_493), Reflex::Literal("set"), method_4372, 0, "pObj;hint_id;link_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("type"), method_4373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10542), Reflex::Literal("data"), method_4374, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10529), Reflex::Literal("data"), method_4375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10529), Reflex::Literal("target"), method_4376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10542), Reflex::Literal("target"), method_4377, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211), Reflex::Literal("path"), method_4378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4201), Reflex::Literal("operator=="), operator_4379, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883, type_4201), Reflex::Literal("operator!="), operator_4380, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4201, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4381, 0, "pObj;pContd", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730, type_9073, type_9034), Reflex::Literal("_setEnvironment"), method_4382, 0, "pObj;pContd", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730, type_5534), Reflex::Literal("operator()"), operator_4383, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4201, type_9034), Reflex::Literal("operator()"), operator_4384, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730, type_9074), Reflex::Literal("operator()"), operator_4385, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4201, type_9073), Reflex::Literal("operator()"), operator_4386, 0, "pObj", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730, type_4201), Reflex::Literal("operator="), operator_4387, 0, "c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730, type_10542), Reflex::Literal("operator="), operator_4388, 0, "pObject", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10543), Reflex::Literal("operator*"), operator_4389, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10544), Reflex::Literal("operator*"), operator_4390, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10542), Reflex::Literal("operator->"), operator_4391, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10529), Reflex::Literal("operator->"), operator_4392, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10529), Reflex::Literal("operator const Gaudi::Examples::Collision*"), converter_4393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10542), Reflex::Literal("operator Gaudi::Examples::Collision*"), converter_4394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("writeRef"), method_4395, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3724, type_3724), Reflex::Literal("readRef"), method_4396, 0, "s", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<KeyedObject<int>*,std::allocator<KeyedObject<int>*> > -------------------------------
static void constructor_5422( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<KeyedObject<int>*>();
  else ::new(mem) ::std::vector<KeyedObject<int>*>();
}

static void constructor_5423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<KeyedObject<int>*>(*(const ::std::allocator<KeyedObject<int>*>*)arg[0]);
  else ::new(mem) ::std::vector<KeyedObject<int>*>(*(const ::std::allocator<KeyedObject<int>*>*)arg[0]);
}

static void constructor_5424( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<KeyedObject<int>*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<KeyedObject<int>*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<KeyedObject<int>*>(*(::std::size_t*)arg[0],
      *(::KeyedObject<int>* const*)arg[1]);
  else ::new(mem) ::std::vector<KeyedObject<int>*>(*(::std::size_t*)arg[0],
      *(::KeyedObject<int>* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<KeyedObject<int>*>(*(::std::size_t*)arg[0],
      *(::KeyedObject<int>* const*)arg[1],
      *(const ::std::allocator<KeyedObject<int>*>*)arg[2]);
  else ::new(mem) ::std::vector<KeyedObject<int>*>(*(::std::size_t*)arg[0],
      *(::KeyedObject<int>* const*)arg[1],
      *(const ::std::allocator<KeyedObject<int>*>*)arg[2]);
  }
}

static void constructor_5425( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<KeyedObject<int>*>(*(const ::std::vector<KeyedObject<int>*>*)arg[0]);
  else ::new(mem) ::std::vector<KeyedObject<int>*>(*(const ::std::vector<KeyedObject<int>*>*)arg[0]);
}

static void destructor_5426(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<KeyedObject<int>*>*)o)->::std::vector<KeyedObject<int>*>::~vector)();
}
static  void operator_5427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<KeyedObject<int>*>*)o)->operator=)(*(const ::std::vector<KeyedObject<int>*>*)arg[0]);
  else   (((::std::vector<KeyedObject<int>*>*)o)->operator=)(*(const ::std::vector<KeyedObject<int>*>*)arg[0]);
}

static  void method_5428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<KeyedObject<int>*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::KeyedObject<int>* const*)arg[1]);
}

static  void method_5429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >)((((::std::vector<KeyedObject<int>*>*)o)->begin)());
  else   (((::std::vector<KeyedObject<int>*>*)o)->begin)();
}

static  void method_5430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<KeyedObject<int>* const*,std::vector<KeyedObject<int>*> >)((((const ::std::vector<KeyedObject<int>*>*)o)->begin)());
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->begin)();
}

static  void method_5431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >)((((::std::vector<KeyedObject<int>*>*)o)->end)());
  else   (((::std::vector<KeyedObject<int>*>*)o)->end)();
}

static  void method_5432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<KeyedObject<int>* const*,std::vector<KeyedObject<int>*> >)((((const ::std::vector<KeyedObject<int>*>*)o)->end)());
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->end)();
}

static  void method_5437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<KeyedObject<int>*>*)o)->size)());
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->size)();
}

static  void method_5438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<KeyedObject<int>*>*)o)->max_size)());
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->max_size)();
}

static  void method_5439( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<KeyedObject<int>*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<KeyedObject<int>*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::KeyedObject<int>*)arg[1]);
  }
}

static  void method_5440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<KeyedObject<int>*>*)o)->capacity)());
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->capacity)();
}

static  void method_5441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<KeyedObject<int>*>*)o)->empty)());
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->empty)();
}

static  void method_5442( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<KeyedObject<int>*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<KeyedObject<int>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<KeyedObject<int>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<KeyedObject<int>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<KeyedObject<int>*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<KeyedObject<int>*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<KeyedObject<int>*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<KeyedObject<int>*>*)o)->front)();
  else   (((::std::vector<KeyedObject<int>*>*)o)->front)();
}

static  void method_5449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<KeyedObject<int>*>*)o)->front)();
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->front)();
}

static  void method_5450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<KeyedObject<int>*>*)o)->back)();
  else   (((::std::vector<KeyedObject<int>*>*)o)->back)();
}

static  void method_5451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<KeyedObject<int>*>*)o)->back)();
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->back)();
}

static  void method_5452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<KeyedObject<int>*>*)o)->data)());
  else   (((::std::vector<KeyedObject<int>*>*)o)->data)();
}

static  void method_5453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<KeyedObject<int>*>*)o)->data)());
  else   (((const ::std::vector<KeyedObject<int>*>*)o)->data)();
}

static  void method_5454( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<KeyedObject<int>*>*)o)->push_back)(*(::KeyedObject<int>* const*)arg[0]);
}

static  void method_5455( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<KeyedObject<int>*>*)o)->pop_back)();
}

static  void method_5456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >)((((::std::vector<KeyedObject<int>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[0],
    *(::KeyedObject<int>* const*)arg[1]));
  else   (((::std::vector<KeyedObject<int>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[0],
    *(::KeyedObject<int>* const*)arg[1]);
}

static  void method_5457( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<KeyedObject<int>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::KeyedObject<int>* const*)arg[2]);
}

static  void method_5458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >)((((::std::vector<KeyedObject<int>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[0]));
  else   (((::std::vector<KeyedObject<int>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[0]);
}

static  void method_5459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >)((((::std::vector<KeyedObject<int>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[1]));
  else   (((::std::vector<KeyedObject<int>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<KeyedObject<int>**,std::vector<KeyedObject<int>*> >*)arg[1]);
}

static  void method_5460( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<KeyedObject<int>*>*)o)->swap)(*(::std::vector<KeyedObject<int>*>*)arg[0]);
}

static  void method_5461( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<KeyedObject<int>*>*)o)->clear)();
}

static void method_newdel_2257( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<KeyedObject<int>*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<KeyedObject<int>*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<KeyedObject<int>*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<KeyedObject<int>*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<KeyedObject<int>*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<KeyedObject<int>*,std::allocator<KeyedObject<int>*> >")), ::Reflex::BaseOffset< ::std::vector<KeyedObject<int>*>,::std::_Vector_base<KeyedObject<int>*,std::allocator<KeyedObject<int>*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<KeyedObject<int>*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<KeyedObject<int>*> >::Generate();
}

//------Dictionary for class vector<KeyedObject<int>*,std::allocator<KeyedObject<int>*> > -------------------------------
void __std__vector_KeyedObject_int_p__db_datamem(Reflex::Class*);
void __std__vector_KeyedObject_int_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_KeyedObject_int_p__datamem_bld(&__std__vector_KeyedObject_int_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_KeyedObject_int_p__funcmem_bld(&__std__vector_KeyedObject_int_p__db_funcmem);
void __std__vector_KeyedObject_int_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<KeyedObject<int>*>"), typeid(::std::vector<KeyedObject<int>*>), sizeof(::std::vector<KeyedObject<int>*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2218, ::Reflex::BaseOffset< ::std::vector<KeyedObject<int>*>, ::std::_Vector_base<KeyedObject<int>*,std::allocator<KeyedObject<int>*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5402, Reflex::Literal("std::vector<KeyedObject<int>*>::_Alloc_value_type"))
  .AddTypedef(type_2218, Reflex::Literal("std::vector<KeyedObject<int>*>::_Base"))
  .AddTypedef(type_2595, Reflex::Literal("std::vector<KeyedObject<int>*>::_Tp_alloc_type"))
  .AddTypedef(type_3965, Reflex::Literal("std::vector<KeyedObject<int>*>::_Alloc_traits"))
  .AddTypedef(type_5402, Reflex::Literal("std::vector<KeyedObject<int>*>::value_type"))
  .AddTypedef(type_5079, Reflex::Literal("std::vector<KeyedObject<int>*>::pointer"))
  .AddTypedef(type_5409, Reflex::Literal("std::vector<KeyedObject<int>*>::const_pointer"))
  .AddTypedef(type_5411, Reflex::Literal("std::vector<KeyedObject<int>*>::reference"))
  .AddTypedef(type_5413, Reflex::Literal("std::vector<KeyedObject<int>*>::const_reference"))
  .AddTypedef(type_3918, Reflex::Literal("std::vector<KeyedObject<int>*>::iterator"))
  .AddTypedef(type_3919, Reflex::Literal("std::vector<KeyedObject<int>*>::const_iterator"))
  .AddTypedef(type_2665, Reflex::Literal("std::vector<KeyedObject<int>*>::const_reverse_iterator"))
  .AddTypedef(type_2666, Reflex::Literal("std::vector<KeyedObject<int>*>::reverse_iterator"))
  .AddTypedef(type_2567, Reflex::Literal("std::vector<KeyedObject<int>*>::size_type"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<KeyedObject<int>*>::difference_type"))
  .AddTypedef(type_2595, Reflex::Literal("std::vector<KeyedObject<int>*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5422, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12222), Reflex::Literal("vector"), constructor_5423, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2567, type_5413, type_12222), Reflex::Literal("vector"), constructor_5424, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12396), Reflex::Literal("vector"), constructor_5425, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5426, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2257, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_KeyedObject_int_p__funcmem_bld);
}

//------Delayed data member builder for class vector<KeyedObject<int>*,std::allocator<KeyedObject<int>*> > -------------------
void __std__vector_KeyedObject_int_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<KeyedObject<int>*,std::allocator<KeyedObject<int>*> > -------------------
void __std__vector_KeyedObject_int_p__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12397, type_12396), Reflex::Literal("operator="), operator_5427, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_5413), Reflex::Literal("assign"), method_5428, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3918), Reflex::Literal("begin"), method_5429, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3919), Reflex::Literal("begin"), method_5430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3918), Reflex::Literal("end"), method_5431, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3919), Reflex::Literal("end"), method_5432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("size"), method_5437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("max_size"), method_5438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_5402), Reflex::Literal("resize"), method_5439, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("capacity"), method_5440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_5441, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567), Reflex::Literal("reserve"), method_5442, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5411, type_2567), Reflex::Literal("operator[]"), operator_5443, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5413, type_2567), Reflex::Literal("operator[]"), operator_5444, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5411, type_2567), Reflex::Literal("at"), method_5446, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5413, type_2567), Reflex::Literal("at"), method_5447, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5411), Reflex::Literal("front"), method_5448, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5413), Reflex::Literal("front"), method_5449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5411), Reflex::Literal("back"), method_5450, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5413), Reflex::Literal("back"), method_5451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5079), Reflex::Literal("data"), method_5452, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5409), Reflex::Literal("data"), method_5453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_5413), Reflex::Literal("push_back"), method_5454, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_5455, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3918, type_3918, type_5413), Reflex::Literal("insert"), method_5456, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3918, type_2567, type_5413), Reflex::Literal("insert"), method_5457, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3918, type_3918), Reflex::Literal("erase"), method_5458, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3918, type_3918, type_3918), Reflex::Literal("erase"), method_5459, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_12397), Reflex::Literal("swap"), method_5460, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_5461, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> > -------------------------------
static void constructor_5486( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>();
  else ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>();
}

static void constructor_5487( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(const ::std::allocator<Gaudi::Examples::MyVertex*>*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(const ::std::allocator<Gaudi::Examples::MyVertex*>*)arg[0]);
}

static void constructor_5488( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyVertex* const*)arg[1]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyVertex* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyVertex* const*)arg[1],
      *(const ::std::allocator<Gaudi::Examples::MyVertex*>*)arg[2]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyVertex* const*)arg[1],
      *(const ::std::allocator<Gaudi::Examples::MyVertex*>*)arg[2]);
  }
}

static void constructor_5489( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(const ::std::vector<Gaudi::Examples::MyVertex*>*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyVertex*>(*(const ::std::vector<Gaudi::Examples::MyVertex*>*)arg[0]);
}

static void destructor_5490(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Gaudi::Examples::MyVertex*>*)o)->::std::vector<Gaudi::Examples::MyVertex*>::~vector)();
}
static  void operator_5491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyVertex*>*)o)->operator=)(*(const ::std::vector<Gaudi::Examples::MyVertex*>*)arg[0]);
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->operator=)(*(const ::std::vector<Gaudi::Examples::MyVertex*>*)arg[0]);
}

static  void method_5492( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::Gaudi::Examples::MyVertex* const*)arg[1]);
}

static  void method_5493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::std::vector<Gaudi::Examples::MyVertex*>*)o)->begin)());
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->begin)();
}

static  void method_5494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> >)((((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->begin)());
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->begin)();
}

static  void method_5495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::std::vector<Gaudi::Examples::MyVertex*>*)o)->end)());
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->end)();
}

static  void method_5496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex* const*,std::vector<Gaudi::Examples::MyVertex*> >)((((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->end)());
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->end)();
}

static  void method_5501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->size)());
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->size)();
}

static  void method_5502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->max_size)());
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->max_size)();
}

static  void method_5503( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::Gaudi::Examples::MyVertex*)arg[1]);
  }
}

static  void method_5504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->capacity)());
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->capacity)();
}

static  void method_5505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->empty)());
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->empty)();
}

static  void method_5506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyVertex*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5508( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyVertex*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5511( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyVertex*>*)o)->front)();
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->front)();
}

static  void method_5513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->front)();
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->front)();
}

static  void method_5514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyVertex*>*)o)->back)();
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->back)();
}

static  void method_5515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->back)();
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->back)();
}

static  void method_5516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Gaudi::Examples::MyVertex*>*)o)->data)());
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->data)();
}

static  void method_5517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->data)());
  else   (((const ::std::vector<Gaudi::Examples::MyVertex*>*)o)->data)();
}

static  void method_5518( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->push_back)(*(::Gaudi::Examples::MyVertex* const*)arg[0]);
}

static  void method_5519( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->pop_back)();
}

static  void method_5520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::std::vector<Gaudi::Examples::MyVertex*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::Gaudi::Examples::MyVertex* const*)arg[1]));
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::Gaudi::Examples::MyVertex* const*)arg[1]);
}

static  void method_5521( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::Gaudi::Examples::MyVertex* const*)arg[2]);
}

static  void method_5522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::std::vector<Gaudi::Examples::MyVertex*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0]));
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0]);
}

static  void method_5523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >)((((::std::vector<Gaudi::Examples::MyVertex*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[1]));
  else   (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyVertex**,std::vector<Gaudi::Examples::MyVertex*> >*)arg[1]);
}

static  void method_5524( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->swap)(*(::std::vector<Gaudi::Examples::MyVertex*>*)arg[0]);
}

static  void method_5525( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Gaudi::Examples::MyVertex*>*)o)->clear)();
}

static void method_newdel_2258( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyVertex*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyVertex*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyVertex*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyVertex*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyVertex*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> >")), ::Reflex::BaseOffset< ::std::vector<Gaudi::Examples::MyVertex*>,::std::_Vector_base<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Gaudi::Examples::MyVertex*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<Gaudi::Examples::MyVertex*> >::Generate();
}

//------Dictionary for class vector<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> > -------------------------------
void __std__vector_Gaudi__Examples__MyVertexp__db_datamem(Reflex::Class*);
void __std__vector_Gaudi__Examples__MyVertexp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Gaudi__Examples__MyVertexp__datamem_bld(&__std__vector_Gaudi__Examples__MyVertexp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Gaudi__Examples__MyVertexp__funcmem_bld(&__std__vector_Gaudi__Examples__MyVertexp__db_funcmem);
void __std__vector_Gaudi__Examples__MyVertexp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>"), typeid(::std::vector<Gaudi::Examples::MyVertex*>), sizeof(::std::vector<Gaudi::Examples::MyVertex*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2219, ::Reflex::BaseOffset< ::std::vector<Gaudi::Examples::MyVertex*>, ::std::_Vector_base<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3027, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::_Alloc_value_type"))
  .AddTypedef(type_2219, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::_Base"))
  .AddTypedef(type_2596, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::_Tp_alloc_type"))
  .AddTypedef(type_3966, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::_Alloc_traits"))
  .AddTypedef(type_3027, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::value_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::pointer"))
  .AddTypedef(type_3041, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::const_pointer"))
  .AddTypedef(type_3029, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::reference"))
  .AddTypedef(type_3031, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::const_reference"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::iterator"))
  .AddTypedef(type_3035, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::const_iterator"))
  .AddTypedef(type_2667, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::const_reverse_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::reverse_iterator"))
  .AddTypedef(type_2567, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::size_type"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::difference_type"))
  .AddTypedef(type_2596, Reflex::Literal("std::vector<Gaudi::Examples::MyVertex*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5486, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12235), Reflex::Literal("vector"), constructor_5487, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2567, type_3031, type_12235), Reflex::Literal("vector"), constructor_5488, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12398), Reflex::Literal("vector"), constructor_5489, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5490, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2258, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Gaudi__Examples__MyVertexp__funcmem_bld);
}

//------Delayed data member builder for class vector<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> > -------------------
void __std__vector_Gaudi__Examples__MyVertexp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Gaudi::Examples::MyVertex*,std::allocator<Gaudi::Examples::MyVertex*> > -------------------
void __std__vector_Gaudi__Examples__MyVertexp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12399, type_12398), Reflex::Literal("operator="), operator_5491, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_3031), Reflex::Literal("assign"), method_5492, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("begin"), method_5493, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3035), Reflex::Literal("begin"), method_5494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("end"), method_5495, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3035), Reflex::Literal("end"), method_5496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("size"), method_5501, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("max_size"), method_5502, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_3027), Reflex::Literal("resize"), method_5503, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("capacity"), method_5504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_5505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567), Reflex::Literal("reserve"), method_5506, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029, type_2567), Reflex::Literal("operator[]"), operator_5507, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031, type_2567), Reflex::Literal("operator[]"), operator_5508, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029, type_2567), Reflex::Literal("at"), method_5510, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031, type_2567), Reflex::Literal("at"), method_5511, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029), Reflex::Literal("front"), method_5512, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031), Reflex::Literal("front"), method_5513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3029), Reflex::Literal("back"), method_5514, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3031), Reflex::Literal("back"), method_5515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3039), Reflex::Literal("data"), method_5516, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3041), Reflex::Literal("data"), method_5517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3031), Reflex::Literal("push_back"), method_5518, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_5519, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_3033, type_3031), Reflex::Literal("insert"), method_5520, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3033, type_2567, type_3031), Reflex::Literal("insert"), method_5521, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_3033), Reflex::Literal("erase"), method_5522, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_3033, type_3033), Reflex::Literal("erase"), method_5523, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_12399), Reflex::Literal("swap"), method_5524, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_5525, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> > -------------------------------
static void constructor_5618( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>();
  else ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>();
}

static void constructor_5619( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(const ::std::allocator<Gaudi::Examples::MyTrack*>*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(const ::std::allocator<Gaudi::Examples::MyTrack*>*)arg[0]);
}

static void constructor_5620( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyTrack* const*)arg[1]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyTrack* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyTrack* const*)arg[1],
      *(const ::std::allocator<Gaudi::Examples::MyTrack*>*)arg[2]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(::std::size_t*)arg[0],
      *(::Gaudi::Examples::MyTrack* const*)arg[1],
      *(const ::std::allocator<Gaudi::Examples::MyTrack*>*)arg[2]);
  }
}

static void constructor_5621( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(const ::std::vector<Gaudi::Examples::MyTrack*>*)arg[0]);
  else ::new(mem) ::std::vector<Gaudi::Examples::MyTrack*>(*(const ::std::vector<Gaudi::Examples::MyTrack*>*)arg[0]);
}

static void destructor_5622(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Gaudi::Examples::MyTrack*>*)o)->::std::vector<Gaudi::Examples::MyTrack*>::~vector)();
}
static  void operator_5623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyTrack*>*)o)->operator=)(*(const ::std::vector<Gaudi::Examples::MyTrack*>*)arg[0]);
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->operator=)(*(const ::std::vector<Gaudi::Examples::MyTrack*>*)arg[0]);
}

static  void method_5624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::Gaudi::Examples::MyTrack* const*)arg[1]);
}

static  void method_5625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::std::vector<Gaudi::Examples::MyTrack*>*)o)->begin)());
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->begin)();
}

static  void method_5626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> >)((((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->begin)());
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->begin)();
}

static  void method_5627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::std::vector<Gaudi::Examples::MyTrack*>*)o)->end)());
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->end)();
}

static  void method_5628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack* const*,std::vector<Gaudi::Examples::MyTrack*> >)((((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->end)());
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->end)();
}

static  void method_5633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->size)());
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->size)();
}

static  void method_5634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->max_size)());
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->max_size)();
}

static  void method_5635( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::Gaudi::Examples::MyTrack*)arg[1]);
  }
}

static  void method_5636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->capacity)());
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->capacity)();
}

static  void method_5637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->empty)());
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->empty)();
}

static  void method_5638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyTrack*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyTrack*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyTrack*>*)o)->front)();
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->front)();
}

static  void method_5645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->front)();
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->front)();
}

static  void method_5646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Gaudi::Examples::MyTrack*>*)o)->back)();
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->back)();
}

static  void method_5647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->back)();
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->back)();
}

static  void method_5648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Gaudi::Examples::MyTrack*>*)o)->data)());
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->data)();
}

static  void method_5649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->data)());
  else   (((const ::std::vector<Gaudi::Examples::MyTrack*>*)o)->data)();
}

static  void method_5650( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->push_back)(*(::Gaudi::Examples::MyTrack* const*)arg[0]);
}

static  void method_5651( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->pop_back)();
}

static  void method_5652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::std::vector<Gaudi::Examples::MyTrack*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::Gaudi::Examples::MyTrack* const*)arg[1]));
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::Gaudi::Examples::MyTrack* const*)arg[1]);
}

static  void method_5653( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::Gaudi::Examples::MyTrack* const*)arg[2]);
}

static  void method_5654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::std::vector<Gaudi::Examples::MyTrack*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0]));
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0]);
}

static  void method_5655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >)((((::std::vector<Gaudi::Examples::MyTrack*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[1]));
  else   (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Gaudi::Examples::MyTrack**,std::vector<Gaudi::Examples::MyTrack*> >*)arg[1]);
}

static  void method_5656( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->swap)(*(::std::vector<Gaudi::Examples::MyTrack*>*)arg[0]);
}

static  void method_5657( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Gaudi::Examples::MyTrack*>*)o)->clear)();
}

static void method_newdel_2261( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyTrack*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyTrack*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyTrack*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyTrack*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Gaudi::Examples::MyTrack*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> >")), ::Reflex::BaseOffset< ::std::vector<Gaudi::Examples::MyTrack*>,::std::_Vector_base<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Gaudi::Examples::MyTrack*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<Gaudi::Examples::MyTrack*> >::Generate();
}

//------Dictionary for class vector<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> > -------------------------------
void __std__vector_Gaudi__Examples__MyTrackp__db_datamem(Reflex::Class*);
void __std__vector_Gaudi__Examples__MyTrackp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Gaudi__Examples__MyTrackp__datamem_bld(&__std__vector_Gaudi__Examples__MyTrackp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Gaudi__Examples__MyTrackp__funcmem_bld(&__std__vector_Gaudi__Examples__MyTrackp__db_funcmem);
void __std__vector_Gaudi__Examples__MyTrackp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>"), typeid(::std::vector<Gaudi::Examples::MyTrack*>), sizeof(::std::vector<Gaudi::Examples::MyTrack*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2220, ::Reflex::BaseOffset< ::std::vector<Gaudi::Examples::MyTrack*>, ::std::_Vector_base<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3084, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::_Alloc_value_type"))
  .AddTypedef(type_2220, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::_Base"))
  .AddTypedef(type_2599, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::_Tp_alloc_type"))
  .AddTypedef(type_3967, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::_Alloc_traits"))
  .AddTypedef(type_3084, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::value_type"))
  .AddTypedef(type_3096, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::pointer"))
  .AddTypedef(type_3098, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::const_pointer"))
  .AddTypedef(type_3086, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::reference"))
  .AddTypedef(type_3088, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::const_reference"))
  .AddTypedef(type_3090, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::iterator"))
  .AddTypedef(type_3092, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::const_iterator"))
  .AddTypedef(type_2669, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::const_reverse_iterator"))
  .AddTypedef(type_2670, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::reverse_iterator"))
  .AddTypedef(type_2567, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::size_type"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::difference_type"))
  .AddTypedef(type_2599, Reflex::Literal("std::vector<Gaudi::Examples::MyTrack*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5618, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12248), Reflex::Literal("vector"), constructor_5619, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2567, type_3088, type_12248), Reflex::Literal("vector"), constructor_5620, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12402), Reflex::Literal("vector"), constructor_5621, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5622, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2261, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Gaudi__Examples__MyTrackp__funcmem_bld);
}

//------Delayed data member builder for class vector<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> > -------------------
void __std__vector_Gaudi__Examples__MyTrackp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Gaudi::Examples::MyTrack*,std::allocator<Gaudi::Examples::MyTrack*> > -------------------
void __std__vector_Gaudi__Examples__MyTrackp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12403, type_12402), Reflex::Literal("operator="), operator_5623, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_3088), Reflex::Literal("assign"), method_5624, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090), Reflex::Literal("begin"), method_5625, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3092), Reflex::Literal("begin"), method_5626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090), Reflex::Literal("end"), method_5627, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3092), Reflex::Literal("end"), method_5628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("size"), method_5633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("max_size"), method_5634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_3084), Reflex::Literal("resize"), method_5635, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("capacity"), method_5636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_5637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567), Reflex::Literal("reserve"), method_5638, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086, type_2567), Reflex::Literal("operator[]"), operator_5639, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3088, type_2567), Reflex::Literal("operator[]"), operator_5640, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086, type_2567), Reflex::Literal("at"), method_5642, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3088, type_2567), Reflex::Literal("at"), method_5643, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("front"), method_5644, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3088), Reflex::Literal("front"), method_5645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3086), Reflex::Literal("back"), method_5646, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3088), Reflex::Literal("back"), method_5647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3096), Reflex::Literal("data"), method_5648, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3098), Reflex::Literal("data"), method_5649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3088), Reflex::Literal("push_back"), method_5650, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_5651, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090, type_3090, type_3088), Reflex::Literal("insert"), method_5652, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3090, type_2567, type_3088), Reflex::Literal("insert"), method_5653, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090, type_3090), Reflex::Literal("erase"), method_5654, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090, type_3090, type_3090), Reflex::Literal("erase"), method_5655, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_12403), Reflex::Literal("swap"), method_5656, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_5657, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > -------------------------------
static void constructor_5749( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >();
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >();
}

static void constructor_5750( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(const ::std::allocator<SmartRef<Gaudi::Examples::MyVertex> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(const ::std::allocator<SmartRef<Gaudi::Examples::MyVertex> >*)arg[0]);
}

static void constructor_5751( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[1],
      *(const ::std::allocator<SmartRef<Gaudi::Examples::MyVertex> >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[1],
      *(const ::std::allocator<SmartRef<Gaudi::Examples::MyVertex> >*)arg[2]);
  }
}

static void constructor_5752( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >(*(const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)arg[0]);
}

static void destructor_5753(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->::std::vector<SmartRef<Gaudi::Examples::MyVertex> >::~vector)();
}
static  void operator_5754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->operator=)(*(const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->operator=)(*(const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)arg[0]);
}

static  void method_5755( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[1]);
}

static  void method_5756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->begin)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->begin)();
}

static  void method_5757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >)((((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->begin)();
}

static  void method_5758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->end)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->end)();
}

static  void method_5759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >)((((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->end)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->end)();
}

static  void method_5764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->size)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->size)();
}

static  void method_5765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->max_size)();
}

static  void method_5766( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<Gaudi::Examples::MyVertex>*)arg[1]);
  }
}

static  void method_5767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->capacity)();
}

static  void method_5768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->empty)();
}

static  void method_5769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->front)();
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->front)();
}

static  void method_5776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->front)();
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->front)();
}

static  void method_5777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->back)();
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->back)();
}

static  void method_5778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->back)();
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->back)();
}

static  void method_5779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->data)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->data)();
}

static  void method_5780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->data)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->data)();
}

static  void method_5781( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->push_back)(*(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[0]);
}

static  void method_5782( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->pop_back)();
}

static  void method_5783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[1]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[1]);
}

static  void method_5784( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<Gaudi::Examples::MyVertex>*)arg[2]);
}

static  void method_5785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[0]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[0]);
}

static  void method_5786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[1]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyVertex>*,std::vector<SmartRef<Gaudi::Examples::MyVertex> > >*)arg[1]);
}

static  void method_5787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->swap)(*(::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)arg[0]);
}

static  void method_5788( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyVertex> >*)o)->clear)();
}

static void method_newdel_2263( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >,::std::_Vector_base<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> > >::Generate();
}

//------Dictionary for class vector<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > -------------------------------
void __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__datamem_bld(&__std__vector_SmartRef_Gaudi__Examples__MyVertex_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__funcmem_bld(&__std__vector_SmartRef_Gaudi__Examples__MyVertex_s__db_funcmem);
void __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >"), typeid(::std::vector<SmartRef<Gaudi::Examples::MyVertex> >), sizeof(::std::vector<SmartRef<Gaudi::Examples::MyVertex> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2222, ::Reflex::BaseOffset< ::std::vector<SmartRef<Gaudi::Examples::MyVertex> >, ::std::_Vector_base<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2005, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::_Alloc_value_type"))
  .AddTypedef(type_2222, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::_Base"))
  .AddTypedef(type_2601, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::_Tp_alloc_type"))
  .AddTypedef(type_3969, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::_Alloc_traits"))
  .AddTypedef(type_2005, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::value_type"))
  .AddTypedef(type_5153, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::pointer"))
  .AddTypedef(type_5738, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::const_pointer"))
  .AddTypedef(type_3728, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::reference"))
  .AddTypedef(type_4199, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::const_reference"))
  .AddTypedef(type_3921, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::iterator"))
  .AddTypedef(type_3162, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::const_iterator"))
  .AddTypedef(type_2673, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::const_reverse_iterator"))
  .AddTypedef(type_2674, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::reverse_iterator"))
  .AddTypedef(type_2567, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::size_type"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::difference_type"))
  .AddTypedef(type_2601, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyVertex> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5749, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12274), Reflex::Literal("vector"), constructor_5750, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2567, type_4199, type_12274), Reflex::Literal("vector"), constructor_5751, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4222), Reflex::Literal("vector"), constructor_5752, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5753, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2263, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_Gaudi__Examples__MyVertex_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > -------------------
void __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<Gaudi::Examples::MyVertex>,std::allocator<SmartRef<Gaudi::Examples::MyVertex> > > -------------------
void __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3733, type_4222), Reflex::Literal("operator="), operator_5754, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_4199), Reflex::Literal("assign"), method_5755, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3921), Reflex::Literal("begin"), method_5756, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3162), Reflex::Literal("begin"), method_5757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3921), Reflex::Literal("end"), method_5758, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3162), Reflex::Literal("end"), method_5759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("size"), method_5764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("max_size"), method_5765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_2005), Reflex::Literal("resize"), method_5766, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("capacity"), method_5767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_5768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567), Reflex::Literal("reserve"), method_5769, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_2567), Reflex::Literal("operator[]"), operator_5770, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4199, type_2567), Reflex::Literal("operator[]"), operator_5771, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728, type_2567), Reflex::Literal("at"), method_5773, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4199, type_2567), Reflex::Literal("at"), method_5774, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728), Reflex::Literal("front"), method_5775, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4199), Reflex::Literal("front"), method_5776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3728), Reflex::Literal("back"), method_5777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4199), Reflex::Literal("back"), method_5778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5153), Reflex::Literal("data"), method_5779, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5738), Reflex::Literal("data"), method_5780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_4199), Reflex::Literal("push_back"), method_5781, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_5782, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3921, type_3921, type_4199), Reflex::Literal("insert"), method_5783, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3921, type_2567, type_4199), Reflex::Literal("insert"), method_5784, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3921, type_3921), Reflex::Literal("erase"), method_5785, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3921, type_3921, type_3921), Reflex::Literal("erase"), method_5786, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3733), Reflex::Literal("swap"), method_5787, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_5788, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > -------------------------------
static void constructor_5814( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >();
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >();
}

static void constructor_5815( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(const ::std::allocator<SmartRef<Gaudi::Examples::MyTrack> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(const ::std::allocator<SmartRef<Gaudi::Examples::MyTrack> >*)arg[0]);
}

static void constructor_5816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[1],
      *(const ::std::allocator<SmartRef<Gaudi::Examples::MyTrack> >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[1],
      *(const ::std::allocator<SmartRef<Gaudi::Examples::MyTrack> >*)arg[2]);
  }
}

static void constructor_5817( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >(*(const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)arg[0]);
}

static void destructor_5818(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->::std::vector<SmartRef<Gaudi::Examples::MyTrack> >::~vector)();
}
static  void operator_5819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->operator=)(*(const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->operator=)(*(const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)arg[0]);
}

static  void method_5820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[1]);
}

static  void method_5821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->begin)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->begin)();
}

static  void method_5822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >)((((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->begin)();
}

static  void method_5823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->end)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->end)();
}

static  void method_5824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >)((((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->end)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->end)();
}

static  void method_5829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->size)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->size)();
}

static  void method_5830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->max_size)();
}

static  void method_5831( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<Gaudi::Examples::MyTrack>*)arg[1]);
  }
}

static  void method_5832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->capacity)();
}

static  void method_5833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->empty)();
}

static  void method_5834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->front)();
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->front)();
}

static  void method_5841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->front)();
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->front)();
}

static  void method_5842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->back)();
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->back)();
}

static  void method_5843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->back)();
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->back)();
}

static  void method_5844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->data)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->data)();
}

static  void method_5845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->data)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->data)();
}

static  void method_5846( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->push_back)(*(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[0]);
}

static  void method_5847( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->pop_back)();
}

static  void method_5848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[1]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[1]);
}

static  void method_5849( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<Gaudi::Examples::MyTrack>*)arg[2]);
}

static  void method_5850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[0]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[0]);
}

static  void method_5851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >)((((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[1]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::MyTrack>*,std::vector<SmartRef<Gaudi::Examples::MyTrack> > >*)arg[1]);
}

static  void method_5852( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->swap)(*(::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)arg[0]);
}

static  void method_5853( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::MyTrack> >*)o)->clear)();
}

static void method_newdel_2264( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >,::std::_Vector_base<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> > >::Generate();
}

//------Dictionary for class vector<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > -------------------------------
void __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__datamem_bld(&__std__vector_SmartRef_Gaudi__Examples__MyTrack_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__funcmem_bld(&__std__vector_SmartRef_Gaudi__Examples__MyTrack_s__db_funcmem);
void __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >"), typeid(::std::vector<SmartRef<Gaudi::Examples::MyTrack> >), sizeof(::std::vector<SmartRef<Gaudi::Examples::MyTrack> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2221, ::Reflex::BaseOffset< ::std::vector<SmartRef<Gaudi::Examples::MyTrack> >, ::std::_Vector_base<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2006, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::_Alloc_value_type"))
  .AddTypedef(type_2221, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::_Base"))
  .AddTypedef(type_2602, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::_Tp_alloc_type"))
  .AddTypedef(type_3968, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::_Alloc_traits"))
  .AddTypedef(type_2006, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::value_type"))
  .AddTypedef(type_5134, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::pointer"))
  .AddTypedef(type_5803, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::const_pointer"))
  .AddTypedef(type_3726, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::reference"))
  .AddTypedef(type_4197, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::const_reference"))
  .AddTypedef(type_3923, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::iterator"))
  .AddTypedef(type_3200, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::const_iterator"))
  .AddTypedef(type_2671, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::const_reverse_iterator"))
  .AddTypedef(type_2672, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::reverse_iterator"))
  .AddTypedef(type_2567, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::size_type"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::difference_type"))
  .AddTypedef(type_2602, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::MyTrack> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5814, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12261), Reflex::Literal("vector"), constructor_5815, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2567, type_4197, type_12261), Reflex::Literal("vector"), constructor_5816, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12406), Reflex::Literal("vector"), constructor_5817, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5818, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2264, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_Gaudi__Examples__MyTrack_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > -------------------
void __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<Gaudi::Examples::MyTrack>,std::allocator<SmartRef<Gaudi::Examples::MyTrack> > > -------------------
void __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12407, type_12406), Reflex::Literal("operator="), operator_5819, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_4197), Reflex::Literal("assign"), method_5820, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3923), Reflex::Literal("begin"), method_5821, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3200), Reflex::Literal("begin"), method_5822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3923), Reflex::Literal("end"), method_5823, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3200), Reflex::Literal("end"), method_5824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("size"), method_5829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("max_size"), method_5830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_2006), Reflex::Literal("resize"), method_5831, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("capacity"), method_5832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_5833, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567), Reflex::Literal("reserve"), method_5834, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726, type_2567), Reflex::Literal("operator[]"), operator_5835, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197, type_2567), Reflex::Literal("operator[]"), operator_5836, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726, type_2567), Reflex::Literal("at"), method_5838, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197, type_2567), Reflex::Literal("at"), method_5839, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726), Reflex::Literal("front"), method_5840, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197), Reflex::Literal("front"), method_5841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3726), Reflex::Literal("back"), method_5842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197), Reflex::Literal("back"), method_5843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5134), Reflex::Literal("data"), method_5844, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5803), Reflex::Literal("data"), method_5845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_4197), Reflex::Literal("push_back"), method_5846, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_5847, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3923, type_3923, type_4197), Reflex::Literal("insert"), method_5848, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3923, type_2567, type_4197), Reflex::Literal("insert"), method_5849, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3923, type_3923), Reflex::Literal("erase"), method_5850, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3923, type_3923, type_3923), Reflex::Literal("erase"), method_5851, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_12407), Reflex::Literal("swap"), method_5852, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_5853, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > -------------------------------
static void constructor_5879( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >();
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >();
}

static void constructor_5880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(const ::std::allocator<SmartRef<Gaudi::Examples::Collision> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(const ::std::allocator<SmartRef<Gaudi::Examples::Collision> >*)arg[0]);
}

static void constructor_5881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[1]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[1],
      *(const ::std::allocator<SmartRef<Gaudi::Examples::Collision> >*)arg[2]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(::std::size_t*)arg[0],
      *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[1],
      *(const ::std::allocator<SmartRef<Gaudi::Examples::Collision> >*)arg[2]);
  }
}

static void constructor_5882( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)arg[0]);
  else ::new(mem) ::std::vector<SmartRef<Gaudi::Examples::Collision> >(*(const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)arg[0]);
}

static void destructor_5883(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->::std::vector<SmartRef<Gaudi::Examples::Collision> >::~vector)();
}
static  void operator_5884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->operator=)(*(const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->operator=)(*(const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)arg[0]);
}

static  void method_5885( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[1]);
}

static  void method_5886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >)((((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->begin)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->begin)();
}

static  void method_5887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >)((((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->begin)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->begin)();
}

static  void method_5888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >)((((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->end)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->end)();
}

static  void method_5889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >)((((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->end)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->end)();
}

static  void method_5894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->size)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->size)();
}

static  void method_5895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->max_size)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->max_size)();
}

static  void method_5896( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SmartRef<Gaudi::Examples::Collision>*)arg[1]);
  }
}

static  void method_5897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->capacity)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->capacity)();
}

static  void method_5898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->empty)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->empty)();
}

static  void method_5899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->front)();
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->front)();
}

static  void method_5906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->front)();
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->front)();
}

static  void method_5907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->back)();
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->back)();
}

static  void method_5908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->back)();
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->back)();
}

static  void method_5909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->data)());
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->data)();
}

static  void method_5910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->data)());
  else   (((const ::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->data)();
}

static  void method_5911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->push_back)(*(const ::SmartRef<Gaudi::Examples::Collision>*)arg[0]);
}

static  void method_5912( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->pop_back)();
}

static  void method_5913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >)((((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[1]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[0],
    *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[1]);
}

static  void method_5914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SmartRef<Gaudi::Examples::Collision>*)arg[2]);
}

static  void method_5915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >)((((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[0]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[0]);
}

static  void method_5916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >)((((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[1]));
  else   (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SmartRef<Gaudi::Examples::Collision>*,std::vector<SmartRef<Gaudi::Examples::Collision> > >*)arg[1]);
}

static  void method_5917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->swap)(*(::std::vector<SmartRef<Gaudi::Examples::Collision> >*)arg[0]);
}

static  void method_5918( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SmartRef<Gaudi::Examples::Collision> >*)o)->clear)();
}

static void method_newdel_2265( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > >")), ::Reflex::BaseOffset< ::std::vector<SmartRef<Gaudi::Examples::Collision> >,::std::_Vector_base<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<SmartRef<Gaudi::Examples::Collision> > >::Generate();
}

//------Dictionary for class vector<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > -------------------------------
void __std__vector_SmartRef_Gaudi__Examples__Collision_s__db_datamem(Reflex::Class*);
void __std__vector_SmartRef_Gaudi__Examples__Collision_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_Gaudi__Examples__Collision_s__datamem_bld(&__std__vector_SmartRef_Gaudi__Examples__Collision_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SmartRef_Gaudi__Examples__Collision_s__funcmem_bld(&__std__vector_SmartRef_Gaudi__Examples__Collision_s__db_funcmem);
void __std__vector_SmartRef_Gaudi__Examples__Collision_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >"), typeid(::std::vector<SmartRef<Gaudi::Examples::Collision> >), sizeof(::std::vector<SmartRef<Gaudi::Examples::Collision> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2226, ::Reflex::BaseOffset< ::std::vector<SmartRef<Gaudi::Examples::Collision> >, ::std::_Vector_base<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2008, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::_Alloc_value_type"))
  .AddTypedef(type_2226, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::_Base"))
  .AddTypedef(type_2603, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::_Tp_alloc_type"))
  .AddTypedef(type_3973, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::_Alloc_traits"))
  .AddTypedef(type_2008, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::value_type"))
  .AddTypedef(type_5227, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::pointer"))
  .AddTypedef(type_5868, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::const_pointer"))
  .AddTypedef(type_3730, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::reference"))
  .AddTypedef(type_4201, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::const_reference"))
  .AddTypedef(type_3922, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::iterator"))
  .AddTypedef(type_3181, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::const_iterator"))
  .AddTypedef(type_2681, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::const_reverse_iterator"))
  .AddTypedef(type_2682, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::reverse_iterator"))
  .AddTypedef(type_2567, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::size_type"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::difference_type"))
  .AddTypedef(type_2603, Reflex::Literal("std::vector<SmartRef<Gaudi::Examples::Collision> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5879, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12326), Reflex::Literal("vector"), constructor_5880, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2567, type_4201, type_12326), Reflex::Literal("vector"), constructor_5881, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4223), Reflex::Literal("vector"), constructor_5882, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5883, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2265, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SmartRef_Gaudi__Examples__Collision_s__funcmem_bld);
}

//------Delayed data member builder for class vector<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > -------------------
void __std__vector_SmartRef_Gaudi__Examples__Collision_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SmartRef<Gaudi::Examples::Collision>,std::allocator<SmartRef<Gaudi::Examples::Collision> > > -------------------
void __std__vector_SmartRef_Gaudi__Examples__Collision_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3734, type_4223), Reflex::Literal("operator="), operator_5884, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_4201), Reflex::Literal("assign"), method_5885, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922), Reflex::Literal("begin"), method_5886, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3181), Reflex::Literal("begin"), method_5887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922), Reflex::Literal("end"), method_5888, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3181), Reflex::Literal("end"), method_5889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("size"), method_5894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("max_size"), method_5895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567, type_2008), Reflex::Literal("resize"), method_5896, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567), Reflex::Literal("capacity"), method_5897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("empty"), method_5898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_2567), Reflex::Literal("reserve"), method_5899, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730, type_2567), Reflex::Literal("operator[]"), operator_5900, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4201, type_2567), Reflex::Literal("operator[]"), operator_5901, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730, type_2567), Reflex::Literal("at"), method_5903, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4201, type_2567), Reflex::Literal("at"), method_5904, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730), Reflex::Literal("front"), method_5905, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4201), Reflex::Literal("front"), method_5906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3730), Reflex::Literal("back"), method_5907, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4201), Reflex::Literal("back"), method_5908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5227), Reflex::Literal("data"), method_5909, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5868), Reflex::Literal("data"), method_5910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_4201), Reflex::Literal("push_back"), method_5911, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("pop_back"), method_5912, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922, type_3922, type_4201), Reflex::Literal("insert"), method_5913, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3922, type_2567, type_4201), Reflex::Literal("insert"), method_5914, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922, type_3922), Reflex::Literal("erase"), method_5915, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922, type_3922, type_3922), Reflex::Literal("erase"), method_5916, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_3734), Reflex::Literal("swap"), method_5917, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630), Reflex::Literal("clear"), method_5918, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Counter -------------------------------
static  void operator_12957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Counter*)o)->operator=)(*(const ::Gaudi::Examples::Counter*)arg[0]);
  else   (((::Gaudi::Examples::Counter*)o)->operator=)(*(const ::Gaudi::Examples::Counter*)arg[0]);
}

static void constructor_12958( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::Counter(*(const ::Gaudi::Examples::Counter*)arg[0]);
  else ::new(mem) ::Gaudi::Examples::Counter(*(const ::Gaudi::Examples::Counter*)arg[0]);
}

static void constructor_12959( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Examples::Counter();
  else ::new(mem) ::Gaudi::Examples::Counter();
}

static void destructor_12960(void*, void * o, const std::vector<void*>&, void *) {
(((::Gaudi::Examples::Counter*)o)->::Gaudi::Examples::Counter::~Counter)();
}
static  void method_12961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Examples::Counter*)o)->clID)();
  else   (((const ::Gaudi::Examples::Counter*)o)->clID)();
}

static  void method_12962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Examples::Counter*)o)->classID)();
  else   (((::Gaudi::Examples::Counter*)o)->classID)();
}

static  void method_12963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::Gaudi::Examples::Counter*)o)->value)());
  else   (((const ::Gaudi::Examples::Counter*)o)->value)();
}

static  void method_12964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Gaudi::Examples::Counter*)o)->increment)());
  else   (((::Gaudi::Examples::Counter*)o)->increment)();
}

static  void method_12965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Gaudi::Examples::Counter*)o)->decrement)());
  else   (((::Gaudi::Examples::Counter*)o)->decrement)();
}

static  void method_12966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Gaudi::Examples::Counter*)o)->set)(*(int*)arg[0]);
}

static void method_newdel_9110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Counter >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Counter >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Counter >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Counter >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::Examples::Counter >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("DataObject")), ::Reflex::BaseOffset< ::Gaudi::Examples::Counter,::DataObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Counter -------------------------------
void __Gaudi__Examples__Counter_db_datamem(Reflex::Class*);
void __Gaudi__Examples__Counter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__Counter_datamem_bld(&__Gaudi__Examples__Counter_db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__Examples__Counter_funcmem_bld(&__Gaudi__Examples__Counter_db_funcmem);
void __Gaudi__Examples__Counter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Gaudi::Examples::Counter"), typeid(::Gaudi::Examples::Counter), sizeof(::Gaudi::Examples::Counter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "0000006D-0000-0000-0000-000000000000")
  .AddBase(type_240, ::Reflex::BaseOffset< ::Gaudi::Examples::Counter, ::DataObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15815, type_15816), Reflex::Literal("operator="), operator_12957, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15816), Reflex::Literal("Counter"), constructor_12958, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Counter"), constructor_12959, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Counter"), destructor_12960, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__Examples__Counter_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__Examples__Counter_funcmem_bld);
}

//------Delayed data member builder for class Counter -------------------
void __Gaudi__Examples__Counter_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_112, Reflex::Literal("m_counter"), OffsetOf(__shadow__::__Gaudi__Examples__Counter, m_counter), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Counter -------------------
void __Gaudi__Examples__Counter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("clID"), method_12961, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8974), Reflex::Literal("classID"), method_12962, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("value"), method_12963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("increment"), method_12964, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_112), Reflex::Literal("decrement"), method_12965, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_630, type_112), Reflex::Literal("set"), method_12966, 0, "val", ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __Gaudi__Examples__MyVertex_dict(); 
      __ObjectVector_Gaudi__Examples__MyVertex__dict(); 
      __Gaudi__Examples__MyTrack_dict(); 
      __ObjectVector_Gaudi__Examples__MyTrack__dict(); 
      __SmartRefVector_Gaudi__Examples__MyVertex__dict(); 
      __Gaudi__Examples__Collision_dict(); 
      __SmartRefVector_Gaudi__Examples__Collision__dict(); 
      __SmartRefVector_Gaudi__Examples__MyTrack__dict(); 
      __KeyedContainer_Gaudi__Examples__MyVertex_Containers__KeyedObjectManager_Containers__hashmap_s__dict(); 
      __KeyedContainer_Gaudi__Examples__MyTrack_Containers__KeyedObjectManager_Containers__hashmap_s__dict(); 
      __SmartRef_Gaudi__Examples__MyVertex__dict(); 
      __SmartRef_Gaudi__Examples__MyTrack__dict(); 
      __Gaudi__Examples__Event_dict(); 
      __SmartRef_Gaudi__Examples__Event__dict(); 
      __SmartRef_Gaudi__Examples__Collision__dict(); 
      __std__vector_KeyedObject_int_p__dict(); 
      __std__vector_Gaudi__Examples__MyVertexp__dict(); 
      __std__vector_Gaudi__Examples__MyTrackp__dict(); 
      __std__vector_SmartRef_Gaudi__Examples__MyVertex_s__dict(); 
      __std__vector_SmartRef_Gaudi__Examples__MyTrack_s__dict(); 
      __std__vector_SmartRef_Gaudi__Examples__Collision_s__dict(); 
      __Gaudi__Examples__Counter_dict(); 
    }
    ~Dictionaries() {
      type_3025.Unload(); // class Gaudi::Examples::MyVertex 
      type_372.Unload(); // class ObjectVector<Gaudi::Examples::MyVertex> 
      type_3082.Unload(); // class Gaudi::Examples::MyTrack 
      type_373.Unload(); // class ObjectVector<Gaudi::Examples::MyTrack> 
      type_443.Unload(); // class SmartRefVector<Gaudi::Examples::MyVertex> 
      type_4357.Unload(); // class Gaudi::Examples::Collision 
      type_444.Unload(); // class SmartRefVector<Gaudi::Examples::Collision> 
      type_445.Unload(); // class SmartRefVector<Gaudi::Examples::MyTrack> 
      type_969.Unload(); // class KeyedContainer<Gaudi::Examples::MyVertex,Containers::KeyedObjectManager<Containers::hashmap> > 
      type_970.Unload(); // class KeyedContainer<Gaudi::Examples::MyTrack,Containers::KeyedObjectManager<Containers::hashmap> > 
      type_2005.Unload(); // class SmartRef<Gaudi::Examples::MyVertex> 
      type_2006.Unload(); // class SmartRef<Gaudi::Examples::MyTrack> 
      type_4314.Unload(); // class Gaudi::Examples::Event 
      type_2007.Unload(); // class SmartRef<Gaudi::Examples::Event> 
      type_2008.Unload(); // class SmartRef<Gaudi::Examples::Collision> 
      type_2257.Unload(); // class std::vector<KeyedObject<int>*> 
      type_2258.Unload(); // class std::vector<Gaudi::Examples::MyVertex*> 
      type_2261.Unload(); // class std::vector<Gaudi::Examples::MyTrack*> 
      type_2263.Unload(); // class std::vector<SmartRef<Gaudi::Examples::MyVertex> > 
      type_2264.Unload(); // class std::vector<SmartRef<Gaudi::Examples::MyTrack> > 
      type_2265.Unload(); // class std::vector<SmartRef<Gaudi::Examples::Collision> > 
      type_9110.Unload(); // class Gaudi::Examples::Counter 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
